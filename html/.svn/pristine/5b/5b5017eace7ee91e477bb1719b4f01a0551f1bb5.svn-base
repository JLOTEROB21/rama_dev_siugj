/*
Stimulsoft.Reports.JS
Version: 2021.4.3
Build date: 2021.11.04
License: https://www.stimulsoft.com/en/licensing/reports
*/
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Events;
        (function (Events) {
            var EventArgs = Stimulsoft.System.EventArgs;
            class StiGetTitleEventArgs extends EventArgs {
                constructor() {
                    super(...arguments);
                    this._series = null;
                }
                get value() {
                    return this.valueObject;
                }
                set value(value) {
                    this.valueObject = value;
                }
                get index() {
                    return this._index;
                }
                set index(value) {
                    this._index = value;
                }
                get series() {
                    return this._series;
                }
                set series(value) {
                    this._series = value;
                }
            }
            Events.StiGetTitleEventArgs = StiGetTitleEventArgs;
        })(Events = Report.Events || (Report.Events = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Events;
        (function (Events) {
            var EventArgs = Stimulsoft.System.EventArgs;
            class StiNewAutoSeriesEventArgs extends EventArgs {
                constructor(seriesIndex, series, color) {
                    super();
                    this._seriesIndex = seriesIndex;
                    this._series = series;
                    this._color = color;
                }
                get seriesIndex() {
                    return this._seriesIndex;
                }
                set seriesIndex(value) {
                    this._seriesIndex = value;
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get series() {
                    return this._series;
                }
                set series(value) {
                    this._series = value;
                }
            }
            Events.StiNewAutoSeriesEventArgs = StiNewAutoSeriesEventArgs;
        })(Events = Report.Events || (Report.Events = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiNumber = Stimulsoft.System.StiNumber;
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiNewAutoSeriesEventArgs = Stimulsoft.Report.Events.StiNewAutoSeriesEventArgs;
            var StiGetTitleEventArgs = Stimulsoft.Report.Events.StiGetTitleEventArgs;
            var DBNull = Stimulsoft.System.Data.DBNull;
            var StiValueEventArgs = Stimulsoft.Report.Events.StiValueEventArgs;
            var StiGetValueEventArgs = Stimulsoft.Report.Events.StiGetValueEventArgs;
            var StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
            var StiDataColumn = Stimulsoft.Report.Dictionary.StiDataColumn;
            var DateTime = Stimulsoft.System.DateTime;
            var Char = Stimulsoft.System.Char;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
            var StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
            var StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StiParser = Stimulsoft.Report.Engine.StiParser.StiParser;
            var List = Stimulsoft.System.Collections.List;
            class StiChartHelper {
                static fillSeriesData(series, items) {
                    series.values = StiArray.create(Number, items.length);
                    series.arguments = StiArray.create(Object, items.length);
                    series.tags = StiArray.create(Object, items.length);
                    for (let index = 0; index < items.length; index++) {
                        let item = items[index];
                        series.values[index] = typeof item.value == "number" ? item.value : 0;
                        series.arguments[index] = item.argument;
                        series.tags[index] = item.tag;
                        if (series.is(Chart.IStiRangeSeries))
                            series.valuesEnd[index] = typeof item.valueEnd == "number" ? item.valueEnd : 0;
                        if (series.is(Chart.IStiFinancialSeries)) {
                            series.valuesOpen[index] = typeof item.valueOpen == "number" ? item.valueOpen : 0;
                            series.valuesClose[index] = typeof item.valueClose == "number" ? item.valueClose : 0;
                            series.valuesLow[index] = typeof item.valueLow == "number" ? item.valueLow : 0;
                            series.valuesHigh[index] = typeof item.valueHigh == "number" ? item.valueHigh : 0;
                        }
                    }
                }
                static getFilterData(report, filter, filterMethodName) {
                    try {
                        if (filter.item == StiFilterItem.Expression) {
                            let lowerName = filterMethodName.substr(0, 1).toLowerCase() + filterMethodName.substr(1);
                            if (report[filterMethodName] != null)
                                return report[filterMethodName]();
                            if (report[lowerName] != null)
                                return report[lowerName]();
                            let tempTxt = new StiText();
                            tempTxt.name = "*Chart_Filter*";
                            tempTxt.page = report.pages.getByIndex(0);
                            let parserResult = StiParser.parseTextValue("{" + filter.value + "}", tempTxt);
                            return parserResult;
                        }
                        switch (filter.dataType) {
                            case StiFilterDataType.String:
                                return filter.value;
                            case StiFilterDataType.Numeric:
                                return filter.value != null ? filter.value.stimulsoft().toNumber() : 0;
                            case StiFilterDataType.DateTime: {
                                let result = DateTime.fromString(filter.value);
                                if (result != null) {
                                    return result;
                                }
                                break;
                            }
                            case StiFilterDataType.Boolean:
                                return filter.value.toLowerCase() == "true";
                        }
                    }
                    catch (ee) {
                        Stimulsoft.System.StiError.showError(ee.message, false);
                    }
                    return null;
                }
                static getFilterResult(filter, itemArgument, itemValue, itemValueEnd, itemValueOpen, itemValueClose, itemValueLow, itemValueHigh, data) {
                    if (filter.item == StiFilterItem.Expression)
                        return data.stimulsoft().toBoolean();
                    let itemData = null;
                    switch (filter.item) {
                        case StiFilterItem.Argument:
                            itemData = itemArgument;
                            break;
                        case StiFilterItem.Value:
                            itemData = itemValue;
                            break;
                        case StiFilterItem.ValueEnd:
                            itemData = itemValueEnd;
                            break;
                        case StiFilterItem.ValueOpen:
                            itemData = itemValueOpen;
                            break;
                        case StiFilterItem.ValueClose:
                            itemData = itemValueClose;
                            break;
                        case StiFilterItem.ValueLow:
                            itemData = itemValueLow;
                            break;
                        case StiFilterItem.ValueHigh:
                            itemData = itemValueHigh;
                            break;
                    }
                    let result = false;
                    if (itemData != null) {
                        if (filter.dataType == StiFilterDataType.Numeric) {
                            let str = itemData.stimulsoft().as(String);
                            if (str != null) {
                                let tryResult = StiNumber.tryParse(str);
                                if (tryResult.successfully) {
                                    itemData = tryResult.result;
                                }
                            }
                        }
                        else if (filter.dataType == StiFilterDataType.DateTime) {
                            let resultDateTime = DateTime.fromString(itemData.toString(), false);
                            if (resultDateTime != null) {
                                itemData = resultDateTime;
                            }
                            else {
                                itemData = DateTime.fromOADate(itemData.stimulsoft().toNumber());
                            }
                        }
                        let comparable = itemData;
                        if (comparable != null && data != null) {
                            if (itemData.stimulsoft().getType() != data.stimulsoft().getType()) {
                                itemData = itemData.toString();
                                data = data.toString();
                                comparable = itemData;
                            }
                            try {
                                switch (filter.condition) {
                                    case StiFilterCondition.EqualTo:
                                        return comparable.stimulsoft().compareTo(data) == 0;
                                    case StiFilterCondition.NotEqualTo:
                                        return comparable.stimulsoft().compareTo(data) != 0;
                                    case StiFilterCondition.GreaterThan:
                                        return comparable.stimulsoft().compareTo(data) == 1;
                                    case StiFilterCondition.GreaterThanOrEqualTo:
                                        return comparable.stimulsoft().compareTo(data) >= 0;
                                    case StiFilterCondition.LessThan:
                                        return comparable.stimulsoft().compareTo(data) == -1;
                                    case StiFilterCondition.LessThanOrEqualTo:
                                        return comparable.stimulsoft().compareTo(data) <= 0;
                                    case StiFilterCondition.Containing: {
                                        let str1 = itemData.toString();
                                        let str2 = data.toString();
                                        return str1.indexOf(str2) != -1;
                                    }
                                    case StiFilterCondition.NotContaining: {
                                        let str3 = itemData.toString();
                                        let str4 = data.toString();
                                        return str3.indexOf(str4) == -1;
                                    }
                                    case StiFilterCondition.BeginningWith: {
                                        let str5 = itemData.toString();
                                        let str6 = data.toString();
                                        return str5.stimulsoft().startsWith(str6);
                                    }
                                    case StiFilterCondition.EndingWith: {
                                        let str7 = itemData.toString();
                                        let str8 = data.toString();
                                        return str7.stimulsoft().endsWith(str8);
                                    }
                                }
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                        }
                    }
                    return result;
                }
                static convertStringToColor(colorStr) {
                    let color;
                    if (colorStr != null) {
                        colorStr = colorStr.trim();
                        let separator = ",";
                        for (let index = 0; index < colorStr.length; index++) {
                            if (!(Char.isDigit(colorStr[index]) || Char.isWhitespace(colorStr[index]))) {
                                separator = colorStr[index];
                                break;
                            }
                        }
                        let rgb = colorStr.split(separator);
                        if (rgb.length == 3 || rgb.length == 4) {
                            try {
                                if (rgb.length == 3) {
                                    color = Color.fromArgb(parseInt(rgb[0].trim()), parseInt(rgb[1].trim()), parseInt(rgb[2].trim()));
                                }
                                else {
                                    color = Color.fromArgb(parseInt(rgb[0].trim()), parseInt(rgb[1].trim()), parseInt(rgb[2].trim()), parseInt(rgb[3].trim()));
                                }
                                if (Number.isNaN(color.b) || Number.isNaN(color.g) || Number.isNaN(color.r) || Number.isNaN(color.a)) {
                                    return null;
                                }
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                                let error = StiString.format("Can't get color from '{0}'", colorStr);
                                Report.StiLogService.write1("StiChartHelper.ConvertStringToColor " + error);
                            }
                        }
                        else {
                            try {
                                let result = parseInt(colorStr);
                                if (result >= 0) {
                                    let color2 = Color.fromArgb(result);
                                    if (result < 0xffffff)
                                        color2 = Color.fromArgb(0xff, color2.r, color2.g, color2.b);
                                    return color2;
                                }
                                return Color.fromName(colorStr);
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                                let error = StiString.format("Can't get color from '{0}'", colorStr);
                                Report.StiLogService.write1("StiChartHelper.ConvertStringToColor " + error);
                            }
                        }
                    }
                    return color;
                }
                static createChart(masterChart, chartComp) {
                    let seriesToColor = new Hashtable();
                    let applyStyle = false;
                    let seriesIndex = 0;
                    while (seriesIndex < chartComp.series.count) {
                        let series = chartComp.series.getByIndex(seriesIndex);
                        this.setTitle(masterChart, seriesIndex, series);
                        series.valuesStart = [];
                        series.values = this.checkValueNaN(this.getValues(masterChart, series));
                        let ganttSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiGanttSeries);
                        if (ganttSeries != null) {
                            ganttSeries.valuesEnd = this.getValuesEnd(masterChart, ganttSeries, ganttSeries.valueDataColumnEnd, ganttSeries.invokeGetListOfValuesEnd, ganttSeries.invokeGetValueEnd);
                        }
                        let rangSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiRangeSeries);
                        if (rangSeries != null) {
                            rangSeries.valuesEnd = this.getValuesEnd(masterChart, rangSeries, rangSeries.valueDataColumnEnd, rangSeries.invokeGetListOfValuesEnd, rangSeries.invokeGetValueEnd);
                        }
                        let steppedRangeSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiSteppedRangeSeries);
                        if (steppedRangeSeries != null) {
                            steppedRangeSeries.valuesEnd = this.getValuesEnd(masterChart, steppedRangeSeries, steppedRangeSeries.valueDataColumnEnd, steppedRangeSeries.invokeGetListOfValuesEnd, steppedRangeSeries.invokeGetValueEnd);
                        }
                        let rangeBarSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiRangeBarSeries);
                        if (rangeBarSeries != null) {
                            rangeBarSeries.valuesEnd = this.getValuesEnd(masterChart, rangeBarSeries, rangeBarSeries.valueDataColumnEnd, rangeBarSeries.invokeGetListOfValuesEnd, rangeBarSeries.invokeGetValueEnd);
                        }
                        let splineRangeSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiSplineRangeSeries);
                        if (splineRangeSeries != null) {
                            splineRangeSeries.valuesEnd = this.getValuesEnd(masterChart, splineRangeSeries, splineRangeSeries.valueDataColumnEnd, splineRangeSeries.invokeGetListOfValuesEnd, splineRangeSeries.invokeGetValueEnd);
                        }
                        let candlestickSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiCandlestickSeries);
                        if (candlestickSeries != null) {
                            candlestickSeries.valuesHigh = this.getValuesHigh(masterChart, candlestickSeries);
                            candlestickSeries.valuesLow = this.getValuesLow(masterChart, candlestickSeries);
                            candlestickSeries.valuesClose = this.getValuesClose(masterChart, candlestickSeries);
                            candlestickSeries.valuesOpen = this.getValuesOpen(masterChart, candlestickSeries);
                        }
                        let bubbleSeries = chartComp.series.getByIndex(seriesIndex).stimulsoft().as(Chart.StiBubbleSeries);
                        if (bubbleSeries != null) {
                            bubbleSeries.weights = this.getWeights(masterChart, bubbleSeries);
                        }
                        let pieSeries = series.stimulsoft().as(Chart.StiPieSeries);
                        if (pieSeries != null) {
                            this.setCutPieList(masterChart, pieSeries);
                        }
                        masterChart.cacheValues(true);
                        series.arguments = this.getArguments(masterChart, series);
                        series.tags = this.getTags(masterChart, series);
                        series.hyperlinks = this.getHyperlinks(masterChart, series);
                        series.toolTips = this.getToolTips(masterChart, series);
                        this.checkParetoValues(series);
                        if (series.is(Chart.StiHistogramSeries)) {
                            let formatService = series.chart.area.xAxis.labels.formatService;
                            Chart.StiHistogramHelper.checkValuesAndArguments(series, formatService);
                        }
                        masterChart.cacheValues(false);
                        let autoSeriesKeys = this.getAutoSeriesKeysFromAutoSeriesKeyDataColumn(masterChart, series);
                        let autoSeriesTitles = this.getAutoSeriesTitleFromAutoSeriesTitleDataColumn(masterChart, series);
                        let autoSeriesColors = this.getAutoSeriesColorFromautoSeriesColorDataColumn(masterChart, series);
                        if (series.sortBy != Chart.StiSeriesSortType.None || series.filters.count > 0 || autoSeriesKeys.length > 0) {
                            let count = series.values.length > series.arguments.length ? series.values.length : series.arguments.length;
                            let items = [];
                            for (let index = 0; index < count; index++) {
                                let value = series.values.length > index ? series.values[index] : 0;
                                let argument = series.arguments.length > index ? series.arguments[index] : null;
                                let key = autoSeriesKeys.length > index ? autoSeriesKeys[index] : null;
                                let title = autoSeriesTitles.length > index ? autoSeriesTitles[index] : null;
                                let color = autoSeriesColors.length > index ? autoSeriesColors[index] : null;
                                let tag = series.tags.length > index ? series.tags[index] : 0;
                                let valueEnd = null;
                                if (series.is(Chart.IStiRangeSeries))
                                    valueEnd = series.valuesEnd.length > index ? series.valuesEnd[index] : 0;
                                let valueOpen = null;
                                let valueClose = null;
                                let valueLow = null;
                                let valueHigh = null;
                                if (series.is(Chart.IStiFinancialSeries)) {
                                    valueOpen = series.valuesOpen.length > index ? series.valuesOpen[index] : 0;
                                    valueClose = series.valuesClose.length > index ? series.valuesClose[index] : 0;
                                    valueLow = series.valuesLow.length > index ? series.valuesLow[index] : 0;
                                    valueHigh = series.valuesHigh.length > index ? series.valuesHigh[index] : 0;
                                }
                                let weight = null;
                                if (bubbleSeries != null)
                                    weight = bubbleSeries.weights.length > index ? bubbleSeries.weights[index] : 0;
                                let toolTip = series.toolTips.length > index ? series.toolTips[index] : "";
                                items.push(new Chart.StiDataItem(argument, value, valueEnd, weight, valueOpen, valueClose, valueLow, valueHigh, title, key, color, toolTip, tag));
                            }
                            let filterToValue = new Hashtable();
                            let filterIndex = 0;
                            for (let filter of series.filters.list) {
                                let filterMethodName = StiString.format("{0}Filters_{1}_{2}", chartComp.name, seriesIndex, filterIndex);
                                filterToValue.set(filter, this.getFilterData(chartComp.report, filter, filterMethodName));
                                filterIndex++;
                            }
                            let filteredItems = [];
                            let filterSource = null;
                            let filterBusinessObject = null;
                            if (series.filters.count > 0) {
                                try {
                                    filterSource = StiDataColumn.getDataSourceFromDataColumn(chartComp.report.dictionary, series.valueDataColumn);
                                }
                                catch (e) {
                                    Stimulsoft.System.StiError.showError(e, false);
                                }
                                if (filterSource == null) {
                                    try {
                                        filterSource = StiDataColumn.getDataSourceFromDataColumn(chartComp.report.dictionary, series.argumentDataColumn);
                                    }
                                    catch (e) {
                                        Stimulsoft.System.StiError.showError(e, false);
                                    }
                                }
                                if (filterSource == null)
                                    filterSource = chartComp.dataSource;
                                try {
                                    filterBusinessObject = StiDataColumn.getBusinessObjectFromDataColumn(chartComp.report.dictionary, series.valueDataColumn);
                                }
                                catch (e) {
                                    Stimulsoft.System.StiError.showError(e, false);
                                }
                                if (filterBusinessObject == null) {
                                    try {
                                        filterBusinessObject = StiDataColumn.getBusinessObjectFromDataColumn(chartComp.report.dictionary, series.argumentDataColumn);
                                    }
                                    catch (e) {
                                        Stimulsoft.System.StiError.showError(e, false);
                                    }
                                }
                                if (filterBusinessObject == null)
                                    filterBusinessObject = chartComp.businessObject;
                            }
                            if (filterSource != null) {
                                filterSource.saveState("ChartFilter");
                                filterSource.first();
                            }
                            if (filterBusinessObject != null) {
                                filterBusinessObject.saveState("ChartFilter");
                                filterBusinessObject.createEnumerator();
                            }
                            for (let item of items) {
                                let results = StiArray.create(Boolean, series.filters.count);
                                let index = 0;
                                for (let filter of series.filters.list) {
                                    results[index] = this.getFilterResult(filter, item.argument, item.value, item.valueEnd, item.valueOpen, item.valueClose, item.valueLow, item.valueHigh, filterToValue.get(filter));
                                    if (filter.item == StiFilterItem.Expression) {
                                        let filterMethodName = StiString.format("{0}Filters_{1}_{2}", chartComp.name, seriesIndex, index);
                                        try {
                                            results[index] = this.getFilterData(chartComp.report, filter, filterMethodName).stimulsoft().toBoolean();
                                        }
                                        catch (e) {
                                            Stimulsoft.System.StiError.showError(e, false);
                                        }
                                    }
                                    index++;
                                }
                                let result2 = true;
                                if (series.filterMode == StiFilterMode.And) {
                                    for (let rs of results) {
                                        if (!rs) {
                                            result2 = false;
                                            break;
                                        }
                                    }
                                }
                                else {
                                    result2 = false;
                                    for (let rs of results) {
                                        if (rs) {
                                            result2 = true;
                                            break;
                                        }
                                    }
                                }
                                if (result2)
                                    filteredItems.push(item);
                                if (filterSource != null)
                                    filterSource.next();
                                if (filterBusinessObject != null)
                                    filterBusinessObject.next();
                            }
                            if (filterSource != null)
                                filterSource.restoreState("ChartFilter");
                            if (filterBusinessObject != null)
                                filterBusinessObject.restoreState("ChartFilter");
                            items = filteredItems;
                            if (series.sortBy != Chart.StiSeriesSortType.None) {
                                let comparer = new Chart.StiDataItemComparer(series.sortBy, series.sortDirection);
                                items.stimulsoft().sort2(comparer);
                            }
                            this.fillSeriesData(series, items);
                            if (autoSeriesKeys.length > 0) {
                                let itemToArgument = new Hashtable();
                                let argumentKeys = null;
                                if (series.arguments != null && series.arguments.length > 0) {
                                    let arrayArgumentKeys = [];
                                    let hashArgumentKeys = new Hashtable();
                                    for (let item of items) {
                                        let argument = item.argument;
                                        if (!hashArgumentKeys.containsKey(argument)) {
                                            arrayArgumentKeys.push(argument);
                                            hashArgumentKeys.add(argument, null);
                                        }
                                    }
                                    hashArgumentKeys.clear();
                                    argumentKeys = arrayArgumentKeys.stimulsoft().toArray();
                                    if (series.sortBy == Chart.StiSeriesSortType.Argument) {
                                        StiArray.sort(argumentKeys);
                                        if (series.sortDirection == Chart.StiSeriesSortDirection.Descending)
                                            StiArray.reverse(argumentKeys);
                                    }
                                }
                                else {
                                    let lenghtOfItemsPerKey = new Hashtable();
                                    for (let item of items) {
                                        let list = lenghtOfItemsPerKey.get(item.key);
                                        if (list == null) {
                                            list = [];
                                            lenghtOfItemsPerKey.set(item.key, list);
                                        }
                                        list.push(item);
                                    }
                                    let maxValue = 0;
                                    for (let value of lenghtOfItemsPerKey.values) {
                                        maxValue = Math.max(maxValue, value.count);
                                        let index = 0;
                                        for (let item of value) {
                                            item.argument = index.toString();
                                            itemToArgument.set(item, index.toString());
                                            index++;
                                        }
                                    }
                                    argumentKeys = StiArray.create(String, maxValue);
                                    for (let index = 0; index < maxValue; index++) {
                                        argumentKeys[index] = index.toString();
                                    }
                                }
                                let hashKeys = new Hashtable();
                                for (let key of autoSeriesKeys) {
                                    hashKeys.set(key, key);
                                }
                                let keys = StiArray.create(String, hashKeys.count);
                                hashKeys.keys.copyTo(keys, 0);
                                let REFkeys = {
                                    ref: keys
                                };
                                this.sortArray(REFkeys);
                                keys = REFkeys.ref;
                                let itemsArray = StiArray.create2(Chart.StiDataItem, argumentKeys.length, keys.length);
                                let argumentToIndex = new Hashtable();
                                for (let index = 0; index < argumentKeys.length; index++) {
                                    argumentToIndex.set(argumentKeys[index], index);
                                }
                                let keyToIndex = new Hashtable();
                                for (let index = 0; index < keys.length; index++) {
                                    keyToIndex.set(keys[index], index);
                                }
                                let keyToTitle = new Hashtable();
                                let keyToColor = new Hashtable();
                                for (let item of items) {
                                    let key = this.getKey(item.key);
                                    let argument = item.argument;
                                    if (series.arguments == null || series.arguments.length == 0)
                                        argument = itemToArgument.get(item);
                                    let indexKey = keyToIndex.get(key);
                                    let indexArgument = argumentToIndex.get(argument);
                                    if (item.title != null)
                                        keyToTitle.set(key, item.title);
                                    else
                                        keyToTitle.set(key, item.key);
                                    keyToColor.set(key, item.color);
                                    if (itemsArray[indexArgument][indexKey] != null) {
                                        itemsArray[indexArgument][indexKey].push(item);
                                    }
                                    else {
                                        let list = [];
                                        list.push(item);
                                        itemsArray[indexArgument][indexKey] = list;
                                    }
                                }
                                let newBubbleSeries = null;
                                if (bubbleSeries != null)
                                    newBubbleSeries = bubbleSeries.clone();
                                for (let index = 0; index < keys.length; index++) {
                                    let key = keys[index];
                                    let newSeries = null;
                                    if (index == 0)
                                        newSeries = series;
                                    else {
                                        newSeries = series.clone();
                                        chartComp.series.insert(seriesIndex + index, newSeries);
                                    }
                                    newSeries.coreTitle = keyToTitle.get(key);
                                    let color = keyToColor.get(key);
                                    seriesToColor.set(newSeries, color);
                                    let values = [];
                                    let valuesEnd = [];
                                    let _arguments = [];
                                    let weights = [];
                                    let toolTips = [];
                                    let tags = [];
                                    for (let argumentIndex = 0; argumentIndex < argumentKeys.length; argumentIndex++) {
                                        let list = itemsArray[argumentIndex][index];
                                        if (list == null) {
                                            if (newSeries.is(Chart.IStiScatterSeries))
                                                continue;
                                            values.push(null);
                                            weights.push(0);
                                            toolTips.push(null);
                                            tags.push(null);
                                            if (newSeries.is(Chart.IStiRangeSeries))
                                                valuesEnd.push(null);
                                            _arguments.push(argumentKeys[argumentIndex]);
                                        }
                                        else {
                                            for (let dataItem of list) {
                                                let value = null;
                                                let isNullArgument = newSeries.is(Chart.IStiScatterSeries);
                                                if (dataItem != null && typeof dataItem.value == "number") {
                                                    value = dataItem.value.stimulsoft().toNumber();
                                                    isNullArgument = false;
                                                }
                                                if (newSeries.is(Chart.IStiScatterSeries) && argumentKeys[argumentIndex] == null)
                                                    continue;
                                                values.push(value);
                                                if (!isNullArgument)
                                                    _arguments.push(argumentKeys[argumentIndex]);
                                                if (newSeries.is(Chart.IStiRangeSeries))
                                                    valuesEnd.push(dataItem.valueEnd.stimulsoft().toNumber());
                                                if (newBubbleSeries != null)
                                                    weights.push(dataItem.weight.stimulsoft().toNumber());
                                                if (dataItem.toolTip != null)
                                                    toolTips.push(dataItem.toolTip.toString());
                                                if (dataItem.tag != null)
                                                    tags.push(dataItem.tag);
                                            }
                                        }
                                    }
                                    let arrayValues = StiArray.create(Number, values.length);
                                    values.stimulsoft().copyTo(arrayValues);
                                    newSeries.values = arrayValues;
                                    let arrayArguments = StiArray.create(Object, _arguments.length);
                                    _arguments.stimulsoft().copyTo(arrayArguments);
                                    newSeries.arguments = arrayArguments;
                                    if (newSeries.is(Chart.IStiRangeSeries)) {
                                        let arrayValuesEnd = StiArray.create(Number, valuesEnd.length);
                                        valuesEnd.stimulsoft().copyTo(arrayValuesEnd);
                                        newSeries.valuesEnd = arrayValuesEnd;
                                    }
                                    if (newSeries.is(Chart.StiBubbleSeries)) {
                                        let arrayWeights = StiArray.create(Number, weights.length);
                                        weights.stimulsoft().copyTo(arrayWeights);
                                        newSeries.weights = arrayWeights;
                                    }
                                    newSeries.toolTips = toolTips.stimulsoft().toArray();
                                    newSeries.tags = tags.stimulsoft().toArray();
                                    this.checkArgumentsDateTimeStep(newSeries);
                                    this.createValuesTopN(newSeries);
                                    newSeries.filters = series.filters;
                                    applyStyle = true;
                                }
                                seriesIndex += keys.length - 1;
                            }
                        }
                        else {
                            this.checkArgumentsDateTimeStep(series);
                            this.createValuesTopN(series);
                        }
                        seriesIndex++;
                    }
                    Chart.StiBoxAndWhiskerHelper.checkArgument(chartComp);
                    this.checkWaterfallTotals(chartComp);
                    if (Stimulsoft["StiOptions"].Engine.allowInvokeProcessChartEventForTemplateOfChart)
                        chartComp.invokeEvents();
                    if (applyStyle && Stimulsoft["StiOptions"].Engine.applyStylesInAutoSeries) {
                        chartComp.series.applyStyle(chartComp.style);
                        let index = 0;
                        for (let series of chartComp.series.list) {
                            let color = this.convertStringToColor(seriesToColor.get(series));
                            let arg = new StiNewAutoSeriesEventArgs(index, series, null);
                            if (color != null)
                                arg.color = color;
                            series.invokeNewAutoSeries(arg);
                            if (arg.color instanceof Color)
                                series.core.applyStyle(chartComp.style, arg.color);
                            index++;
                        }
                    }
                }
                static getShorterListPoints(series) {
                    let points = [];
                    for (let index = 0; index < series.values.length; index++) {
                        points[index] = new PointD(series.values[index], index);
                    }
                    let deltaArray = [
                        0.3,
                        0.6,
                        1,
                        5,
                        9,
                        15,
                        20,
                        25,
                        30,
                        40
                    ];
                    let shorterListPoints = [];
                    let prevShorterListPoints = [];
                    for (let index = 0; index < series.values.length; index++) {
                        shorterListPoints = Chart.StiSimplifyHelper.simplify(points, deltaArray[index], true);
                        if (shorterListPoints.length / points.length < 0.02 && shorterListPoints.length < 900 && prevShorterListPoints != null) {
                            shorterListPoints = prevShorterListPoints;
                            break;
                        }
                        prevShorterListPoints = shorterListPoints;
                    }
                    return shorterListPoints;
                }
                static checkParetoValues(series) {
                    let paretoSeries = series.stimulsoft().as(Chart.StiParetoSeries);
                    if (paretoSeries != null) {
                        let values = new List();
                        let argumens = new List();
                        for (let index = 0; index < series.values.length; index++) {
                            let value = series.values[index];
                            if (value > 0) {
                                values.push(value);
                                if (series.arguments != null && index < series.arguments.length) {
                                    argumens.push(series.arguments[index]);
                                }
                                else {
                                    argumens.push(index + 1);
                                }
                            }
                        }
                        paretoSeries.values = values.stimulsoft().toArray();
                        paretoSeries.arguments = argumens.stimulsoft().toArray();
                        paretoSeries.valuesStart = [];
                    }
                }
                static checkValueNaN(values) {
                    for (let index = 0; index < values.length; index++) {
                        if (values[index] != null && isNaN(values[index])) {
                            values[index] = null;
                        }
                    }
                    return values;
                }
                static checkArgumentsDateTimeStep(series) {
                    let objects = series.arguments;
                    if (series.chart.area.is(Chart.StiAxisArea)) {
                        let dateTimeStep = series.chart.area.xAxis.dateTimeStep;
                        let step = dateTimeStep.step;
                        let countValues = dateTimeStep.numberOfValues;
                        if (this.isArgumentsDateTime(objects) && step != Chart.StiTimeDateStep.None) {
                            let _arguments = StiArray.create(DateTime, objects.length);
                            for (let index = 0; index < objects.length; index++) {
                                _arguments[index] = DateTime.fromString(objects[index].toString());
                            }
                            let dateMax = this.maximumDate(_arguments);
                            let dateMin = this.minimumDate(_arguments);
                            let totalStep = (Math.trunc(this.getTotalTimeSpans(step, dateMax, dateMin)) + 1);
                            let listArguments = [];
                            let listValues = [];
                            let firstDate = dateMin;
                            let secondDate = this.getNextDate(dateMin, step);
                            for (let index = 0; index < totalStep; index++) {
                                let ticks = (secondDate.ticks - firstDate.ticks) / countValues;
                                let halfNewSpan = new TimeSpan(ticks / 2);
                                for (let indexNumberOfValues = 0; indexNumberOfValues < countValues; indexNumberOfValues++) {
                                    let arg = new TimeSpan(ticks * indexNumberOfValues);
                                    if (arg.ticks > dateMax.ticks)
                                        continue;
                                    listArguments.push(firstDate.addTicks(arg.ticks));
                                    let firstHalfDate = new DateTime(listArguments[listArguments.length - 1].ticks - halfNewSpan.ticks);
                                    let secondHalfDate = new DateTime(listArguments[listArguments.length - 1].ticks + halfNewSpan.ticks);
                                    let val = this.getValueForDate(firstHalfDate, secondHalfDate, _arguments, series.values);
                                    listValues.push(val);
                                }
                                firstDate = secondDate;
                                secondDate = this.getNextDate(secondDate, step);
                            }
                            let newArguments = StiArray.create(Object, listArguments.length);
                            let newValues = StiArray.create(Number, listValues.length);
                            listArguments.stimulsoft().copyTo(newArguments);
                            listValues.stimulsoft().copyTo(newValues);
                            let firstIndexRealValue = 0;
                            let lastIndexRealValue = 0;
                            let firstValue = null;
                            let lastValue = null;
                            for (let index = 0; index < newValues.length; index++) {
                                if (newValues[index] != null && firstValue == null) {
                                    firstIndexRealValue = index;
                                    firstValue = newValues[index];
                                    continue;
                                }
                                if (newValues[index] != null && firstValue != null) {
                                    lastIndexRealValue = index;
                                    firstValue = newValues[firstIndexRealValue];
                                    lastValue = newValues[lastIndexRealValue];
                                    let stepRealValue = (firstValue - lastValue) / (lastIndexRealValue - firstIndexRealValue);
                                    for (let indexRealValue = firstIndexRealValue + 1; indexRealValue < lastIndexRealValue; indexRealValue++) {
                                        if (dateTimeStep.interpolation) {
                                            newValues[indexRealValue] = newValues[indexRealValue - 1] - stepRealValue;
                                        }
                                        else {
                                            newValues[indexRealValue] = 0;
                                        }
                                    }
                                    firstIndexRealValue = 0;
                                    firstValue = null;
                                    index--;
                                }
                            }
                            series.arguments = newArguments;
                            series.values = newValues;
                        }
                    }
                }
                static checkWaterfallTotals(chart) {
                    let maxCountValues = 0;
                    for (let series of chart.series.toCast()) {
                        let waterfallSeries = series.stimulsoft().as(Chart.StiWaterfallSeries);
                        if (waterfallSeries != null) {
                            maxCountValues = Math.max(maxCountValues, waterfallSeries.values.length);
                        }
                    }
                    for (let indexSeries = 0; indexSeries < chart.series.count; indexSeries++) {
                        let waterfallSeries = chart.series.list[indexSeries].stimulsoft().as(Chart.StiWaterfallSeries);
                        if (waterfallSeries != null) {
                            let listArguments = [];
                            let listValues = [];
                            let totalValue = 0;
                            for (let indexValue = 0; indexValue < maxCountValues; indexValue++) {
                                if (indexSeries == 0) {
                                    if (indexValue < waterfallSeries.arguments.length)
                                        listArguments.push(waterfallSeries.arguments[indexValue]);
                                    else
                                        listArguments.push(indexValue);
                                }
                                if (waterfallSeries.values.length > indexValue) {
                                    listValues.push(waterfallSeries.values[indexValue]);
                                    totalValue += waterfallSeries.values[indexValue];
                                }
                                else {
                                    listValues.push(null);
                                }
                            }
                            if (waterfallSeries.total.visible)
                                listValues.push(totalValue);
                            if (indexSeries == 0)
                                listArguments.push(waterfallSeries.total.text);
                            waterfallSeries.values = listValues;
                            waterfallSeries.arguments = listArguments;
                            waterfallSeries.valuesStart = [];
                        }
                    }
                }
                static createValuesTopN(series) {
                    if (series.topN.mode != Chart.StiTopNMode.None && series.values.length > series.topN.count) {
                        let count = series.topN.count;
                        let tempValues = series.values.stimulsoft().clone();
                        let tempIndexValues = StiArray.create(Number, series.values.length);
                        for (let indexValues = 0; indexValues < series.values.length; indexValues++) {
                            tempIndexValues[indexValues] = indexValues;
                        }
                        StiArray.sort3(tempValues, tempIndexValues);
                        if (series.topN.mode == Chart.StiTopNMode.Top) {
                            StiArray.reverse(tempValues);
                            StiArray.reverse(tempIndexValues);
                        }
                        let newValues = StiArray.create(Number, count);
                        let newIndex = StiArray.create(Number, count);
                        StiArray.copy(tempValues, 0, newValues, count);
                        StiArray.copy(tempIndexValues, 0, newIndex, count);
                        let listValues = [];
                        let listArguments = [];
                        let otherValue = 0;
                        for (let index = 0; index < series.values.length; index++) {
                            if (this.findIndex(newIndex, index)) {
                                listValues.push(series.values[index]);
                                if (index < series.arguments.length)
                                    listArguments.push(series.arguments[index]);
                                else
                                    listArguments.push(index);
                            }
                            else {
                                otherValue += series.values[index];
                            }
                        }
                        if (series.topN.showOthers) {
                            if (series.is(Chart.StiClusteredBarSeries)) {
                                listValues.stimulsoft().insert(0, otherValue);
                                listArguments.stimulsoft().insert(0, series.topN.othersText);
                            }
                            else {
                                listValues.push(otherValue);
                                listArguments.push(series.topN.othersText);
                            }
                        }
                        let resultValues = StiArray.create(Number, listValues.length);
                        listValues.stimulsoft().copyTo(resultValues);
                        let resultArgiments = StiArray.create(Object, listArguments.length);
                        listArguments.stimulsoft().copyTo(resultArgiments);
                        series.values = resultValues;
                        series.arguments = resultArgiments;
                    }
                }
                static getNextDate(firstDate, step) {
                    switch (step) {
                        case Chart.StiTimeDateStep.Second:
                            return firstDate.addSeconds(1);
                        case Chart.StiTimeDateStep.Minute:
                            return firstDate.addMinutes(1);
                        case Chart.StiTimeDateStep.Day:
                            return firstDate.addDays(1);
                        case Chart.StiTimeDateStep.Hour:
                            return firstDate.addHours(1);
                        case Chart.StiTimeDateStep.Month:
                            return firstDate.addMonths(1);
                        case Chart.StiTimeDateStep.Year:
                            return firstDate.addYears(1);
                    }
                    return firstDate;
                }
                static getKey(key) {
                    let numbD = key.stimulsoft().toNumber();
                    if (!isNaN(numbD) && key.split(",").join(".").split(".").length <= 2) {
                        return numbD.toString();
                    }
                    return key.toString();
                }
                static sortArray(REFarrayString) {
                    let arrayString = REFarrayString.ref;
                    let listDouble = [];
                    let listString = [];
                    for (let index = 0; index < arrayString.length; index++) {
                        let numbD = arrayString[index].stimulsoft().toNumber();
                        if (!isNaN(numbD) && arrayString[index].split(",").join(".").split(".").length <= 2) {
                            listDouble.push(numbD);
                        }
                        else {
                            listString.push(arrayString[index]);
                        }
                    }
                    listDouble.sort();
                    listString.sort();
                    let newArrayString = StiArray.create(String, arrayString.length);
                    let newIndex = 0;
                    for (let numbD of listDouble) {
                        newArrayString[newIndex] = numbD.toString();
                        newIndex++;
                    }
                    for (let str of listString) {
                        newArrayString[newIndex] = str;
                        newIndex++;
                    }
                    arrayString = newArrayString;
                    REFarrayString.ref = arrayString;
                }
                static findIndex(array, value) {
                    for (let index = 0; index < array.length; index++) {
                        if (array[index] == value) {
                            return true;
                        }
                    }
                    return false;
                }
                static getValueForDate(dateStart, dateEnd, _arguments, values) {
                    let count = 0;
                    let sum = 0;
                    let valueForDate = null;
                    for (let index = 0; index < _arguments.length; index++) {
                        let currentDate = _arguments[index];
                        if (currentDate > dateStart && currentDate <= dateEnd) {
                            count++;
                            sum += values[index];
                        }
                    }
                    if (count != 0) {
                        valueForDate = sum / count;
                    }
                    return valueForDate;
                }
                static getTotalTimeSpans(step, dateMax, dateMin) {
                    let span = TimeSpan.fromTicks(dateMax.ticks - dateMin.ticks);
                    let total = 0;
                    switch (step) {
                        case Chart.StiTimeDateStep.Second:
                            total = span.totalSeconds;
                            break;
                        case Chart.StiTimeDateStep.Minute:
                            total = span.totalMinutes;
                            break;
                        case Chart.StiTimeDateStep.Hour:
                            total = span.totalHours;
                            break;
                        case Chart.StiTimeDateStep.Day:
                            total = span.totalDays;
                            break;
                        case Chart.StiTimeDateStep.Month:
                            total = ((dateMax.year - dateMin.year) * 12) + dateMax.month - dateMin.month;
                            break;
                        case Chart.StiTimeDateStep.Year:
                            total = dateMax.year - dateMin.year;
                            break;
                    }
                    return total;
                }
                static isArgumentsDateTime(_arguments) {
                    if (_arguments.length == 0)
                        return false;
                    for (let argument of _arguments) {
                        if (argument == null)
                            return false;
                        let strForDate = argument.toString();
                        if (!DateTime.fromString(strForDate, false) != null)
                            return false;
                    }
                    return true;
                }
                static maximumDate(dates) {
                    let maxDate = DateTime.minValue;
                    for (let date of dates) {
                        if (date.toOADate2(false) > maxDate.toOADate2(false)) {
                            maxDate = date;
                        }
                    }
                    return maxDate;
                }
                static minimumDate(dates) {
                    let minDate = DateTime.maxValue;
                    for (let date of dates) {
                        if (date.toOADate2(false) < minDate.toOADate2(false)) {
                            minDate = date;
                        }
                    }
                    return minDate;
                }
                static getAutoSeriesColorFromautoSeriesColorDataColumn(masterChart, series) {
                    if (series.autoSeriesColorDataColumn != null && series.autoSeriesColorDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.autoSeriesColorDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let autoSeriesColors = StiArray.create(String, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.autoSeriesColorDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesColors[posIndex] = valueObject;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return autoSeriesColors;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.autoSeriesColorDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let autoSeriesColors = StiArray.create(String, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.autoSeriesColorDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesColors[posIndex] = valueObject;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return autoSeriesColors;
                        }
                    }
                    return [];
                }
                static getAutoSeriesTitleFromAutoSeriesTitleDataColumn(masterChart, series) {
                    if (series.autoSeriesTitleDataColumn != null && series.autoSeriesTitleDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.autoSeriesTitleDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let autoSeriesTitles = StiArray.create(String, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.autoSeriesTitleDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesTitles[posIndex] = valueObject;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return autoSeriesTitles;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.autoSeriesTitleDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let autoSeriesTitles = StiArray.create(String, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.autoSeriesTitleDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesTitles[posIndex] = valueObject;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return autoSeriesTitles;
                        }
                    }
                    return [];
                }
                static getAutoSeriesKeysFromAutoSeriesKeyDataColumn(masterChart, series) {
                    if (series.autoSeriesKeyDataColumn != null && series.autoSeriesKeyDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.autoSeriesKeyDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let autoSeriesKeys = StiArray.create(String, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.autoSeriesKeyDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesKeys[posIndex] = valueObject;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return autoSeriesKeys;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.autoSeriesKeyDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let autoSeriesKeys = StiArray.create(String, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let valueObject = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.autoSeriesKeyDataColumn);
                                if (valueObject == null)
                                    valueObject = "";
                                else
                                    valueObject = valueObject.toString();
                                autoSeriesKeys[posIndex] = valueObject;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return autoSeriesKeys;
                        }
                    }
                    return [];
                }
                static setTitle(masterChart, seriesIndex, series) {
                    let eTitle = new StiGetTitleEventArgs();
                    eTitle.series = series;
                    eTitle.index = seriesIndex;
                    series.invokeGetTitle(masterChart, eTitle);
                    if (!StiString.isNullOrEmpty(eTitle.value)) {
                        series.coreTitle = eTitle.value;
                    }
                }
                static setCutPieList(masterChart, series) {
                    let ep = new StiGetValueEventArgs();
                    series.invokeGetCutPieList(masterChart, ep);
                    if (!StiString.isNullOrEmpty(ep.value)) {
                        series.cutPieListValues = Chart.StiSeries.getValuesFromString(ep.value);
                    }
                }
                static getArguments(masterChart, series) {
                    let _arguments = this.getArgumentsFromListOfArguments(masterChart, series);
                    if (_arguments != null)
                        return _arguments;
                    _arguments = this.getArgumentsFromArgumentDataColumn(masterChart, series);
                    if (_arguments != null)
                        return _arguments;
                    _arguments = this.getArgumentsFromArgumentExpression(masterChart, series);
                    if (_arguments != null)
                        return _arguments;
                    return [];
                }
                static getArgumentsFromArgumentExpression(masterChart, series) {
                    let _arguments = StiArray.create(Object, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let ee = new StiValueEventArgs();
                        series.invokeGetArgument(masterChart, ee);
                        _arguments[posIndex] = ee.value;
                        masterChart.next();
                    }
                    return _arguments;
                }
                static getArgumentsFromArgumentDataColumn(masterChart, series) {
                    if (series.argumentDataColumn != null && series.argumentDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.argumentDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let _arguments = StiArray.create(Object, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                _arguments[posIndex] = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.argumentDataColumn);
                                if (_arguments != null && _arguments[posIndex] instanceof DateTime)
                                    series.core.isDateTimeArguments = true;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return _arguments;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.argumentDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let _arguments = StiArray.create(Object, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                _arguments[posIndex] = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.argumentDataColumn);
                                if (_arguments[posIndex] instanceof DateTime)
                                    series.core.isDateTimeArguments = true;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return _arguments;
                        }
                    }
                    return null;
                }
                static getArgumentsFromListOfArguments(masterChart, series) {
                    let e2 = new StiGetValueEventArgs();
                    series.invokeGetListOfArguments(masterChart, e2);
                    if (e2.value != null && e2.value.length > 0) {
                        return Chart.StiSeries.getArgumentsFromString(e2.value);
                    }
                    return null;
                }
                static getValues(masterChart, series) {
                    let values = this.getValuesFromListOfValues(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesFromValueDataColumn(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesFromValueExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesFromValueExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let ee = new StiGetValueEventArgs();
                        ee.value = "0";
                        series.invokeGetValue(masterChart, ee);
                        values[posIndex] = ee.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesFromValueDataColumn(masterChart, series) {
                    if (series.valueDataColumn != null && series.valueDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.valueDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.valueDataColumn);
                                if (series.is(Chart.StiGanttSeries) && !(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = null;
                                if (data != null && data instanceof DateTime) {
                                    value = data.toOADate2(false);
                                    series.core.isDateTimeValues = true;
                                }
                                else if (data != null && data != DBNull.value)
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.valueDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.valueDataColumn);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = null;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else if (data != null && data != DBNull.value)
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesFromListOfValues(masterChart, series) {
                    let e = new StiGetValueEventArgs();
                    series.invokeGetListOfValues(masterChart, e, series);
                    if (e.value != null && e.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, e.value);
                    }
                    return null;
                }
                static getValuesEnd(masterChart, series, valueDataColumnEnd, listValuesEnd, valuesEnd) {
                    let values = this.getValuesEndFromListOfValuesEnd(masterChart, series, listValuesEnd);
                    if (values != null)
                        return values;
                    values = this.getValuesEndFromValueDataColumnEnd(masterChart, series, valueDataColumnEnd);
                    if (values != null)
                        return values;
                    values = this.getValuesEndFromValueEndExpression(masterChart, valuesEnd, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesEndFromValueEndExpression(masterChart, valuesEnd, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        valuesEnd(masterChart, eeg, series);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesEndFromValueDataColumnEnd(masterChart, series, valueDataColumnEnd) {
                    if (valueDataColumnEnd != null && valueDataColumnEnd.trim().length > 0) {
                        let dataSourceGantt = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, valueDataColumnEnd);
                        if (dataSourceGantt != null) {
                            dataSourceGantt.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSourceGantt.count);
                            dataSourceGantt.first();
                            for (let posIndex = 0; posIndex < dataSourceGantt.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, valueDataColumnEnd);
                                if (series.is(Chart.StiGanttSeries) && !(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = null;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else if (data != null && data != DBNull.value)
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSourceGantt.next();
                            }
                            dataSourceGantt.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObjectGantt = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, valueDataColumnEnd);
                        if (businessObjectGantt != null) {
                            businessObjectGantt.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObjectGantt.count);
                            businessObjectGantt.first();
                            for (let posIndex = 0; posIndex < businessObjectGantt.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, valueDataColumnEnd);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = null;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else if (data != null && data != DBNull.value)
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObjectGantt.next();
                            }
                            businessObjectGantt.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesEndFromListOfValuesEnd(masterChart, series, listValues) {
                    let eg = new StiGetValueEventArgs();
                    listValues(masterChart, eg, series);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getValuesOpen(masterChart, series) {
                    let values = this.getValuesOpenFromListOfValuesOpen(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesOpenFromValueDataColumnOpen(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesOpenFromValuesOpenExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesOpenFromValuesOpenExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        series.invokeGetValueOpen(masterChart, eeg);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesOpenFromValueDataColumnOpen(masterChart, series) {
                    if (series.valueDataColumnOpen != null && series.valueDataColumnOpen.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.valueDataColumnOpen);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.valueDataColumnOpen);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.valueDataColumnOpen);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.valueDataColumnOpen);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesOpenFromListOfValuesOpen(masterChart, series) {
                    let eg = new StiGetValueEventArgs();
                    series.invokeGetListOfValuesOpen(masterChart, eg);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getValuesClose(masterChart, series) {
                    let values = this.getValuesCloseFromListOfValuesClose(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesCloseFromValueDataColumnClose(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesCloseFromValuesCloseExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesCloseFromValuesCloseExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        series.invokeGetValueClose(masterChart, eeg);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesCloseFromValueDataColumnClose(masterChart, series) {
                    if (series.valueDataColumnClose != null && series.valueDataColumnClose.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.valueDataColumnClose);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.valueDataColumnClose);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.valueDataColumnClose);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.valueDataColumnClose);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesCloseFromListOfValuesClose(masterChart, series) {
                    let eg = new StiGetValueEventArgs();
                    series.invokeGetListOfValuesClose(masterChart, eg);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getValuesHigh(masterChart, series) {
                    let values = this.getValuesHighFromListOfValuesHigh(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesHighFromValueDataColumnHigh(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesHighFromValuesHighExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesHighFromValuesHighExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        series.invokeGetValueHigh(masterChart, eeg);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesHighFromValueDataColumnHigh(masterChart, series) {
                    if (series.valueDataColumnHigh != null && series.valueDataColumnHigh.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.valueDataColumnHigh);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.valueDataColumnHigh);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.valueDataColumnHigh);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.valueDataColumnHigh);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesHighFromListOfValuesHigh(masterChart, series) {
                    let eg = new StiGetValueEventArgs();
                    series.invokeGetListOfValuesHigh(masterChart, eg);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getValuesLow(masterChart, series) {
                    let values = this.getValuesLowFromListOfValuesLow(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesLowFromValueDataColumnLow(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getValuesLowFromValuesLowExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getValuesLowFromValuesLowExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        series.invokeGetValueLow(masterChart, eeg);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getValuesLowFromValueDataColumnLow(masterChart, series) {
                    if (series.valueDataColumnLow != null && series.valueDataColumnLow.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.valueDataColumnLow);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.valueDataColumnLow);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.valueDataColumnLow);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.valueDataColumnLow);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getValuesLowFromListOfValuesLow(masterChart, series) {
                    let eg = new StiGetValueEventArgs();
                    series.invokeGetListOfValuesLow(masterChart, eg);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getWeights(masterChart, series) {
                    let values = this.getWeightsFromListOfWeights(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getWeightsFromWeightDataColumn(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getWeightsWeightExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getWeightsWeightExpression(masterChart, series) {
                    let values = StiArray.create(Number, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let eeg = new StiGetValueEventArgs();
                        eeg.value = "0";
                        series.invokeGetWeight(masterChart, eeg);
                        values[posIndex] = eeg.value.stimulsoft().toNumber();
                        masterChart.next();
                    }
                    return values;
                }
                static getWeightsFromWeightDataColumn(masterChart, series) {
                    if (series.weightDataColumn != null && series.weightDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.weightDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.weightDataColumn);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.weightDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Number, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.weightDataColumn);
                                if (!(data instanceof DateTime) && DateTime.fromString(data.toString(), false) != null)
                                    data = DateTime.fromString(data.toString());
                                let value = 0;
                                if (data instanceof DateTime) {
                                    series.core.isDateTimeValues = true;
                                    value = data.toOADate2(false);
                                }
                                else
                                    value = data.stimulsoft().toNumber();
                                values[posIndex] = value;
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getWeightsFromListOfWeights(masterChart, series) {
                    let eg = new StiGetValueEventArgs();
                    series.invokeGetListOfWeights(masterChart, eg, series);
                    if (eg.value != null && eg.value.length > 0) {
                        return Chart.StiSeries.getNullableValuesFromString(series, eg.value);
                    }
                    return null;
                }
                static getHyperlinks(masterChart, series) {
                    let values = this.getHyperlinksFromListOfHyperlinks(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getHyperlinksFromHyperlinkDataColumn(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getHyperlinksFromHyperlinkExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getHyperlinksFromHyperlinkExpression(masterChart, series) {
                    let values = StiArray.create(String, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let ee = new StiValueEventArgs();
                        ee.value = null;
                        series.invokeGetHyperlink(masterChart, ee);
                        if (ee.value != null)
                            values[posIndex] = ee.value.toString();
                        masterChart.next();
                    }
                    return values;
                }
                static getHyperlinksFromHyperlinkDataColumn(masterChart, series) {
                    if (series.hyperlinkDataColumn != null && series.hyperlinkDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.hyperlinkDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(String, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.hyperlinkDataColumn);
                                if (data != null)
                                    values[posIndex] = data.toString();
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.hyperlinkDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(String, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.hyperlinkDataColumn);
                                if (data != null)
                                    values[posIndex] = data.toString();
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getHyperlinksFromListOfHyperlinks(masterChart, series) {
                    let e = new StiGetValueEventArgs();
                    series.invokeGetListOfHyperlinks(masterChart, e);
                    if (e.value != null && e.value.length > 0) {
                        return Chart.StiSeries.getStringsFromString(e.value);
                    }
                    return null;
                }
                static getTags(masterChart, series) {
                    let values = this.getTagsFromListOfTags(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getTagsFromTagDataColumn(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getTagsFromTagExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getTagsFromTagExpression(masterChart, series) {
                    let values = StiArray.create(Object, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let ee = new StiValueEventArgs();
                        ee.value = null;
                        series.invokeGetTag(masterChart, ee);
                        values[posIndex] = ee.value;
                        masterChart.next();
                    }
                    return values;
                }
                static getTagsFromTagDataColumn(masterChart, series) {
                    if (series.tagDataColumn != null && series.tagDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.tagDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Object, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.tagDataColumn);
                                values[posIndex] = data;
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.tagDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(Object, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                values[posIndex] = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.tagDataColumn);
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getTagsFromListOfTags(masterChart, series) {
                    let e = new StiGetValueEventArgs();
                    series.invokeGetListOfTags(masterChart, e);
                    if (e.value != null && e.value.length > 0) {
                        return Chart.StiSeries.getStringsFromString(e.value);
                    }
                    return null;
                }
                static getToolTips(masterChart, series) {
                    let values = this.getToolTipsFromListOfToolTips(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getToolTipsFromToolTipDataColumn(masterChart, series);
                    if (values != null)
                        return values;
                    values = this.getToolTipsFromToolTipExpression(masterChart, series);
                    if (values != null)
                        return values;
                    return [];
                }
                static getToolTipsFromToolTipExpression(masterChart, series) {
                    let values = StiArray.create(String, masterChart.count);
                    masterChart.first();
                    for (let posIndex = 0; posIndex < masterChart.count; posIndex++) {
                        let ee = new StiValueEventArgs();
                        ee.value = null;
                        series.invokeGetToolTip(masterChart, ee);
                        if (ee.value != null)
                            values[posIndex] = ee.value.toString();
                        masterChart.next();
                    }
                    return values;
                }
                static getToolTipsFromToolTipDataColumn(masterChart, series) {
                    if (series.toolTipDataColumn != null && series.toolTipDataColumn.trim().length > 0) {
                        let dataSource = StiDataColumn.getDataSourceFromDataColumn(masterChart.report.dictionary, series.toolTipDataColumn);
                        if (dataSource != null) {
                            dataSource.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(String, dataSource.count);
                            dataSource.first();
                            for (let posIndex = 0; posIndex < dataSource.count; posIndex++) {
                                let data = StiDataColumn.getDataFromDataColumn(masterChart.report.dictionary, series.toolTipDataColumn);
                                if (data != null)
                                    values[posIndex] = data.toString();
                                dataSource.next();
                            }
                            dataSource.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                        let businessObject = StiDataColumn.getBusinessObjectFromDataColumn(masterChart.report.dictionary, series.toolTipDataColumn);
                        if (businessObject != null) {
                            businessObject.saveState("ChartRender_DataColumn");
                            let values = StiArray.create(String, businessObject.count);
                            businessObject.first();
                            for (let posIndex = 0; posIndex < businessObject.count; posIndex++) {
                                let data = StiDataColumn.getDataFromBusinessObject(masterChart.report.dictionary, series.toolTipDataColumn);
                                if (data != null)
                                    values[posIndex] = data.toString();
                                businessObject.next();
                            }
                            businessObject.restoreState("ChartRender_DataColumn");
                            return values;
                        }
                    }
                    return null;
                }
                static getToolTipsFromListOfToolTips(masterChart, series) {
                    let e = new StiGetValueEventArgs();
                    series.invokeGetListOfToolTips(masterChart, e);
                    if (e.value != null && e.value.length > 0) {
                        return Chart.StiSeries.getStringsFromString(e.value);
                    }
                    return null;
                }
                static getAnimationСompatibilitySeries(series1, series2) {
                    let type1 = StiChartHelper.getAnimationSeriesType(series1);
                    let type2 = StiChartHelper.getAnimationSeriesType(series2);
                    if (type1 == Chart.StiSeriesAnimationType.None || type2 == Chart.StiSeriesAnimationType.None)
                        return false;
                    return type1 == type2;
                }
                static getAnimationSeriesType(series) {
                    let seriesType = series.stimulsoft().getType();
                    if (seriesType == Chart.StiClusteredColumnSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiStackedColumnSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiFullStackedColumnSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiRangeBarSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiHistogramSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiWaterfallSeries)
                        return Chart.StiSeriesAnimationType.Column;
                    if (seriesType == Chart.StiLineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiStackedLineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiFullStackedLineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiSplineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiStackedSplineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiFullStackedSplineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiSteppedLineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiScatterLineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiScatterSplineSeries)
                        return Chart.StiSeriesAnimationType.Line;
                    if (seriesType == Chart.StiClusteredBarSeries)
                        return Chart.StiSeriesAnimationType.Bar;
                    if (seriesType == Chart.StiStackedBarSeries)
                        return Chart.StiSeriesAnimationType.Bar;
                    if (seriesType == Chart.StiFullStackedBarSeries)
                        return Chart.StiSeriesAnimationType.Bar;
                    if (seriesType == Chart.StiGanttSeries)
                        return Chart.StiSeriesAnimationType.Bar;
                    if (seriesType == Chart.StiAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiStackedAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiFullStackedAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiSplineAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiStackedSplineAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiFullStackedSplineAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiSteppedAreaSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiRangeSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiSplineRangeSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    if (seriesType == Chart.StiSteppedRangeSeries)
                        return Chart.StiSeriesAnimationType.Range;
                    return Chart.StiSeriesAnimationType.None;
                }
            }
            StiChartHelper.globalDurationElement = new TimeSpan(0, 0, 1);
            StiChartHelper.globalBeginTimeElement = new TimeSpan(0, 0, 1);
            Chart.StiChartHelper = StiChartHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Events;
        (function (Events) {
            class StiProcessChartEvent extends Events.StiEvent {
                toString() {
                    return "ProcessChart";
                }
            }
            Events.StiProcessChartEvent = StiProcessChartEvent;
        })(Events = Report.Events || (Report.Events = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiService = Stimulsoft.Base.Services.StiService;
            class StiArea extends StiService {
                constructor() {
                    super(...arguments);
                    this._chart = null;
                    this._allowApplyStyle = true;
                    this._colorEach = false;
                    this._showShadow = false;
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.white);
                }
                implements() {
                    if (!StiArea.implementsStiArea)
                        StiArea.implementsStiArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiArea.implementsStiArea;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyBool("ColorEach", this.colorEach);
                    jObject.addPropertyBool("ShowShadow", this._showShadow);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "ColorEach":
                                this.colorEach = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowShadow":
                                this._showShadow = property.value.stimulsoft().toBoolean();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ColorEach":
                                this.colorEach = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowShadow":
                                this._showShadow = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                        }
                    }
                }
                static loadFromJsonObjectInternal(jObject) {
                    let ident = jObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                    let service = Stimulsoft["StiOptions"].Services.chartAreas.firstOrDefault(x => x.stimulsoft().getType().stimulsoft().getTypeName() == ident);
                    if (service == null)
                        throw StiString.format("Type {0} is not found!", ident);
                    let area = service.createNew();
                    area.loadFromJsonObject(jObject);
                    return area;
                }
                static loadAreaFromXml(xmlNode, chart) {
                    switch (xmlNode.attributes.getNamedItem("type").value) {
                        case "Stimulsoft.Report.Chart.StiClusteredColumnArea": {
                            let clusteredColumnArea = new Chart.StiClusteredColumnArea();
                            clusteredColumnArea.chart = chart;
                            clusteredColumnArea.loadFromXml(xmlNode);
                            return clusteredColumnArea;
                        }
                        case "Stimulsoft.Report.Chart.StiLineArea": {
                            let lineArea = new Chart.StiLineArea();
                            lineArea.chart = chart;
                            lineArea.loadFromXml(xmlNode);
                            return lineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiAreaArea": {
                            let areaArea = new Chart.StiAreaArea();
                            areaArea.chart = chart;
                            areaArea.loadFromXml(xmlNode);
                            return areaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSplineArea": {
                            let splineArea = new Chart.StiSplineArea();
                            splineArea.chart = chart;
                            splineArea.loadFromXml(xmlNode);
                            return splineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSplineAreaArea": {
                            let splineAreaArea = new Chart.StiSplineAreaArea();
                            splineAreaArea.chart = chart;
                            splineAreaArea.loadFromXml(xmlNode);
                            return splineAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedColumnArea": {
                            let stackedColumnArea = new Chart.StiStackedColumnArea();
                            stackedColumnArea.chart = chart;
                            stackedColumnArea.loadFromXml(xmlNode);
                            return stackedColumnArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedLineArea": {
                            let stackedLineArea = new Chart.StiStackedLineArea();
                            stackedLineArea.chart = chart;
                            stackedLineArea.loadFromXml(xmlNode);
                            return stackedLineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedAreaArea": {
                            let stackedAreaArea = new Chart.StiStackedAreaArea();
                            stackedAreaArea.chart = chart;
                            stackedAreaArea.loadFromXml(xmlNode);
                            return stackedAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedSplineArea": {
                            let stackedSplineArea = new Chart.StiStackedSplineArea();
                            stackedSplineArea.chart = chart;
                            stackedSplineArea.loadFromXml(xmlNode);
                            return stackedSplineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedSplineAreaArea": {
                            let stackedSplineAreaArea = new Chart.StiStackedSplineAreaArea();
                            stackedSplineAreaArea.chart = chart;
                            stackedSplineAreaArea.loadFromXml(xmlNode);
                            return stackedSplineAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSteppedLineArea": {
                            let steppedLineArea = new Chart.StiSteppedLineArea();
                            steppedLineArea.chart = chart;
                            steppedLineArea.loadFromXml(xmlNode);
                            return steppedLineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSteppedAreaArea": {
                            let steppedAreaArea = new Chart.StiSteppedAreaArea();
                            steppedAreaArea.chart = chart;
                            steppedAreaArea.loadFromXml(xmlNode);
                            return steppedAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedColumnArea": {
                            let fullStackedColumnArea = new Chart.StiFullStackedColumnArea();
                            fullStackedColumnArea.chart = chart;
                            fullStackedColumnArea.loadFromXml(xmlNode);
                            return fullStackedColumnArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedLineArea": {
                            let fullStackedLineArea = new Chart.StiFullStackedLineArea();
                            fullStackedLineArea.chart = chart;
                            fullStackedLineArea.loadFromXml(xmlNode);
                            return fullStackedLineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedAreaArea": {
                            let fullStackedAreaArea = new Chart.StiFullStackedAreaArea();
                            fullStackedAreaArea.chart = chart;
                            fullStackedAreaArea.loadFromXml(xmlNode);
                            return fullStackedAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedSplineArea": {
                            let fullStackedSplineArea = new Chart.StiFullStackedSplineArea();
                            fullStackedSplineArea.chart = chart;
                            fullStackedSplineArea.loadFromXml(xmlNode);
                            return fullStackedSplineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedSplineAreaArea": {
                            let fullStackedSplineAreaArea = new Chart.StiFullStackedSplineAreaArea();
                            fullStackedSplineAreaArea.chart = chart;
                            fullStackedSplineAreaArea.loadFromXml(xmlNode);
                            return fullStackedSplineAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiClusteredBarArea": {
                            let clusteredBarArea = new Chart.StiClusteredBarArea();
                            clusteredBarArea.chart = chart;
                            clusteredBarArea.loadFromXml(xmlNode);
                            return clusteredBarArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStackedBarArea": {
                            let stackedBarArea = new Chart.StiStackedBarArea();
                            stackedBarArea.chart = chart;
                            stackedBarArea.loadFromXml(xmlNode);
                            return stackedBarArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFullStackedBarArea": {
                            let fullStackedBarArea = new Chart.StiFullStackedBarArea();
                            fullStackedBarArea.chart = chart;
                            fullStackedBarArea.loadFromXml(xmlNode);
                            return fullStackedBarArea;
                        }
                        case "Stimulsoft.Report.Chart.StiPieArea": {
                            let pieArea = new Chart.StiPieArea();
                            pieArea.chart = chart;
                            pieArea.loadFromXml(xmlNode);
                            return pieArea;
                        }
                        case "Stimulsoft.Report.Chart.StiDoughnutArea": {
                            let doughnutArea = new Chart.StiDoughnutArea();
                            doughnutArea.chart = chart;
                            doughnutArea.loadFromXml(xmlNode);
                            return doughnutArea;
                        }
                        case "Stimulsoft.Report.Chart.StiRadarPointArea": {
                            let radarPointArea = new Chart.StiRadarPointArea();
                            radarPointArea.chart = chart;
                            radarPointArea.loadFromXml(xmlNode);
                            return radarPointArea;
                        }
                        case "Stimulsoft.Report.Chart.StiRadarLineArea": {
                            let radarLineArea = new Chart.StiRadarLineArea();
                            radarLineArea.chart = chart;
                            radarLineArea.loadFromXml(xmlNode);
                            return radarLineArea;
                        }
                        case "Stimulsoft.Report.Chart.StiRadarAreaArea": {
                            let radarAreaArea = new Chart.StiRadarAreaArea();
                            radarAreaArea.chart = chart;
                            radarAreaArea.loadFromXml(xmlNode);
                            return radarAreaArea;
                        }
                        case "Stimulsoft.Report.Chart.StiGanttArea": {
                            let ganttArea = new Chart.StiGanttArea();
                            ganttArea.chart = chart;
                            ganttArea.loadFromXml(xmlNode);
                            return ganttArea;
                        }
                        case "Stimulsoft.Report.Chart.StiScatterArea": {
                            let scatterArea = new Chart.StiScatterArea();
                            scatterArea.chart = chart;
                            scatterArea.loadFromXml(xmlNode);
                            return scatterArea;
                        }
                        case "Stimulsoft.Report.Chart.StiBubbleArea": {
                            let bubbleArea = new Chart.StiBubbleArea();
                            bubbleArea.chart = chart;
                            bubbleArea.loadFromXml(xmlNode);
                            return bubbleArea;
                        }
                        case "Stimulsoft.Report.Chart.StiRangeArea": {
                            let rangeArea = new Chart.StiRangeArea();
                            rangeArea.chart = chart;
                            rangeArea.loadFromXml(xmlNode);
                            return rangeArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSplineRangeArea": {
                            let splineRangeArea = new Chart.StiSplineRangeArea();
                            splineRangeArea.chart = chart;
                            splineRangeArea.loadFromXml(xmlNode);
                            return splineRangeArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSteppedRangeArea": {
                            let steppedRangeArea = new Chart.StiSteppedRangeArea();
                            steppedRangeArea.chart = chart;
                            steppedRangeArea.loadFromXml(xmlNode);
                            return steppedRangeArea;
                        }
                        case "Stimulsoft.Report.Chart.StiRangeBarArea": {
                            let rangeBarArea = new Chart.StiRangeBarArea();
                            rangeBarArea.chart = chart;
                            rangeBarArea.loadFromXml(xmlNode);
                            return rangeBarArea;
                        }
                        case "Stimulsoft.Report.Chart.StiCandlestickArea": {
                            let candlestickArea = new Chart.StiCandlestickArea();
                            candlestickArea.chart = chart;
                            candlestickArea.loadFromXml(xmlNode);
                            return candlestickArea;
                        }
                        case "Stimulsoft.Report.Chart.StiStockArea": {
                            let stockArea = new Chart.StiStockArea();
                            stockArea.chart = chart;
                            stockArea.loadFromXml(xmlNode);
                            return stockArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFunnelArea": {
                            let funnelArea = new Chart.StiFunnelArea();
                            funnelArea.chart = chart;
                            funnelArea.loadFromXml(xmlNode);
                            return funnelArea;
                        }
                        case "Stimulsoft.Report.Chart.StiFunnelWeightedSlicesArea": {
                            let funnelWeightedSlicesArea = new Chart.StiFunnelWeightedSlicesArea();
                            funnelWeightedSlicesArea.chart = chart;
                            funnelWeightedSlicesArea.loadFromXml(xmlNode);
                            return funnelWeightedSlicesArea;
                        }
                        case "Stimulsoft.Report.Chart.StiTreemapArea": {
                            let treemapArea = new Chart.StiTreemapArea();
                            treemapArea.chart = chart;
                            treemapArea.loadFromXml(xmlNode);
                            return treemapArea;
                        }
                        case "Stimulsoft.Report.Chart.StiPictorialArea": {
                            let pictorialArea = new Chart.StiPictorialArea();
                            pictorialArea.chart = chart;
                            pictorialArea.loadFromXml(xmlNode);
                            return pictorialArea;
                        }
                        case "Stimulsoft.Report.Chart.StiParetoArea": {
                            let paretoArea = new Chart.StiParetoArea();
                            paretoArea.chart = chart;
                            paretoArea.loadFromXml(xmlNode);
                            return paretoArea;
                        }
                        case "Stimulsoft.Report.Chart.StiWaterfallArea": {
                            let waterfallArea = new Chart.StiWaterfallArea();
                            waterfallArea.chart = chart;
                            waterfallArea.loadFromXml(xmlNode);
                            return waterfallArea;
                        }
                        case "Stimulsoft.Report.Chart.StiHistogramArea": {
                            let histogramArea = new Chart.StiHistogramArea();
                            histogramArea.chart = chart;
                            histogramArea.loadFromXml(xmlNode);
                            return histogramArea;
                        }
                        case "Stimulsoft.Report.Chart.StiSunburstArea": {
                            let sunburstArea = new Chart.StiSunburstArea();
                            sunburstArea.chart = chart;
                            sunburstArea.loadFromXml(xmlNode);
                            return sunburstArea;
                        }
                        case "Stimulsoft.Report.Chart.StiBoxAndWhiskerArea": {
                            let boxAndWhiskerArea = new Chart.StiBoxAndWhiskerArea();
                            boxAndWhiskerArea.chart = chart;
                            boxAndWhiskerArea.loadFromXml(xmlNode);
                            return boxAndWhiskerArea;
                        }
                    }
                    return null;
                }
                get componentId() {
                    return null;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let area = super.clone();
                    area.brush = this.brush.clone();
                    if (this.core != null) {
                        area.core = this.core.clone();
                        area.core.area = area;
                    }
                    return area;
                }
                createNew() {
                    return null;
                }
                toString() {
                    return this.serviceName;
                }
                getDefaultSeriesType() {
                    return null;
                }
                getSeriesTypes() {
                    return null;
                }
                getDefaultSeriesLabelsType() {
                    return null;
                }
                getSeriesLabelsTypes() {
                    return null;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiArea;
                }
                get isDefaultSeriesTypeFullStackedColumnSeries() {
                    return this.getDefaultSeriesType() == Chart.StiFullStackedColumnSeries;
                }
                get isDefaultSeriesTypeFullStackedBarSeries() {
                    return this.getDefaultSeriesType() == Chart.StiFullStackedBarSeries;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get colorEach() {
                    return this._colorEach;
                }
                set colorEach(value) {
                    this._colorEach = value;
                }
                get showShadow() {
                    return this._showShadow;
                }
                set showShadow(value) {
                    this._showShadow = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
            }
            Chart.StiArea = StiArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Enum = Stimulsoft.System.Enum;
            class StiRadarArea extends Chart.StiArea {
                constructor() {
                    super();
                    this._radarStyle = Chart.StiRadarStyle.Circle;
                    this.xAxis = new Chart.StiXRadarAxis();
                    this.yAxis = new Chart.StiYRadarAxis();
                    this.interlacingHor = new Chart.StiInterlacingHor();
                    this.interlacingVert = new Chart.StiInterlacingVert();
                    this.gridLinesHor = new Chart.StiRadarGridLinesHor();
                    this.gridLinesVert = new Chart.StiRadarGridLinesVert();
                }
                implements() {
                    if (!StiRadarArea.implementsStiRadarArea)
                        StiRadarArea.implementsStiRadarArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarArea,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiRadarArea.implementsStiRadarArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyJObject("InterlacingHor", this._interlacingHor.saveToJsonObject(mode));
                    jObject.addPropertyJObject("InterlacingVert", this._interlacingVert.saveToJsonObject(mode));
                    jObject.addPropertyJObject("GridLinesHor", this._gridLinesHor.saveToJsonObject(mode));
                    jObject.addPropertyJObject("GridLinesVert", this._gridLinesHor.saveToJsonObject(mode));
                    jObject.addPropertyEnum("RadarStyle", Chart.StiRadarStyle, this._radarStyle, Chart.StiRadarStyle.Circle);
                    jObject.addPropertyJObject("XAxis", this._xAxis.saveToJsonObject(mode));
                    jObject.addPropertyJObject("YAxis", this._yAxis.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "InterlacingHor":
                                this._interlacingHor.loadFromJsonObject(property.value);
                                break;
                            case "InterlacingVert":
                                this._interlacingVert.loadFromJsonObject(property.value);
                                break;
                            case "GridLinesHor":
                                this._gridLinesHor.loadFromJsonObject(property.value);
                                break;
                            case "GridLinesVert":
                                this._gridLinesVert.loadFromJsonObject(property.value);
                                break;
                            case "RadarStyle":
                                this._radarStyle = Enum.parse(Chart.StiRadarStyle, property.value.toString());
                                break;
                            case "XAxis":
                                this._xAxis.loadFromJsonObject(property.value);
                                if (this._xAxis.stimulsoft().as(Chart.StiRadarAxis).jsonLoadFromJsonObjectArea == true) {
                                    this._xAxis.stimulsoft().as(Chart.StiRadarAxis).jsonLoadFromJsonObjectArea = false;
                                    this._xAxis.area = this;
                                }
                                break;
                            case "YAxis":
                                this._yAxis.loadFromJsonObject(property.value);
                                if (this._yAxis.stimulsoft().as(Chart.StiRadarAxis).jsonLoadFromJsonObjectArea == true) {
                                    this._yAxis.stimulsoft().as(Chart.StiRadarAxis).jsonLoadFromJsonObjectArea = false;
                                    this._yAxis.area = this;
                                }
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "InterlacingHor":
                                this._interlacingHor.loadFromXml(node);
                                break;
                            case "InterlacingVert":
                                this._interlacingVert.loadFromXml(node);
                                break;
                            case "GridLinesHor":
                                this._gridLinesHor.loadFromXml(node);
                                break;
                            case "GridLinesVert":
                                this._gridLinesVert.loadFromXml(node);
                                break;
                            case "RadarStyle":
                                this._radarStyle = Enum.parse(Chart.StiRadarStyle, node.textContent);
                                break;
                            case "XAxis":
                                this._xAxis.loadFromXml(node);
                                this._xAxis.area = this;
                                break;
                            case "YAxis":
                                this._yAxis.loadFromXml(node);
                                this._yAxis.area = this;
                                break;
                        }
                    }
                }
                clone() {
                    let area = super.clone();
                    area.interlacingHor = this.interlacingHor.clone();
                    area.interlacingVert = this.interlacingVert.clone();
                    area.gridLinesHor = this.gridLinesHor.clone();
                    area.gridLinesVert = this.gridLinesVert.clone();
                    area.xAxis = this.xAxis.clone();
                    area.yAxis = this.yAxis.clone();
                    return area;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiNoneLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiOutsideBaseAxisLabels,
                        Chart.StiOutsideEndAxisLabels,
                        Chart.StiOutsideAxisLabels,
                        Chart.StiValueAxisLabels];
                }
                get interlacingHor() {
                    return this._interlacingHor;
                }
                set interlacingHor(value) {
                    this._interlacingHor = value;
                    if (this._interlacingHor != null)
                        this._interlacingHor.area = this;
                }
                get interlacingVert() {
                    return this._interlacingVert;
                }
                set interlacingVert(value) {
                    this._interlacingVert = value;
                    if (this._interlacingVert != null)
                        this._interlacingVert.area = this;
                }
                get gridLinesHor() {
                    return this._gridLinesHor;
                }
                set gridLinesHor(value) {
                    this._gridLinesHor = value;
                    if (this._gridLinesHor != null)
                        this._gridLinesHor.area = this;
                }
                get gridLinesVert() {
                    return this._gridLinesVert;
                }
                set gridLinesVert(value) {
                    this._gridLinesVert = value;
                    if (this._gridLinesVert != null)
                        this._gridLinesVert.area = this;
                }
                get radarStyle() {
                    return this._radarStyle;
                }
                set radarStyle(value) {
                    if (this._radarStyle != value) {
                        this._radarStyle = value;
                    }
                }
                get xAxis() {
                    return this._xAxis;
                }
                set xAxis(value) {
                    this._xAxis = value;
                    if (this._xAxis != null)
                        this._xAxis.area = this;
                }
                get yAxis() {
                    return this._yAxis;
                }
                set yAxis(value) {
                    this._yAxis = value;
                    if (this._yAxis != null)
                        this._yAxis.area = this;
                }
            }
            Chart.StiRadarArea = StiRadarArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var ICloneable = Stimulsoft.System.ICloneable;
            var IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
            class StiChartCoreXF {
                constructor(chart) {
                    this._chart = chart;
                }
                implements() {
                    if (!StiChartCoreXF.implementsStiChartCoreXF)
                        StiChartCoreXF.implementsStiChartCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiChartCoreXF
                        ];
                    return StiChartCoreXF.implementsStiChartCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    this.chart.style = style;
                    if (this.chart.allowApplyStyle)
                        this.chart.brush = style.core.chartBrush;
                    if (this.chart.title != null)
                        this.chart.title.core.applyStyle(style);
                    if (this.chart.area != null)
                        this.chart.area.core.applyStyle(style);
                    if (this.chart.legend != null)
                        this.chart.legend.core.applyStyle(style);
                    if (this.chart.seriesLabels != null)
                        this.chart.seriesLabels.core.applyStyle(style);
                    if (this.chart.series != null)
                        this.chart.series.applyStyle(style);
                    if (this.chart.constantLines != null)
                        this.chart.constantLines.applyStyle(style);
                    if (this.chart.strips != null)
                        this.chart.strips.applyStyle(style);
                    if (this.chart.table != null)
                        this.chart.table.core.applyStyle(style);
                }
                render(context, rect, useMargins) {
                    let chartGeom = new Chart.StiChartGeom(rect);
                    chartGeom.createChildGeoms();
                    let fullRectangle;
                    if (useMargins) {
                        let zoom = context.options.zoom;
                        fullRectangle = new RectangleD(rect.x + this._chart.horSpacing * zoom, rect.y + this._chart.vertSpacing * zoom, rect.width - this._chart.horSpacing * 2 * zoom, rect.height - this._chart.vertSpacing * 2 * zoom);
                    }
                    else {
                        fullRectangle = rect.clone();
                    }
                    this._fullRectangle = fullRectangle;
                    let titleGeom = this._chart.title.core.render(context, this._chart.title, fullRectangle);
                    if (titleGeom != null) {
                        switch (this._chart.title.dock) {
                            case Chart.StiChartTitleDock.Top:
                                fullRectangle.y += titleGeom.clientRectangle.height;
                                fullRectangle.height -= titleGeom.clientRectangle.height;
                                break;
                            case Chart.StiChartTitleDock.Right:
                                fullRectangle.width -= titleGeom.clientRectangle.width;
                                break;
                            case Chart.StiChartTitleDock.Bottom:
                                fullRectangle.height -= titleGeom.clientRectangle.height;
                                break;
                            case Chart.StiChartTitleDock.Left:
                                fullRectangle.x += titleGeom.clientRectangle.width;
                                fullRectangle.width -= titleGeom.clientRectangle.width;
                                break;
                        }
                        chartGeom.childGeoms.push(titleGeom);
                    }
                    let areaGeom = null;
                    let legendGeom = null;
                    let areaRect = fullRectangle.clone();
                    if (this._chart.legend != null) {
                        areaGeom = this._chart.area.core.render(context, areaRect.clone());
                        legendGeom = this._chart.legend.core.render(context, areaGeom.clientRectangle.clone());
                        if (legendGeom != null) {
                            let legendRect = legendGeom.clientRectangle.clone();
                            let REFfullRectangle = { ref: fullRectangle };
                            let REFareaRect = { ref: areaRect };
                            let REFlegendRect = { ref: legendRect };
                            this.setLegendRect(context, this._chart, REFfullRectangle, REFareaRect, REFlegendRect);
                            fullRectangle = REFfullRectangle.ref;
                            legendRect = REFlegendRect.ref;
                            areaRect = REFareaRect.ref;
                        }
                    }
                    let defaultWidth = 0;
                    let defaulHeight = 0;
                    if (this._chart.table.core.showTable()) {
                        areaGeom = this._chart.area.core.render(context, areaRect.clone());
                        defaultWidth = this._chart.table.core.getWidthCellLegend(context) + areaGeom.clientRectangle.width;
                        defaulHeight = this._chart.table.core.getHeightTable(context, defaultWidth);
                        areaRect.height -= defaulHeight;
                    }
                    if (this._chart.area != null) {
                        areaGeom = this._chart.area.core.render(context, areaRect.clone());
                        if (areaGeom != null) {
                            chartGeom.childGeoms.push(areaGeom);
                        }
                    }
                    let seriesGeoms = chartGeom.getSeriesElementGeoms();
                    for (let index = 0; index < seriesGeoms.length; index++) {
                        let seriesElementGeom = seriesGeoms[index].stimulsoft().as(IStiSeriesElement);
                        if (seriesElementGeom != null)
                            seriesElementGeom.elementIndex = index.toString();
                    }
                    if (this._chart.table.core.showTable()) {
                        let series = this._chart.series;
                        let area = this.chart.area;
                        if (series != null && series.count > 0) {
                            let x = areaRect.x;
                            if (this._chart.table.core.getWidthCellLegend(context) < (areaGeom.clientRectangle.x - areaRect.x))
                                x = areaGeom.clientRectangle.x - this._chart.table.core.getWidthCellLegend(context);
                            if (area.reverseHor && area.yRightAxis.visible)
                                x = areaGeom.clientRectangle.left;
                            let y = areaGeom.clientRectangle.bottom;
                            if (this._chart.table.chart.area.is(Chart.IStiClusteredBarArea))
                                y = areaRect.bottom;
                            let rectTable = new RectangleD(x, y, defaultWidth, defaulHeight);
                            let tableGeom = this._chart.table.core.render(context, rectTable);
                            chartGeom.childGeoms.push(tableGeom);
                        }
                    }
                    chartGeom.createChildGeoms();
                    if (legendGeom != null) {
                        areaRect = areaGeom.clientRectangle.clone();
                        let legendRect = legendGeom.clientRectangle.clone();
                        let REFfullRectangle = { ref: fullRectangle };
                        let REFareaRect = { ref: areaRect };
                        let REFlegendRect = { ref: legendRect };
                        this.setLegendRect(context, this._chart, REFfullRectangle, REFareaRect, REFlegendRect);
                        fullRectangle = REFfullRectangle.ref;
                        legendRect = REFlegendRect.ref;
                        areaRect = REFareaRect.ref;
                        legendGeom.clientRectangle = legendRect.clone();
                        chartGeom.childGeoms.push(legendGeom);
                    }
                    return chartGeom;
                }
                setLegendRect(context, chart, REFfullRectangle, REFareaRect, REFlegendRect) {
                    let fullRectangle = REFfullRectangle.ref;
                    let areaRect = REFareaRect.ref;
                    let legendRect = REFlegendRect.ref;
                    let scaledChartHorSpacing = chart.horSpacing * context.options.zoom;
                    let scaledChartVertSpacing = chart.vertSpacing * context.options.zoom;
                    switch (chart.legend.horAlignment) {
                        case Chart.StiLegendHorAlignment.LeftOutside:
                            legendRect.x = fullRectangle.x;
                            areaRect.width -= legendRect.width + scaledChartHorSpacing;
                            areaRect.x += legendRect.width + scaledChartHorSpacing;
                            break;
                        case Chart.StiLegendHorAlignment.Left:
                            legendRect.x = areaRect.x + scaledChartHorSpacing;
                            break;
                        case Chart.StiLegendHorAlignment.Center:
                            legendRect.x = areaRect.x + (areaRect.width - legendRect.width) / 2;
                            break;
                        case Chart.StiLegendHorAlignment.Right:
                            legendRect.x = areaRect.right - scaledChartHorSpacing - legendRect.width;
                            if (chart.legend.showShadow &&
                                (chart.legend.vertAlignment == Chart.StiLegendVertAlignment.BottomOutside)) {
                                legendRect.x -= 5;
                                areaRect.width -= 5;
                            }
                            break;
                        case Chart.StiLegendHorAlignment.RightOutside:
                            legendRect.x = fullRectangle.right - legendRect.width;
                            areaRect.width -= legendRect.width + scaledChartHorSpacing;
                            if (chart.legend.showShadow) {
                                legendRect.x -= 5;
                                areaRect.width -= 5;
                            }
                            break;
                    }
                    switch (chart.legend.vertAlignment) {
                        case Chart.StiLegendVertAlignment.TopOutside:
                            legendRect.y = fullRectangle.y;
                            areaRect.height -= legendRect.height + scaledChartVertSpacing;
                            areaRect.y += legendRect.height + scaledChartVertSpacing;
                            break;
                        case Chart.StiLegendVertAlignment.Top:
                            legendRect.y = areaRect.y + scaledChartVertSpacing;
                            break;
                        case Chart.StiLegendVertAlignment.Center:
                            legendRect.y = areaRect.y + (areaRect.height - legendRect.height) / 2;
                            break;
                        case Chart.StiLegendVertAlignment.Bottom:
                            legendRect.y = areaRect.bottom - scaledChartVertSpacing - legendRect.height;
                            if (chart.legend.showShadow &&
                                (chart.legend.horAlignment == Chart.StiLegendHorAlignment.LeftOutside ||
                                    chart.legend.horAlignment == Chart.StiLegendHorAlignment.RightOutside)) {
                                legendRect.y -= 5;
                                areaRect.height -= 5;
                            }
                            break;
                        case Chart.StiLegendVertAlignment.BottomOutside:
                            legendRect.y = fullRectangle.bottom - legendRect.height;
                            areaRect.height -= legendRect.height + scaledChartVertSpacing;
                            if (chart.legend.showShadow) {
                                legendRect.y -= 5;
                                areaRect.height -= 5;
                            }
                            break;
                    }
                    if (chart.legend.vertAlignment == Chart.StiLegendVertAlignment.BottomOutside ||
                        chart.legend.vertAlignment == Chart.StiLegendVertAlignment.TopOutside) {
                        if (chart.legend.horAlignment == Chart.StiLegendHorAlignment.Left)
                            legendRect.x -= scaledChartHorSpacing;
                        if (chart.legend.horAlignment == Chart.StiLegendHorAlignment.Right)
                            legendRect.x += scaledChartHorSpacing;
                    }
                    else if (chart.legend.horAlignment == Chart.StiLegendHorAlignment.RightOutside ||
                        chart.legend.horAlignment == Chart.StiLegendHorAlignment.LeftOutside) {
                        if (chart.legend.vertAlignment == Chart.StiLegendVertAlignment.Top)
                            legendRect.y -= scaledChartVertSpacing;
                        if (chart.legend.vertAlignment == Chart.StiLegendVertAlignment.Bottom)
                            legendRect.y += scaledChartVertSpacing;
                    }
                    REFfullRectangle.ref = fullRectangle;
                    REFareaRect.ref = areaRect;
                    REFlegendRect.ref = legendRect;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                get fullRectangle() {
                    return this._fullRectangle;
                }
            }
            Chart.StiChartCoreXF = StiChartCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiChartTable {
                constructor() {
                    this._visible = false;
                    this._allowApplyStyle = true;
                    this._markerVisible = true;
                    this._gridLineColor = Color.gray;
                    this._gridLinesHor = true;
                    this._gridLinesVert = true;
                    this._gridOutline = true;
                    this._format = "";
                    this._chart = null;
                    this.header = new Chart.StiChartTableHeader();
                    this.dataCells = new Chart.StiChartTableDataCells();
                    this.core = new Chart.StiChartTableCoreXF(this);
                }
                implements() {
                    if (!StiChartTable.implementsStiChartTable)
                        StiChartTable.implementsStiChartTable = [
                            IStiJsonReportObject,
                            Chart.IStiChartTable,
                            ICloneable
                        ];
                    return StiChartTable.implementsStiChartTable;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("Visible", this._visible);
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyBool("MarkerVisible", this._markerVisible, true);
                    jObject.addPropertyStringNullOrEmpty("GridLineColor", StiJsonReportObjectHelper.Serialize.jColor(this._gridLineColor, Color.gray));
                    jObject.addPropertyBool("GridLinesHor", this._gridLinesHor, true);
                    jObject.addPropertyBool("GridLinesVert", this._gridLinesVert, true);
                    jObject.addPropertyBool("GridOutline", this._gridOutline, true);
                    jObject.addPropertyStringNullOrEmpty("Format", this._format);
                    jObject.addPropertyJObject("Header", this._header.saveToJsonObject(mode));
                    jObject.addPropertyJObject("DataCells", this._dataCells.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Font":
                                this.dataCells.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.dataCells.font);
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "GridLineColor":
                                this._gridLineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "TextColor":
                                this.dataCells.textColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "GridLinesHor":
                                this._gridLinesHor = property.value.stimulsoft().toBoolean();
                                break;
                            case "GridLinesVert":
                                this._gridLinesVert = property.value.stimulsoft().toBoolean();
                                break;
                            case "GridOutline":
                                this._gridOutline = property.value.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = property.value.toString();
                                break;
                            case "Header":
                                this._header.loadFromJsonObject(property.value);
                                break;
                            case "DataCells":
                                this._dataCells.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Font":
                            case "fn":
                                this.dataCells.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "GridLineColor":
                                this._gridLineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "TextColor":
                                this.dataCells.textColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "GridLinesHor":
                                this._gridLinesHor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "GridLinesVert":
                                this._gridLinesVert = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "GridOutline":
                                this._gridOutline = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = node.textContent;
                                break;
                            case "Header": {
                                let _newHeader = new Chart.StiChartTableHeader();
                                _newHeader.loadFromXml(node);
                                this._header = _newHeader;
                                break;
                            }
                            case "DataCells": {
                                let _newDataCells = new Chart.StiChartTableDataCells();
                                _newDataCells.loadFromXml(node);
                                this._dataCells = _newDataCells;
                                break;
                            }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiChartTable;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let table = this.stimulsoft().memberwiseClone();
                    table.font = this.font.clone();
                    table.header = this.header.clone();
                    table.dataCells = this.dataCells.clone();
                    if (this.core != null) {
                        table.core = this.core.clone();
                        table.core.chartTable = table;
                    }
                    return table;
                }
                get font() {
                    return this.dataCells.font;
                }
                set font(value) {
                    this.dataCells.font = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get markerVisible() {
                    return this._markerVisible;
                }
                set markerVisible(value) {
                    this._markerVisible = value;
                }
                get gridLineColor() {
                    return this._gridLineColor;
                }
                set gridLineColor(value) {
                    this._gridLineColor = value;
                }
                get textColor() {
                    return this.dataCells.textColor;
                }
                set textColor(value) {
                    this.dataCells.textColor = value;
                }
                get gridLinesHor() {
                    return this._gridLinesHor;
                }
                set gridLinesHor(value) {
                    this._gridLinesHor = value;
                }
                get gridLinesVert() {
                    return this._gridLinesVert;
                }
                set gridLinesVert(value) {
                    this._gridLinesVert = value;
                }
                get gridOutline() {
                    return this._gridOutline;
                }
                set gridOutline(value) {
                    this._gridOutline = value;
                }
                get format() {
                    return this._format;
                }
                set format(value) {
                    this._format = value;
                }
                get header() {
                    return this._header;
                }
                set header(value) {
                    this._header = value;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get dataCells() {
                    return this._dataCells;
                }
                set dataCells(value) {
                    this._dataCells = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
            }
            Chart.StiChartTable = StiChartTable;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            var FontStyle = Stimulsoft.System.Drawing.FontStyle;
            class StiChartTitle {
                constructor(font = new Font("Tahoma", 12, FontStyle.Bold), text = "", brush = new StiSolidBrush(Color.saddleBrown), antialiasing = true, alignment = StringAlignment.Center, dock = Chart.StiChartTitleDock.Top, spacing = 2, visible = false, allowApplyStyle = true) {
                    this._allowApplyStyle = true;
                    this._font = new Font("Tahoma", 12, FontStyle.Bold);
                    this._text = "";
                    this._brush = new StiSolidBrush(Color.saddleBrown);
                    this._antialiasing = true;
                    this._alignment = StringAlignment.Center;
                    this._dock = Chart.StiChartTitleDock.Top;
                    this._spacing = 2;
                    this._visible = false;
                    this._chart = null;
                    this.core = new Chart.StiChartTitleCoreXF(this);
                    this.font = font;
                    this.text = text;
                    this.brush = brush;
                    this.antialiasing = antialiasing;
                    this.alignment = alignment;
                    this.dock = dock;
                    this.spacing = spacing;
                    this.visible = visible;
                    this.allowApplyStyle = allowApplyStyle;
                }
                implements() {
                    if (!StiChartTitle.implementsStiChartTitle)
                        StiChartTitle.implementsStiChartTitle = [
                            Chart.IStiChartTitle,
                            ICloneable,
                            IStiJsonReportObject
                        ];
                    return StiChartTitle.implementsStiChartTitle;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this._font, "Tahoma", 12, FontStyle.Bold));
                    jObject.addPropertyStringNullOrEmpty("Text", this._text);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyBool("Antialiasing", this._antialiasing, true);
                    jObject.addPropertyEnum("Alignment", StringAlignment, this._alignment, StringAlignment.Center);
                    jObject.addPropertyEnum("Dock", Chart.StiChartTitleDock, this._dock, Chart.StiChartTitleDock.Top);
                    jObject.addPropertyNumber("Spacing", this._spacing, 2);
                    jObject.addPropertyBool("Visible", this._visible);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Font":
                                this._font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this._font);
                                break;
                            case "Text":
                                this._text = property.value.toString();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Antialiasing":
                                this._antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Alignment":
                                this._alignment = Enum.parse(StringAlignment, property.value.toString());
                                break;
                            case "Dock":
                                this._dock = Enum.parse(Chart.StiChartTitleDock, property.value.toString());
                                break;
                            case "Spacing":
                                this._spacing = property.value.stimulsoft().toNumber();
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Font":
                            case "fn":
                                this._font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Text":
                            case "text":
                                this._text = node.textContent;
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Antialiasing":
                                this._antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Alignment":
                                this._alignment = Enum.parse(StringAlignment, node.textContent);
                                break;
                            case "Dock":
                                this._dock = Enum.parse(Chart.StiChartTitleDock, node.textContent);
                                break;
                            case "Spacing":
                                this._spacing = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiChartTitle;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let title = this.stimulsoft().memberwiseClone();
                    title.alignment = this.alignment;
                    title.font = this.font.clone();
                    title.brush = this.brush.clone();
                    if (this.core != null) {
                        title.core = this.core.clone();
                        title.core.chartTitle = title;
                    }
                    return title;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get text() {
                    return this._text;
                }
                set text(value) {
                    this._text = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get alignment() {
                    return this._alignment;
                }
                set alignment(value) {
                    this._alignment = value;
                }
                get dock() {
                    return this._dock;
                }
                set dock(value) {
                    this._dock = value;
                }
                get spacing() {
                    return this._spacing;
                }
                set spacing(value) {
                    this._spacing = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
            }
            Chart.StiChartTitle = StiChartTitle;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            class StiStripsCollection extends CollectionBase {
                constructor() {
                    super(...arguments);
                    this.chart = null;
                }
                implements() {
                    if (!StiStripsCollection.implementsStiStripsCollection)
                        StiStripsCollection.implementsStiStripsCollection = [
                            IStiJsonReportObject,
                            Chart.IStiApplyStyle,
                            Chart.IStiStripsCollection
                        ];
                    return StiStripsCollection.implementsStiStripsCollection;
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let strips of this.list) {
                        jObject.addPropertyJObject(index.toString(), strips.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let strips = new Chart.StiStrips();
                        strips.chart = this.chart;
                        this.add(strips);
                        strips.loadFromJsonObject(property.value);
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.attributes == null)
                            continue;
                        let attr = node.attributes.getNamedItem("type");
                        if (attr != null) {
                            if (node.attributes.getNamedItem("type").value == "Stimulsoft.Report.Chart.StiStrips") {
                                let strips = new Chart.StiStrips();
                                strips.chart = this.chart;
                                this.add(strips);
                                strips.loadFromXml(node);
                            }
                        }
                    }
                }
                applyStyle(style) {
                    for (let strips of this.list) {
                        strips.core.applyStyle(style);
                    }
                }
                getStripsTitle() {
                    let baseTitle = StiLocalization.get("Chart", "Strip");
                    let title = baseTitle;
                    let index = 1;
                    let finded = true;
                    while (finded) {
                        title = baseTitle + " " + index.toString();
                        finded = false;
                        for (let line of this.list) {
                            if (line.text == title) {
                                finded = true;
                                break;
                            }
                        }
                        index++;
                    }
                    return title;
                }
                add(value) {
                    if (this.chart != null) {
                        if (StiString.isNullOrEmpty(value.text))
                            value.text = this.getStripsTitle();
                        value.chart = this.chart;
                    }
                    super.add(value);
                }
            }
            Chart.StiStripsCollection = StiStripsCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            class StiConstantLinesCollection extends CollectionBase {
                constructor() {
                    super(...arguments);
                    this.chart = null;
                }
                implements() {
                    if (!StiConstantLinesCollection.implementsStiConstantLinesCollection)
                        StiConstantLinesCollection.implementsStiConstantLinesCollection = [
                            IStiJsonReportObject,
                            Chart.IStiApplyStyle,
                            Chart.IStiConstantLinesCollection
                        ];
                    return StiConstantLinesCollection.implementsStiConstantLinesCollection;
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let constantLines of this.list) {
                        jObject.addPropertyJObject(index.toString(), constantLines.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let constantLines = new Chart.StiConstantLines();
                        constantLines.chart = this.chart;
                        this.add(constantLines);
                        constantLines.loadFromJsonObject(property.value);
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.attributes == null)
                            continue;
                        let attr = node.attributes.getNamedItem("type");
                        if (attr != null) {
                            if (node.attributes.getNamedItem("type").value == "Stimulsoft.Report.Chart.StiConstantLines") {
                                let constantLines = new Chart.StiConstantLines();
                                constantLines.chart = this.chart;
                                this.add(constantLines);
                                constantLines.loadFromXml(node);
                            }
                        }
                    }
                }
                applyStyle(style) {
                    for (let lines of this.list) {
                        lines.core.applyStyle(style);
                    }
                }
                getConstantLineTitle() {
                    let baseTitle = StiLocalization.get("Chart", "ConstantLine");
                    let title = baseTitle;
                    let index = 1;
                    let finded = true;
                    while (finded) {
                        title = baseTitle + " " + index.toString();
                        finded = false;
                        for (let line of this.list) {
                            if (line.text == title) {
                                finded = true;
                                break;
                            }
                        }
                        index++;
                    }
                    return title;
                }
                add(value) {
                    if (this.chart != null) {
                        if (StiString.isNullOrEmpty(value.text))
                            value.text = this.getConstantLineTitle();
                        value.chart = this.chart;
                    }
                    super.add(value);
                }
            }
            Chart.StiConstantLinesCollection = StiConstantLinesCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var SizeD = Stimulsoft.System.Drawing.Size;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiService = Stimulsoft.Base.Services.StiService;
            var Font = Stimulsoft.System.Drawing.Font;
            var StiFormatService = Stimulsoft.Report.Components.TextFormats.StiFormatService;
            var StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
            class StiSeriesLabels extends StiService {
                constructor() {
                    super(...arguments);
                    this._preventIntersection = false;
                    this._allowApplyStyle = true;
                    this._showZeros = false;
                    this._showNulls = true;
                    this._markerVisible = false;
                    this._markerSize = new SizeD(8, 6);
                    this._markerAlignment = Chart.StiMarkerAlignment.Left;
                    this._step = 0;
                    this._valueType = Chart.StiSeriesLabelsValueType.Value;
                    this._valueTypeSeparator = "-";
                    this._legendValueType = Chart.StiSeriesLabelsValueType.Value;
                    this._textBefore = "";
                    this._textAfter = "";
                    this._angle = 0;
                    this._format = "";
                    this._antialiasing = true;
                    this._visible = true;
                    this._drawBorder = true;
                    this._useSeriesColor = false;
                    this._labelColor = Color.black;
                    this._borderColor = Color.black;
                    this._brush = new StiSolidBrush(Color.white);
                    this._font = new Font("Arial", 7);
                    this._chart = null;
                    this._wordWrap = false;
                    this._width = 0;
                }
                implements() {
                    if (!StiSeriesLabels.implementsStiSeriesLabels)
                        StiSeriesLabels.implementsStiSeriesLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiSeriesLabels.implementsStiSeriesLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyBool("PreventIntersection", this._preventIntersection);
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyBool("ShowNulls", this._showNulls, true);
                    jObject.addPropertyBool("MarkerVisible", this._markerVisible);
                    jObject.addPropertyJObject("MarkerSize", StiJsonReportObjectHelper.Serialize.size(this._markerSize));
                    jObject.addPropertyEnum("MarkerAlignment", Chart.StiMarkerAlignment, this.markerAlignment, Chart.StiMarkerAlignment.Left);
                    jObject.addPropertyNumber("Step", this._step);
                    jObject.addPropertyEnum("ValueType", Chart.StiSeriesLabelsValueType, this.valueType, Chart.StiSeriesLabelsValueType.Value);
                    jObject.addPropertyStringNullOrEmpty("ValueTypeSeparator", this.valueTypeSeparator);
                    jObject.addPropertyEnum("LegendValueType", Chart.StiSeriesLabelsValueType, this.legendValueType, Chart.StiSeriesLabelsValueType.Value);
                    jObject.addPropertyStringNullOrEmpty("TextBefore", this._textBefore);
                    jObject.addPropertyStringNullOrEmpty("TextAfter", this._textAfter);
                    jObject.addPropertyNumber("Angle", this.angle, 0);
                    jObject.addPropertyStringNullOrEmpty("Format", this._format);
                    jObject.addPropertyBool("Antialiasing", this.antialiasing, true);
                    jObject.addPropertyBool("Visible", this.visible, true);
                    jObject.addPropertyBool("DrawBorder", this.drawBorder, true);
                    jObject.addPropertyBool("UseSeriesColor", this.useSeriesColor);
                    jObject.addPropertyStringNullOrEmpty("LabelColor", StiJsonReportObjectHelper.Serialize.jColor(this.labelColor, Color.black));
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this.borderColor, Color.black));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this.font, "Arial", 7));
                    jObject.addPropertyBool("WordWrap", this._wordWrap);
                    jObject.addPropertyNumber("Width", this._width);
                    if (this.formatService != null && !(this.formatService.is(StiGeneralFormatService)))
                        jObject.addPropertyJObject("FormatService", this.formatService.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "PreventIntersection":
                                this._preventIntersection = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowZeros":
                                this._showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowNulls":
                                this._showNulls = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerSize":
                                this._markerSize = StiJsonReportObjectHelper.Deserialize.size(property.value);
                                break;
                            case "MarkerAlignment":
                                this.markerAlignment = Enum.parse(Chart.StiMarkerAlignment, property.value.toString());
                                break;
                            case "Step":
                                this._step = property.value.stimulsoft().toNumber();
                                break;
                            case "ValueType":
                                this.valueType = Enum.parse(Chart.StiSeriesLabelsValueType, property.value.toString());
                                break;
                            case "ValueTypeSeparator":
                                this.valueTypeSeparator = property.value.toString();
                                break;
                            case "LegendValueType":
                                this.legendValueType = Enum.parse(Chart.StiSeriesLabelsValueType, property.value.toString());
                                break;
                            case "TextBefore":
                                this._textBefore = property.value.toString();
                                break;
                            case "TextAfter":
                                this._textAfter = property.value.toString();
                                break;
                            case "Angle":
                                this.angle = property.value.stimulsoft().toNumber();
                                break;
                            case "Format":
                                this._format = property.value.toString();
                                break;
                            case "Antialiasing":
                                this.antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "DrawBorder":
                                this.drawBorder = property.value.stimulsoft().toBoolean();
                                break;
                            case "UseSeriesColor":
                                this.useSeriesColor = property.value.stimulsoft().toBoolean();
                                break;
                            case "LabelColor":
                                this.labelColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "BorderColor":
                                this.borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this.brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "WordWrap":
                                this._wordWrap = property.value.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "FormatService":
                                this.formatService = StiFormatService.createFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "PreventIntersection":
                                this._preventIntersection = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowZeros":
                                this._showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowNulls":
                                this._showNulls = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerSize":
                                this._markerSize = SizeD.convertFromXml(node.textContent);
                                break;
                            case "MarkerAlignment":
                                this.markerAlignment = Enum.parse(Chart.StiMarkerAlignment, node.textContent);
                                break;
                            case "Step":
                                this._step = node.textContent.stimulsoft().toNumber();
                                break;
                            case "ValueType":
                                this.valueType = Enum.parse(Chart.StiSeriesLabelsValueType, node.textContent);
                                break;
                            case "ValueTypeSeparator":
                                this.valueTypeSeparator = node.textContent;
                                break;
                            case "LegendValueType":
                                this.legendValueType = Enum.parse(Chart.StiSeriesLabelsValueType, node.textContent);
                                break;
                            case "TextBefore":
                                this._textBefore = node.textContent;
                                break;
                            case "TextAfter":
                                this._textAfter = node.textContent;
                                break;
                            case "Angle":
                                this.angle = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Format":
                                this._format = node.textContent;
                                break;
                            case "Antialiasing":
                                this.antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "DrawBorder":
                                this.drawBorder = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "UseSeriesColor":
                                this.useSeriesColor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LabelColor":
                                this.labelColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "BorderColor":
                                this.borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this.brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "WordWrap":
                                this._wordWrap = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                static loadFromJsonObjectInternal(jObject, chart) {
                    let ident = jObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                    let service = Stimulsoft["StiOptions"].Services.chartSerieLabels.firstOrDefault(x => x.stimulsoft().getType().stimulsoft().getTypeName() == ident);
                    if (service == null)
                        throw StiString.format("Type {0} is not found!", ident);
                    let seriesLabels = service.createNew();
                    seriesLabels.chart = chart;
                    seriesLabels.loadFromJsonObject(jObject);
                    return seriesLabels;
                }
                static loadLabelsFromXml(xmlNode, chart) {
                    var _a;
                    let ident = (_a = xmlNode.attributes.getNamedItem("type")) === null || _a === void 0 ? void 0 : _a.value;
                    switch (ident) {
                        case "Stimulsoft.Report.Chart.StiNoneLabels": {
                            let noneLabels = new Chart.StiNoneLabels();
                            noneLabels.chart = chart;
                            noneLabels.loadFromXml(xmlNode);
                            return noneLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiCenterAxisLabels": {
                            let centerAxisLabels = new Chart.StiCenterAxisLabels();
                            centerAxisLabels.chart = chart;
                            centerAxisLabels.loadFromXml(xmlNode);
                            return centerAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsideAxisLabels": {
                            let outsideAxisLabels = new Chart.StiOutsideAxisLabels();
                            outsideAxisLabels.chart = chart;
                            outsideAxisLabels.loadFromXml(xmlNode);
                            return outsideAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiInsideBaseAxisLabels": {
                            let insideBaseAxisLabels = new Chart.StiInsideBaseAxisLabels();
                            insideBaseAxisLabels.chart = chart;
                            insideBaseAxisLabels.loadFromXml(xmlNode);
                            return insideBaseAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiInsideEndAxisLabels": {
                            let insideEndAxisLabels = new Chart.StiInsideEndAxisLabels();
                            insideEndAxisLabels.chart = chart;
                            insideEndAxisLabels.loadFromXml(xmlNode);
                            return insideEndAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsideBaseAxisLabels": {
                            let outsideBaseAxisLabels = new Chart.StiOutsideBaseAxisLabels();
                            outsideBaseAxisLabels.chart = chart;
                            outsideBaseAxisLabels.loadFromXml(xmlNode);
                            return outsideBaseAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsideEndAxisLabels": {
                            let outsideEndAxisLabels = new Chart.StiOutsideEndAxisLabels();
                            outsideEndAxisLabels.chart = chart;
                            outsideEndAxisLabels.loadFromXml(xmlNode);
                            return outsideEndAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiLeftAxisLabels": {
                            let leftAxisLabels = new Chart.StiLeftAxisLabels();
                            leftAxisLabels.chart = chart;
                            leftAxisLabels.loadFromXml(xmlNode);
                            return leftAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiValueAxisLabels": {
                            let valueAxisLabels = new Chart.StiValueAxisLabels();
                            valueAxisLabels.chart = chart;
                            valueAxisLabels.loadFromXml(xmlNode);
                            return valueAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiRightAxisLabels": {
                            let rightAxisLabels = new Chart.StiRightAxisLabels();
                            rightAxisLabels.chart = chart;
                            rightAxisLabels.loadFromXml(xmlNode);
                            return rightAxisLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiInsideEndPieLabels": {
                            let insideEndPieLabels = new Chart.StiInsideEndPieLabels();
                            insideEndPieLabels.chart = chart;
                            insideEndPieLabels.loadFromXml(xmlNode);
                            return insideEndPieLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiCenterPieLabels": {
                            let centerPieLabels = new Chart.StiCenterPieLabels();
                            centerPieLabels.chart = chart;
                            centerPieLabels.loadFromXml(xmlNode);
                            return centerPieLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsidePieLabels": {
                            let outsidePieLabels = new Chart.StiOutsidePieLabels();
                            outsidePieLabels.chart = chart;
                            outsidePieLabels.loadFromXml(xmlNode);
                            return outsidePieLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiTwoColumnsPieLabels": {
                            let twoColumnsPieLabels = new Chart.StiTwoColumnsPieLabels();
                            twoColumnsPieLabels.chart = chart;
                            twoColumnsPieLabels.loadFromXml(xmlNode);
                            return twoColumnsPieLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiCenterFunnelLabels": {
                            let centerFunnelLabels = new Chart.StiCenterFunnelLabels();
                            centerFunnelLabels.chart = chart;
                            centerFunnelLabels.loadFromXml(xmlNode);
                            return centerFunnelLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsideRightFunnelLabels": {
                            let outsideRightFunnelLabels = new Chart.StiOutsideRightFunnelLabels();
                            outsideRightFunnelLabels.chart = chart;
                            outsideRightFunnelLabels.loadFromXml(xmlNode);
                            return outsideRightFunnelLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiOutsideLeftFunnelLabels": {
                            let outsideLeftFunnelLabels = new Chart.StiOutsideLeftFunnelLabels();
                            outsideLeftFunnelLabels.chart = chart;
                            outsideLeftFunnelLabels.loadFromXml(xmlNode);
                            return outsideLeftFunnelLabels;
                        }
                        case "Stimulsoft.Report.Chart.StiCenterTreemapLabels": {
                            let centerTreemapLabels = new Chart.StiCenterTreemapLabels();
                            centerTreemapLabels.chart = chart;
                            centerTreemapLabels.loadFromXml(xmlNode);
                            return centerTreemapLabels;
                        }
                    }
                    if (ident)
                        throw StiString.format("Type {0} is not found!", ident);
                    return null;
                }
                get componentId() {
                    return Report.StiComponentId.StiSeriesLabels;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let labels = super.clone();
                    labels.brush = this.brush.clone();
                    labels.font = this.font.clone();
                    if (this.core != null) {
                        labels.core = this.core.clone();
                        labels.core.seriesLabels = labels;
                    }
                    return labels;
                }
                get serviceName() {
                    return this.core.localizedName;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiSeriesLabels;
                }
                get preventIntersection() {
                    return this._preventIntersection;
                }
                set preventIntersection(value) {
                    this._preventIntersection = value;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get axisCore() {
                    return this.core;
                }
                get pieCore() {
                    return this.core;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && Chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get conditions() {
                    if (this.chart == null)
                        return null;
                    return this.chart.seriesLabelsConditions;
                }
                set conditions(value) {
                    if (this.chart == null)
                        return;
                    this.chart.seriesLabelsConditions = value;
                }
                get showOnZeroValues() {
                    return this.showZeros;
                }
                set showOnZeroValues(value) {
                    this.showZeros = value;
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get showNulls() {
                    return this._showNulls;
                }
                set showNulls(value) {
                    this._showNulls = value;
                }
                get markerVisible() {
                    return this._markerVisible;
                }
                set markerVisible(value) {
                    this._markerVisible = value;
                }
                get markerSize() {
                    return this._markerSize;
                }
                set markerSize(value) {
                    this._markerSize = value;
                }
                get markerAlignment() {
                    return this._markerAlignment;
                }
                set markerAlignment(value) {
                    this._markerAlignment = value;
                }
                get step() {
                    return this._step;
                }
                set step(value) {
                    this._step = value;
                }
                get valueType() {
                    return this._valueType;
                }
                set valueType(value) {
                    if (this._valueType != value) {
                        this._valueType = value;
                    }
                }
                get valueTypeSeparator() {
                    return this._valueTypeSeparator;
                }
                set valueTypeSeparator(value) {
                    if (this._valueTypeSeparator != value) {
                        this._valueTypeSeparator = value;
                    }
                }
                get legendValueType() {
                    return this._legendValueType;
                }
                set legendValueType(value) {
                    this._legendValueType = value;
                }
                get textBefore() {
                    return this._textBefore;
                }
                set textBefore(value) {
                    this._textBefore = value;
                }
                get textAfter() {
                    return this._textAfter;
                }
                set textAfter(value) {
                    this._textAfter = value;
                }
                get angle() {
                    return this._angle;
                }
                set angle(value) {
                    this._angle = value;
                }
                get format() {
                    return this._format;
                }
                set format(value) {
                    this._format = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get drawBorder() {
                    return this._drawBorder;
                }
                set drawBorder(value) {
                    this._drawBorder = value;
                }
                get useSeriesColor() {
                    return this._useSeriesColor;
                }
                set useSeriesColor(value) {
                    this._useSeriesColor = value;
                }
                get labelColor() {
                    return this._labelColor;
                }
                set labelColor(value) {
                    this._labelColor = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                get wordWrap() {
                    return this._wordWrap;
                }
                set wordWrap(value) {
                    this._wordWrap = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    this._width = value;
                }
                get formatService() {
                    return this._formatService;
                }
                set formatService(value) {
                    this._formatService = value;
                }
                toString() {
                    return this.serviceName;
                }
                createNew() {
                    return null;
                }
            }
            Chart.StiSeriesLabels = StiSeriesLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisSeriesLabels extends Chart.StiSeriesLabels {
                constructor() {
                    super(...arguments);
                    this._showInPercent = false;
                }
                implements() {
                    if (!StiAxisSeriesLabels.implementsStiAxisSeriesLabels)
                        StiAxisSeriesLabels.implementsStiAxisSeriesLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable,
                            Chart.IStiAxisSeriesLabels
                        ]);
                    return StiAxisSeriesLabels.implementsStiAxisSeriesLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("ShowInPercent", this._showInPercent);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowInPercent":
                                this._showInPercent = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowInPercent":
                                this._showInPercent = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get showInPercent() {
                    return this._showInPercent;
                }
                set showInPercent(value) {
                    this._showInPercent = value;
                    if (this._showInPercent && !this.format.stimulsoft().startsWith("P"))
                        this.format = "P2";
                    if (!this._showInPercent)
                        this.format = "";
                }
            }
            Chart.StiAxisSeriesLabels = StiAxisSeriesLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiCenterAxisLabels extends Chart.StiAxisSeriesLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiCenterAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiCenterAxisLabels.implementsStiCenterAxisLabels)
                        StiCenterAxisLabels.implementsStiCenterAxisLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            ICloneable
                        ]);
                    return StiCenterAxisLabels.implementsStiCenterAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiCenterAxisLabels;
                }
                createNew() {
                    return new StiCenterAxisLabels();
                }
            }
            Chart.StiCenterAxisLabels = StiCenterAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            class StiAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, allowApplyStyle = true, logarithmicScale = false) {
                    this._logarithmicScale = false;
                    this._allowApplyStyle = true;
                    this._startFromZero = true;
                    this._interaction = new Chart.StiAxisInteraction();
                    this._labels = new Chart.StiAxisLabels();
                    this._range = new Chart.StiAxisRange();
                    this._ticks = new Chart.StiAxisTicks();
                    this._arrowStyle = Chart.StiArrowStyle.None;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lineColor = Color.gray;
                    this._lineWidth = 1;
                    this._visible = true;
                    this._info = new Chart.StiAxisInfoXF();
                    this._labels = labels;
                    this._range = range;
                    this._title = title;
                    this._ticks = ticks;
                    this._interaction = interaction;
                    this._arrowStyle = arrowStyle;
                    this._lineStyle = lineStyle;
                    this._lineColor = lineColor;
                    this._lineWidth = lineWidth;
                    this._visible = visible;
                    this._startFromZero = startFromZero;
                    this._allowApplyStyle = allowApplyStyle;
                    this._logarithmicScale = logarithmicScale;
                }
                implements() {
                    if (!StiAxis.implementsStiAxis)
                        StiAxis.implementsStiAxis = [IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiAxis,
                            IStiJsonReportObject];
                    return StiAxis.implementsStiAxis;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyBool("LogarithmicScale", this.logarithmicScale);
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyBool("StartFromZero", this.startFromZero, true);
                    jObject.addPropertyJObject("Interaction", this._interaction.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Labels", this._labels.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Range", this.range.saveToJsonObject(mode));
                    jObject.addPropertyBool("Visible", this._visible, true);
                    jObject.addPropertyEnum("ArrowStyle", Chart.StiArrowStyle, this._arrowStyle, Chart.StiArrowStyle.None);
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this._arrowStyle, StiPenStyle.Solid);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this._lineColor, Color.gray));
                    jObject.addPropertyNumber("LineWidth", this._lineWidth, 1);
                    if (this._title != null)
                        jObject.addPropertyJObject("Title", this._title.saveToJsonObject(mode));
                    if (this._ticks != null)
                        jObject.addPropertyJObject("Ticks", this._ticks.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LogarithmicScale":
                                this.logarithmicScale = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "StartFromZero":
                                this.startFromZero = property.value.stimulsoft().toBoolean();
                                break;
                            case "Interaction":
                                this._interaction.loadFromJsonObject(property.value);
                                break;
                            case "Labels":
                                this._labels.loadFromJsonObject(property.value);
                                break;
                            case "Range":
                                this.range.loadFromJsonObject(property.value);
                                break;
                            case "Title":
                                this.title.loadFromJsonObject(property.value);
                                break;
                            case "Ticks":
                                this.ticks.loadFromJsonObject(property.value);
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "ArrowStyle":
                                this._arrowStyle = Enum.parse(Chart.StiArrowStyle, property.value.toString());
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "LineColor":
                                this._lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineWidth":
                                this._lineWidth = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LogarithmicScale":
                                this.logarithmicScale = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "StartFromZero":
                                this.startFromZero = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Interaction":
                                this._interaction.loadFromXml(node);
                                break;
                            case "Labels":
                                this._labels.loadFromXml(node);
                                break;
                            case "Range":
                                this.range.loadFromXml(node);
                                break;
                            case "Title":
                                this.title.loadFromXml(node);
                                break;
                            case "Ticks":
                                this.ticks.loadFromXml(node);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ArrowStyle":
                                this._arrowStyle = Enum.parse(Chart.StiArrowStyle, node.textContent);
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "LineColor":
                                this._lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineWidth":
                                this._lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                clone() {
                    let axis = this.stimulsoft().memberwiseClone();
                    axis.arrowStyle = this.arrowStyle;
                    axis.lineStyle = this.lineStyle;
                    axis.labels = this.labels.clone();
                    axis.range = this.range.clone();
                    axis.title = this.title.clone();
                    axis.ticks = this.ticks.clone();
                    if (this.core != null) {
                        axis.core = this.core.clone();
                        axis.core.axis = axis;
                    }
                    return axis;
                }
                get logarithmicScale() {
                    return this._logarithmicScale;
                }
                set logarithmicScale(value) {
                    this._logarithmicScale = value;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.area != null && this.area.chart != null)
                            this.core.applyStyle(this.area.chart.style);
                    }
                }
                get startFromZero() {
                    return this._startFromZero;
                }
                set startFromZero(value) {
                    this._startFromZero = value;
                }
                get step() {
                    if (this.labels == null)
                        return 0;
                    return this.labels.step;
                }
                set step(value) {
                    if (this.labels != null)
                        this.labels.step = value;
                }
                get interaction() {
                    return this._interaction;
                }
                set interaction(value) {
                    this._interaction = value;
                }
                get labels() {
                    return this._labels;
                }
                set labels(value) {
                    this._labels = value;
                }
                get range() {
                    return this._range;
                }
                set range(value) {
                    this._range = value;
                }
                get title() {
                    if (this._title == null) {
                        this._title = new Chart.StiAxisTitle();
                        if (this.is(Chart.StiXBottomAxis))
                            this._title.direction = Chart.StiDirection.LeftToRight;
                        else if (this.is(Chart.StiXTopAxis))
                            this._title.direction = Chart.StiDirection.LeftToRight;
                        else if (this.is(Chart.StiYRightAxis))
                            this._title.direction = Chart.StiDirection.TopToBottom;
                        else if (this.is(Chart.StiYLeftAxis))
                            this._title.direction = Chart.StiDirection.BottomToTop;
                    }
                    return this._title;
                }
                set title(value) {
                    if (this._title == null) {
                        this._title = new Chart.StiAxisTitle();
                        if (this.is(Chart.StiXBottomAxis))
                            this._title.direction = Chart.StiDirection.LeftToRight;
                        else if (this.is(Chart.StiXTopAxis))
                            this._title.direction = Chart.StiDirection.LeftToRight;
                        else if (this.is(Chart.StiYRightAxis))
                            this._title.direction = Chart.StiDirection.TopToBottom;
                        else if (this.is(Chart.StiYLeftAxis))
                            this._title.direction = Chart.StiDirection.BottomToTop;
                    }
                    this._title = value;
                }
                get ticks() {
                    return this._ticks;
                }
                set ticks(value) {
                    this._ticks = value;
                }
                get arrowStyle() {
                    return this._arrowStyle;
                }
                set arrowStyle(value) {
                    this._arrowStyle = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    this._lineWidth = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get titleDirection() {
                    if (this.title == null)
                        return Chart.StiLegendDirection.BottomToTop;
                    switch (this.title.direction) {
                        case Chart.StiDirection.BottomToTop:
                            return Chart.StiLegendDirection.BottomToTop;
                        case Chart.StiDirection.LeftToRight:
                            return Chart.StiLegendDirection.LeftToRight;
                        case Chart.StiDirection.RightToLeft:
                            return Chart.StiLegendDirection.RightToLeft;
                        case Chart.StiDirection.TopToBottom:
                            return Chart.StiLegendDirection.TopToBottom;
                    }
                    return Chart.StiLegendDirection.BottomToTop;
                }
                set titleDirection(value) {
                    if (this.title == null)
                        return;
                    switch (value) {
                        case Chart.StiLegendDirection.BottomToTop:
                            this.title.direction = Chart.StiDirection.BottomToTop;
                            break;
                        case Chart.StiLegendDirection.LeftToRight:
                            this.title.direction = Chart.StiDirection.LeftToRight;
                            break;
                        case Chart.StiLegendDirection.RightToLeft:
                            this.title.direction = Chart.StiDirection.RightToLeft;
                            break;
                        case Chart.StiLegendDirection.TopToBottom:
                            this.title.direction = Chart.StiDirection.TopToBottom;
                            break;
                    }
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
                get info() {
                    return this._info;
                }
                set info(value) {
                    this._info = value;
                }
            }
            Chart.StiAxis = StiAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiYAxis extends Chart.StiAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, showYAxis = Chart.StiShowYAxis.Both, allowApplyStyle = true, logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, allowApplyStyle, logarithmicScale);
                    this._showYAxis = Chart.StiShowYAxis.Both;
                    this._showYAxis = showYAxis;
                }
                implements() {
                    if (!StiYAxis.implementsStiYAxis)
                        StiYAxis.implementsStiYAxis = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiYAxis,
                            ICloneable,
                            Chart.IStiAxis
                        ]);
                    return StiYAxis.implementsStiYAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyEnum("ShowYAxis", Chart.StiShowYAxis, this.showYAxis, Chart.StiShowYAxis.Both);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowYAxis":
                                this.showYAxis = Enum.parse(Chart.StiShowYAxis, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowYAxis":
                                this.showYAxis = Enum.parse(Chart.StiShowYAxis, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiYAxis;
                }
                get propName() {
                    return "";
                }
                get showYAxis() {
                    return this._showYAxis;
                }
                set showYAxis(value) {
                    this._showYAxis = value;
                }
            }
            Chart.StiYAxis = StiYAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiYRightAxis extends Chart.StiYAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, allowApplyStyle = true, logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, Chart.StiShowYAxis.Both, allowApplyStyle, logarithmicScale);
                    this.visible = false;
                    this.labels.textAlignment = StiHorAlignment.Left;
                    this.core = new Chart.StiYRightAxisCoreXF(this);
                }
                implements() {
                    if (!StiYRightAxis.implementsStiYRightAxis)
                        StiYRightAxis.implementsStiYRightAxis = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiYAxis,
                            ICloneable,
                            Chart.IStiAxis,
                            Chart.IStiYRightAxis
                        ]);
                    return StiYRightAxis.implementsStiYRightAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("ShowYAxis");
                    jObject.addPropertyBool("Visible", this.visible, false);
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiYRightAxis;
                }
            }
            Chart.StiYRightAxis = StiYRightAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiXAxis extends Chart.StiAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, showXAxis = Chart.StiShowXAxis.Both, showEdgeValues = false, allowApplyStyle = true, dateTimeStep = new Chart.StiAxisDateTimeStep(), logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, allowApplyStyle, logarithmicScale);
                    this._showEdgeValues = false;
                    this._showXAxis = Chart.StiShowXAxis.Both;
                    this._dateTimeStep = new Chart.StiAxisDateTimeStep();
                    this._showXAxis = showXAxis;
                    this._dateTimeStep = dateTimeStep;
                    this._showEdgeValues = showEdgeValues;
                }
                implements() {
                    if (!StiXAxis.implementsStiXAxis)
                        StiXAxis.implementsStiXAxis = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiAxis,
                            Chart.IStiXAxis,
                            ICloneable
                        ]);
                    return StiXAxis.implementsStiXAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("ShowEdgeValues", this._showEdgeValues);
                    jObject.addPropertyEnum("ShowXAxis", Chart.StiShowXAxis, this.showXAxis, Chart.StiShowXAxis.Both);
                    jObject.addPropertyJObject("DateTimeStep", this.dateTimeStep.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowEdgeValues":
                                this.showEdgeValues = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowXAxis":
                                this.showXAxis = Enum.parse(Chart.StiShowXAxis, property.value.toString());
                                break;
                            case "DateTimeStep":
                                this.dateTimeStep.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowEdgeValues":
                                this.showEdgeValues = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowXAxis":
                                this.showXAxis = Enum.parse(Chart.StiShowXAxis, node.textContent);
                                break;
                            case "DateTimeStep":
                                this.dateTimeStep.loadFromXml(node);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiXAxis;
                }
                get propName() {
                    return "";
                }
                get showEdgeValues() {
                    return this._showEdgeValues;
                }
                set showEdgeValues(value) {
                    this._showEdgeValues = value;
                }
                get showXAxis() {
                    return this._showXAxis;
                }
                set showXAxis(value) {
                    this._showXAxis = value;
                }
                get dateTimeStep() {
                    return this._dateTimeStep;
                }
                set dateTimeStep(value) {
                    this._dateTimeStep = value;
                }
            }
            Chart.StiXAxis = StiXAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiXTopAxis extends Chart.StiXAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = false, startFromZero = true, showXAxis = Chart.StiShowXAxis.Both, showEdgeValues = false, allowApplyStyle = true, logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, Chart.StiShowXAxis.Both, showEdgeValues, allowApplyStyle, new Chart.StiAxisDateTimeStep(), logarithmicScale);
                    this.core = new Chart.StiXTopAxisCoreXF(this);
                }
                implements() {
                    if (!StiXTopAxis.implementsStiXTopAxis)
                        StiXTopAxis.implementsStiXTopAxis = super.implements().concat([
                            Chart.IStiXTopAxis,
                            ICloneable,
                            Chart.IStiAxis,
                            Chart.IStiXAxis,
                            IStiJsonReportObject
                        ]);
                    return StiXTopAxis.implementsStiXTopAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("Range");
                    jObject.removeProperty("ShowXAxis");
                    jObject.removeProperty("DateTimeStep");
                    jObject.addPropertyBool("Visible", this.visible, false);
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiXTopAxis;
                }
            }
            Chart.StiXTopAxis = StiXTopAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiYLeftAxis extends Chart.StiYAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, showYAxis = Chart.StiShowYAxis.Both, allowApplyStyle = true, logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, showYAxis, allowApplyStyle, logarithmicScale);
                    this.core = new Chart.StiYLeftAxisCoreXF(this);
                }
                implements() {
                    if (!StiYLeftAxis.implementsStiYLeftAxis)
                        StiYLeftAxis.implementsStiYLeftAxis = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiYAxis,
                            ICloneable,
                            Chart.IStiAxis,
                            Chart.IStiYLeftAxis
                        ]);
                    return StiYLeftAxis.implementsStiYLeftAxis;
                }
            }
            Chart.StiYLeftAxis = StiYLeftAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiAxisLabels {
                constructor(format = "", textBefore = "", textAfter = "", angle = 0, font = new Font("Tahoma", 8), antialiasing = true, placement = Chart.StiLabelsPlacement.OneLine, color = Color.black, width = 0, textAlignment = StiHorAlignment.Right, step = 0, allowApplyStyle = true, wordWrap = false) {
                    this._allowApplyStyle = true;
                    this._format = "";
                    this._angle = 0;
                    this._width = 0;
                    this._textBefore = "";
                    this._textAfter = "";
                    this._font = new Font("Tahoma", 8);
                    this._antialiasing = true;
                    this._placement = Chart.StiLabelsPlacement.OneLine;
                    this._color = Color.black;
                    this._textAlignment = StiHorAlignment.Right;
                    this._step = 0;
                    this._wordWrap = false;
                    this._format = format;
                    this._textBefore = textBefore;
                    this._textAfter = textAfter;
                    this._angle = angle;
                    this._font = font;
                    this._antialiasing = antialiasing;
                    this._placement = placement;
                    this._color = color;
                    this._width = width;
                    this._textAlignment = textAlignment;
                    this._step = step;
                    this._allowApplyStyle = allowApplyStyle;
                    this._wordWrap = wordWrap;
                    this._core = new Chart.StiAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiAxisLabels.implementsStiAxisLabels)
                        StiAxisLabels.implementsStiAxisLabels = [
                            IStiJsonReportObject,
                            Chart.IStiAxisLabels,
                            ICloneable
                        ];
                    return StiAxisLabels.implementsStiAxisLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Format", this._format);
                    jObject.addPropertyNumber("Angle", this._angle, 0);
                    jObject.addPropertyNumber("Width", this._width, 0);
                    jObject.addPropertyStringNullOrEmpty("TextBefore", this._textBefore);
                    jObject.addPropertyStringNullOrEmpty("TextAfter", this._textAfter);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this._font, "Tahoma", 8));
                    jObject.addPropertyBool("Antialiasing", this._antialiasing, true);
                    jObject.addPropertyEnum("Placement", Chart.StiLabelsPlacement, this._placement, Chart.StiLabelsPlacement.OneLine);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this._color, Color.black));
                    jObject.addPropertyEnum("TextAlignment", StiHorAlignment, this.textAlignment, StiHorAlignment.Right);
                    jObject.addPropertyNumber("Step", this.step, 0);
                    jObject.addPropertyBool("WordWrap", this._wordWrap, false);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = property.value.toString();
                                break;
                            case "Angle":
                                this._angle = property.value.stimulsoft().toNumber();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "TextBefore":
                                this._textBefore = property.value.toString();
                                break;
                            case "TextAfter":
                                this._textAfter = property.value.toString();
                                break;
                            case "Font":
                                this._font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this._font);
                                break;
                            case "Antialiasing":
                                this._antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Placement":
                                this._placement = Enum.parse(Chart.StiLabelsPlacement, property.value.toString());
                                break;
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "TextAlignment":
                                this.textAlignment = Enum.parse(StiHorAlignment, property.value.toString());
                                break;
                            case "Step":
                                this.step = property.value.stimulsoft().toNumber();
                                break;
                            case "WordWrap":
                                this.wordWrap = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = node.textContent;
                                break;
                            case "Angle":
                                this._angle = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "TextBefore":
                                this._textBefore = node.textContent;
                                break;
                            case "TextAfter":
                                this._textAfter = node.textContent;
                                break;
                            case "Font":
                            case "fn":
                                this._font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Antialiasing":
                                this._antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Placement":
                                this._placement = Enum.parse(Chart.StiLabelsPlacement, node.textContent);
                                break;
                            case "Color":
                                this._color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "TextAlignment":
                                this.textAlignment = Enum.parse(StiHorAlignment, node.textContent);
                                break;
                            case "Step":
                                this.step = node.textContent.stimulsoft().toNumber();
                                break;
                            case "WordWrap":
                                this.wordWrap = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let labels = this.stimulsoft().memberwiseClone();
                    labels.placement = this.placement;
                    labels.font = this.font.clone();
                    if (this.core != null) {
                        labels.core = this.core.clone();
                        labels.core.labels = labels;
                    }
                    return labels;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get format() {
                    return this._format;
                }
                set format(value) {
                    this._format = value;
                }
                get angle() {
                    return this._angle;
                }
                set angle(value) {
                    this._angle = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    this._width = value;
                }
                get textBefore() {
                    return this._textBefore;
                }
                set textBefore(value) {
                    this._textBefore = value;
                }
                get textAfter() {
                    return this._textAfter;
                }
                set textAfter(value) {
                    this._textAfter = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get placement() {
                    return this._placement;
                }
                set placement(value) {
                    this._placement = value;
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get textAlignment() {
                    return this._textAlignment;
                }
                set textAlignment(value) {
                    this._textAlignment = value;
                }
                get step() {
                    return this._step;
                }
                set step(value) {
                    this._step = value;
                }
                get wordWrap() {
                    return this._wordWrap;
                }
                set wordWrap(value) {
                    this._wordWrap = value;
                }
            }
            Chart.StiAxisLabels = StiAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisRange {
                constructor(auto = true, minimum = 0, maximum = 0) {
                    this._minimum = 0;
                    this._maximum = 0;
                    this._auto = true;
                    this._auto = auto;
                    this._minimum = minimum;
                    this._maximum = maximum;
                }
                implements() {
                    if (!StiAxisRange.implementsStiAxisRange)
                        StiAxisRange.implementsStiAxisRange = [
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiAxisRange
                        ];
                    return StiAxisRange.implementsStiAxisRange;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyNumber("Minimum", this._minimum, 0);
                    jObject.addPropertyNumber("Maximum", this._maximum, 0);
                    jObject.addPropertyBool("Auto", this._auto, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Minimum":
                                this._minimum = property.value.stimulsoft().toNumber();
                                break;
                            case "Maximum":
                                this._maximum = property.value.stimulsoft().toNumber();
                                break;
                            case "Auto":
                                this._auto = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Minimum":
                                this._minimum = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Maximum":
                                this._maximum = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Auto":
                                this._auto = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get minimum() {
                    return this._minimum;
                }
                set minimum(value) {
                    this._minimum = value;
                }
                get maximum() {
                    return this._maximum;
                }
                set maximum(value) {
                    this._maximum = value;
                }
                get auto() {
                    return this._auto;
                }
                set auto(value) {
                    this._auto = value;
                }
            }
            Chart.StiAxisRange = StiAxisRange;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisTicks {
                constructor(visible = true, length = 5, minorVisible = false, minorLength = 2, minorCount = 4, step = 0, lengthUnderLabels = 5) {
                    this._lengthUnderLabels = 5;
                    this._length = 5;
                    this._minorLength = 2;
                    this._minorCount = 4;
                    this._step = 0;
                    this._minorVisible = false;
                    this._visible = true;
                    this._visible = visible;
                    this._length = length;
                    this._minorVisible = minorVisible;
                    this._minorLength = minorLength;
                    this._minorCount = minorCount;
                    this._step = step;
                    this._lengthUnderLabels = lengthUnderLabels;
                }
                implements() {
                    if (!StiAxisTicks.implementsStiAxisTicks)
                        StiAxisTicks.implementsStiAxisTicks = [
                            IStiJsonReportObject,
                            Chart.IStiAxisTicks,
                            ICloneable
                        ];
                    return StiAxisTicks.implementsStiAxisTicks;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyNumber("LengthUnderLabels", this._lengthUnderLabels, 5);
                    jObject.addPropertyNumber("Length", this._length, 5);
                    jObject.addPropertyNumber("MinorLength", this._minorLength, 2);
                    jObject.addPropertyNumber("MinorCount", this._minorCount, 4);
                    jObject.addPropertyNumber("Step", this._step);
                    jObject.addPropertyBool("MinorVisible", this.minorVisible);
                    jObject.addPropertyBool("Visible", this.visible, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LengthUnderLabels":
                                this._lengthUnderLabels = property.value.stimulsoft().toNumber();
                                break;
                            case "Length":
                                this._length = property.value.stimulsoft().toNumber();
                                break;
                            case "MinorLength":
                                this._minorLength = property.value.stimulsoft().toNumber();
                                break;
                            case "MinorCount":
                                this._minorCount = property.value.stimulsoft().toNumber();
                                break;
                            case "Step":
                                this._step = property.value.stimulsoft().toNumber();
                                break;
                            case "MinorVisible":
                                this.minorVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LengthUnderLabels":
                                this._lengthUnderLabels = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Length":
                                this._length = node.textContent.stimulsoft().toNumber();
                                break;
                            case "MinorLength":
                                this._minorLength = node.textContent.stimulsoft().toNumber();
                                break;
                            case "MinorCount":
                                this._minorCount = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Step":
                                this._step = node.textContent.stimulsoft().toNumber();
                                break;
                            case "MinorVisible":
                                this.minorVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get lengthUnderLabels() {
                    return this._lengthUnderLabels;
                }
                set lengthUnderLabels(value) {
                    if (value > 0)
                        this._lengthUnderLabels = value;
                }
                get length() {
                    return this._length;
                }
                set length(value) {
                    if (value > 0)
                        this._length = value;
                }
                get minorLength() {
                    return this._minorLength;
                }
                set minorLength(value) {
                    if (value > 0)
                        this._minorLength = value;
                }
                get minorCount() {
                    return this._minorCount;
                }
                set minorCount(value) {
                    if (value >= 0)
                        this._minorCount = value;
                }
                get step() {
                    return this._step;
                }
                set step(value) {
                    if (value >= 0)
                        this._step = value;
                }
                get minorVisible() {
                    return this._minorVisible;
                }
                set minorVisible(value) {
                    this._minorVisible = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
            }
            Chart.StiAxisTicks = StiAxisTicks;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisInteraction {
                constructor(showScrollBar = false, rangeScrollEnabled = true) {
                    this._showScrollBar = false;
                    this._rangeScrollEnabled = true;
                    this._showScrollBar = showScrollBar;
                    this._rangeScrollEnabled = rangeScrollEnabled;
                }
                implements() {
                    if (!StiAxisInteraction.implementsStiAxisInteraction)
                        StiAxisInteraction.implementsStiAxisInteraction = [
                            IStiJsonReportObject,
                            Chart.IStiAxisInteraction,
                            ICloneable
                        ];
                    return StiAxisInteraction.implementsStiAxisInteraction;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("ShowScrollBar", this._showScrollBar);
                    jObject.addPropertyBool("RangeScrollEnabled", this._rangeScrollEnabled, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowScrollBar":
                                this._showScrollBar = property.value.stimulsoft().toBoolean();
                                break;
                            case "RangeScrollEnabled":
                                this._rangeScrollEnabled = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowScrollBar":
                                this._showScrollBar = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "RangeScrollEnabled":
                                this._rangeScrollEnabled = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let interaction = this.stimulsoft().memberwiseClone();
                    return interaction;
                }
                get showScrollBar() {
                    return this._showScrollBar;
                }
                set showScrollBar(value) {
                    if (this._showScrollBar != value) {
                        this._showScrollBar = value;
                    }
                }
                get rangeScrollEnabled() {
                    return this._rangeScrollEnabled;
                }
                set rangeScrollEnabled(value) {
                    if (this._rangeScrollEnabled != value) {
                        this._rangeScrollEnabled = value;
                    }
                }
            }
            Chart.StiAxisInteraction = StiAxisInteraction;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Enum = Stimulsoft.System.Enum;
            class StiAxisDateTimeStep {
                constructor(step = Chart.StiTimeDateStep.None, numberOfValues = 1, interpolation = false) {
                    this._step = Chart.StiTimeDateStep.None;
                    this._numberOfValues = 1;
                    this._interpolation = false;
                    this._step = step;
                    this._numberOfValues = numberOfValues;
                    this._interpolation = interpolation;
                }
                implements() {
                    if (!StiAxisDateTimeStep.implementsStiAxisDateTimeStep)
                        StiAxisDateTimeStep.implementsStiAxisDateTimeStep = [IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiAxisDateTimeStep,
                            IStiJsonReportObject];
                    return StiAxisDateTimeStep.implementsStiAxisDateTimeStep;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyEnum("Step", Chart.StiTimeDateStep, this._step, Chart.StiTimeDateStep.None);
                    jObject.addPropertyNumber("NumberOfValues", this._numberOfValues, 1);
                    jObject.addPropertyBool("Interpolation", this._interpolation);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Step":
                                this._step = Enum.parse(Chart.StiTimeDateStep, property.value.toString());
                                break;
                            case "NumberOfValues":
                                this._numberOfValues = property.value.stimulsoft().toNumber();
                                break;
                            case "Interpolation":
                                this._interpolation = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Step":
                                this._step = Enum.parse(Chart.StiTimeDateStep, node.textContent);
                                break;
                            case "NumberOfValues":
                                this._numberOfValues = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Interpolation":
                                this._interpolation = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get step() {
                    return this._step;
                }
                set step(value) {
                    this._step = value;
                }
                get numberOfValues() {
                    return this._numberOfValues;
                }
                set numberOfValues(value) {
                    this._numberOfValues = value;
                }
                get interpolation() {
                    return this._interpolation;
                }
                set interpolation(value) {
                    this._interpolation = value;
                }
            }
            Chart.StiAxisDateTimeStep = StiAxisDateTimeStep;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiXBottomAxis extends Chart.StiXAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), title = null, ticks = new Chart.StiAxisTicks(), interaction = new Chart.StiAxisInteraction(), arrowStyle = Chart.StiArrowStyle.None, lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, startFromZero = true, showXAxis = Chart.StiShowXAxis.Both, showEdgeValues = false, allowApplyStyle = true, dateTimeStep = new Chart.StiAxisDateTimeStep(), logarithmicScale = false) {
                    super(labels, range, title, ticks, interaction, arrowStyle, lineStyle, lineColor, lineWidth, visible, startFromZero, showXAxis, showEdgeValues, allowApplyStyle, dateTimeStep, logarithmicScale);
                    this.dateTimeStep = dateTimeStep;
                    this.core = new Chart.StiXBottomAxisCoreXF(this);
                }
                implements() {
                    if (!StiXBottomAxis.implementsStiXBottomAxis)
                        StiXBottomAxis.implementsStiXBottomAxis = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiXAxis,
                            ICloneable,
                            Chart.IStiXBottomAxis,
                            Chart.IStiAxis
                        ]);
                    return StiXBottomAxis.implementsStiXBottomAxis;
                }
            }
            Chart.StiXBottomAxis = StiXBottomAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Dot, visible = true, minorColor = Color.gainsboro, minorStyle = StiPenStyle.Dot, minorVisible = false, minorCount = 0, allowApplyStyle = true) {
                    this.needSetAreaJsonPropertyInternal = false;
                    this._allowApplyStyle = true;
                    this._color = Color.silver;
                    this._minorColor = Color.gainsboro;
                    this._style = StiPenStyle.Dot;
                    this._minorStyle = StiPenStyle.Dot;
                    this._visible = true;
                    this._minorVisible = false;
                    this._minorCount = 0;
                    this._color = color;
                    this._style = style;
                    this._visible = visible;
                    this._minorColor = minorColor;
                    this._minorStyle = minorStyle;
                    this._minorVisible = minorVisible;
                    this._minorCount = minorCount;
                    this._allowApplyStyle = allowApplyStyle;
                    this._core = new Chart.StiGridLinesCoreXF(this);
                }
                implements() {
                    if (!StiGridLines.implementsStiGridLines)
                        StiGridLines.implementsStiGridLines = [
                            IStiJsonReportObject,
                            Chart.IStiGridLines,
                            ICloneable
                        ];
                    return StiGridLines.implementsStiGridLines;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this._color, Color.silver));
                    jObject.addPropertyStringNullOrEmpty("MinorColor", StiJsonReportObjectHelper.Serialize.jColor(this._minorColor, Color.gainsboro));
                    jObject.addPropertyEnum("Style", StiPenStyle, this._style, StiPenStyle.Dot);
                    jObject.addPropertyEnum("MinorStyle", StiPenStyle, this._minorStyle, StiPenStyle.Dot);
                    jObject.addPropertyBool("Visible", this._visible, true);
                    jObject.addPropertyBool("MinorVisible", this._minorVisible);
                    jObject.addPropertyNumber("MinorCount", this._minorCount);
                    if (this.area != null)
                        jObject.addPropertyBool("Area", true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "MinorColor":
                                this._minorColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Style":
                                this._style = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "MinorStyle":
                                this._minorStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "MinorVisible":
                                this._minorVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "MinorCount":
                                this._minorCount = property.value.stimulsoft().toNumber();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "MinorColor":
                                this._minorColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Style":
                                this._style = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "MinorStyle":
                                this._minorStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MinorVisible":
                                this._minorVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MinorCount":
                                this._minorCount = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiGridLines;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let gridLines = this.stimulsoft().memberwiseClone();
                    gridLines.style = this.style;
                    gridLines.minorStyle = this.minorStyle;
                    if (this.core != null) {
                        gridLines.core = this.core.clone();
                        gridLines.core.gridLines = gridLines;
                    }
                    return gridLines;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.area != null && this.area.chart != null)
                            this.core.applyStyle(this.area.chart.style);
                    }
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get minorColor() {
                    return this._minorColor;
                }
                set minorColor(value) {
                    this._minorColor = value;
                }
                get style() {
                    return this._style;
                }
                set style(value) {
                    this._style = value;
                }
                get minorStyle() {
                    return this._minorStyle;
                }
                set minorStyle(value) {
                    this._minorStyle = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get minorVisible() {
                    return this._minorVisible;
                }
                set minorVisible(value) {
                    this._minorVisible = value;
                }
                get minorCount() {
                    return this._minorCount;
                }
                set minorCount(value) {
                    if (value >= 0)
                        this._minorCount = value;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
            }
            Chart.StiGridLines = StiGridLines;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiGridLinesVert extends Chart.StiGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Dot, visible = true, minorColor = Color.gainsboro, minorStyle = StiPenStyle.Dot, minorVisible = false, minorCount = 0, allowApplyStyle = true) {
                    super(color, style, visible, minorColor, minorStyle, minorVisible, minorCount, allowApplyStyle);
                }
                implements() {
                    if (!StiGridLinesVert.implementsStiGridLinesVert)
                        StiGridLinesVert.implementsStiGridLinesVert = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiGridLines,
                            ICloneable,
                            Chart.IStiGridLinesVert
                        ]);
                    return StiGridLinesVert.implementsStiGridLinesVert;
                }
            }
            Chart.StiGridLinesVert = StiGridLinesVert;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiGridLinesHor extends Chart.StiGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Dot, visible = true, minorColor = Color.gainsboro, minorStyle = StiPenStyle.Dot, minorVisible = false, minorCount = 0, allowApplyStyle = true) {
                    super(color, style, visible, minorColor, minorStyle, minorVisible, minorCount, allowApplyStyle);
                }
                implements() {
                    if (!StiGridLinesHor.implementsStiGridLinesHor)
                        StiGridLinesHor.implementsStiGridLinesHor = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiGridLines,
                            Chart.IStiGridLinesHor,
                            ICloneable
                        ]);
                    return StiGridLinesHor.implementsStiGridLinesHor;
                }
            }
            Chart.StiGridLinesHor = StiGridLinesHor;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiInterlacing {
                constructor(interlacedBrush = new StiSolidBrush(Color.transparent), visible = true, allowApplyStyle = true) {
                    this.needSetAreaJsonPropertyInternal = false;
                    this._allowApplyStyle = true;
                    this._interlacedBrush = new StiSolidBrush(Color.transparent);
                    this._visible = true;
                    this._interlacedBrush = interlacedBrush;
                    this._visible = visible;
                    this._allowApplyStyle = allowApplyStyle;
                    this._core = new Chart.StiInterlacingCoreXF(this);
                }
                implements() {
                    if (!StiInterlacing.implementsStiInterlacing)
                        StiInterlacing.implementsStiInterlacing = [
                            Chart.IStiInterlacing,
                            ICloneable,
                            IStiJsonReportObject
                        ];
                    return StiInterlacing.implementsStiInterlacing;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("InterlacedBrush", StiJsonReportObjectHelper.Serialize.jBrush(this._interlacedBrush));
                    jObject.addPropertyBool("Visible", this._visible, true);
                    if (this._area != null)
                        jObject.addPropertyBool("Area", true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "InterlacedBrush":
                                this._interlacedBrush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "InterlacedBrush":
                                this._interlacedBrush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiInterlacing;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let interlacing = this.stimulsoft().memberwiseClone();
                    interlacing.interlacedBrush = this.interlacedBrush.clone();
                    if (this.core != null) {
                        interlacing.core = this.core.clone();
                        interlacing.core.interlacing = interlacing;
                    }
                    return interlacing;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.area != null && this.area.chart != null)
                            this.core.applyStyle(this.area.chart.style);
                    }
                }
                get interlacedBrush() {
                    return this._interlacedBrush;
                }
                set interlacedBrush(value) {
                    this._interlacedBrush = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
            }
            Chart.StiInterlacing = StiInterlacing;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiInterlacingVert extends Chart.StiInterlacing {
                constructor(interlacedBrush = new StiSolidBrush(Color.transparent), visible = true, allowApplyStyle = true) {
                    super(interlacedBrush, visible, allowApplyStyle);
                }
                implements() {
                    if (!StiInterlacingVert.implementsStiInterlacingVert)
                        StiInterlacingVert.implementsStiInterlacingVert = super.implements().concat([
                            Chart.IStiInterlacing,
                            Chart.IStiInterlacingVert,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiInterlacingVert.implementsStiInterlacingVert;
                }
            }
            Chart.StiInterlacingVert = StiInterlacingVert;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiInterlacingHor extends Chart.StiInterlacing {
                constructor(interlacedBrush = new StiSolidBrush(Color.transparent), visible = true, allowApplyStyle = true) {
                    super(interlacedBrush, visible, allowApplyStyle);
                }
                implements() {
                    if (!StiInterlacingHor.implementsStiInterlacingHor)
                        StiInterlacingHor.implementsStiInterlacingHor = super.implements().concat([
                            Chart.IStiInterlacing,
                            Chart.IStiInterlacingHor,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiInterlacingHor.implementsStiInterlacingHor;
                }
            }
            Chart.StiInterlacingHor = StiInterlacingHor;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisArea extends Chart.StiArea {
                constructor() {
                    super();
                    this._reverseHor = false;
                    this._reverseVert = false;
                    this.interlacingHor = new Chart.StiInterlacingHor();
                    this.interlacingVert = new Chart.StiInterlacingVert();
                    this.gridLinesHor = new Chart.StiGridLinesHor();
                    this.gridLinesHorRight = new Chart.StiGridLinesHor();
                    this.gridLinesVert = new Chart.StiGridLinesVert();
                    this.gridLinesHorRight.visible = false;
                    this.xAxis = new Chart.StiXBottomAxis();
                    this.yAxis = new Chart.StiYLeftAxis();
                    this.xTopAxis = new Chart.StiXTopAxis();
                    this.yRightAxis = new Chart.StiYRightAxis();
                }
                implements() {
                    if (!StiAxisArea.implementsStiAxisArea)
                        StiAxisArea.implementsStiAxisArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiAxisArea,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiAxisArea.implementsStiAxisArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyJObject("InterlacingHor", this._interlacingHor.saveToJsonObject(mode));
                    jObject.addPropertyJObject("InterlacingVert", this._interlacingVert.saveToJsonObject(mode));
                    jObject.addPropertyJObject("GridLinesHor", this._gridLinesHor.saveToJsonObject(mode));
                    jObject.addPropertyJObject("GridLinesHorRight", this._gridLinesHorRight.saveToJsonObject(mode));
                    jObject.addPropertyJObject("GridLinesVert", this._gridLinesVert.saveToJsonObject(mode));
                    jObject.addPropertyJObject("YAxis", this._yAxis.saveToJsonObject(mode));
                    jObject.addPropertyJObject("YRightAxis", this._yRightAxis.saveToJsonObject(mode));
                    jObject.addPropertyJObject("XAxis", this._xAxis.saveToJsonObject(mode));
                    jObject.addPropertyJObject("XTopAxis", this._xTopAxis.saveToJsonObject(mode));
                    jObject.addPropertyBool("ReverseHor", this.reverseHor);
                    jObject.addPropertyBool("ReverseVert", this.reverseVert);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "InterlacingHor":
                                {
                                    this._interlacingHor.loadFromJsonObject(property.value);
                                    if (this._interlacingHor.needSetAreaJsonPropertyInternal) {
                                        this._interlacingHor.needSetAreaJsonPropertyInternal = false;
                                        this._interlacingHor.area = this;
                                    }
                                }
                                break;
                            case "InterlacingVert":
                                {
                                    this._interlacingVert.loadFromJsonObject(property.value);
                                    if (this._interlacingVert.needSetAreaJsonPropertyInternal) {
                                        this._interlacingVert.needSetAreaJsonPropertyInternal = false;
                                        this._interlacingVert.area = this;
                                    }
                                }
                                break;
                            case "GridLinesHor":
                                {
                                    this._gridLinesHor.loadFromJsonObject(property.value);
                                    if (this._gridLinesHor.needSetAreaJsonPropertyInternal) {
                                        this._gridLinesHor.needSetAreaJsonPropertyInternal = false;
                                        this._gridLinesHor.area = this;
                                    }
                                }
                                break;
                            case "GridLinesHorRight":
                                {
                                    this._gridLinesHorRight.loadFromJsonObject(property.value);
                                    if (this._gridLinesHorRight.needSetAreaJsonPropertyInternal) {
                                        this._gridLinesHorRight.needSetAreaJsonPropertyInternal = false;
                                        this._gridLinesHorRight.area = this;
                                    }
                                }
                                break;
                            case "GridLinesVert":
                                {
                                    this._gridLinesVert.loadFromJsonObject(property.value);
                                    if (this._gridLinesVert.needSetAreaJsonPropertyInternal) {
                                        this._gridLinesVert.needSetAreaJsonPropertyInternal = false;
                                        this._gridLinesVert.area = this;
                                    }
                                }
                                break;
                            case "YAxis":
                                this._yAxis.loadFromJsonObject(property.value);
                                break;
                            case "YRightAxis":
                                this._yRightAxis.loadFromJsonObject(property.value);
                                break;
                            case "XAxis":
                                this._xAxis.loadFromJsonObject(property.value);
                                break;
                            case "XTopAxis":
                                this._xTopAxis.loadFromJsonObject(property.value);
                                break;
                            case "ReverseHor":
                                this.reverseHor = property.value.stimulsoft().toBoolean();
                                break;
                            case "ReverseVert":
                                this.reverseVert = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "InterlacingHor":
                                this._interlacingHor.loadFromXml(node);
                                this._interlacingHor.area = this;
                                break;
                            case "InterlacingVert":
                                this._interlacingVert.loadFromXml(node);
                                this._interlacingVert.area = this;
                                break;
                            case "GridLinesHor":
                                {
                                    this._gridLinesHor.loadFromXml(node);
                                    this._gridLinesHor.area = this;
                                }
                                break;
                            case "GridLinesHorRight":
                                {
                                    this._gridLinesHorRight.loadFromXml(node);
                                    this._gridLinesHorRight.area = this;
                                }
                                break;
                            case "GridLinesVert":
                                {
                                    this._gridLinesVert.loadFromXml(node);
                                    this._gridLinesVert.area = this;
                                }
                                break;
                            case "YAxis":
                                this._yAxis.loadFromXml(node);
                                break;
                            case "YRightAxis":
                                this._yRightAxis.loadFromXml(node);
                                break;
                            case "XAxis":
                                this._xAxis.loadFromXml(node);
                                break;
                            case "XTopAxis":
                                this._xTopAxis.loadFromXml(node);
                                break;
                            case "ReverseHor":
                                this.reverseHor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ReverseVert":
                                this.reverseVert = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let area = super.clone();
                    area.interlacingHor = this.interlacingHor.clone();
                    area.interlacingVert = this.interlacingVert.clone();
                    area.gridLinesHor = this.gridLinesHor.clone();
                    area.gridLinesHorRight = this.gridLinesHorRight.clone();
                    area.gridLinesVert = this.gridLinesVert.clone();
                    area.yAxis = this.yAxis.clone();
                    area.yRightAxis = this.yRightAxis.clone();
                    area.xAxis = this.xAxis.clone();
                    area.xTopAxis = this.xTopAxis.clone();
                    return area;
                }
                get axisCore() {
                    return this.core;
                }
                get interlacingHor() {
                    return this._interlacingHor;
                }
                set interlacingHor(value) {
                    this._interlacingHor = value;
                    if (this._interlacingHor != null)
                        this._interlacingHor.area = this;
                }
                get interlacingVert() {
                    return this._interlacingVert;
                }
                set interlacingVert(value) {
                    this._interlacingVert = value;
                    if (this._interlacingVert != null)
                        this._interlacingVert.area = this;
                }
                get gridLinesHor() {
                    return this._gridLinesHor;
                }
                set gridLinesHor(value) {
                    this._gridLinesHor = value;
                    if (this._gridLinesHor != null)
                        this._gridLinesHor.area = this;
                }
                get gridLinesHorRight() {
                    return this._gridLinesHorRight;
                }
                set gridLinesHorRight(value) {
                    this._gridLinesHorRight = value;
                    if (this._gridLinesHorRight != null)
                        this._gridLinesHorRight.area = this;
                }
                get gridLinesVert() {
                    return this._gridLinesVert;
                }
                set gridLinesVert(value) {
                    this._gridLinesVert = value;
                    if (this._gridLinesVert != null)
                        this._gridLinesVert.area = this;
                }
                get yAxis() {
                    return this._yAxis;
                }
                set yAxis(value) {
                    this._yAxis = value;
                    if (this._yAxis != null)
                        this._yAxis.area = this;
                }
                get yRightAxis() {
                    return this._yRightAxis;
                }
                set yRightAxis(value) {
                    this._yRightAxis = value;
                    if (this._yRightAxis != null)
                        this._yRightAxis.area = this;
                }
                get xAxis() {
                    return this._xAxis;
                }
                set xAxis(value) {
                    this._xAxis = value;
                    if (this._xAxis != null)
                        this._xAxis.area = this;
                }
                get xTopAxis() {
                    return this._xTopAxis;
                }
                set xTopAxis(value) {
                    this._xTopAxis = value;
                    if (this._xTopAxis != null)
                        this._xTopAxis.area = this;
                }
                get reverseHor() {
                    return this._reverseHor;
                }
                set reverseHor(value) {
                    this._reverseHor = value;
                }
                get reverseVert() {
                    return this._reverseVert;
                }
                set reverseVert(value) {
                    this._reverseVert = value;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiCenterAxisLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiInsideBaseAxisLabels,
                        Chart.StiInsideEndAxisLabels,
                        Chart.StiCenterAxisLabels,
                        Chart.StiOutsideBaseAxisLabels,
                        Chart.StiOutsideEndAxisLabels,
                        Chart.StiOutsideAxisLabels,
                        Chart.StiLeftAxisLabels,
                        Chart.StiValueAxisLabels,
                        Chart.StiRightAxisLabels];
                }
            }
            Chart.StiAxisArea = StiAxisArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiClusteredColumnArea extends Chart.StiAxisArea {
                constructor() {
                    super();
                    this.roundValues = false;
                    this.core = new Chart.StiClusteredColumnAreaCoreXF(this);
                }
                implements() {
                    if (!StiClusteredColumnArea.implementsStiClusteredColumnArea)
                        StiClusteredColumnArea.implementsStiClusteredColumnArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            Chart.IStiRoundValuesArea,
                            ICloneable,
                            Chart.IStiArea
                        ]);
                    return StiClusteredColumnArea.implementsStiClusteredColumnArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("RoundValues", this.roundValues);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "RoundValues":
                                this.roundValues = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "RoundValues":
                                this.roundValues = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiClusteredColumnArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiClusteredColumnSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiClusteredColumnSeries,
                        Chart.StiLineSeries,
                        Chart.StiSteppedLineSeries,
                        Chart.StiSplineSeries,
                        Chart.StiAreaSeries,
                        Chart.StiSteppedAreaSeries,
                        Chart.StiSplineAreaSeries
                    ];
                }
                createNew() {
                    return new StiClusteredColumnArea();
                }
            }
            Chart.StiClusteredColumnArea = StiClusteredColumnArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var EventArgs = Stimulsoft.System.EventArgs;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            class StiSeriesCollection extends CollectionBase {
                constructor() {
                    super(...arguments);
                    this.chart = null;
                }
                implements() {
                    if (!StiSeriesCollection.implementsStiSeriesCollection)
                        StiSeriesCollection.implementsStiSeriesCollection = [
                            IStiJsonReportObject,
                            Chart.IStiApplyStyle,
                            Chart.IStiSeriesCollection
                        ];
                    return StiSeriesCollection.implementsStiSeriesCollection;
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let component of this.list) {
                        jObject.addPropertyJObject(index.toString(), component.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let propJObject = property.value;
                        let ident = propJObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                        let series = Stimulsoft["StiOptions"].Services.chartSeries.firstOrDefault(x => x.stimulsoft().getType().stimulsoft().getTypeName() == ident);
                        if (series == null)
                            throw StiString.format("Type {0} is not found!", ident);
                        let seriesClone = series.createNew();
                        seriesClone.chart = this.chart;
                        this.list.push(seriesClone);
                        seriesClone.loadFromJsonObject(property.value);
                    }
                }
                loadFromXml(xmlNode, chart) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.attributes == null)
                            continue;
                        let attr = node.attributes.getNamedItem("type");
                        if (attr != null) {
                            switch (node.attributes.getNamedItem("type").value) {
                                case "Stimulsoft.Report.Chart.StiClusteredColumnSeries": {
                                    let clusteredColumnSeries = new Chart.StiClusteredColumnSeries();
                                    clusteredColumnSeries.chart = chart;
                                    this.list.push(clusteredColumnSeries);
                                    clusteredColumnSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiLineSeries": {
                                    let lineSeries = new Chart.StiLineSeries();
                                    lineSeries.chart = chart;
                                    this.list.push(lineSeries);
                                    lineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiAreaSeries": {
                                    let areaSeries = new Chart.StiAreaSeries();
                                    areaSeries.chart = chart;
                                    this.list.push(areaSeries);
                                    areaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSplineSeries": {
                                    let splineSeries = new Chart.StiSplineSeries();
                                    splineSeries.chart = chart;
                                    this.list.push(splineSeries);
                                    splineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSplineAreaSeries": {
                                    let splineAreaSeries = new Chart.StiSplineAreaSeries();
                                    splineAreaSeries.chart = chart;
                                    this.list.push(splineAreaSeries);
                                    splineAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedColumnSeries": {
                                    let stackedColumnSeries = new Chart.StiStackedColumnSeries();
                                    stackedColumnSeries.chart = chart;
                                    this.list.push(stackedColumnSeries);
                                    stackedColumnSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedLineSeries": {
                                    let stackedLineSeries = new Chart.StiStackedLineSeries();
                                    stackedLineSeries.chart = chart;
                                    this.list.push(stackedLineSeries);
                                    stackedLineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedAreaSeries": {
                                    let stackedAreaSeries = new Chart.StiStackedAreaSeries();
                                    stackedAreaSeries.chart = chart;
                                    this.list.push(stackedAreaSeries);
                                    stackedAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedSplineSeries": {
                                    let stackedSplineSeries = new Chart.StiStackedSplineSeries();
                                    stackedSplineSeries.chart = chart;
                                    this.list.push(stackedSplineSeries);
                                    stackedSplineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedSplineAreaSeries": {
                                    let stackedSplineAreaSeries = new Chart.StiStackedSplineAreaSeries();
                                    stackedSplineAreaSeries.chart = chart;
                                    this.list.push(stackedSplineAreaSeries);
                                    stackedSplineAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSteppedLineSeries": {
                                    let steppedLineSeries = new Chart.StiSteppedLineSeries();
                                    steppedLineSeries.chart = chart;
                                    this.list.push(steppedLineSeries);
                                    steppedLineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSteppedAreaSeries": {
                                    let steppedAreaSeries = new Chart.StiSteppedAreaSeries();
                                    steppedAreaSeries.chart = chart;
                                    this.list.push(steppedAreaSeries);
                                    steppedAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedColumnSeries": {
                                    let fullStackedColumnSeries = new Chart.StiFullStackedColumnSeries();
                                    fullStackedColumnSeries.chart = chart;
                                    this.list.push(fullStackedColumnSeries);
                                    fullStackedColumnSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedLineSeries": {
                                    let fullStackedLineSeries = new Chart.StiFullStackedLineSeries();
                                    fullStackedLineSeries.chart = chart;
                                    this.list.push(fullStackedLineSeries);
                                    fullStackedLineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedAreaSeries": {
                                    let fullStackedAreaSeries = new Chart.StiFullStackedAreaSeries();
                                    fullStackedAreaSeries.chart = chart;
                                    this.list.push(fullStackedAreaSeries);
                                    fullStackedAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedSplineSeries": {
                                    let fullStackedSplineSeries = new Chart.StiFullStackedSplineSeries();
                                    fullStackedSplineSeries.chart = chart;
                                    this.list.push(fullStackedSplineSeries);
                                    fullStackedSplineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedSplineAreaSeries": {
                                    let fullStackedSplineAreaSeries = new Chart.StiFullStackedSplineAreaSeries();
                                    fullStackedSplineAreaSeries.chart = chart;
                                    this.list.push(fullStackedSplineAreaSeries);
                                    fullStackedSplineAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiClusteredBarSeries": {
                                    let clusteredBarSeries = new Chart.StiClusteredBarSeries();
                                    clusteredBarSeries.chart = chart;
                                    this.list.push(clusteredBarSeries);
                                    clusteredBarSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStackedBarSeries": {
                                    let stackedBarSeries = new Chart.StiStackedBarSeries();
                                    stackedBarSeries.chart = chart;
                                    this.list.push(stackedBarSeries);
                                    stackedBarSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFullStackedBarSeries": {
                                    let fullStackedBarSeries = new Chart.StiFullStackedBarSeries();
                                    fullStackedBarSeries.chart = chart;
                                    this.list.push(fullStackedBarSeries);
                                    fullStackedBarSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiDoughnutSeries": {
                                    let doughnutSeries = new Chart.StiDoughnutSeries();
                                    doughnutSeries.chart = chart;
                                    this.list.push(doughnutSeries);
                                    doughnutSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiGanttSeries": {
                                    let ganttSeries = new Chart.StiGanttSeries();
                                    ganttSeries.chart = chart;
                                    this.list.push(ganttSeries);
                                    ganttSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiPieSeries": {
                                    let pieSeries = new Chart.StiPieSeries();
                                    pieSeries.chart = chart;
                                    this.list.push(pieSeries);
                                    pieSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiBubbleSeries": {
                                    let bubbleSeries = new Chart.StiBubbleSeries();
                                    bubbleSeries.chart = chart;
                                    this.list.push(bubbleSeries);
                                    bubbleSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiScatterSeries": {
                                    let scatterSeries = new Chart.StiScatterSeries();
                                    scatterSeries.chart = chart;
                                    this.list.push(scatterSeries);
                                    scatterSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiScatterLineSeries": {
                                    let scatterLineSeries = new Chart.StiScatterLineSeries();
                                    scatterLineSeries.chart = chart;
                                    this.list.push(scatterLineSeries);
                                    scatterLineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiScatterSplineSeries": {
                                    let scatterSplineSeries = new Chart.StiScatterSplineSeries();
                                    scatterSplineSeries.chart = chart;
                                    this.list.push(scatterSplineSeries);
                                    scatterSplineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiRadarPointSeries": {
                                    let radarPointSeries = new Chart.StiRadarPointSeries();
                                    radarPointSeries.chart = chart;
                                    this.list.push(radarPointSeries);
                                    radarPointSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiRadarLineSeries": {
                                    let radarLineSeries = new Chart.StiRadarLineSeries();
                                    radarLineSeries.chart = chart;
                                    this.list.push(radarLineSeries);
                                    radarLineSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiRadarAreaSeries": {
                                    let radarAreaSeries = new Chart.StiRadarAreaSeries();
                                    radarAreaSeries.chart = chart;
                                    this.list.push(radarAreaSeries);
                                    radarAreaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFunnelSeries": {
                                    let funnelSeries = new Chart.StiFunnelSeries();
                                    funnelSeries.chart = chart;
                                    this.list.push(funnelSeries);
                                    funnelSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiStockSeries": {
                                    let stockSeries = new Chart.StiStockSeries();
                                    stockSeries.chart = chart;
                                    this.list.push(stockSeries);
                                    stockSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiCandlestickSeries": {
                                    let candlestickSeries = new Chart.StiCandlestickSeries();
                                    candlestickSeries.chart = chart;
                                    this.list.push(candlestickSeries);
                                    candlestickSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiFunnelWeightedSlicesSeries": {
                                    let funnelWeightedSlicesSeries = new Chart.StiFunnelWeightedSlicesSeries();
                                    funnelWeightedSlicesSeries.chart = chart;
                                    this.list.push(funnelWeightedSlicesSeries);
                                    funnelWeightedSlicesSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSteppedRangeSeries": {
                                    let steppedRangeSeries = new Chart.StiSteppedRangeSeries();
                                    steppedRangeSeries.chart = chart;
                                    this.list.push(steppedRangeSeries);
                                    steppedRangeSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSplineRangeSeries": {
                                    let splineRangeSeries = new Chart.StiSplineRangeSeries();
                                    splineRangeSeries.chart = chart;
                                    this.list.push(splineRangeSeries);
                                    splineRangeSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiRangeSeries": {
                                    let rangeSeries = new Chart.StiRangeSeries();
                                    rangeSeries.chart = chart;
                                    this.list.push(rangeSeries);
                                    rangeSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiRangeBarSeries": {
                                    let rangeBarSeries = new Chart.StiRangeBarSeries();
                                    rangeBarSeries.chart = chart;
                                    this.list.push(rangeBarSeries);
                                    rangeBarSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiTreemapSeries": {
                                    let treemapSeries = new Chart.StiTreemapSeries();
                                    treemapSeries.chart = chart;
                                    this.list.push(treemapSeries);
                                    treemapSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiPictorialSeries": {
                                    let pictoriaSeries = new Chart.StiPictorialSeries();
                                    pictoriaSeries.chart = chart;
                                    this.list.push(pictoriaSeries);
                                    pictoriaSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiParetoSeries": {
                                    let paretoSeries = new Chart.StiParetoSeries();
                                    paretoSeries.chart = chart;
                                    this.list.push(paretoSeries);
                                    paretoSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiWaterfallSeries": {
                                    let waterfallSeries = new Chart.StiWaterfallSeries();
                                    waterfallSeries.chart = chart;
                                    this.list.push(waterfallSeries);
                                    waterfallSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiHistogramSeries": {
                                    let histogramSeries = new Chart.StiHistogramSeries();
                                    histogramSeries.chart = chart;
                                    this.list.push(histogramSeries);
                                    histogramSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiSunburstSeries": {
                                    let sunburstSeries = new Chart.StiSunburstSeries();
                                    sunburstSeries.chart = chart;
                                    this.list.push(sunburstSeries);
                                    sunburstSeries.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiBoxAndWhiskerSeries": {
                                    let boxAndWhiskerSeries = new Chart.StiBoxAndWhiskerSeries();
                                    boxAndWhiskerSeries.chart = chart;
                                    this.list.push(boxAndWhiskerSeries);
                                    boxAndWhiskerSeries.loadFromXml(node);
                                    break;
                                }
                            }
                        }
                    }
                }
                applyStyle(style) {
                    if (style == null)
                        return;
                    let index = 0;
                    for (let series of this.list) {
                        let colors = style.core.getColors(this.length, series.core.seriesColors);
                        series.core.applyStyle(style, colors[index++]);
                    }
                }
                getSeriesTitle() {
                    let baseTitle = StiLocalization.get("Chart", "Series");
                    let title = baseTitle;
                    let index = 1;
                    let finded = true;
                    while (finded) {
                        title = baseTitle + " " + index.toString();
                        finded = false;
                        for (let series of this.list) {
                            if (series.coreTitle == title) {
                                finded = true;
                                break;
                            }
                        }
                        index++;
                    }
                    return title;
                }
                add(value) {
                    if (this.chart != null) {
                        if (StiString.isNullOrEmpty(value.coreTitle))
                            value.coreTitle = this.getSeriesTitle();
                        value.chart = this.chart;
                    }
                    super.add(value);
                    this.invokeSeriesAdded(value);
                }
                insert(index, value) {
                    if (this.chart != null) {
                        if (StiString.isNullOrEmpty(value.coreTitle))
                            value.coreTitle = this.getSeriesTitle();
                        value.chart = this.chart;
                    }
                    super.insert(index, value);
                    this.invokeSeriesAdded(value);
                }
                remove(item) {
                    this.invokeSeriesRemoved(item);
                    super.remove(item);
                }
                removeAt(index) {
                    let item = this.getByIndex(index);
                    this.invokeSeriesRemoved(item);
                    super.removeAt(index);
                }
                getByName(name) {
                    for (let series of this.list) {
                        if (series.coreTitle == name) {
                            return series;
                        }
                    }
                    return null;
                }
                setByName(name, value) {
                    for (let index = 0; index < this.list.length; index++) {
                        let series = this.list[index];
                        if (series.coreTitle == name) {
                            this.list[index] = value;
                            return;
                        }
                    }
                    this.add(value);
                }
                invokeSeriesAdded(sender) {
                    if (this.seriesAdded != null)
                        this.seriesAdded(sender, EventArgs.empty);
                }
                invokeSeriesRemoved(sender) {
                    if (this.seriesRemoved != null)
                        this.seriesRemoved(sender, EventArgs.empty);
                }
            }
            Chart.StiSeriesCollection = StiSeriesCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
            var StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Enum = Stimulsoft.System.Enum;
            var StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
            class StiChartFilter {
                constructor(item = StiFilterItem.Argument, dataType = StiFilterDataType.String, condition = StiFilterCondition.EqualTo, value = "") {
                    this._condition = StiFilterCondition.EqualTo;
                    this._dataType = StiFilterDataType.String;
                    this._item = StiFilterItem.Argument;
                    this._valueObj = "";
                    this.filters = null;
                    this._item = item;
                    this._dataType = dataType;
                    this._condition = condition;
                    this._valueObj = value;
                }
                implements() {
                    if (!StiChartFilter.implementsStiChartFilter)
                        StiChartFilter.implementsStiChartFilter = [
                            IStiJsonReportObject,
                            Chart.IStiChartFilter,
                            ICloneable
                        ];
                    return StiChartFilter.implementsStiChartFilter;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyEnum("Condition", StiFilterCondition, this.condition, StiFilterCondition.EqualTo);
                    jObject.addPropertyEnum("DataType", StiFilterDataType, this.dataType, StiFilterDataType.String);
                    jObject.addPropertyEnum("Item", StiFilterItem, this.item, StiFilterItem.Argument);
                    jObject.addPropertyStringNullOrEmpty("Value", this.value);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Condition":
                                this._condition = Enum.parse(StiFilterCondition, property.value.toString());
                                break;
                            case "DataType":
                                this._dataType = Enum.parse(StiFilterDataType, property.value.toString());
                                break;
                            case "Item":
                                this._item = Enum.parse(StiFilterItem, property.value.toString());
                                break;
                            case "Value":
                                this._valueObj = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode, isDocument) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Condition":
                                this._condition = Enum.parse(StiFilterCondition, node.textContent);
                                break;
                            case "DataType":
                                this._dataType = Enum.parse(StiFilterDataType, node.textContent);
                                break;
                            case "Item":
                                this._item = Enum.parse(StiFilterItem, node.textContent);
                                break;
                            case "Value":
                                this._valueObj = node.textContent;
                                break;
                        }
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get index() {
                    if (this.filters == null)
                        return -1;
                    let index = this.filters.indexOf(this);
                    return index;
                }
                get condition() {
                    return this._condition;
                }
                set condition(value) {
                    this._condition = value;
                }
                get dataType() {
                    return this._dataType;
                }
                set dataType(value) {
                    this._dataType = value;
                }
                get item() {
                    return this._item;
                }
                set item(value) {
                    this._item = value;
                }
                get value() {
                    return this._valueObj;
                }
                set value(value) {
                    this._valueObj = value;
                }
                toString() {
                    let sign = "";
                    switch (this.condition) {
                        case StiFilterCondition.EqualTo:
                            sign = "=";
                            break;
                        case StiFilterCondition.NotEqualTo:
                            sign = "<>";
                            break;
                        case StiFilterCondition.GreaterThan:
                            sign = ">";
                            break;
                        case StiFilterCondition.GreaterThanOrEqualTo:
                            sign = ">=";
                            break;
                        case StiFilterCondition.LessThan:
                            sign = "<";
                            break;
                        case StiFilterCondition.LessThanOrEqualTo:
                            sign = "=<";
                            break;
                    }
                    let item = StiLocalization.get("PropertyMain", "Argument");
                    switch (Enum.parse(StiFilterItem, item)) {
                        case StiFilterItem.Value:
                            item = StiLocalization.get("PropertyMain", "Value");
                            break;
                        case StiFilterItem.ValueEnd:
                            item = StiLocalization.get("PropertyMain", "Value");
                            break;
                    }
                    return StiString.format("{0} {1} {2}", item, sign, this.value);
                }
            }
            Chart.StiChartFilter = StiChartFilter;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
            var StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
            var StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiChartCondition extends Chart.StiChartFilter {
                constructor(color = Color.white, item = StiFilterItem.Argument, dataType = StiFilterDataType.String, condition = StiFilterCondition.EqualTo, value = "", markerType, markerAngle) {
                    super(item, dataType, condition, value);
                    this._color = Color.white;
                    this._markerType = Chart.StiMarkerType.Circle;
                    this._markerAngle = 0;
                    this.conditions = null;
                    this.color = color;
                    if (markerType != null)
                        this.markerType = markerType;
                    if (markerAngle != null)
                        this.markerAngle = markerAngle;
                }
                implements() {
                    if (!StiChartCondition.implementsStiChartCondition)
                        StiChartCondition.implementsStiChartCondition = super.implements().concat([
                            Chart.IStiChartCondition,
                            Chart.IStiChartFilter,
                            IStiJsonReportObject
                        ]);
                    return StiChartCondition.implementsStiChartCondition;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this.color, Color.white));
                    jObject.addPropertyEnum("MarkerType", Chart.StiMarkerType, this.markerType, Chart.StiMarkerType.Circle);
                    jObject.addPropertyNumber("MarkerAngle", this.markerAngle, 0);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "MarkerType":
                                this.markerType = Enum.parse(Chart.StiMarkerType, property.value.toString());
                                break;
                            case "MarkerAngle":
                                this.markerAngle = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode, isDocument) {
                    super.loadFromXml(xmlNode, isDocument);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Color":
                                this.color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "MarkerType":
                                this.markerType = Enum.parse(Chart.StiMarkerType, node.textContent);
                                break;
                            case "MarkerAngle":
                                this.markerAngle = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                clone() {
                    return super.clone();
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get markerType() {
                    return this._markerType;
                }
                set markerType(value) {
                    this._markerType = value;
                }
                get markerAngle() {
                    return this._markerAngle;
                }
                set markerAngle(value) {
                    this._markerAngle = value;
                }
            }
            Chart.StiChartCondition = StiChartCondition;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            var Enum = Stimulsoft.System.Enum;
            var XMLConvert = Stimulsoft.System.Text.XMLConvert;
            var StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
            var StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
            var StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
            class StiChartConditionsCollection extends CollectionBase {
                implements() {
                    if (!StiChartConditionsCollection.implementsStiChartConditionsCollection)
                        StiChartConditionsCollection.implementsStiChartConditionsCollection = [
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiChartConditionsCollection
                        ];
                    return StiChartConditionsCollection.implementsStiChartConditionsCollection;
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let condition of this.list) {
                        jObject.addPropertyJObject(index.toString(), condition.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let condition = new Chart.StiChartCondition();
                        condition.loadFromJsonObject(property.value);
                        this.list.push(condition);
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.nodeName == "value") {
                            let words = node.textContent.split(",");
                            let condition = words[3];
                            if (condition == "GreaterThen")
                                condition = "GreaterThan";
                            else if (condition == "GreaterThenOrEqualTo")
                                condition = "GreaterThanOrEqualTo";
                            else if (condition == "LessThen")
                                condition = "LessThan";
                            else if (condition == "LessThenOrEqualTo")
                                condition = "LessThanOrEqualTo";
                            let filter = new Chart.StiChartCondition(Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(words[0]), Enum.parse(StiFilterItem, words[1]), Enum.parse(StiFilterDataType, words[2]), Enum.parse(StiFilterCondition, condition), XMLConvert.decodeName(words[4]));
                            this.add(filter);
                        }
                    }
                }
                clone() {
                    let conditions = new StiChartConditionsCollection();
                    for (let condition of this.list) {
                        conditions.add(condition.clone());
                    }
                    return conditions;
                }
                add(condition) {
                    this.list.push(condition);
                    if (condition.conditions == null)
                        condition.conditions = this;
                }
            }
            Chart.StiChartConditionsCollection = StiChartConditionsCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiNumber = Stimulsoft.System.StiNumber;
            var CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
            var StiString = Stimulsoft.System.StiString;
            var DateTime = Stimulsoft.System.DateTime;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var XmlConvert = Stimulsoft.System.Text.XMLConvert;
            var StiJson = Stimulsoft.Base.StiJson;
            var StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
            var StiGuidUtils = Stimulsoft.Base.StiGuidUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var Enum = Stimulsoft.System.Enum;
            var StiService = Stimulsoft.Base.Services.StiService;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            class StiSeries extends StiService {
                constructor() {
                    super();
                    this._allowApplyStyle = true;
                    this._format = "";
                    this._sortBy = Chart.StiSeriesSortType.None;
                    this._sortDirection = Chart.StiSeriesSortDirection.Ascending;
                    this._showInLegend = true;
                    this._showSeriesLabels = Chart.StiShowSeriesLabels.FromChart;
                    this._showShadow = true;
                    this._filterMode = StiFilterMode.And;
                    this._filters = new Chart.StiChartFiltersCollection();
                    this._conditions = new Chart.StiChartConditionsCollection();
                    this._topN = new Chart.StiSeriesTopN();
                    this._yAxis = Chart.StiSeriesYAxis.LeftYAxis;
                    this._trendLines = new Chart.StiTrendLinesCollection();
                    this.valuesStart = [];
                    this._values = [1, 3, 2];
                    this._valueDataColumn = "";
                    this._arguments = [];
                    this._argumentDataColumn = "";
                    this._autoSeriesTitleDataColumn = "";
                    this._autoSeriesKeyDataColumn = "";
                    this._autoSeriesColorDataColumn = "";
                    this._toolTips = [];
                    this._toolTipDataColumn = "";
                    this._tags = [];
                    this._tagDataColumn = "";
                    this._hyperlinks = [];
                    this._hyperlinkDataColumn = "";
                    this._drillDownEnabled = false;
                    this._drillDownReport = "";
                    this._drillDownPageGuid = null;
                    this._allowSeries = true;
                    this._allowSeriesElements = true;
                    this.valueObj = "";
                    this._listOfValues = "";
                    this._argument = "";
                    this._listOfArguments = "";
                    this._titleValue = null;
                    this._title = "";
                    this._toolTip = "";
                    this._listOfToolTips = "";
                    this._tag = "";
                    this._listOfTags = "";
                    this._hyperlink = "";
                    this._listOfHyperlinks = "";
                    this.seriesLabels = new Chart.StiCenterAxisLabels();
                    this.interaction = new Chart.StiSeriesInteraction();
                }
                implements() {
                    if (!StiSeries.implementsStiSeries)
                        StiSeries.implementsStiSeries = super.implements().concat([
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiSeries,
                            IStiJsonReportObject
                        ]);
                    return StiSeries.implementsStiSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Format", this._format);
                    jObject.addPropertyEnum("SortBy", Chart.StiSeriesSortType, this._sortBy, Chart.StiSeriesSortType.None);
                    jObject.addPropertyEnum("SortDirection", Chart.StiSeriesSortDirection, this._sortDirection, Chart.StiSeriesSortDirection.Ascending);
                    jObject.addPropertyBool("ShowInLegend", this._showInLegend, true);
                    jObject.addPropertyEnum("ShowSeriesLabels", Chart.StiShowSeriesLabels, this._showSeriesLabels, Chart.StiShowSeriesLabels.FromChart);
                    jObject.addPropertyBool("ShowShadow", this._showShadow, true);
                    jObject.addPropertyEnum("FilterMode", StiFilterMode, this._filterMode, StiFilterMode.And);
                    jObject.addPropertyJObject("Filters", this._filters.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Conditions", this._conditions.saveToJsonObject(mode));
                    jObject.addPropertyJObject("TopN", this.topN.saveToJsonObject(mode));
                    jObject.addPropertyEnum("YAxis", Chart.StiSeriesYAxis, this._yAxis, Chart.StiSeriesYAxis.LeftYAxis);
                    jObject.addPropertyJObject("SeriesLabels", this._seriesLabels.saveToJsonObject(mode));
                    jObject.addPropertyJObject("TrendLines", this._trendLines.saveToJsonObject(mode));
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumn", this.valueDataColumn);
                    jObject.addPropertyStringNullOrEmpty("ArgumentDataColumn", this._argumentDataColumn);
                    jObject.addPropertyStringNullOrEmpty("AutoSeriesTitleDataColumn", this._autoSeriesTitleDataColumn);
                    jObject.addPropertyStringNullOrEmpty("AutoSeriesKeyDataColumn", this._autoSeriesKeyDataColumn);
                    jObject.addPropertyStringNullOrEmpty("AutoSeriesColorDataColumn", this._autoSeriesColorDataColumn);
                    jObject.addPropertyStringNullOrEmpty("ToolTipDataColumn", this._toolTipDataColumn);
                    jObject.addPropertyStringNullOrEmpty("TagDataColumn", this._tagDataColumn);
                    jObject.addPropertyStringNullOrEmpty("HyperlinkDataColumn", this._hyperlinkDataColumn);
                    jObject.addPropertyBool("DrillDownEnabled", this.drillDownEnabled);
                    jObject.addPropertyStringNullOrEmpty("DrillDownReport", this.drillDownReport);
                    jObject.addPropertyStringNullOrEmpty("DrillDownPageGuid", this._drillDownPageGuid);
                    jObject.addPropertyBool("AllowSeries", this._allowSeries, true);
                    jObject.addPropertyBool("AllowSeriesElements", this._allowSeriesElements, true);
                    jObject.addPropertyJObject("Interaction", this.interaction.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Value", new StiExpression(this.value).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValues", new StiExpression(this.listOfValues).saveToJsonObject(mode));
                    jObject.addPropertyJObject("Argument", new StiExpression(this.argument).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfArguments", new StiExpression(this.listOfArguments).saveToJsonObject(mode));
                    jObject.addPropertyJObject("Title", new StiExpression(this.title).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ToolTip", new StiExpression(this.toolTip).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfToolTips", new StiExpression(this.listOfToolTips).saveToJsonObject(mode));
                    jObject.addPropertyJObject("Tag", new StiExpression(this.tag).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfTags", new StiExpression(this.listOfTags).saveToJsonObject(mode));
                    jObject.addPropertyJObject("Hyperlink", new StiExpression(this.hyperlink).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfHyperlinks", new StiExpression(this.listOfHyperlinks).saveToJsonObject(mode));
                    if (mode == StiJsonSaveMode.Document) {
                        jObject.addPropertyStringNullOrEmpty("ValuesString", this.valuesString);
                        jObject.addPropertyStringNullOrEmpty("ArgumentsString", this.argumentsString);
                        jObject.addPropertyStringNullOrEmpty("ToolTipsString", this.toolTipsString);
                        jObject.addPropertyStringNullOrEmpty("TagString", this.tagString);
                        jObject.addPropertyStringNullOrEmpty("HyperlinkString", this.hyperlinkString);
                        jObject.addPropertyStringNullOrEmpty("TitleValue", this.titleValue);
                        jObject.addPropertyStringNullOrEmpty("LegendColor", StiJsonReportObjectHelper.Serialize.jColor(this.legendColor, null));
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = property.value.toString();
                                break;
                            case "SortBy":
                                this._sortBy = Enum.parse(Chart.StiSeriesSortType, property.value.toString());
                                break;
                            case "SortDirection":
                                this._sortDirection = Enum.parse(Chart.StiSeriesSortDirection, property.value.toString());
                                break;
                            case "ShowInLegend":
                                this._showInLegend = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowSeriesLabels":
                                this._showSeriesLabels = Enum.parse(Chart.StiShowSeriesLabels, property.value.toString());
                                break;
                            case "ShowShadow":
                                this._showShadow = property.value.stimulsoft().toBoolean();
                                break;
                            case "FilterMode":
                                this._filterMode = Enum.parse(StiFilterMode, property.value.toString());
                                break;
                            case "Filters":
                                this._filters.loadFromJsonObject(property.value);
                                break;
                            case "Conditions":
                                this._conditions.loadFromJsonObject(property.value);
                                break;
                            case "TopN":
                                this.topN.loadFromJsonObject(property.value);
                                break;
                            case "YAxis":
                                this._yAxis = Enum.parse(Chart.StiSeriesYAxis, property.value.toString());
                                break;
                            case "SeriesLabels":
                                this._seriesLabels = Chart.StiSeriesLabels.loadFromJsonObjectInternal(property.value, this.chart);
                                break;
                            case "TrendLine":
                                this.trendLine = Chart.StiTrendLine.loadFromJsonObjectInternal(property.value);
                                break;
                            case "TrendLines":
                                this.trendLines.loadFromJsonObject(property.value);
                                break;
                            case "ValueDataColumn":
                                this.valueDataColumn = property.value.toString();
                                break;
                            case "ArgumentDataColumn":
                                this._argumentDataColumn = property.value.toString();
                                break;
                            case "AutoSeriesTitleDataColumn":
                                this._autoSeriesTitleDataColumn = property.value.toString();
                                break;
                            case "AutoSeriesKeyDataColumn":
                                this._autoSeriesKeyDataColumn = property.value.toString();
                                break;
                            case "AutoSeriesColorDataColumn":
                                this._autoSeriesColorDataColumn = property.value.toString();
                                break;
                            case "ToolTipDataColumn":
                                this._toolTipDataColumn = property.value.toString();
                                break;
                            case "TagDataColumn":
                                this._tagDataColumn = property.value.toString();
                                break;
                            case "HyperlinkDataColumn":
                                this._hyperlinkDataColumn = property.value.toString();
                                break;
                            case "DrillDownEnabled":
                                this.drillDownEnabled = property.value.stimulsoft().toBoolean();
                                break;
                            case "DrillDownReport":
                                this.drillDownReport = property.value.toString();
                                break;
                            case "DrillDownPageGuid":
                                this._drillDownPageGuid = property.value.toString();
                                break;
                            case "AllowSeries":
                                this._allowSeries = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowSeriesElements":
                                this._allowSeriesElements = property.value.stimulsoft().toBoolean();
                                break;
                            case "Interaction":
                                this.interaction.loadFromJsonObject(property.value);
                                break;
                            case "NewAutoSeriesEvent":
                                break;
                            case "GetValueEvent":
                                break;
                            case "GetListOfValuesEvent":
                                break;
                            case "GetArgumentEvent":
                                break;
                            case "GetListOfArgumentsEvent":
                                break;
                            case "GetTitleEvent":
                                break;
                            case "GetToolTipEvent":
                                break;
                            case "GetListOfToolTipsEvent":
                                break;
                            case "GetTagEvent":
                                break;
                            case "GetListOfTagsEvent":
                                break;
                            case "GetHyperlinkEvent":
                                break;
                            case "GetListOfHyperlinksEvent":
                                break;
                            case "Value": {
                                let _valueObj = new StiExpression();
                                _valueObj.loadFromJsonObject(property.value);
                                this.value = _valueObj.value;
                                break;
                            }
                            case "ListOfValues":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValues = _expression.value;
                                    break;
                                }
                            case "Argument":
                                {
                                    let _argument = new StiExpression();
                                    _argument.loadFromJsonObject(property.value);
                                    this.argument = _argument.value;
                                    break;
                                }
                            case "ListOfArguments":
                                {
                                    let _listOfArguments = new StiExpression();
                                    _listOfArguments.loadFromJsonObject(property.value);
                                    this.listOfArguments = _listOfArguments.value;
                                    break;
                                }
                            case "Title":
                                {
                                    let _title = new StiExpression();
                                    _title.loadFromJsonObject(property.value);
                                    this.title = _title.value;
                                    break;
                                }
                            case "ToolTip":
                                {
                                    let _toolTip = new StiExpression();
                                    _toolTip.loadFromJsonObject(property.value);
                                    this.toolTip = _toolTip.value;
                                    break;
                                }
                            case "ListOfToolTips":
                                {
                                    let _listOfToolTips = new StiExpression();
                                    _listOfToolTips.loadFromJsonObject(property.value);
                                    this.listOfToolTips = _listOfToolTips.value;
                                    break;
                                }
                            case "Tag":
                                {
                                    let _tag = new StiExpression();
                                    _tag.loadFromJsonObject(property.value);
                                    this.tag = _tag.value;
                                    break;
                                }
                            case "ListOfTags":
                                {
                                    let _listOfTags = new StiExpression();
                                    _listOfTags.loadFromJsonObject(property.value);
                                    this.listOfTags = _listOfTags.value;
                                    break;
                                }
                            case "Hyperlink":
                                {
                                    let _hyperlink = new StiExpression();
                                    _hyperlink.loadFromJsonObject(property.value);
                                    this.hyperlink = _hyperlink.value;
                                    break;
                                }
                            case "ListOfHyperlinks":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfHyperlinks = _expression.value;
                                    break;
                                }
                            case "ValuesString":
                                this.valuesString = property.value.toString();
                                break;
                            case "ArgumentsString":
                                this.argumentsString = property.value.toString();
                                break;
                            case "ToolTipsString":
                                this.toolTipsString = property.value.toString();
                                break;
                            case "TagString":
                                this.tagString = property.value.toString();
                                break;
                            case "HyperlinkString":
                                this.hyperlinkString = property.value.toString();
                                break;
                            case "TitleValue":
                                this.titleValue = property.value.toString();
                                break;
                            case "LegendColor":
                                this.legendColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = node.textContent;
                                break;
                            case "SortBy":
                                this._sortBy = Enum.parse(Chart.StiSeriesSortType, node.textContent);
                                break;
                            case "SortDirection":
                                this._sortDirection = Enum.parse(Chart.StiSeriesSortDirection, node.textContent);
                                break;
                            case "ValuesString":
                                this.valuesString = node.textContent;
                                break;
                            case "ArgumentsString":
                                this.argumentsString = node.textContent;
                                break;
                            case "ShowInLegend":
                                this._showInLegend = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowSeriesLabels":
                                this._showSeriesLabels = Enum.parse(Chart.StiShowSeriesLabels, node.textContent);
                                break;
                            case "ShowShadow":
                                this._showShadow = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "FilterMode":
                                this._filterMode = Enum.parse(StiFilterMode, node.textContent);
                                break;
                            case "Filters":
                                this._filters.loadFromXml(node);
                                break;
                            case "Conditions":
                                this._conditions.loadFromXml(node);
                                break;
                            case "TopN":
                                this.topN.loadFromXml(node);
                                break;
                            case "YAxis":
                                this._yAxis = Enum.parse(Chart.StiSeriesYAxis, node.textContent);
                                break;
                            case "SeriesLabels":
                                this._seriesLabels = Chart.StiSeriesLabels.loadLabelsFromXml(node, this._chart);
                                break;
                            case "TrendLine":
                                this.trendLine = Chart.StiTrendLine.loadTrendLineFromXml(node);
                                break;
                            case "TrendLines":
                                this.trendLines.loadFromXml(node);
                                break;
                            case "ValueDataColumn":
                                this.valueDataColumn = node.textContent;
                                break;
                            case "ArgumentDataColumn":
                                this._argumentDataColumn = node.textContent;
                                break;
                            case "AutoSeriesTitleDataColumn":
                                this._autoSeriesTitleDataColumn = node.textContent;
                                break;
                            case "AutoSeriesKeyDataColumn":
                                this._autoSeriesKeyDataColumn = node.textContent;
                                break;
                            case "AutoSeriesColorDataColumn":
                                this._autoSeriesColorDataColumn = node.textContent;
                                break;
                            case "ToolTipDataColumn":
                                this._toolTipDataColumn = node.textContent;
                                break;
                            case "TagDataColumn":
                                this._tagDataColumn = node.textContent;
                                break;
                            case "HyperlinkDataColumn":
                                this._hyperlinkDataColumn = node.textContent;
                                break;
                            case "DrillDownEnabled":
                                this.drillDownEnabled = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "DrillDownReport":
                                this.drillDownReport = node.textContent;
                                break;
                            case "DrillDownPageGuid":
                                this._drillDownPageGuid = node.textContent;
                                break;
                            case "AllowSeries":
                                this._allowSeries = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowSeriesElements":
                                this._allowSeriesElements = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Interaction":
                                this.interaction.loadFromXml(node);
                                break;
                            case "NewAutoSeriesEvent":
                                break;
                            case "GetValueEvent":
                                break;
                            case "GetListOfValuesEvent":
                                break;
                            case "GetArgumentEvent":
                                break;
                            case "GetListOfArgumentsEvent":
                                break;
                            case "GetTitleEvent":
                                break;
                            case "GetToolTipEvent":
                                break;
                            case "GetListOfToolTipsEvent":
                                break;
                            case "GetTagEvent":
                                break;
                            case "GetListOfTagsEvent":
                                break;
                            case "GetHyperlinkEvent":
                                break;
                            case "GetListOfHyperlinksEvent":
                                break;
                            case "Value":
                                {
                                    let _valueObj = new StiExpression();
                                    _valueObj.loadFromXml(node);
                                    this.value = _valueObj.value;
                                    break;
                                }
                            case "ListOfValues":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValues = _expression.value;
                                    break;
                                }
                            case "Argument":
                                {
                                    let _argument = new StiExpression();
                                    _argument.loadFromXml(node);
                                    this.argument = _argument.value;
                                    break;
                                }
                            case "ListOfArguments":
                                {
                                    let _listOfArguments = new StiExpression();
                                    _listOfArguments.loadFromXml(node);
                                    this.listOfArguments = _listOfArguments.value;
                                    break;
                                }
                            case "Title":
                                {
                                    let _title = new StiExpression();
                                    _title.loadFromXml(node);
                                    this.title = _title.value;
                                    break;
                                }
                            case "ToolTip":
                                {
                                    let _toolTip = new StiExpression();
                                    _toolTip.loadFromXml(node);
                                    this.toolTip = _toolTip.value;
                                    break;
                                }
                            case "ListOfToolTips":
                                {
                                    let _listOfToolTips = new StiExpression();
                                    _listOfToolTips.loadFromXml(node);
                                    this.listOfToolTips = _listOfToolTips.value;
                                    break;
                                }
                            case "Tag":
                                {
                                    let _tag = new StiExpression();
                                    _tag.loadFromXml(node);
                                    this.tag = _tag.value;
                                    break;
                                }
                            case "ListOfTags":
                                {
                                    let _listOfTags = new StiExpression();
                                    _listOfTags.loadFromXml(node);
                                    this.listOfTags = _listOfTags.value;
                                    break;
                                }
                            case "Hyperlink":
                                {
                                    let _hyperlink = new StiExpression();
                                    _hyperlink.loadFromXml(node);
                                    this.hyperlink = _hyperlink.value;
                                    break;
                                }
                            case "ListOfHyperlinks":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfHyperlinks = _expression.value;
                                    break;
                                }
                            case "TitleValue":
                                {
                                    let _titleValue = new StiExpression();
                                    _titleValue.loadFromXml(node);
                                    this.titleValue = _titleValue.value;
                                    break;
                                }
                            case "LegendColor":
                                this.legendColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSeries;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let series = super.clone();
                    series.title = this.title;
                    series.values = this.values.stimulsoft().clone();
                    series.arguments = this.arguments.stimulsoft().clone();
                    series.tags = this.tags.stimulsoft().clone();
                    series.toolTips = this.toolTips.stimulsoft().clone();
                    series.hyperlinks = this.hyperlinks.stimulsoft().clone();
                    series.topN = this.topN.clone();
                    series.interaction = this.interaction.clone();
                    series.seriesLabels = this.seriesLabels.clone();
                    if (this.core != null) {
                        series.core = this.core.clone();
                        series.core.series = series;
                    }
                    return series;
                }
                baseTransform(context, x, y, angle, dx, dy) {
                }
                get parent() {
                    return this.chart;
                }
                get serviceName() {
                    return this.core.localizedName;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiSeries;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get format() {
                    return this._format;
                }
                set format(value) {
                    this._format = value;
                }
                get sortBy() {
                    return this._sortBy;
                }
                set sortBy(value) {
                    this._sortBy = value;
                }
                get sortDirection() {
                    return this._sortDirection;
                }
                set sortDirection(value) {
                    this._sortDirection = value;
                }
                get showInLegend() {
                    return this._showInLegend;
                }
                set showInLegend(value) {
                    this._showInLegend = value;
                }
                get showLabels() {
                    return true;
                }
                set showLabels(value) {
                    if (value)
                        this.showSeriesLabels = Chart.StiShowSeriesLabels.FromChart;
                }
                get showSeriesLabels() {
                    return this._showSeriesLabels;
                }
                set showSeriesLabels(value) {
                    this._showSeriesLabels = (value == Chart.StiShowSeriesLabels.None) ? Chart.StiShowSeriesLabels.FromChart : value;
                }
                get showShadow() {
                    return this._showShadow;
                }
                set showShadow(value) {
                    this._showShadow = value;
                }
                get filterMode() {
                    return this._filterMode;
                }
                set filterMode(value) {
                    this._filterMode = value;
                }
                get filters() {
                    return this._filters;
                }
                set filters(value) {
                    this._filters = value;
                }
                get conditions() {
                    return this._conditions;
                }
                set conditions(value) {
                    this._conditions = value;
                }
                get topN() {
                    return this._topN;
                }
                set topN(value) {
                    this._topN = value;
                }
                get yAxis() {
                    return this._yAxis;
                }
                set yAxis(value) {
                    this._yAxis = value;
                }
                get seriesLabels() {
                    return this._seriesLabels;
                }
                set seriesLabels(value) {
                    this._seriesLabels = value;
                    this._seriesLabels.chart = this.chart;
                }
                get trendLine() {
                    if (this._trendLines != null && this._trendLines.count > 0)
                        return this._trendLines.getByIndex(0);
                    return new Chart.StiTrendLineNone();
                }
                set trendLine(value) {
                    if (!value.is(Chart.StiTrendLineNone)) {
                        this._trendLines.insert(0, value);
                    }
                }
                get trendLines() {
                    return this._trendLines;
                }
                set trendLines(value) {
                    this._trendLines = value;
                }
                get isTotalLabel() {
                    return this._isTotalLabel;
                }
                set isTotalLabel(value) {
                    this._isTotalLabel = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    if (this._chart != value) {
                        this._chart = value;
                        if (value != null) {
                            this.seriesLabels.chart = value;
                        }
                    }
                }
                get values() {
                    if (this.chart == null || this.chart != null && !this.chart.isDesigning || this.isDashboard)
                        return this._values;
                    let serIndex = this.chart.series.indexOf(this);
                    let defaultValues = [];
                    let waterfallSeries = this.as(Chart.StiWaterfallSeries);
                    if (waterfallSeries != null) {
                        if (waterfallSeries.total.visible)
                            defaultValues = [3, -1, 2, 4];
                        else
                            defaultValues = [3, -1, 2];
                    }
                    else if (this.is(Chart.IStiBoxAndWhiskerSeries))
                        defaultValues = [8, 2, 3, 9, 10];
                    else if (this.is(Chart.IStiHistogramSeries))
                        defaultValues = [4, 2, 1];
                    else if (!StiString.isNullOrEmpty(this.listOfValues) && !this.listOfValues.stimulsoft().contains("{")) {
                        defaultValues = StiSeries.getNullableValuesFromString(this, this.listOfValues);
                    }
                    else if (this.is(Chart.IStiSteppedRangeSeries))
                        defaultValues = [1 + serIndex * 3, 3 + serIndex * 4, 2 + serIndex * 3, 3 + serIndex * 3, 3 + serIndex * 3];
                    else if (this.is(Chart.IStiFunnelSeries))
                        defaultValues = [3, 2, 1];
                    else if (this.is(Chart.IStiGanttSeries))
                        defaultValues = [1 + serIndex * 3, 3 + serIndex * 4, 7 + serIndex * 3];
                    else if (this.is(Chart.IStiScatterSeries))
                        defaultValues = [1 + serIndex, 6 + serIndex, 2 + serIndex];
                    else if (this.is(Chart.IStiPieSeries)) {
                        if (serIndex == 0)
                            defaultValues = [1, 3, 2];
                        else
                            defaultValues = [1 + serIndex, 3 + serIndex, 4 + serIndex];
                    }
                    else {
                        if (this.is(Chart.StiRadarSeries)) {
                            defaultValues = [1 + serIndex, 2 + serIndex, 3 + serIndex, 4 + serIndex, 5 + serIndex];
                        }
                        else if (serIndex == 0)
                            defaultValues = this._values;
                        else
                            defaultValues = [1 + serIndex, 3 + serIndex, 2.5 + serIndex];
                    }
                    let offset = this.getOffsetForValues();
                    if (offset != 0) {
                        let correctionValues = [];
                        for (let index = 0; index < defaultValues.length; index++) {
                            correctionValues[index] = defaultValues[index] + offset;
                        }
                        return correctionValues;
                    }
                    return defaultValues;
                }
                set values(value) {
                    var _a;
                    let preparedValues = [];
                    for (let index = 0; index < value.length; index++) {
                        if (index < this.values.length && ((_a = this.valuesStart) === null || _a === void 0 ? void 0 : _a.length) > 0)
                            preparedValues[index] = this.values[index];
                        else
                            preparedValues[index] = 0;
                    }
                    this.valuesStart = preparedValues;
                    this._values = value;
                }
                get valueDataColumn() {
                    return this._valueDataColumn;
                }
                set valueDataColumn(value) {
                    this._valueDataColumn = value;
                }
                get valuesString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this._values) {
                        if (first)
                            sb.appendFormat("{0}", value == null ? 0 : value);
                        else
                            sb.appendFormat(";{0}", value == null ? 0 : value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._values = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._values = [];
                        for (let str of strs) {
                            this._values.push(str.stimulsoft().toNumber());
                        }
                    }
                }
                get arguments() {
                    return this.getArguments();
                }
                set arguments(value) {
                    this.setArguments(value);
                }
                getArguments() {
                    if (this.chart == null || !this.chart.isDesigning || this.isDashboard) {
                        return this._arguments;
                    }
                    if (!StiString.isNullOrEmpty(this.listOfArguments)) {
                        return StiSeries.getArgumentsFromString(this.listOfArguments);
                    }
                    let waterfallSeries = this.as(Chart.StiWaterfallSeries);
                    if (waterfallSeries != null &&
                        (this._arguments == null || this._arguments.length == 0)) {
                        if (waterfallSeries.total.visible)
                            return ["A", "B", "C", waterfallSeries.total.text];
                        else
                            return ["A", "B", "C"];
                    }
                    if (this.is(Chart.IStiHistogramSeries))
                        return ["[1, 2]", "(2, 3]", "(3, 4]"];
                    if ((this.is(Chart.IStiTreemapSeries) || this.is(Chart.IStiGanttSeries) || this.is(Chart.IStiRangeBarSeries) || this.is(Chart.IStiCandlestickSeries) || this.is(Chart.StiSunburstSeries)) &&
                        (this._arguments == null || this._arguments.length == 0))
                        return ["A", "B", "C"];
                    if ((this.is(Chart.IStiScatterSeries) || this.is(Chart.IStiScatterLineSeries) || this.is(Chart.IStiScatterSplineSeries)) &&
                        (this._arguments == null || this._arguments.length == 0))
                        return ["1", "5", "4"];
                    return this._arguments;
                }
                setArguments(value) {
                    this._arguments = value;
                }
                get argumentDataColumn() {
                    return this._argumentDataColumn;
                }
                set argumentDataColumn(value) {
                    this._argumentDataColumn = value;
                }
                get argumentsString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let arg of this._arguments) {
                        if (arg != null) {
                            if (first)
                                sb.appendFormat("{0}", XmlConvert.encodeName(arg.toString()));
                            else
                                sb.appendFormat(";{0}", XmlConvert.encodeName(arg.toString()));
                            first = false;
                        }
                    }
                    return sb.toString();
                }
                set argumentsString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._arguments = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._arguments = [];
                        for (let str of strs) {
                            this._arguments.push(XmlConvert.decodeName(str));
                        }
                    }
                }
                get autoSeriesTitleDataColumn() {
                    return this._autoSeriesTitleDataColumn;
                }
                set autoSeriesTitleDataColumn(value) {
                    this._autoSeriesTitleDataColumn = value;
                }
                get autoSeriesKeyDataColumn() {
                    return this._autoSeriesKeyDataColumn;
                }
                set autoSeriesKeyDataColumn(value) {
                    this._autoSeriesKeyDataColumn = value;
                }
                get autoSeriesColorDataColumn() {
                    return this._autoSeriesColorDataColumn;
                }
                set autoSeriesColorDataColumn(value) {
                    this._autoSeriesColorDataColumn = value;
                }
                get toolTips() {
                    if (this.chart != null && this.chart.isDesigning || this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfToolTips)) {
                            return StiSeries.getStringsFromString(this.listOfToolTips);
                        }
                    }
                    return this._toolTips;
                }
                set toolTips(value) {
                    this._toolTips = value;
                }
                get toolTipDataColumn() {
                    return this._toolTipDataColumn;
                }
                set toolTipDataColumn(value) {
                    this._toolTipDataColumn = value;
                }
                get toolTipsString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let arg of this._toolTips) {
                        if (arg != null) {
                            if (first)
                                sb.appendFormat("{0}", XmlConvert.encodeName(arg.toString()));
                            else
                                sb.appendFormat(";{0}", XmlConvert.encodeName(arg.toString()));
                            first = false;
                        }
                    }
                    return sb.toString();
                }
                set toolTipsString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._toolTips = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._toolTips = [];
                        for (let str of strs) {
                            this._toolTips.push(XmlConvert.decodeName(str));
                        }
                    }
                }
                get tags() {
                    if (this.chart != null && this.chart.isDesigning || this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfTags)) {
                            return StiSeries.getArgumentsFromString(this.listOfTags);
                        }
                    }
                    return this._tags;
                }
                set tags(value) {
                    this._tags = value;
                }
                get tagDataColumn() {
                    return this._tagDataColumn;
                }
                set tagDataColumn(value) {
                    this._tagDataColumn = value;
                }
                get tagString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let arg of this.tags) {
                        if (arg != null) {
                            if (first)
                                sb.appendFormat("{0}", XmlConvert.encodeName(arg.toString()));
                            else
                                sb.appendFormat(";{0}", XmlConvert.encodeName(arg.toString()));
                            first = false;
                        }
                    }
                    return sb.toString();
                }
                set tagString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._tags = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._tags = [];
                        for (let str of strs) {
                            this._tags.push(XmlConvert.decodeName(str));
                        }
                    }
                }
                get hyperlinks() {
                    if (this.chart != null && this.chart.isDesigning || this.isDashboard) {
                        if (this.listOfHyperlinks != null && this.listOfHyperlinks.length > 0) {
                            return StiSeries.getStringsFromString(this.listOfHyperlinks);
                        }
                    }
                    return this._hyperlinks;
                }
                set hyperlinks(value) {
                    this._hyperlinks = value;
                }
                get hyperlinkDataColumn() {
                    return this._hyperlinkDataColumn;
                }
                set hyperlinkDataColumn(value) {
                    this._hyperlinkDataColumn = value;
                }
                get hyperlinkString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let arg of this._hyperlinks) {
                        if (arg != null) {
                            if (first)
                                sb.appendFormat("{0}", XmlConvert.encodeName(arg.toString()));
                            else
                                sb.appendFormat(";{0}", XmlConvert.encodeName(arg.toString()));
                            first = false;
                        }
                    }
                    return sb.toString();
                }
                set hyperlinkString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._hyperlinks = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._hyperlinks = [];
                        for (let str of strs) {
                            this._hyperlinks.push(XmlConvert.decodeName(str));
                        }
                    }
                }
                get drillDownEnabled() {
                    return this._drillDownEnabled;
                }
                set drillDownEnabled(value) {
                    this._drillDownEnabled = value;
                }
                get drillDownReport() {
                    return this._drillDownReport;
                }
                set drillDownReport(value) {
                    this._drillDownReport = value;
                }
                get drillDownPage() {
                    if (this.chart == null || this.chart.report == null)
                        return null;
                    for (let page of this.chart.report.pages.list) {
                        if (page.guid == this.drillDownPageGuid)
                            return page;
                    }
                    return null;
                }
                set drillDownPage(value) {
                    if (value == null)
                        this.drillDownPageGuid = null;
                    else {
                        if (value.guid == null)
                            value.guid = StiGuidUtils.newGuid();
                        this._drillDownPageGuid = value.guid;
                    }
                }
                get drillDownPageGuid() {
                    return this._drillDownPageGuid;
                }
                set drillDownPageGuid(value) {
                    this._drillDownPageGuid = value;
                }
                get allowSeries() {
                    return this._allowSeries;
                }
                set allowSeries(value) {
                    this._allowSeries = value;
                }
                get allowSeriesElements() {
                    return this._allowSeriesElements;
                }
                set allowSeriesElements(value) {
                    this._allowSeriesElements = value;
                }
                get coreTitle() {
                    let value = null;
                    if (this.chart != null && this.chart.isDesigning)
                        value = this.title;
                    else
                        value = this.titleValue;
                    if (value == null)
                        value = "";
                    return value;
                }
                set coreTitle(value) {
                    this.title = value;
                    this.titleValue = value;
                }
                get interaction() {
                    return this._interaction;
                }
                set interaction(value) {
                    if (this._interaction != value) {
                        this._interaction = value;
                        if (value != null)
                            this._interaction.parentSeries = this;
                    }
                }
                processSeriesColors(pointIndex, seriesColor) {
                    for (let condition of this.conditions.list) {
                        if (this.getConditionResult(pointIndex, condition)) {
                            return condition.color;
                        }
                    }
                    return seriesColor;
                }
                processSeriesMarkerType(pointIndex, markerType) {
                    for (let condition of this.conditions.list) {
                        if (this.getConditionResult(pointIndex, condition)) {
                            return condition.markerType;
                        }
                    }
                    return markerType;
                }
                processSeriesMarkerAngle(pointIndex, markerAngle) {
                    for (let condition of this.conditions.list) {
                        if (this.getConditionResult(pointIndex, condition)) {
                            return condition.markerAngle;
                        }
                    }
                    return markerAngle;
                }
                processSeriesMarkerVisible(pointIndex) {
                    for (let condition of this.conditions.list) {
                        if (this.getConditionResult(pointIndex, condition)) {
                            return true;
                        }
                    }
                    return false;
                }
                processSeriesBrushes(pointIndex, seriesBrush) {
                    for (let condition of this.conditions.list) {
                        if (this.getConditionResult(pointIndex, condition)) {
                            if (this.allowApplyStyle && this.chart.style != null)
                                seriesBrush = this.chart.style.core.getColumnBrush(condition.color);
                            else {
                                seriesBrush = new StiSolidBrush(condition.color);
                            }
                            if (this.chart.area.is(Chart.IStiClusteredBarArea)) {
                                if (seriesBrush.is(StiGradientBrush))
                                    seriesBrush.angle += 90;
                                if (seriesBrush.is(StiGlareBrush))
                                    seriesBrush.angle += 90;
                            }
                            return seriesBrush;
                        }
                    }
                    return seriesBrush;
                }
                getConditionResult(pointIndex, condition) {
                    if ((this.values == null || this.values.length <= pointIndex) && !(this.is(Chart.IStiFinancialSeries)))
                        return false;
                    let itemValue = null;
                    let itemValueEnd = null;
                    let itemValueOpen = null;
                    let itemValueClose = null;
                    let itemValueLow = null;
                    let itemValueHigh = null;
                    let itemArgument = null;
                    if ((this.chart.area.is(Chart.IStiAxisArea) && this.chart.area.reverseHor && !(this.chart.area.is(Chart.IStiClusteredBarArea))) ||
                        (this.chart.area.is(Chart.IStiClusteredBarArea) && this.chart.area.reverseVert)) {
                        if (this.values != null && pointIndex < this.values.length)
                            itemValue = this.values[this.values.length - pointIndex - 1];
                        if (this.is(Chart.IStiRangeSeries) && pointIndex < this.valuesEnd.length)
                            itemValueEnd = this.valuesEnd[this.valuesEnd.length - pointIndex - 1];
                        if (this.is(Chart.IStiFinancialSeries)) {
                            if (pointIndex < this.valuesOpen.length)
                                itemValueOpen = this.valuesOpen[this.valuesOpen.length - pointIndex - 1];
                            if (pointIndex < this.valuesClose.length)
                                itemValueClose = this.valuesClose[this.valuesClose.length - pointIndex - 1];
                            if (pointIndex < this.valuesLow.length)
                                itemValueLow = this.valuesLow[this.valuesLow.length - pointIndex - 1];
                            if (pointIndex < this.valuesHigh.length)
                                itemValueHigh = this.valuesHigh[this.valuesHigh.length - pointIndex - 1];
                        }
                        if (this.arguments != null && pointIndex < this.arguments.length)
                            itemArgument = this.arguments[this.arguments.length - pointIndex - 1];
                    }
                    else {
                        if (this.values != null && pointIndex < this.values.length)
                            itemValue = this.values[pointIndex];
                        if (this.is(Chart.IStiRangeSeries) && pointIndex < this.valuesEnd.length)
                            itemValueEnd = this.valuesEnd[pointIndex];
                        if (this.is(Chart.IStiFinancialSeries)) {
                            if (pointIndex < this.valuesOpen.length)
                                itemValueOpen = this.valuesOpen[pointIndex];
                            if (pointIndex < this.valuesClose.length)
                                itemValueClose = this.valuesClose[pointIndex];
                            if (pointIndex < this.valuesLow.length)
                                itemValueLow = this.valuesLow[pointIndex];
                            if (pointIndex < this.valuesHigh.length)
                                itemValueHigh = this.valuesHigh[pointIndex];
                        }
                        if (this.arguments != null && pointIndex < this.arguments.length)
                            itemArgument = this.arguments[pointIndex];
                    }
                    let data = Chart.StiChartHelper.getFilterData(null, condition, null);
                    return Chart.StiChartHelper.getFilterResult(condition, itemArgument, itemValue, itemValueEnd, itemValueOpen, itemValueClose, itemValueLow, itemValueHigh, data);
                }
                toString() {
                    return this.serviceName;
                }
                static tryParseValue(value, culture, refResult) {
                    this.storedCulture = null;
                    try {
                        if (!StiString.isNullOrEmpty(culture)) {
                            this.storedCulture = CultureInfo.currentCulture;
                            CultureInfo.currentCulture = CultureInfo.cultures[culture];
                        }
                        let result = StiNumber.tryParse(value);
                        refResult.ref = result.result;
                        return result.successfully;
                    }
                    finally {
                        if (this.storedCulture != null)
                            CultureInfo.currentCulture = this.storedCulture;
                    }
                }
                static getNullableValuesFromString(series, list) {
                    let alValue = [];
                    let points = list.split(";");
                    for (let point of points) {
                        if (point != null && point.trim().length > 0) {
                            let value = 0;
                            try {
                                value = point.stimulsoft().replaceAll(",", ".").stimulsoft().toNumber();
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                            let result = point.stimulsoft().toNumber();
                            if (point.length > 0 && !isNaN(result)) {
                                value = result;
                            }
                            else {
                                let resultDateTime = DateTime.fromString(point, false);
                                if (resultDateTime != null) {
                                    series.core.isDateTimeValues = true;
                                    value = resultDateTime.toOADate();
                                }
                            }
                            alValue.push(value);
                        }
                    }
                    return alValue.stimulsoft().toArray();
                }
                static getValuesFromString(list) {
                    let alValue = [];
                    let points = list.split(";");
                    for (let point of points) {
                        if (point != null && point.trim().length > 0) {
                            let value = 0;
                            try {
                                value = point.stimulsoft().replaceAll(",", ".").stimulsoft().toNumber();
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                            alValue.push(value);
                        }
                    }
                    return alValue.stimulsoft().toArray();
                }
                static getStringsFromString(list) {
                    let alValue = [];
                    let points = list.split(";");
                    for (let point of points) {
                        if (point != null && point.trim().length > 0) {
                            alValue.push(point);
                        }
                    }
                    return alValue.stimulsoft().toArray();
                }
                static getArgumentsFromString(list) {
                    return list.split(";");
                }
                getOffsetForValues() {
                    let offset = 0;
                    let area = this.chart.area.as(Chart.StiAxisArea);
                    if (area != null && !area.yAxis.range.auto) {
                        offset = area.yAxis.range.minimum;
                    }
                    return offset;
                }
                createNew() {
                    return null;
                }
                getDefaultAreaType() {
                    return null;
                }
                invokeNewAutoSeries(e) {
                    if (this.newAutoSeries != null)
                        this.newAutoSeries(e.series, e);
                }
                onGetValue(e) {
                }
                invokeGetValue(sender, e) {
                    try {
                        this.onGetValue(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesValue**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.value, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValue != null)
                            this.getValue(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetValue property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetListOfValues(e) {
                }
                invokeGetListOfValues(sender, e, series) {
                    try {
                        this.onGetListOfValues(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesListOfValues**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series._listOfValues, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValues != null)
                            series.getListOfValues(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetListOfValues property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetArgument(e) {
                }
                invokeGetArgument(sender, e) {
                    try {
                        this.onGetArgument(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesArgument**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.argument, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getArgument != null)
                            this.getArgument(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in getArgument property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetListOfArguments(e) {
                }
                invokeGetListOfArguments(sender, e) {
                    try {
                        this.onGetListOfArguments(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesListOfArguments**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this._listOfArguments, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfArguments != null)
                            this.getListOfArguments(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetListOfArguments property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetTitle(e) {
                }
                invokeGetTitle(sender, e) {
                    try {
                        this.onGetTitle(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesTitle**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.title, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getTitle != null)
                            this.getTitle(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in Title property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetToolTip(e) {
                }
                invokeGetToolTip(sender, e) {
                    try {
                        this.onGetToolTip(e);
                        if (this.getToolTip != null)
                            this.getToolTip(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetToolTip property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetListOfToolTips(e) {
                }
                invokeGetListOfToolTips(sender, e) {
                    try {
                        this.onGetListOfToolTips(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesListOfToolTips**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this._listOfToolTips, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfToolTips != null)
                            this.getListOfToolTips(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetListOfToolTips property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetTag(e) {
                }
                invokeGetTag(sender, e) {
                    try {
                        this.onGetTag(e);
                        if (this.getTag != null)
                            this.getTag(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetTag property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetListOfTags(e) {
                }
                invokeGetListOfTags(sender, e) {
                    try {
                        this.onGetListOfTags(e);
                        if (this.getListOfTags != null)
                            this.getListOfTags(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetListOfTags property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetHyperlink(e) {
                }
                invokeGetHyperlink(sender, e) {
                    try {
                        this.onGetHyperlink(e);
                        if (this.getHyperlink != null)
                            this.getHyperlink(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetHyperlink property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetListOfHyperlinks(e) {
                }
                invokeGetListOfHyperlinks(sender, e) {
                    try {
                        this.onGetListOfHyperlinks(e);
                        if (this.getListOfHyperlinks != null)
                            this.getListOfHyperlinks(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetListOfHyperlinks property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get value() {
                    return this.valueObj;
                }
                set value(value) {
                    this.valueObj = value;
                }
                get listOfValues() {
                    return this._listOfValues;
                }
                set listOfValues(value) {
                    this._listOfValues = value;
                }
                get argument() {
                    return this._argument;
                }
                set argument(value) {
                    this._argument = value;
                }
                get listOfArguments() {
                    return this._listOfArguments;
                }
                set listOfArguments(value) {
                    this._listOfArguments = value;
                }
                get titleValue() {
                    return this._titleValue;
                }
                set titleValue(value) {
                    this._titleValue = value;
                }
                get title() {
                    return this._title;
                }
                set title(value) {
                    this._title = value;
                }
                get toolTip() {
                    return this._toolTip;
                }
                set toolTip(value) {
                    this._toolTip = value;
                }
                get listOfToolTips() {
                    return this._listOfToolTips;
                }
                set listOfToolTips(value) {
                    this._listOfToolTips = value;
                }
                get tag() {
                    return this._tag;
                }
                set tag(value) {
                    this._tag = value;
                }
                get listOfTags() {
                    return this._listOfTags;
                }
                set listOfTags(value) {
                    this._listOfTags = value;
                }
                get hyperlink() {
                    return this._hyperlink;
                }
                set hyperlink(value) {
                    this._hyperlink = value;
                }
                get listOfHyperlinks() {
                    return this._listOfHyperlinks;
                }
                set listOfHyperlinks(value) {
                    this._listOfHyperlinks = value;
                }
            }
            Chart.StiSeries = StiSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiComponentInfo = Stimulsoft.Report.Engine.StiComponentInfo;
            class StiChartInfo extends StiComponentInfo {
                constructor() {
                    super(...arguments);
                    this.storedForProcessAtEndChart = null;
                    this.interactiveComps = null;
                }
                implements() {
                    if (!StiChartInfo.implementsStiChartInfo)
                        StiChartInfo.implementsStiChartInfo = [
                            Chart.IStiChartInfo
                        ];
                    return StiChartInfo.implementsStiChartInfo;
                }
            }
            Chart.StiChartInfo = StiChartInfo;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiBaseStyle = Stimulsoft.Report.Styles.StiBaseStyle;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiChartStyle extends StiBaseStyle {
                constructor() {
                    super(...arguments);
                    this.isOffice2015Style = false;
                    this.allowDashboard = false;
                    this.styleIdent = StiElementStyleIdent.Blue;
                }
                implements() {
                    if (!StiChartStyle.implementsStiChartStyle)
                        StiChartStyle.implementsStiChartStyle = super.implements()
                            .concat([IStiJsonReportObject, Chart.IStiChartStyle, ICloneable]);
                    return StiChartStyle.implementsStiChartStyle;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    return jObject;
                }
                loadFromJsonObject(jObject) { }
                static loadFromXml(xmlNode) {
                    if (xmlNode.attributes.getNamedItem("type") != null) {
                        switch (xmlNode.attributes.getNamedItem("type").value) {
                            case "Stimulsoft.Report.Chart.StiCustomStyle":
                                return new Chart.StiCustomStyle();
                            case "Stimulsoft.Report.Chart.StiStyle01":
                                return new Chart.StiStyle01();
                            case "Stimulsoft.Report.Chart.StiStyle02":
                                return new Chart.StiStyle02();
                            case "Stimulsoft.Report.Chart.StiStyle03":
                                return new Chart.StiStyle03();
                            case "Stimulsoft.Report.Chart.StiStyle04":
                                return new Chart.StiStyle04();
                            case "Stimulsoft.Report.Chart.StiStyle05":
                                return new Chart.StiStyle05();
                            case "Stimulsoft.Report.Chart.StiStyle06":
                                return new Chart.StiStyle06();
                            case "Stimulsoft.Report.Chart.StiStyle07":
                                return new Chart.StiStyle07();
                            case "Stimulsoft.Report.Chart.StiStyle08":
                                return new Chart.StiStyle08();
                            case "Stimulsoft.Report.Chart.StiStyle09":
                                return new Chart.StiStyle09();
                            case "Stimulsoft.Report.Chart.StiStyle10":
                                return new Chart.StiStyle10();
                            case "Stimulsoft.Report.Chart.StiStyle11":
                                return new Chart.StiStyle11();
                            case "Stimulsoft.Report.Chart.StiStyle12":
                                return new Chart.StiStyle12();
                            case "Stimulsoft.Report.Chart.StiStyle13":
                                return new Chart.StiStyle13();
                            case "Stimulsoft.Report.Chart.StiStyle14":
                                return new Chart.StiStyle14();
                            case "Stimulsoft.Report.Chart.StiStyle15":
                                return new Chart.StiStyle15();
                            case "Stimulsoft.Report.Chart.StiStyle16":
                                return new Chart.StiStyle16();
                            case "Stimulsoft.Report.Chart.StiStyle17":
                                return new Chart.StiStyle17();
                            case "Stimulsoft.Report.Chart.StiStyle18":
                                return new Chart.StiStyle18();
                            case "Stimulsoft.Report.Chart.StiStyle19":
                                return new Chart.StiStyle19();
                            case "Stimulsoft.Report.Chart.StiStyle20":
                                return new Chart.StiStyle20();
                            case "Stimulsoft.Report.Chart.StiStyle21":
                                return new Chart.StiStyle21();
                            case "Stimulsoft.Report.Chart.StiStyle22":
                                return new Chart.StiStyle22();
                            case "Stimulsoft.Report.Chart.StiStyle23":
                                return new Chart.StiStyle23();
                            case "Stimulsoft.Report.Chart.StiStyle24":
                                return new Chart.StiStyle24();
                            case "Stimulsoft.Report.Chart.StiStyle25":
                                return new Chart.StiStyle25();
                            case "Stimulsoft.Report.Chart.StiStyle26":
                                return new Chart.StiStyle26();
                            case "Stimulsoft.Report.Chart.StiStyle27":
                                return new Chart.StiStyle27();
                            case "Stimulsoft.Report.Chart.StiStyle28":
                                return new Chart.StiStyle28();
                            case "Stimulsoft.Report.Chart.StiStyle29":
                                return new Chart.StiStyle29();
                            case "Stimulsoft.Report.Chart.StiStyle30":
                                return new Chart.StiStyle30();
                            case "Stimulsoft.Report.Chart.StiStyle31":
                                return new Chart.StiStyle31();
                            case "Stimulsoft.Report.Chart.StiStyle32":
                                return new Chart.StiStyle32();
                            case "Stimulsoft.Report.Chart.StiStyle33":
                                return new Chart.StiStyle33();
                        }
                    }
                    return null;
                }
                static loadFromJsonObjectInternal(jObject) {
                    let ident = jObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                    if (ident == "StiCustomStyle") {
                        return new Chart.StiCustomStyle();
                    }
                    else {
                        let service = Stimulsoft["StiOptions"].Services.chartStyles.firstOrDefault(function (x) {
                            return x.stimulsoft().getType().stimulsoft().getTypeName() == ident;
                        });
                        if (service == null)
                            throw StiString.format("Type {0} is not found!", ident);
                        return service.createNew();
                    }
                }
                get serviceName() {
                    return this.core.localizedName;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiChartStyle;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                toString() {
                    if (this.is(Chart.StiCustomStyle) &&
                        this.core.reportChartStyle != null)
                        return this.core.reportChartStyle.name;
                    return this.serviceName;
                }
                compareChartStyle(style) {
                    if (style == null)
                        return false;
                    let style1 = this.stimulsoft().as(Chart.StiCustomStyle);
                    let style2 = style.stimulsoft().as(Chart.StiCustomStyle);
                    if (style1 != null && style2 != null) {
                        let styleName1 = style1.core.reportStyleName;
                        if (style1.core.reportStyle != null)
                            styleName1 = style1.core.reportStyle.name;
                        let styleName2 = style2.core.reportStyleName;
                        if (style2.core.reportStyle != null)
                            styleName2 = style2.core.reportStyle.name;
                        return styleName1 == styleName2;
                    }
                    return this.stimulsoft().getType() == style.stimulsoft().getType();
                }
                createNew() {
                    return null;
                }
            }
            Chart.StiChartStyle = StiChartStyle;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle25 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.Green;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF25();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "Green"); }
                createNew() {
                    return new StiStyle25();
                }
            }
            Chart.StiStyle25 = StiStyle25;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle29 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.Blue;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF29();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "Blue"); }
                createNew() {
                    return new StiStyle29();
                }
            }
            Chart.StiStyle29 = StiStyle29;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var SizeD = Stimulsoft.System.Drawing.Size;
            var Font = Stimulsoft.System.Drawing.Font;
            var FontStyle = Stimulsoft.System.Drawing.FontStyle;
            class StiLegend {
                constructor() {
                    this._allowApplyStyle = true;
                    this._chart = null;
                    this._hideSeriesWithEmptyTitle = false;
                    this._showShadow = true;
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.white);
                    this._titleColor = Color.gray;
                    this._labelsColor = Color.gray;
                    this._direction = Chart.StiLegendDirection.TopToBottom;
                    this._horAlignment = Chart.StiLegendHorAlignment.Left;
                    this._vertAlignment = Chart.StiLegendVertAlignment.Top;
                    this._titleFont = new Font("Arial", 14, FontStyle.Bold);
                    this._font = new Font("Arial", 8, FontStyle.Bold);
                    this._visible = true;
                    this._markerVisible = true;
                    this._markerBorder = true;
                    this._markerSize = new SizeD(10, 10);
                    this._markerAlignment = Chart.StiMarkerAlignment.Left;
                    this._columns = 0;
                    this._horSpacing = 4;
                    this._vertSpacing = 2;
                    this._title = "";
                    this._size = new Stimulsoft.System.Drawing.Size(0, 0);
                    this._core = new Chart.StiLegendCoreXF(this);
                }
                implements() {
                    if (!StiLegend.implementsStiLegend)
                        StiLegend.implementsStiLegend = [
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiLegend
                        ];
                    return StiLegend.implementsStiLegend;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyBool("HideSeriesWithEmptyTitle", this._hideSeriesWithEmptyTitle);
                    jObject.addPropertyBool("ShowShadow", this._showShadow, true);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("TitleColor", StiJsonReportObjectHelper.Serialize.jColor(this._titleColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("LabelsColor", StiJsonReportObjectHelper.Serialize.jColor(this._labelsColor, Color.gray));
                    jObject.addPropertyEnum("Direction", Chart.StiLegendDirection, this.direction, Chart.StiLegendDirection.TopToBottom);
                    jObject.addPropertyEnum("HorAlignment", Chart.StiLegendHorAlignment, this.horAlignment, Chart.StiLegendHorAlignment.Left);
                    jObject.addPropertyEnum("VertAlignment", Chart.StiLegendVertAlignment, this.vertAlignment, Chart.StiLegendVertAlignment.Top);
                    jObject.addPropertyStringNullOrEmpty("TitleFont", StiJsonReportObjectHelper.Serialize.font(this._titleFont, "Arial", 14, FontStyle.Bold));
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this._font, "Arial", 8));
                    jObject.addPropertyBool("Visible", this._visible, true);
                    jObject.addPropertyBool("MarkerVisible", this._markerVisible, true);
                    jObject.addPropertyBool("MarkerBorder", this._markerBorder, true);
                    jObject.addPropertyJObject("MarkerSize", StiJsonReportObjectHelper.Serialize.size(this._markerSize));
                    jObject.addPropertyEnum("MarkerAlignment", Chart.StiMarkerAlignment, this._markerAlignment, Chart.StiMarkerAlignment.Left);
                    jObject.addPropertyNumber("Columns", this._columns, 0);
                    jObject.addPropertyNumber("HorSpacing", this._horSpacing, 4);
                    jObject.addPropertyNumber("VertSpacing", this._vertSpacing, 2);
                    jObject.addPropertyStringNullOrEmpty("Size", StiJsonReportObjectHelper.Serialize.sizeD(this._size));
                    jObject.addPropertyStringNullOrEmpty("Title", this._title);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    this._showShadow = true;
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "HideSeriesWithEmptyTitle":
                                this._hideSeriesWithEmptyTitle = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowShadow":
                                this._showShadow = property.value.stimulsoft().toBoolean();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "TitleColor":
                                this._titleColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LabelsColor":
                                this._labelsColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Direction":
                                this.direction = Enum.parse(Chart.StiLegendDirection, property.value.toString());
                                break;
                            case "HorAlignment":
                                this.horAlignment = Enum.parse(Chart.StiLegendHorAlignment, property.value.toString());
                                break;
                            case "VertAlignment":
                                this.vertAlignment = Enum.parse(Chart.StiLegendVertAlignment, property.value.toString());
                                break;
                            case "TitleFont":
                                this._titleFont = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "Font":
                                this._font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerBorder":
                                this._markerBorder = property.value.stimulsoft().toBoolean();
                                break;
                            case "MarkerSize":
                                this._markerSize = StiJsonReportObjectHelper.Deserialize.size(property.value);
                                break;
                            case "MarkerAlignment":
                                this.markerAlignment = Enum.parse(Chart.StiMarkerAlignment, property.value.toString());
                                break;
                            case "Columns":
                                this._columns = property.value.stimulsoft().toNumber();
                                break;
                            case "HorSpacing":
                                this._horSpacing = property.value.stimulsoft().toNumber();
                                break;
                            case "VertSpacing":
                                this._vertSpacing = property.value.stimulsoft().toNumber();
                                break;
                            case "Size":
                                this._size = StiJsonReportObjectHelper.Deserialize.sizeD(property.value.toString());
                                break;
                            case "Title":
                                this._title = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    this._showShadow = true;
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "HideSeriesWithEmptyTitle":
                                this._hideSeriesWithEmptyTitle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowShadow":
                                this._showShadow = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "TitleColor":
                                this._titleColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LabelsColor":
                                this._labelsColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Direction":
                                this.direction = Enum.parse(Chart.StiLegendDirection, node.textContent);
                                break;
                            case "HorAlignment":
                            case "ha":
                                this.horAlignment = Enum.parse(Chart.StiLegendHorAlignment, node.textContent);
                                break;
                            case "VertAlignment":
                            case "va":
                                this.vertAlignment = Enum.parse(Chart.StiLegendVertAlignment, node.textContent);
                                break;
                            case "TitleFont":
                                this._titleFont = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Font":
                            case "fn":
                                this._font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerVisible":
                                this._markerVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerBorder":
                                this._markerBorder = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MarkerSize":
                                this._markerSize = Stimulsoft.System.Drawing.Size.convertFromXml(node.textContent);
                                break;
                            case "MarkerAlignment":
                                this.markerAlignment = Enum.parse(Chart.StiMarkerAlignment, node.textContent);
                                break;
                            case "Columns":
                                this._columns = node.textContent.stimulsoft().toNumber();
                                break;
                            case "HorSpacing":
                                this._horSpacing = node.textContent.stimulsoft().toNumber();
                                break;
                            case "VertSpacing":
                                this._vertSpacing = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Size":
                                this._size = Stimulsoft.System.Drawing.Size.convertFromXml(node.textContent);
                                break;
                            case "Title":
                                this._title = node.textContent;
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiLegend;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let legend = this.stimulsoft().memberwiseClone();
                    legend.brush = this.brush.clone();
                    legend.font = this.font.clone();
                    legend.titleFont = this.titleFont.clone();
                    legend.direction = this.direction;
                    legend.horAlignment = this.horAlignment;
                    legend.vertAlignment = this.vertAlignment;
                    legend.markerAlignment = this.markerAlignment;
                    if (this.core != null) {
                        legend.core = this.core.clone();
                        legend.core.legend = legend;
                    }
                    return legend;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && Chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                get hideSeriesWithEmptyTitle() {
                    return this._hideSeriesWithEmptyTitle;
                }
                set hideSeriesWithEmptyTitle(value) {
                    this._hideSeriesWithEmptyTitle = value;
                }
                get showShadow() {
                    return this._showShadow;
                }
                set showShadow(value) {
                    this._showShadow = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get titleColor() {
                    return this._titleColor;
                }
                set titleColor(value) {
                    this._titleColor = value;
                }
                get labelsColor() {
                    return this._labelsColor;
                }
                set labelsColor(value) {
                    this._labelsColor = value;
                }
                get direction() {
                    return this._direction;
                }
                set direction(value) {
                    this._direction = value;
                }
                get horAlignment() {
                    return this._horAlignment;
                }
                set horAlignment(value) {
                    this._horAlignment = value;
                }
                get vertAlignment() {
                    return this._vertAlignment;
                }
                set vertAlignment(value) {
                    this._vertAlignment = value;
                }
                get titleFont() {
                    return this._titleFont;
                }
                set titleFont(value) {
                    this._titleFont = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get markerVisible() {
                    return this._markerVisible;
                }
                set markerVisible(value) {
                    this._markerVisible = value;
                }
                get markerBorder() {
                    return this._markerBorder;
                }
                set markerBorder(value) {
                    this._markerBorder = value;
                }
                get markerSize() {
                    return this._markerSize;
                }
                set markerSize(value) {
                    this._markerSize = value;
                }
                get markerAlignment() {
                    return this._markerAlignment;
                }
                set markerAlignment(value) {
                    this._markerAlignment = value;
                }
                get columns() {
                    return this._columns;
                }
                set columns(value) {
                    if (value >= 0) {
                        this._columns = value;
                    }
                }
                get horSpacing() {
                    return this._horSpacing;
                }
                set horSpacing(value) {
                    this._horSpacing = value;
                }
                get vertSpacing() {
                    return this._vertSpacing;
                }
                set vertSpacing(value) {
                    this._vertSpacing = value;
                }
                get size() {
                    return this._size;
                }
                set size(value) {
                    this._size = value;
                }
                get title() {
                    return this._title;
                }
                set title(value) {
                    this._title = value;
                }
            }
            Chart.StiLegend = StiLegend;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Components;
        (function (Components) {
            var StiChartEditorType = Stimulsoft.Report.Chart.StiChartEditorType;
            var IStiGetFonts = Stimulsoft.Base.IStiGetFonts;
            var StiArray = Stimulsoft.System.StiArray;
            var StiAxisArea = Stimulsoft.Report.Chart.StiAxisArea;
            var StiString = Stimulsoft.System.StiString;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var IStiAxisArea = Stimulsoft.Report.Chart.IStiAxisArea;
            var StiProcessChartEvent = Stimulsoft.Report.Events.StiProcessChartEvent;
            var EventArgs = Stimulsoft.System.EventArgs;
            var StiSeriesLabels = Stimulsoft.Report.Chart.StiSeriesLabels;
            var StiChartStyle = Stimulsoft.Report.Chart.StiChartStyle;
            var StiArea = Stimulsoft.Report.Chart.StiArea;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiChartConditionsCollection = Stimulsoft.Report.Chart.StiChartConditionsCollection;
            var IStiChart = Stimulsoft.Report.Chart.IStiChart;
            var IStiClusteredColumnArea = Stimulsoft.Report.Chart.IStiClusteredColumnArea;
            var StiCenterAxisLabels = Stimulsoft.Report.Chart.StiCenterAxisLabels;
            var StiChartCoreXF = Stimulsoft.Report.Chart.StiChartCoreXF;
            var StiChartInfo = Stimulsoft.Report.Chart.StiChartInfo;
            var StiChartTitle = Stimulsoft.Report.Chart.StiChartTitle;
            var StiChartTable = Stimulsoft.Report.Chart.StiChartTable;
            var StiClusteredColumnArea = Stimulsoft.Report.Chart.StiClusteredColumnArea;
            var StiConstantLinesCollection = Stimulsoft.Report.Chart.StiConstantLinesCollection;
            var StiLegend = Stimulsoft.Report.Chart.StiLegend;
            var StiRadarArea = Stimulsoft.Report.Chart.StiRadarArea;
            var StiSeries = Stimulsoft.Report.Chart.StiSeries;
            var StiStripsCollection = Stimulsoft.Report.Chart.StiStripsCollection;
            var StiSeriesCollection = Stimulsoft.Report.Chart.StiSeriesCollection;
            var StiStyle29 = Stimulsoft.Report.Chart.StiStyle29;
            var StiChartHelper = Stimulsoft.Report.Chart.StiChartHelper;
            var StiActivator = Stimulsoft.Base.StiActivator;
            var StiJsonSaveMode = Stimulsoft.Base.StiJsonSaveMode;
            var Enum = Stimulsoft.System.Enum;
            var StiImageRotation = Stimulsoft.Report.Components.StiImageRotation;
            var StiComponentPriority = Stimulsoft.Report.Components.StiComponentPriority;
            var StiComponentType = Stimulsoft.Report.Components.StiComponentType;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBorder = Stimulsoft.Base.Drawing.StiBorder;
            var StiFilter = Stimulsoft.Report.Components.StiFilter;
            var StiFiltersCollection = Stimulsoft.Report.Components.StiFiltersCollection;
            var StiFilterMode = Stimulsoft.Report.Components.StiFilterMode;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var StiComponent = Stimulsoft.Report.Components.StiComponent;
            var List = Stimulsoft.System.Collections.List;
            class StiChart extends StiComponent {
                constructor(rect = RectangleD.empty) {
                    super(rect);
                    this._filterMode = StiFilterMode.And;
                    this._filters = new StiFiltersCollection();
                    this._filterOn = true;
                    this._border = new StiBorder();
                    this._brush = new StiSolidBrush(Color.transparent);
                    this._sort = [];
                    this._dataSourceName = "";
                    this._businessObjectGuid = "";
                    this._masterComponent = null;
                    this._countData = 0;
                    this.isEofValue = false;
                    this.isBofValue = false;
                    this.isCacheValues = false;
                    this.cachedCount = 0;
                    this.cachedIsBusinessObjectEmpty = false;
                    this.cachedIsDataSourceEmpty = false;
                    this.cachedDataSource = null;
                    this.cachedBusinessObject = null;
                    this._dataRelationName = "";
                    this._processAtEnd = false;
                    this.defaultClientRectangle = new RectangleD(0, 0, 200, 200);
                    this.processChartEvent = new StiProcessChartEvent();
                    this._seriesLabelsConditions = new StiChartConditionsCollection();
                    this._rotation = StiImageRotation.None;
                    this._editorType = StiChartEditorType.Advanced;
                    this._style = new StiStyle29();
                    this._allowApplyStyle = true;
                    this._customStyleName = "";
                    this._horSpacing = 10;
                    this._vertSpacing = 10;
                    this._isAnimation = true;
                    this._isAnimationChangingValues = true;
                    this._chartInfo = new StiChartInfo();
                    this._allowApplyStyle = Stimulsoft["StiOptions"].Engine.defaultValueOfAllowApplyStyleProperty;
                    this.legend = new StiLegend();
                    this.series = new StiSeriesCollection();
                    this.series.seriesAdded = this.series_SeriesAdded;
                    this.series.seriesRemoved = this.series_SeriesRemoved;
                    this.area = new StiClusteredColumnArea();
                    this.seriesLabels = new StiCenterAxisLabels();
                    this.constantLines = new StiConstantLinesCollection();
                    this.strips = new StiStripsCollection();
                    this.title = new StiChartTitle();
                    this.table = new StiChartTable();
                    this.previousAnimations = new List();
                    this._core = new StiChartCoreXF(this);
                    this.core.applyStyle(this.style);
                }
                implements() {
                    if (!StiChart.implementsStiChart)
                        StiChart.implementsStiChart = super.implements().concat([
                            Components.IStiBorder,
                            Components.IStiBusinessObject,
                            Components.IStiBrush,
                            Components.IStiDataSource,
                            Components.IStiDataRelation,
                            Components.IStiMasterComponent,
                            Components.IStiSort,
                            Components.IStiFilter,
                            Components.IStiExportImage,
                            Components.IStiExportImageExtended,
                            Report.IStiIgnoryStyle,
                            Report.IStiGlobalizationProvider,
                            IStiChart,
                            IStiJsonReportObject,
                            IStiGetFonts
                        ]);
                    return StiChart.implementsStiChart;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("CanShrink");
                    jObject.removeProperty("CanGrow");
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyEnum("FilterMode", Stimulsoft.Report.Components.StiFilterMode, this.filterMode, Stimulsoft.Report.Components.StiFilterMode.And);
                    jObject.addPropertyBool("FilterOn", this.filterOn, true);
                    jObject.addPropertyStringNullOrEmpty("Border", StiJsonReportObjectHelper.Serialize.jBorder(this.border));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    jObject.addPropertyStringNullOrEmpty("DataSourceName", this.dataSourceName);
                    jObject.addPropertyStringNullOrEmpty("BusinessObjectGuid", this.businessObjectGuid);
                    jObject.addPropertyNumber("CountData", this.countData);
                    jObject.addPropertyStringNullOrEmpty("DataRelationName", this.dataRelationName);
                    jObject.addPropertyBool("ProcessAtEnd", this.processAtEnd);
                    jObject.addPropertyJObject("ProcessChartEvent", this.processChartEvent.saveToJsonObject(mode));
                    jObject.addPropertyEnum("Rotation", StiImageRotation, this.rotation, StiImageRotation.None);
                    jObject.addPropertyEnum("EditorType", StiChartEditorType, this.editorType, StiChartEditorType.Advanced);
                    jObject.addPropertyStringNullOrEmpty("CustomStyleName", this.customStyleName);
                    jObject.addPropertyNumber("HorSpacing", this.horSpacing, 10);
                    jObject.addPropertyNumber("VertSpacing", this.vertSpacing, 10);
                    if (this.masterComponent != null)
                        jObject.addPropertyStringNullOrEmpty("MasterComponent", this.masterComponent.name);
                    jObject.addPropertyJObject("Series", this._series.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Area", this._area.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Table", this.table.saveToJsonObject(mode));
                    jObject.addPropertyJObject("SeriesLabels", this.seriesLabels.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Legend", this.legend.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Title", this._title.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Strips", this.strips.saveToJsonObject(mode));
                    jObject.addPropertyJObject("ConstantLines", this.constantLines.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Style", this.style.saveToJsonObject(mode));
                    if (mode == StiJsonSaveMode.Report) {
                        jObject.addPropertyJObject("Filters", this.filters.saveToJsonObject(mode));
                        jObject.addPropertyJObject("Sort", StiJsonReportObjectHelper.Serialize.stringArray(this.sort));
                        jObject.addPropertyJObject("SeriesLabelsConditions", this.seriesLabelsConditions.saveToJsonObject(mode));
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "FilterMode":
                                this._filterMode = Enum.parse(Stimulsoft.Report.Components.StiFilterMode, property.value.toString());
                                break;
                            case "Filters":
                                this._filters.loadFromJsonObject(property.value);
                                break;
                            case "FilterOn":
                                this._filterOn = property.value.stimulsoft().toBoolean();
                                break;
                            case "Border":
                            case "br":
                                this._border = StiJsonReportObjectHelper.Deserialize.border(property.value.toString());
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "DataSourceName":
                                this._dataSourceName = property.value.toString();
                                break;
                            case "BusinessObjectGuid":
                                this._businessObjectGuid = property.value.toString();
                                break;
                            case "CountData":
                                this._countData = property.value.stimulsoft().toNumber();
                                break;
                            case "DataRelationName":
                                this._dataRelationName = property.value.toString();
                                break;
                            case "ProcessAtEnd":
                                this._processAtEnd = property.value.stimulsoft().toBoolean();
                                break;
                            case "ProcessChartEvent":
                                {
                                    let _event = new StiProcessChartEvent();
                                    _event.loadFromJsonObject(property.value);
                                    this.processChartEvent = _event;
                                    break;
                                }
                            case "SeriesLabelsConditions":
                                this._seriesLabelsConditions.loadFromJsonObject(property.value);
                                break;
                            case "Rotation":
                                this._rotation = Enum.parse(StiImageRotation, property.value.toString());
                                break;
                            case "EditorType":
                                this._editorType = Enum.parse(StiChartEditorType, property.value.toString());
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "CustomStyleName":
                                this._customStyleName = property.value.toString();
                                break;
                            case "HorSpacing":
                                this._horSpacing = property.value.stimulsoft().toNumber();
                                break;
                            case "VertSpacing":
                                this._vertSpacing = property.value.stimulsoft().toNumber();
                                break;
                            case "MasterComponent":
                                this.jsonMasterComponentTemp = property.value.toString();
                                if (this.report.jsonLoaderHelper)
                                    this.report.jsonLoaderHelper.masterComponents.push(this);
                                break;
                            case "Style":
                                this.style = StiChartStyle.loadFromJsonObjectInternal(property.value);
                                break;
                            case "ConstantLines":
                                this.constantLines.loadFromJsonObject(property.value);
                                break;
                            case "Strips":
                                this.strips.loadFromJsonObject(property.value);
                                break;
                            case "Title":
                                this.title.loadFromJsonObject(property.value);
                                break;
                            case "Legend":
                                this.legend.loadFromJsonObject(property.value);
                                break;
                            case "SeriesLabels":
                                this.seriesLabels = StiSeriesLabels.loadFromJsonObjectInternal(property.value, this);
                                break;
                            case "Table":
                                this._table.loadFromJsonObject(property.value);
                                break;
                            case "Area":
                                this._area = StiArea.loadFromJsonObjectInternal(property.value);
                                this._area.chart = this;
                                break;
                            case "Series":
                                this._series.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                    this.core.applyStyle(this.style);
                }
                loadFromXml(xmlNode, isDocument) {
                    super.loadFromXml(xmlNode, isDocument);
                    let ref = xmlNode.getAttribute("Ref");
                    if (!StiString.isNullOrEmpty(ref) && this.report.jsonLoaderHelper)
                        this.report.jsonLoaderHelper.refNames[ref.stimulsoft().toNumber()] = xmlNode.nodeName;
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "FilterMode":
                                this._filterMode = Enum.parse(Stimulsoft.Report.Components.StiFilterMode, node.textContent);
                                break;
                            case "Filters":
                                this._filters.loadFromXml(node);
                                break;
                            case "FilterOn":
                                this._filterOn = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Border":
                            case "br":
                                this._border = StiBorder.loadFromXml(node.textContent);
                                break;
                            case "Brush":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "DataSourceName":
                                this._dataSourceName = node.textContent;
                                break;
                            case "BusinessObjectGuid":
                                this._businessObjectGuid = node.textContent;
                                break;
                            case "CountData":
                                this._countData = node.textContent.stimulsoft().toNumber();
                                break;
                            case "DataRelationName":
                                this._dataRelationName = node.textContent;
                                break;
                            case "ProcessAtEnd":
                                this._processAtEnd = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ProcessChartEvent": {
                                let _event = new StiProcessChartEvent();
                                _event.script = node.textContent;
                                this.processChartEvent = _event;
                                break;
                            }
                            case "Rotation":
                                this._rotation = Enum.parse(StiImageRotation, node.textContent);
                                break;
                            case "EditorType":
                                this._editorType = Enum.parse(StiChartEditorType, node.textContent);
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "CustomStyleName":
                                this._customStyleName = node.textContent;
                                break;
                            case "HorSpacing":
                                this._horSpacing = node.textContent.stimulsoft().toNumber();
                                break;
                            case "VertSpacing":
                                this._vertSpacing = node.textContent.stimulsoft().toNumber();
                                break;
                            case "MasterComponent":
                                this.jsonMasterComponentTemp = node.getAttribute("isRef");
                                if (this.report.jsonLoaderHelper)
                                    this.report.jsonLoaderHelper.masterComponents.push(this);
                                break;
                            case "Style": {
                                let tempStyle = Stimulsoft.Report.Chart.StiChartStyle.loadFromXml(node);
                                if (tempStyle != null)
                                    this.style = tempStyle;
                                break;
                            }
                            case "ConstantLines":
                                this.constantLines.loadFromXml(node);
                                break;
                            case "Strips":
                                this.strips.loadFromXml(node);
                                break;
                            case "Title": {
                                let _title = new Stimulsoft.Report.Chart.StiChartTitle();
                                _title.loadFromXml(node);
                                _title.chart = this;
                                this.title = _title;
                                break;
                            }
                            case "Legend": {
                                let _legend = new Stimulsoft.Report.Chart.StiLegend();
                                _legend.loadFromXml(node);
                                _legend.chart = this;
                                this.legend = _legend;
                                break;
                            }
                            case "Table": {
                                let _table = new Stimulsoft.Report.Chart.StiChartTable();
                                _table.chart = this;
                                _table.loadFromXml(node);
                                this._table = _table;
                                break;
                            }
                            case "SeriesLabels": {
                                let seriesLabels = Stimulsoft.Report.Chart.StiSeriesLabels.loadLabelsFromXml(node, this);
                                if (seriesLabels)
                                    this.seriesLabels = seriesLabels;
                                break;
                            }
                            case "Area":
                                this._area = StiArea.loadAreaFromXml(node, this);
                                break;
                            case "Series":
                                this._series.loadFromXml(node, this);
                                break;
                            case "SeriesLabelsConditions":
                                this._seriesLabelsConditions.loadFromXml(node);
                                break;
                        }
                    }
                    if (!isDocument)
                        this.core.applyStyle(this.style);
                }
                get componentId() {
                    return Report.StiComponentId.StiChart;
                }
                convert(oldUnit, newUnit, isReportSnapshot = false) {
                    super.convert(oldUnit, newUnit, isReportSnapshot);
                    this.legend.size = newUnit.convertSizeFromHInches(oldUnit.convertSizeToHInches(this.legend.size));
                }
                convertToHInches(value) {
                    if (this.report != null)
                        return this.report.unit.convertToHInches(value);
                    else
                        return value;
                }
                setString(propertyName, value) {
                    switch (propertyName) {
                        case "Legend.Title":
                            this.legend.title = value;
                            break;
                        case "SeriesLabels.TextBefore":
                            this.seriesLabels.textBefore = value;
                            break;
                        case "SeriesLabels.TextAfter":
                            this.seriesLabels.textAfter = value;
                            break;
                    }
                    let axisArea = this.area.as(IStiAxisArea);
                    if (axisArea != null) {
                        switch (propertyName) {
                            case "Area.XAxis.Labels.TextBefore":
                                axisArea.xAxis.labels.textBefore = value;
                                break;
                            case "Area.XAxis.Labels.TextAfter":
                                axisArea.xAxis.labels.textAfter = value;
                                break;
                            case "Area.XAxis.Title.Text":
                                axisArea.xAxis.title.text = value;
                                break;
                            case "Area.YAxis.Labels.TextBefore":
                                axisArea.yAxis.labels.textBefore = value;
                                break;
                            case "Area.YAxis.Labels.TextAfter":
                                axisArea.yAxis.labels.textAfter = value;
                                break;
                            case "Area.YAxis.Title.Text":
                                axisArea.yAxis.title.text = value;
                                break;
                            case "Area.XTopAxis.Labels.TextBefore":
                                axisArea.xTopAxis.labels.textBefore = value;
                                break;
                            case "Area.XTopAxis.Labels.TextAfter":
                                axisArea.xTopAxis.labels.textAfter = value;
                                break;
                            case "Area.XTopAxis.Title.Text":
                                axisArea.xTopAxis.title.text = value;
                                break;
                            case "Area.YRightAxis.Labels.TextBefore":
                                axisArea.yRightAxis.labels.textBefore = value;
                                break;
                            case "Area.YRightAxis.Labels.TextAfter":
                                axisArea.yRightAxis.labels.textAfter = value;
                                break;
                            case "Area.YRightAxis.Title.Text":
                                axisArea.yRightAxis.title.text = value;
                                break;
                        }
                    }
                    let index = 0;
                    for (let series of this.series.list) {
                        let name = StiString.format("Series{0}.Title", index++);
                        if (propertyName == name)
                            series.coreTitle = value;
                    }
                }
                getString(propertyName) {
                    switch (propertyName) {
                        case "Legend.Title":
                            return this.legend.title;
                        case "SeriesLabels.TextBefore":
                            return this.seriesLabels.textBefore;
                        case "SeriesLabels.TextAfter":
                            return this.seriesLabels.textAfter;
                    }
                    let axisArea = this.area.as(IStiAxisArea);
                    if (axisArea != null) {
                        switch (propertyName) {
                            case "Area.XAxis.Labels.TextBefore":
                                return axisArea.xAxis.labels.textBefore;
                            case "Area.XAxis.Labels.TextAfter":
                                return axisArea.xAxis.labels.textAfter;
                            case "Area.XAxis.Title.Text":
                                return axisArea.xAxis.title.text;
                            case "Area.YAxis.Labels.TextBefore":
                                return axisArea.yAxis.labels.textBefore;
                            case "Area.YAxis.Labels.TextAfter":
                                return axisArea.yAxis.labels.textAfter;
                            case "Area.YAxis.Title.Text":
                                return axisArea.yAxis.title.text;
                            case "Area.XTopAxis.Labels.TextBefore":
                                return axisArea.xTopAxis.labels.textBefore;
                            case "Area.XTopAxis.Labels.TextAfter":
                                return axisArea.xTopAxis.labels.textAfter;
                            case "Area.XTopAxis.Title.Text":
                                return axisArea.xTopAxis.title.text;
                            case "Area.YRightAxis.Labels.TextBefore":
                                return axisArea.yRightAxis.labels.textBefore;
                            case "Area.YRightAxis.Labels.TextAfter":
                                return axisArea.yRightAxis.labels.textAfter;
                            case "Area.YRightAxis.Title.Text":
                                return axisArea.yRightAxis.title.text;
                        }
                    }
                    let index = 0;
                    for (let series of this.series.list) {
                        let name = StiString.format("Series{0}.Title", index++);
                        if (propertyName == name)
                            return series.coreTitle;
                    }
                    throw StiString.format("Property with name {0}", propertyName);
                }
                getAllStrings() {
                    let list = [];
                    list.push("Legend.Title");
                    list.push("SeriesLabels.TextBefore");
                    list.push("SeriesLabels.TextAfter");
                    if (this.area.is(IStiAxisArea)) {
                        list.push("Area.XAxis.Labels.TextBefore");
                        list.push("Area.XAxis.Labels.TextAfter");
                        list.push("Area.XAxis.Title.Text");
                        list.push("Area.YAxis.Labels.TextBefore");
                        list.push("Area.YAxis.Labels.TextAfter");
                        list.push("Area.YAxis.Title.Text");
                        list.push("Area.XTopAxis.Labels.TextBefore");
                        list.push("Area.XTopAxis.Labels.TextAfter");
                        list.push("Area.XTopAxis.Title.Text");
                        list.push("Area.YRightAxis.Labels.TextBefore");
                        list.push("Area.YRightAxis.Labels.TextAfter");
                        list.push("Area.YRightAxis.Title.Text");
                    }
                    for (let index = 0; index < this.series.count; index++) {
                        list.push(StiString.format("Series{0}.Title", index));
                    }
                    return list;
                }
                clone() {
                    let chart = super.clone();
                    chart._chartInfo = this.chartInfo.clone();
                    chart.brush = this.brush.clone();
                    chart.border = this.border.clone();
                    if (this.sort != null)
                        chart.sort = this.sort.stimulsoft().clone();
                    else
                        chart.sort = null;
                    if (this.filters != null)
                        chart.filters = this.filters.clone();
                    else
                        chart.filters = null;
                    if (chart.title != null)
                        chart.title = this.title.clone();
                    if (chart.area != null)
                        chart.area = this.area.clone();
                    if (chart.seriesLabels != null)
                        chart.seriesLabels = this.seriesLabels.clone();
                    if (chart.legend != null)
                        chart.legend = this.legend.clone();
                    if (chart.table != null)
                        chart.table = this.table.clone();
                    chart.series = new StiSeriesCollection();
                    chart.series.seriesAdded = this.series_SeriesAdded;
                    chart.series.seriesRemoved = this.series_SeriesRemoved;
                    for (let series of this.series.list) {
                        let newSeries = series.clone();
                        let oldTitle = newSeries.title;
                        chart.series.add(newSeries);
                        newSeries.title = oldTitle;
                    }
                    chart.constantLines = new StiConstantLinesCollection();
                    for (let line of this.constantLines.list)
                        chart.constantLines.add(line.clone());
                    chart.strips = new StiStripsCollection();
                    for (let strip of this.strips.list)
                        chart.strips.add(strip.clone());
                    if (chart.core != null) {
                        chart.core = this.core.clone();
                        chart.core.chart = chart;
                    }
                    return chart;
                }
                saveState(stateName) {
                    super.saveState(stateName);
                    this.states.pushInt(stateName, this, "positionValue", this.positionValue);
                    this.states.pushBool(stateName, this, "isEofValue", this.isEofValue);
                    this.states.pushBool(stateName, this, "isBofValue", this.isBofValue);
                    if (this.dataSource != null)
                        this.dataSource.saveState(stateName);
                }
                restoreState(stateName) {
                    super.restoreState(stateName);
                    if (this.states.isExist(stateName, this)) {
                        this.isBofValue = this.states.popBool(stateName, this, "isBofValue");
                        this.isEofValue = this.states.popBool(stateName, this, "isEofValue");
                        this.positionValue = this.states.popInt(stateName, this, "positionValue");
                    }
                    if (this.dataSource != null)
                        this.dataSource.restoreState(stateName);
                }
                getImage(REFzoom, format = Report.StiExportFormat.None) {
                    if (this.report != null && this.report.preparedExportImages != null) {
                        let image = this.report.preparedExportImages.get(this);
                        if (image != null)
                            return image;
                    }
                    let data = new Report.Export.StiSvgData();
                    data.component = this;
                    data.x = 0;
                    data.y = 0;
                    data.width = this.report.unit.convertToHInches(this.width);
                    data.height = this.report.unit.convertToHInches(this.height);
                    return Stimulsoft.Report.Export.StiChartSvgHelper.getImage(data);
                }
                isExportAsImage(format) {
                    if (format == Report.StiExportFormat.Pdf)
                        return false;
                    if (format == Report.StiExportFormat.ImageSvg)
                        return false;
                    return true;
                }
                get filterMethodHandler() {
                    return this._filterMethodHandler;
                }
                set filterMethodHandler(value) {
                    this._filterMethodHandler = value;
                }
                get filterMode() {
                    return this._filterMode;
                }
                set filterMode(value) {
                    this._filterMode = value;
                }
                get filters() {
                    return this._filters;
                }
                set filters(value) {
                    this._filters = value;
                }
                get filter() {
                    if (this.filters.count == 0)
                        this.filters.add(new StiFilter());
                    this.filters.getByIndex(0).item = Stimulsoft.Report.Components.StiFilterItem.Expression;
                    return this.filters.getByIndex(0).expression;
                }
                set filter(value) {
                    if (this.filters.count == 0)
                        this.filters.add(new StiFilter());
                    this.filters.getByIndex(0).item = Stimulsoft.Report.Components.StiFilterItem.Expression;
                    this.filters.getByIndex(0).expression = value;
                }
                get filterOn() {
                    return this._filterOn;
                }
                set filterOn(value) {
                    this._filterOn = value;
                }
                get border() {
                    return this._border;
                }
                set border(value) {
                    this._border = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get sort() {
                    return this._sort;
                }
                set sort(value) {
                    this._sort = value;
                }
                get dataSource() {
                    if (this.isCacheValues) {
                        return this.cachedDataSource;
                    }
                    if (this.page == null ||
                        this.report == null ||
                        this.report.dataSources == null ||
                        this.dataSourceName == null ||
                        this.dataSourceName.length == 0)
                        return null;
                    return this.report.dataSources.getByName(this.dataSourceName);
                }
                get dataSourceName() {
                    return this._dataSourceName;
                }
                set dataSourceName(value) {
                    if (this._dataSourceName != value) {
                        this._dataSourceName = value;
                    }
                }
                get isDataSourceEmpty() {
                    if (this.isCacheValues) {
                        return this.cachedIsDataSourceEmpty;
                    }
                    return StiString.isNullOrEmpty(this.dataSourceName) || this.dataSource == null;
                }
                get isBusinessObjectEmpty() {
                    if (this.isCacheValues) {
                        return this.cachedIsBusinessObjectEmpty;
                    }
                    return StiString.isNullOrEmpty(this.businessObjectGuid) || this.businessObject == null;
                }
                get businessObject() {
                    if (this.isCacheValues) {
                        return this.cachedBusinessObject;
                    }
                    if (this.page == null ||
                        this.report == null ||
                        this.businessObjectGuid == null ||
                        this.businessObjectGuid.length == 0)
                        return null;
                    return Stimulsoft.Report.Dictionary.StiBusinessObjectHelper.getBusinessObjectFromGuid(this.report, this.businessObjectGuid);
                }
                get businessObjectGuid() {
                    return this._businessObjectGuid;
                }
                set businessObjectGuid(value) {
                    if (this._businessObjectGuid != value) {
                        this._businessObjectGuid = value;
                        if (!StiString.isNullOrEmpty(value))
                            this.dataSourceName = null;
                    }
                }
                get masterComponent() {
                    return this._masterComponent;
                }
                set masterComponent(value) {
                    this._masterComponent = value;
                }
                get countData() {
                    return this._countData;
                }
                set countData(value) {
                    this._countData = value;
                }
                first() {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.first();
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.first();
                    else {
                        this.isEofValue = false;
                        this.isBofValue = true;
                        this.positionValue = 0;
                    }
                }
                prior() {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.prior();
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.prior();
                    else {
                        this.isBofValue = false;
                        this.isEofValue = false;
                        if (this.positionValue <= 0)
                            this.isBofValue = true;
                        else
                            this.positionValue--;
                    }
                }
                next() {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.next();
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.next();
                    else {
                        this.isBofValue = false;
                        this.isEofValue = false;
                        if (this.positionValue >= this.countData - 1)
                            this.isEofValue = true;
                        else
                            this.positionValue++;
                    }
                }
                last() {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.last();
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.last();
                    else {
                        this.isEofValue = true;
                        this.isBofValue = false;
                        this.positionValue = this.countData - 1;
                    }
                }
                get isEof() {
                    if (!this.isBusinessObjectEmpty)
                        return this.businessObject.isEof;
                    else if (!this.isDataSourceEmpty)
                        return this.dataSource.isEof;
                    else
                        return this.isEofValue;
                }
                set isEof(value) {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.isEof = value;
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.isEof = value;
                    else
                        this.isEofValue = value;
                }
                get isBof() {
                    if (!this.isBusinessObjectEmpty)
                        return this.businessObject.isBof;
                    else if (!this.isDataSourceEmpty)
                        return this.dataSource.isBof;
                    else
                        return this.isBofValue;
                }
                set isBof(value) {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.isBof = value;
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.isBof = value;
                    else
                        this.isBofValue = value;
                }
                get isEmpty() {
                    if (!this.isBusinessObjectEmpty)
                        return this.businessObject.isEmpty;
                    else if (!this.isDataSourceEmpty)
                        return this.dataSource.isEmpty;
                    else
                        return this.countData == 0;
                }
                get position() {
                    if (!this.isBusinessObjectEmpty)
                        return this.businessObject.position;
                    else if (!this.isDataSourceEmpty)
                        return this.dataSource.position;
                    return this.positionValue;
                }
                set position(value) {
                    if (!this.isBusinessObjectEmpty)
                        this.businessObject.position = value;
                    else if (!this.isDataSourceEmpty)
                        this.dataSource.position = value;
                    else
                        this.positionValue = value;
                }
                get count() {
                    if (this.isCacheValues) {
                        return this.cachedCount;
                    }
                    if (!this.isBusinessObjectEmpty)
                        return this.businessObject.count;
                    else if (!this.isDataSourceEmpty)
                        return this.dataSource.count;
                    else
                        return this.countData;
                }
                cacheValues(cache) {
                    if (cache) {
                        this.cachedCount = this.count;
                        this.cachedIsBusinessObjectEmpty = this.isBusinessObjectEmpty;
                        this.cachedIsDataSourceEmpty = this.isDataSourceEmpty;
                        this.cachedDataSource = this.dataSource;
                        this.cachedBusinessObject = this.businessObject;
                    }
                    else {
                        this.cachedDataSource = null;
                        this.cachedBusinessObject = null;
                    }
                    this.isCacheValues = cache;
                }
                get dataRelation() {
                    if (this.page == null ||
                        this.report == null ||
                        this.report.dictionary == null ||
                        this.report.dictionary.relations == null ||
                        this.dataRelationName == null ||
                        this.dataRelationName.length == 0)
                        return null;
                    return this.report.dictionary.relations.getByName(this.dataRelationName);
                }
                get dataRelationName() {
                    return this._dataRelationName;
                }
                set dataRelationName(value) {
                    this._dataRelationName = value;
                }
                get processAtEnd() {
                    return this._processAtEnd;
                }
                set processAtEnd(value) {
                    this._processAtEnd = value;
                }
                getFonts() {
                    let result = super.getFonts();
                    result.push(this.title.font);
                    result.push(this.legend.font);
                    result.push(this.table.dataCells.font);
                    result.push(this.table.header.font);
                    for (let line of this.constantLines.list) {
                        result.push((line).font);
                    }
                    for (let line of this.strips.list) {
                        result.push((line).font);
                    }
                    let area = this.area.as(StiAxisArea);
                    if (area != null) {
                        result.push(area.xAxis.labels.font);
                        result.push(area.xAxis.title.font);
                        result.push(area.yAxis.labels.font);
                        result.push(area.yAxis.title.font);
                        result.push(area.xTopAxis.labels.font);
                        result.push(area.xTopAxis.title.font);
                        result.push(area.yRightAxis.labels.font);
                        result.push(area.yRightAxis.title.font);
                    }
                    let area2 = this.area.as(StiRadarArea);
                    if (area2 != null) {
                        result.push(area2.xAxis.labels.font);
                        result.push(area2.yAxis.labels.font);
                    }
                    for (let ser of this.series.list) {
                        let serie = ser.as(StiSeries);
                        if (serie != null) {
                            for (let line of serie.trendLines.list) {
                                result.push(line.font);
                            }
                            if (serie.seriesLabels != null)
                                result.push(serie.seriesLabels.font);
                        }
                        if (ser.is(Stimulsoft.Report.Chart.StiPictorialSeries)) {
                        }
                    }
                    return StiArray.distinct(result);
                }
                get priority() {
                    return StiComponentPriority.Component;
                }
                get localizedCategory() {
                    return StiLocalization.get("Report", "Components");
                }
                get componentType() {
                    return StiComponentType.Simple;
                }
                get localizedName() {
                    return StiLocalization.get("Components", "StiChart");
                }
                invokeEvents() {
                    try {
                        super.invokeEvents();
                        this.invokeProcessChart(this, EventArgs.empty);
                    }
                    catch (e) {
                        Report.StiLogService.write(this.stimulsoft().getType(), "DoEvents...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), e);
                    }
                }
                onProcessChart(e) {
                }
                invokeProcessChart(sender, e) {
                    try {
                        this.onProcessChart(e);
                    }
                    catch (ex) {
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeProcessChart...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                series_SeriesAdded(sender) {
                    let series = sender;
                    let chart = series.chart;
                    if (chart.area == null || !chart.area.core.isAcceptableSeries(series.stimulsoft().getType())) {
                        chart.area = StiActivator.createObject(series.getDefaultAreaType());
                        if (chart.seriesLabels == null || (!chart.area.core.isAcceptableSeriesLabels(chart.seriesLabels.stimulsoft().getType())))
                            chart.seriesLabels = StiActivator.createObject(chart.area.getDefaultSeriesLabelsType());
                    }
                    if (chart.allowApplyStyle)
                        chart.core.applyStyle(chart.style);
                }
                series_SeriesRemoved(sender) {
                    let seriesTemp = sender;
                    let chart = seriesTemp.chart;
                    if (chart.series.count == 0) {
                        if (!(chart.area.is(IStiClusteredColumnArea))) {
                            chart.area = new StiClusteredColumnArea();
                            chart.area.core.applyStyle(this.style);
                        }
                        return;
                    }
                    if (chart.area != null) {
                        let areaType = chart.area.stimulsoft().getType();
                        for (let series of chart.series.list) {
                            let defaultAreaType = series.getDefaultAreaType();
                            if (defaultAreaType == areaType)
                                return;
                        }
                    }
                    chart.area = StiActivator.createObject(chart.series.getByIndex(0).getDefaultAreaType());
                    if (this.allowApplyStyle)
                        this.core.applyStyle(chart.style);
                }
                get seriesLabelsConditions() {
                    return this._seriesLabelsConditions;
                }
                set seriesLabelsConditions(value) {
                    this._seriesLabelsConditions = value;
                }
                get chartType() {
                    return this.area;
                }
                set chartType(value) {
                    this.area = value;
                }
                get isDashboard() {
                    return this._isDashboard;
                }
                set isDashboard(value) {
                    this._isDashboard = value;
                }
                createNew() {
                    return new StiChart();
                }
                applyStyle() {
                    if (this.allowApplyStyle)
                        this.core.applyStyle(this.style);
                }
                simplifyValues() {
                    let seriesIndex = 0;
                    while (seriesIndex < this.series.count) {
                        let series = this.series.getByIndex(seriesIndex);
                        if (series.values.length > 3000) {
                            let shorterListPoints = StiChartHelper.getShorterListPoints(series);
                            series.values = [];
                            series.arguments = [];
                            for (let index = 1; index < shorterListPoints.length; index++) {
                                series.values[index] = shorterListPoints[index].x;
                                series.arguments[index] = shorterListPoints[index].y;
                            }
                        }
                        seriesIndex++;
                    }
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get rotation() {
                    return this._rotation;
                }
                set rotation(value) {
                    this._rotation = value;
                }
                get editorType() {
                    return this._editorType;
                }
                set editorType(value) {
                    this._editorType = value;
                }
                get series() {
                    return this._series;
                }
                set series(value) {
                    this._series = value;
                    this._series.chart = this;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    if (this._area != value) {
                        if (value.is(StiRadarArea))
                            this._area = value;
                        this._area = value;
                        if (value != null) {
                            this._area.chart = this;
                        }
                        else {
                            this._area = null;
                        }
                    }
                }
                get table() {
                    return this._table;
                }
                set table(value) {
                    if (this._table != value) {
                        this._table = value;
                        this._table.chart = this;
                    }
                }
                get style() {
                    return this._style;
                }
                set style(value) {
                    if (this._style != value) {
                        this._style = value;
                        if (value != null)
                            value.core.chart = this;
                    }
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value)
                            this.core.applyStyle(this.style);
                    }
                }
                get customStyleName() {
                    return this._customStyleName;
                }
                set customStyleName(value) {
                    this._customStyleName = value;
                }
                get horSpacing() {
                    return this._horSpacing;
                }
                set horSpacing(value) {
                    if (value >= 0)
                        this._horSpacing = value;
                }
                get vertSpacing() {
                    return this._vertSpacing;
                }
                set vertSpacing(value) {
                    if (value >= 0)
                        this._vertSpacing = value;
                }
                get seriesLabels() {
                    return this._seriesLabels;
                }
                set seriesLabels(value) {
                    this._seriesLabels = value;
                    if (value != null)
                        this._seriesLabels.chart = this;
                }
                get labels() {
                    return this._seriesLabels;
                }
                set labels(value) {
                    this._seriesLabels = value;
                }
                get legend() {
                    return this._legend;
                }
                set legend(value) {
                    if (value == null)
                        throw new Error(("new NullReferenceException()"));
                    this._legend = value;
                    this._legend.chart = this;
                }
                get title() {
                    return this._title;
                }
                set title(value) {
                    if (this._title != value) {
                        this._title = value;
                        this._title.chart = this;
                    }
                }
                get strips() {
                    return this._strips;
                }
                set strips(value) {
                    this._strips = value;
                    this._strips.chart = this;
                }
                get constantLines() {
                    return this._constantLines;
                }
                set constantLines(value) {
                    this._constantLines = value;
                    this._constantLines.chart = this;
                }
                get isAnimation() {
                    return this._isAnimation;
                }
                set isAnimation(value) {
                    if (this._isAnimation != value) {
                        this._isAnimation = value;
                    }
                }
                get isAnimationChangingValues() {
                    return this._isAnimationChangingValues;
                }
                set isAnimationChangingValues(value) {
                    if (this._isAnimationChangingValues != value) {
                        this._isAnimationChangingValues = value;
                    }
                }
                get chartInfo() {
                    return this._chartInfo;
                }
            }
            Components.StiChart = StiChart;
        })(Components = Report.Components || (Report.Components = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiChartOptions {
                static get oldChartPercentMode() {
                    return StiChartOptions._oldChartPercentMode;
                }
                static set oldChartPercentMode(value) {
                    StiChartOptions._oldChartPercentMode = value;
                }
            }
            StiChartOptions._oldChartPercentMode = false;
            Chart.StiChartOptions = StiChartOptions;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var SizeD = Stimulsoft.System.Drawing.Size;
            class StiInteractionOptions {
                constructor() {
                    this._updateContext = false;
                    this._recallEvent = false;
                    this._recallTime = TimeSpan.zero;
                    this._isRecalled = false;
                    this._mousePoint = PointD.empty;
                    this._dragEnabled = false;
                    this._dragDelta = SizeD.empty;
                    this._interactionToolTip = null;
                    this._interactionHyperlink = null;
                    this._seriesInteractionData = null;
                }
                get updateContext() {
                    return this._updateContext;
                }
                set updateContext(value) {
                    this._updateContext = value;
                }
                get recallEvent() {
                    return this._recallEvent;
                }
                set recallEvent(value) {
                    this._recallEvent = value;
                }
                get recallTime() {
                    return this._recallTime;
                }
                set recallTime(value) {
                    this._recallTime = value;
                }
                get isRecalled() {
                    return this._isRecalled;
                }
                set isRecalled(value) {
                    this._isRecalled = value;
                }
                get mousePoint() {
                    return this._mousePoint;
                }
                set mousePoint(value) {
                    this._mousePoint = value;
                }
                get dragEnabled() {
                    return this._dragEnabled;
                }
                set dragEnabled(value) {
                    this._dragEnabled = value;
                }
                get dragDelta() {
                    return this._dragDelta;
                }
                set dragDelta(value) {
                    this._dragDelta = value;
                }
                get interactionToolTip() {
                    return this._interactionToolTip;
                }
                set interactionToolTip(value) {
                    this._interactionToolTip = value;
                }
                get interactionHyperlink() {
                    return this._interactionHyperlink;
                }
                set interactionHyperlink(value) {
                    this._interactionHyperlink = value;
                }
                get seriesInteractionData() {
                    return this._seriesInteractionData;
                }
                set seriesInteractionData(value) {
                    this._seriesInteractionData = value;
                }
            }
            Chart.StiInteractionOptions = StiInteractionOptions;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var PointD = Stimulsoft.System.Drawing.Point;
            let PointClassify;
            (function (PointClassify) {
                PointClassify[PointClassify["Left"] = 0] = "Left";
                PointClassify[PointClassify["Right"] = 1] = "Right";
                PointClassify[PointClassify["Beyond"] = 2] = "Beyond";
                PointClassify[PointClassify["Behind"] = 3] = "Behind";
                PointClassify[PointClassify["Between"] = 4] = "Between";
                PointClassify[PointClassify["Origin"] = 5] = "Origin";
                PointClassify[PointClassify["Destination"] = 6] = "Destination";
            })(PointClassify || (PointClassify = {}));
            class StiPointHelper {
                static getPointClassify(basePoint, point1, point2) {
                    let a = new PointD(point2.x - point1.x, point2.y - point1.y);
                    let b = new PointD(basePoint.x - point1.x, basePoint.y - point1.y);
                    let sa = a.x * b.y - b.x * a.y;
                    if (sa > 0.0)
                        return PointClassify.Left;
                    if (sa < 0.0)
                        return PointClassify.Right;
                    if ((a.x * b.x < 0.0) || (a.y * b.y < 0.0))
                        return PointClassify.Behind;
                    if (Math.sqrt(a.x * a.x + a.y * a.y) < Math.sqrt(b.x * b.x + b.y * b.y))
                        return PointClassify.Beyond;
                    if (point1.equals(basePoint))
                        return PointClassify.Origin;
                    if (point2.equals(basePoint))
                        return PointClassify.Destination;
                    return PointClassify.Between;
                }
                static isPointInTriangle(p, a, b, c) {
                    return ((StiPointHelper.getPointClassify(p, a, b) != PointClassify.Left) &&
                        (StiPointHelper.getPointClassify(p, b, c) != PointClassify.Left) &&
                        (StiPointHelper.getPointClassify(p, c, a) != PointClassify.Left));
                }
                static isPointInPolygon(p, points) {
                    for (let index = 0; index < points.length; index++) {
                        if (StiPointHelper.getPointClassify(p, points[index], (index + 1 < points.length ? points[index + 1] : points[0])) == PointClassify.Left)
                            return false;
                    }
                    return true;
                }
                static getLineOffsetRectangle(point1, point2, offset) {
                    let angle = Math.atan2(point2.y - point1.y, point2.x - point1.x);
                    let halfDist = offset / 2;
                    let points = StiArray.create(PointD, 4, true);
                    points[0] = new PointD((point1.x + halfDist * Math.cos(angle + 0.5 * Math.PI)), (point1.y + halfDist * Math.sin(angle + 0.5 * Math.PI)));
                    points[1] = new PointD((point2.x + halfDist * Math.cos(angle + 0.5 * Math.PI)), (point2.y + halfDist * Math.sin(angle + 0.5 * Math.PI)));
                    points[2] = new PointD((point2.x + halfDist * Math.cos(angle + 1.5 * Math.PI)), (point2.y + halfDist * Math.sin(angle + 1.5 * Math.PI)));
                    points[3] = new PointD((point1.x + halfDist * Math.cos(angle + 1.5 * Math.PI)), (point1.y + halfDist * Math.sin(angle + 1.5 * Math.PI)));
                    return points;
                }
                static isLineContainsPoint(startPoint, endPoint, offset, point) {
                    let points = this.getLineOffsetRectangle(startPoint, endPoint, offset);
                    return StiPointHelper.isPointInPolygon(point, points);
                }
                static optimizePoints(points) {
                    if (points.length < 800)
                        return points;
                    let step = 1;
                    let index = 0;
                    let minx = 0;
                    let miny = 0;
                    let maxy = 0;
                    let points2 = [];
                    while (index < points.length) {
                        if (points[index] == null) {
                            while ((index < points.length) && (points[index] == null))
                                index++;
                            points2.push(null);
                            continue;
                        }
                        let pf = points[index];
                        index++;
                        if ((index < points.length) && points[index] != null && (points[index] != null) && ((points[index].x - pf.x) < step)) {
                            minx = pf.x;
                            miny = pf.y;
                            maxy = pf.y;
                            let firstY = pf.y;
                            let lastY = pf.y;
                            while ((index < points.length) && points[index] != null && (points[index] != null) && (points[index].x - minx) < step) {
                                miny = Math.min(miny, points[index].y);
                                maxy = Math.max(maxy, points[index].y);
                                lastY = points[index].y;
                                index++;
                            }
                            if (lastY > firstY) {
                                points2.push(new PointD(minx, miny));
                                points2.push(new PointD(minx + step / 2, maxy));
                            }
                            else {
                                points2.push(new PointD(minx, maxy));
                                points2.push(new PointD(minx + step / 2, miny));
                            }
                        }
                        else {
                            points2.push(pf);
                        }
                    }
                    return points2.stimulsoft().toArray();
                }
            }
            Chart.StiPointHelper = StiPointHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiSimplifyHelper {
                static getSquareDistance(p1, p2) {
                    let dx = p1.x - p2.x, dy = p1.y - p2.y;
                    return (dx * dx) + (dy * dy);
                }
                static getSquareSegmentDistance(p, p1, p2) {
                    let x = p1.x;
                    let y = p1.y;
                    let dx = p2.x - x;
                    let dy = p2.y - y;
                    if (dx !== 0 || dy !== 0) {
                        let t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
                        if (t > 1) {
                            x = p2.x;
                            y = p2.y;
                        }
                        else if (t > 0) {
                            x += dx * t;
                            y += dy * t;
                        }
                    }
                    dx = p.x - x;
                    dy = p.y - y;
                    return (dx * dx) + (dy * dy);
                }
                static simplifyRadialDistance(points, sqTolerance) {
                    let prevPoint = points[0];
                    let newPoints = [];
                    newPoints.push(prevPoint);
                    let point = new PointD();
                    for (let i = 1; i < points.length; i++) {
                        point = points[i];
                        if (StiSimplifyHelper.getSquareDistance(point, prevPoint) > sqTolerance) {
                            newPoints.push(point);
                            prevPoint = point;
                        }
                    }
                    if (prevPoint != point)
                        newPoints.push(point);
                    return newPoints;
                }
                static simplifyDouglasPeucker(points, sqTolerance) {
                    let len = points.length;
                    let markers = StiArray.create(Number, len);
                    let first = 0;
                    let last = len - 1;
                    let index = 0;
                    let stack = [];
                    let newPoints = [];
                    markers[first] = markers[last] = 1;
                    while (last != null) {
                        let maxSqDist = 0.0;
                        for (let i = first + 1; i < last; i++) {
                            let sqDist = StiSimplifyHelper.getSquareSegmentDistance(points[i], points[first], points[last]);
                            if (sqDist > maxSqDist) {
                                index = i;
                                maxSqDist = sqDist;
                            }
                        }
                        if (maxSqDist > sqTolerance) {
                            markers[index] = 1;
                            let range = [first, index, index, last];
                            stack.stimulsoft().addRange(range);
                        }
                        if (stack.length > 0) {
                            last = stack[stack.length - 1];
                            stack.stimulsoft().removeAt(stack.length - 1);
                        }
                        else
                            last = null;
                        if (stack.length > 0) {
                            first = stack[stack.length - 1];
                            stack.stimulsoft().removeAt(stack.length - 1);
                        }
                        else
                            first = null;
                    }
                    for (let i = 0; i < len; i++) {
                        if (markers[i] != 0)
                            newPoints.push(points[i]);
                    }
                    return newPoints;
                }
                static simplify(points, tolerance, highestQuality) {
                    if (points == null || points.length == 0)
                        return [];
                    let sqTolerance = tolerance * tolerance;
                    if (highestQuality)
                        return StiSimplifyHelper.simplifyDouglasPeucker(points, sqTolerance);
                    let points2 = StiSimplifyHelper.simplifyRadialDistance(points, sqTolerance);
                    return StiSimplifyHelper.simplifyDouglasPeucker(points2, sqTolerance);
                }
            }
            Chart.StiSimplifyHelper = StiSimplifyHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAreaCoreXF {
                constructor(area) {
                    this._area = area;
                }
                implements() {
                    if (!StiAreaCoreXF.implementsStiAreaCoreXF)
                        StiAreaCoreXF.implementsStiAreaCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiAreaCoreXF
                        ];
                    return StiAreaCoreXF.implementsStiAreaCoreXF;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.area.allowApplyStyle) {
                        this.area.brush = style.core.chartAreaBrush;
                        this.area.borderColor = style.core.chartAreaBorderColor;
                        this.area.showShadow = style.core.chartAreaShowShadow;
                    }
                }
                render(context, rect) {
                    return null;
                }
                prepareInfo(rect) {
                }
                checkInLabelsTypes(typeForCheck) {
                    let types = this._area.getSeriesLabelsTypes();
                    for (let type of types) {
                        if (type.stimulsoft().getType().stimulsoft().getTypeName() == typeForCheck.stimulsoft().getType().stimulsoft().getTypeName())
                            return true;
                    }
                    return false;
                }
                getSeries() {
                    let cachedSeriesTypes = new Hashtable();
                    let types = this.area.getSeriesTypes();
                    for (let type of types) {
                        cachedSeriesTypes.set(type, type);
                    }
                    let newSeries = [];
                    for (let series of this.area.chart.series.list) {
                        if (cachedSeriesTypes.get(series.stimulsoft().getType()) == null)
                            continue;
                        newSeries.push(series);
                    }
                    return newSeries;
                }
                isAcceptableSeries(seriesType) {
                    let types = this.area.getSeriesTypes();
                    for (let type of types) {
                        if (type == seriesType)
                            return true;
                    }
                    return false;
                }
                isAcceptableSeriesLabels(seriesLabelsType) {
                    let types = this.area.getSeriesLabelsTypes();
                    for (let type of types) {
                        if (type == seriesLabelsType)
                            return true;
                    }
                    return false;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
                get localizedName() {
                    return null;
                }
                get seriesOrientation() {
                    return Chart.StiChartSeriesOrientation.Vertical;
                }
                get position() {
                    return null;
                }
            }
            Chart.StiAreaCoreXF = StiAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiShowEmptyCellsAs = Stimulsoft.Report.Chart.StiShowEmptyCellsAs;
            class StiBaseLineSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showNulls = true;
                    this._showZeros = true;
                    this._marker = new Chart.StiMarker();
                    this._lineMarker = new Chart.StiLineMarker();
                    this._lineColor = Color.black;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lighting = true;
                    this._lineWidth = 2;
                    this._labelsOffset = 0;
                    this._lineColorNegative = Color.firebrick;
                    this._allowApplyColorNegative = false;
                    this.showNullsAs = StiShowEmptyCellsAs.Gap;
                    this.showZerosAs = StiShowEmptyCellsAs.Gap;
                    this.seriesLabels = new Chart.StiOutsideEndAxisLabels();
                }
                implements() {
                    if (!StiBaseLineSeries.implementsStiBaseLineSeries)
                        StiBaseLineSeries.implementsStiBaseLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiBaseLineSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyColorNegative,
                            Chart.IStiShowNullsSeries,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiBaseLineSeries.implementsStiBaseLineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("ShowZeros", this.showZeros, true);
                    jObject.addPropertyBool("ShowNulls", this.showNulls, true);
                    jObject.addPropertyJObject("Marker", this.marker.saveToJsonObject(mode));
                    jObject.addPropertyJObject("LineMarker", this.lineMarker.saveToJsonObject(mode));
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("Lighting", this.lighting, true);
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 2);
                    jObject.addPropertyNumber("LabelsOffset", this._labelsOffset);
                    jObject.addPropertyStringNullOrEmpty("LineColorNegative", StiJsonReportObjectHelper.Serialize.jColor(this.lineColorNegative, Color.firebrick));
                    jObject.addPropertyBool("AllowApplyColorNegative", this.allowApplyColorNegative);
                    jObject.addPropertyEnum("ShowNullsAs", StiShowEmptyCellsAs, this.showNullsAs, StiShowEmptyCellsAs.Gap);
                    jObject.addPropertyEnum("ShowZerosAs", StiShowEmptyCellsAs, this.showZerosAs, StiShowEmptyCellsAs.Gap);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowNulls":
                                this.showNulls = property.value.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromJsonObject(property.value);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromJsonObject(property.value);
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Lighting":
                                this.lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LabelsOffset":
                                this._labelsOffset = property.value.stimulsoft().toNumber();
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "AllowApplyColorNegative":
                                this.allowApplyColorNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowNullsAs":
                                this.showNullsAs = Enum.parse(StiShowEmptyCellsAs, property.value.toString());
                                break;
                            case "ShowZerosAs":
                                this.showZerosAs = Enum.parse(StiShowEmptyCellsAs, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowNulls":
                                this.showNulls = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromXml(node);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromXml(node);
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Lighting":
                                this.lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LabelsOffset":
                                this._labelsOffset = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "AllowApplyColorNegative":
                                this.allowApplyColorNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowNullsAs":
                                this.showNullsAs = Enum.parse(StiShowEmptyCellsAs, node.textContent);
                                break;
                            case "ShowZerosAs":
                                this.showZerosAs = Enum.parse(StiShowEmptyCellsAs, node.textContent);
                                break;
                        }
                    }
                }
                clone() {
                    let series = super.clone();
                    series.marker = this.marker.clone();
                    series.lineStyle = this.lineStyle;
                    return series;
                }
                get showNulls() {
                    return this._showNulls;
                }
                set showNulls(value) {
                    this._showNulls = value;
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get showMarker() {
                    return this.marker.visible;
                }
                set showMarker(value) {
                    this.marker.visible = value;
                }
                get markerColor() {
                    return StiBrush.toColor(this.marker.brush);
                }
                set markerColor(value) {
                    this.marker.brush = new StiSolidBrush(value);
                    this.marker.borderColor = StiColorUtils.dark(value, 50);
                }
                get markerSize() {
                    return this.marker.size;
                }
                set markerSize(value) {
                    this.marker.size = value;
                }
                get markerType() {
                    return this.marker.type;
                }
                set markerType(value) {
                    this.marker.type = value;
                }
                get marker() {
                    return this._marker;
                }
                set marker(value) {
                    this._marker = value;
                }
                get lineMarker() {
                    return this._lineMarker;
                }
                set lineMarker(value) {
                    this._lineMarker = value;
                }
                get lineColor() {
                    return this.getLineColor();
                }
                set lineColor(value) {
                    this.setLineColor(value);
                }
                getLineColor() {
                    return this._lineColor;
                }
                setLineColor(value) {
                    this._lineColor = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                get labelsOffset() {
                    return this._labelsOffset;
                }
                set labelsOffset(value) {
                    this._labelsOffset = value;
                }
                get lineColorNegative() {
                    return this._lineColorNegative;
                }
                set lineColorNegative(value) {
                    this._lineColorNegative = value;
                }
                get allowApplyColorNegative() {
                    return this._allowApplyColorNegative;
                }
                set allowApplyColorNegative(value) {
                    this._allowApplyColorNegative = value;
                }
            }
            Chart.StiBaseLineSeries = StiBaseLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiScatterSeries extends Chart.StiBaseLineSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiScatterSeriesCoreXF(this);
                }
                implements() {
                    if (!StiScatterSeries.implementsStiScatterSeries)
                        StiScatterSeries.implementsStiScatterSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiScatterSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiScatterSeries.implementsStiScatterSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("LineColorNegative");
                    jObject.removeProperty("TopN");
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiScatterSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiScatterArea;
                }
                getLineColor() {
                    if (this.stimulsoft().getType() == StiScatterSeries) {
                        if (this.marker.brush.is(StiSolidBrush))
                            return this.marker.brush.color;
                        if (this.marker.brush.is(StiGradientBrush))
                            return this.marker.brush.startColor;
                    }
                    return super.getLineColor();
                }
                setLineColor(value) {
                    super.setLineColor(value);
                }
                createNew() {
                    return new StiScatterSeries();
                }
            }
            Chart.StiScatterSeries = StiScatterSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiScatterLineSeries extends Chart.StiScatterSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiScatterLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiScatterLineSeries.implementsStiScatterLineSeries)
                        StiScatterLineSeries.implementsStiScatterLineSeries = super.implements().concat([
                            Chart.IStiScatterLineSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiScatterSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiScatterLineSeries.implementsStiScatterLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiScatterLineSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiScatterArea;
                }
                createNew() {
                    return new StiScatterLineSeries();
                }
            }
            Chart.StiScatterLineSeries = StiScatterLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiAxisAreaCoreXF extends Chart.StiAreaCoreXF {
                constructor(area) {
                    super(area);
                    this.valuesCount = 0;
                    this._scrollRangeX = 0;
                    this._scrollRangeY = 0;
                    this._scrollViewX = 0;
                    this._scrollViewY = 0;
                    this._blockScrollValueX = false;
                    this._blockScrollValueY = false;
                    this._scrollValueX = 0;
                    this._scrollValueY = 0;
                    this._scrollDpiX = 1;
                    this._scrollDpiY = 1;
                    this._scrollDragStartValue = 0;
                }
                implements() {
                    if (!StiAxisAreaCoreXF.implementsStiAxisAreaCoreXF)
                        StiAxisAreaCoreXF.implementsStiAxisAreaCoreXF = [
                            Chart.IStiAxisAreaCoreXF
                        ];
                    return StiAxisAreaCoreXF.implementsStiAxisAreaCoreXF;
                }
                applyStyle(style) {
                    super.applyStyle(style);
                    let axisArea = this.area;
                    if (axisArea.allowApplyStyle) {
                        if (axisArea.interlacingHor != null)
                            axisArea.interlacingHor.core.applyStyle(style);
                        if (axisArea.interlacingVert != null)
                            axisArea.interlacingVert.core.applyStyle(style);
                        if (axisArea.gridLinesHor != null)
                            axisArea.gridLinesHor.core.applyStyle(style);
                        if (axisArea.gridLinesVert != null)
                            axisArea.gridLinesVert.core.applyStyle(style);
                        if (axisArea.xAxis != null)
                            axisArea.xAxis.core.applyStyle(style);
                        if (axisArea.xTopAxis != null)
                            axisArea.xTopAxis.core.applyStyle(style);
                        if (axisArea.yAxis != null)
                            axisArea.yAxis.core.applyStyle(style);
                        if (axisArea.yRightAxis != null)
                            axisArea.yRightAxis.core.applyStyle(style);
                    }
                }
                render(context, rect) {
                    let axisArea = this.area;
                    axisArea.yAxis.info.minimum = 0;
                    axisArea.yAxis.info.maximum = 0;
                    axisArea.yRightAxis.info.minimum = 0;
                    axisArea.yRightAxis.info.maximum = 0;
                    axisArea.xAxis.info.minimum = 0;
                    axisArea.xAxis.info.maximum = 0;
                    axisArea.xTopAxis.info.minimum = 0;
                    axisArea.xTopAxis.info.maximum = 0;
                    this.prepareInfo(rect.clone());
                    let axisYLeftViewGeom = null;
                    let axisYCenterViewGeom = null;
                    let axisYRightViewGeom = null;
                    let axisXTopViewGeom = null;
                    let axisXCenterViewGeom = null;
                    let axisXBottomViewGeom = null;
                    let axisYLeftGeom = null;
                    let axisYCenterGeom = null;
                    let axisYRightGeom = null;
                    let axisXTopGeom = null;
                    let axisXCenterGeom = null;
                    let axisXBottomGeom = null;
                    let rectYLeftAxis = RectangleD.empty;
                    let rectYCenterAxis = RectangleD.empty;
                    let rectYRightAxis = RectangleD.empty;
                    let rectXTopAxis = RectangleD.empty;
                    let rectXCenterAxis = RectangleD.empty;
                    let rectXBottomAxis = RectangleD.empty;
                    let viewRect = RectangleD.empty;
                    let seriesCollection = axisArea.core.getSeries();
                    if (seriesCollection.length > 0) {
                        let distTop = 0;
                        let distBottom = 0;
                        let distLeft = 0;
                        let distRight = 0;
                        rectYLeftAxis = axisArea.reverseHor ?
                            axisArea.yRightAxis.core.getAxisRect(context, rect, true, true, false, true) :
                            axisArea.yAxis.core.getAxisRect(context, rect, true, true, false, true);
                        if (this.area.chart.table.core.showTable()) {
                            let widhtLegendTableChart = this.area.chart.table.core.getWidthCellLegend(context);
                            if (widhtLegendTableChart > rectYLeftAxis.width) {
                                rectYLeftAxis.width = widhtLegendTableChart;
                                rectYLeftAxis.x = -widhtLegendTableChart;
                                if (rectYLeftAxis.height == 0)
                                    rectYLeftAxis.height = 1;
                            }
                        }
                        if (!rectYLeftAxis.isEmpty) {
                            rectYLeftAxis.x += rect.x;
                            rectYLeftAxis.y += rect.y;
                        }
                        if (!rectYLeftAxis.isEmpty) {
                            distLeft = rectYLeftAxis.width;
                            if (rectYLeftAxis.top < rect.top)
                                distTop = Math.abs(rect.top - rectYLeftAxis.top);
                            if (rect.bottom < rectYLeftAxis.bottom)
                                distBottom = Math.abs(rectYLeftAxis.bottom - rect.bottom);
                        }
                        rectYCenterAxis = axisArea.yAxis.core.getCenterAxisRect(context, rect, true, true, false);
                        if (!rectYCenterAxis.isEmpty) {
                            rectYCenterAxis.x += rect.x;
                            rectYCenterAxis.y += rect.y;
                        }
                        rectYRightAxis = axisArea.reverseHor ?
                            axisArea.yAxis.core.getAxisRect(context, rect, true, true, false, true) :
                            axisArea.yRightAxis.core.getAxisRect(context, rect, true, true, false, true);
                        if (!rectYRightAxis.isEmpty) {
                            rectYRightAxis.x += rect.x;
                            rectYRightAxis.y += rect.y;
                        }
                        if (!rectYRightAxis.isEmpty) {
                            distRight = rectYRightAxis.width;
                            if (rectYRightAxis.top < rect.top)
                                distTop = Math.max(distTop, Math.abs(rect.top - rectYRightAxis.top));
                            if (rect.bottom < rectYRightAxis.bottom)
                                distBottom = Math.max(distBottom, Math.abs(rectYRightAxis.bottom - rect.bottom));
                        }
                        rectXTopAxis = axisArea.xTopAxis.core.getAxisRect(context, rect, true, true, false, true);
                        if (!rectXTopAxis.isEmpty) {
                            rectXTopAxis.x += rect.x;
                            rectXTopAxis.y += rect.y;
                        }
                        if (!rectXTopAxis.isEmpty) {
                            distTop = Math.max(rectXTopAxis.height, distTop);
                            if (rectXTopAxis.x < rect.x)
                                distLeft = Math.max(distLeft, Math.abs(rect.left - rectXTopAxis.left));
                            if (rect.right < rectXTopAxis.right)
                                distRight = Math.max(distRight, Math.abs(rectXTopAxis.right - rect.right));
                        }
                        rectXCenterAxis = axisArea.xAxis.core.getCenterAxisRect(context, rect, true, true, false);
                        if (!rectXCenterAxis.isEmpty) {
                            rectXCenterAxis.x += rect.x;
                            rectXCenterAxis.y += rect.y;
                        }
                        if (axisArea.reverseHor) {
                            let REFdistLeft = { ref: distLeft };
                            let REFdistRight = { ref: distRight };
                            this.swap(REFdistLeft, REFdistRight);
                            distLeft = REFdistLeft.ref;
                            distRight = REFdistRight.ref;
                        }
                        let rectWithoutYAxis = new RectangleD(rect.x + distLeft, rect.y, rect.width - distLeft - distRight, rect.height);
                        axisArea.xAxis.info.dpi = rectWithoutYAxis.width / axisArea.xAxis.info.range;
                        this.calculateStepX(axisArea.xAxis, rectWithoutYAxis.left, rectWithoutYAxis.right);
                        let REFlabelsCollection = { ref: axisArea.xAxis.info.labelsCollection };
                        this.calculatePositions(axisArea.xAxis, REFlabelsCollection, axisArea.xAxis.labels.step > 0 ? Math.trunc(axisArea.xAxis.labels.step) : 1, false);
                        axisArea.xAxis.info.labelsCollection = REFlabelsCollection.ref;
                        rectXBottomAxis = axisArea.xAxis.core.getAxisRect(context, rectWithoutYAxis, true, true, false, true);
                        if (!rectXBottomAxis.isEmpty && !this.area.chart.table.core.showTable()) {
                            rectXBottomAxis.x += rect.x;
                            rectXBottomAxis.y += rect.y;
                        }
                        if (!rectXBottomAxis.isEmpty && !(this.area.chart.table.core.showTable() && !(this.area.chart.table.chart.area.is(Chart.IStiClusteredBarArea)))) {
                            distBottom = Math.max(rectXBottomAxis.height, distBottom);
                            if (rectXBottomAxis.x < rect.x)
                                distLeft = Math.max(distLeft, Math.abs(rect.left - rectXBottomAxis.left));
                            if (rect.right < rectXBottomAxis.right)
                                distRight = Math.max(distRight, Math.abs(rectXBottomAxis.right - rect.right));
                        }
                        if (axisArea.reverseHor) {
                            let REFdistLeft = { ref: distLeft };
                            let REFdistRight = { ref: distRight };
                            this.swap(REFdistLeft, REFdistRight);
                            distLeft = REFdistLeft.ref;
                            distRight = REFdistRight.ref;
                        }
                        if (axisArea.reverseVert) {
                            let REFdistTop = { ref: distTop };
                            let REFdistBottom = { ref: distBottom };
                            this.swap(REFdistTop, REFdistBottom);
                            distTop = REFdistTop.ref;
                            distBottom = REFdistBottom.ref;
                        }
                        rect.x += distLeft;
                        rect.width -= distLeft + distRight;
                        rect.y += distTop;
                        rect.height -= distTop + distBottom;
                        this.prepareInfo(rect);
                        axisYLeftViewGeom = axisArea.yAxis.core.renderView(context, rect);
                        axisYCenterViewGeom = axisArea.yAxis.core.renderCenterView(context, rect);
                        axisYRightViewGeom = axisArea.yRightAxis.core.renderView(context, rect);
                        axisXTopViewGeom = axisArea.xTopAxis.core.renderView(context, rect);
                        axisXCenterViewGeom = axisArea.xAxis.core.renderCenterView(context, rect);
                        axisXBottomViewGeom = axisArea.xAxis.core.renderView(context, rect);
                    }
                    viewRect = rect.clone();
                    let scrollFactorX = this.calculateScrollValuesX(rect.clone(), axisArea);
                    let scrollFactorY = this.calculateScrollValuesY(rect.clone(), axisArea);
                    rect.x = -this.scrollDistanceX;
                    rect.y = -this.scrollDistanceY;
                    rect.width *= scrollFactorX;
                    rect.height *= scrollFactorY;
                    this.prepareInfo(rect.clone());
                    if (seriesCollection.length > 0) {
                        axisYLeftGeom = axisArea.yAxis.core.render(context, rect.clone());
                        axisYCenterGeom = axisArea.yAxis.core.renderCenter(context, rect.clone());
                        axisYRightGeom = axisArea.yRightAxis.core.render(context, rect.clone());
                        axisXTopGeom = axisArea.xTopAxis.core.render(context, rect.clone());
                        axisXCenterGeom = axisArea.xAxis.core.renderCenter(context, rect.clone());
                        axisXBottomGeom = axisArea.xAxis.core.render(context, rect.clone());
                        if (axisYLeftGeom != null)
                            axisYLeftGeom.view = axisYLeftViewGeom;
                        if (axisYCenterGeom != null)
                            axisYCenterGeom.view = axisYCenterViewGeom;
                        if (axisYRightGeom != null)
                            axisYRightGeom.view = axisYRightViewGeom;
                        if (axisXTopGeom != null)
                            axisXTopGeom.view = axisXTopViewGeom;
                        if (axisXCenterGeom != null)
                            axisXCenterGeom.view = axisXCenterViewGeom;
                        if (axisXBottomGeom != null)
                            axisXBottomGeom.view = axisXBottomViewGeom;
                    }
                    if (axisXBottomViewGeom != null)
                        axisArea.xAxis.core.renderScrollBar(context, axisXBottomViewGeom.clientRectangle, axisXBottomViewGeom);
                    if (axisXTopViewGeom != null)
                        axisArea.xTopAxis.core.renderScrollBar(context, axisXTopViewGeom.clientRectangle, axisXTopViewGeom);
                    if (axisYLeftViewGeom != null)
                        axisArea.yAxis.core.renderScrollBar(context, axisYLeftViewGeom.clientRectangle, axisYLeftViewGeom);
                    if (axisYRightViewGeom != null)
                        axisArea.yRightAxis.core.renderScrollBar(context, axisYRightViewGeom.clientRectangle, axisYRightViewGeom);
                    let viewGeom = new Chart.StiAxisAreaViewGeom(axisArea, viewRect);
                    let geom = new Chart.StiAxisAreaGeom(viewGeom, axisArea, rect.clone());
                    viewGeom.createChildGeoms();
                    viewGeom.childGeoms.push(geom);
                    for (let strip of this.area.chart.strips.list) {
                        if (strip.showBehind)
                            strip.core.render(context, geom, rect.clone());
                    }
                    for (let line of this.area.chart.constantLines.list) {
                        if (line.showBehind)
                            line.core.render(context, geom, rect.clone());
                    }
                    this.renderSeries(context, rect.clone(), geom, seriesCollection);
                    for (let strip of this.area.chart.strips.list) {
                        if (!strip.showBehind)
                            strip.core.render(context, geom, rect.clone());
                    }
                    for (let line of this.area.chart.constantLines.list) {
                        if (!line.showBehind)
                            line.core.render(context, geom, rect.clone());
                    }
                    if (axisYLeftGeom != null) {
                        viewGeom.createChildGeoms();
                        axisYLeftViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisYLeftViewGeom);
                        axisYLeftViewGeom.childGeoms.push(axisYLeftGeom);
                    }
                    if (axisYCenterGeom != null) {
                        viewGeom.createChildGeoms();
                        axisYCenterViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisYCenterViewGeom);
                        axisYCenterViewGeom.childGeoms.push(axisYCenterGeom);
                    }
                    if (axisYRightGeom != null) {
                        viewGeom.createChildGeoms();
                        axisYRightViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisYRightViewGeom);
                        axisYRightViewGeom.childGeoms.push(axisYRightGeom);
                    }
                    if (axisXTopGeom != null) {
                        viewGeom.createChildGeoms();
                        axisXTopViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisXTopViewGeom);
                        axisXTopViewGeom.childGeoms.push(axisXTopGeom);
                    }
                    if (axisXCenterGeom != null) {
                        viewGeom.createChildGeoms();
                        axisXCenterViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisXCenterViewGeom);
                        axisXCenterViewGeom.childGeoms.push(axisXCenterGeom);
                    }
                    if (axisXBottomGeom != null && !(this.area.chart.table.core.showTable() && !(this.area.chart.table.chart.area.is(Chart.IStiClusteredBarArea)))) {
                        viewGeom.createChildGeoms();
                        axisXBottomViewGeom.createChildGeoms();
                        viewGeom.childGeoms.push(axisXBottomViewGeom);
                        axisXBottomViewGeom.childGeoms.push(axisXBottomGeom);
                    }
                    return viewGeom;
                }
                calculateScrollValuesX(rect, axisArea) {
                    let minimum;
                    let maximum;
                    let scrollFactorX = 1;
                    if (!this.isAutoRangeXAxis(axisArea.xAxis)) {
                        minimum = axisArea.xAxis.range.minimum;
                        maximum = axisArea.xAxis.range.maximum;
                        if (minimum > maximum) {
                            minimum = axisArea.xAxis.info.minimum;
                            maximum = axisArea.xAxis.info.maximum;
                        }
                    }
                    else {
                        minimum = axisArea.xAxis.info.minimum;
                        maximum = axisArea.xAxis.info.maximum;
                    }
                    this._scrollRangeX = axisArea.xAxis.info.maximum - axisArea.xAxis.info.minimum;
                    this._scrollViewX = maximum - minimum;
                    if (!axisArea.xAxis.core.getStartFromZero() || axisArea.xAxis.logarithmicScale)
                        this.blockScrollValueX = true;
                    else
                        this.blockScrollValueX = false;
                    if (!this.blockScrollValueX && !axisArea.xAxis.interaction.showScrollBar) {
                        let value = minimum + Math.abs(axisArea.xAxis.info.minimum);
                        if (axisArea.xAxis.info.minimum > 0 && minimum > 0)
                            value = Math.abs(minimum - axisArea.xAxis.info.minimum);
                        if (!axisArea.reverseHor)
                            this.scrollValueX = value;
                        else
                            this.scrollValueX = this._scrollRangeX - value - this._scrollViewX;
                    }
                    scrollFactorX = this.scrollRangeX / this.scrollViewX;
                    this._scrollDpiX = rect.width * scrollFactorX / this.scrollRangeX;
                    return scrollFactorX;
                }
                calculateScrollValuesY(rect, axisArea) {
                    let minimum;
                    let maximum;
                    let scrollFactorY = 1;
                    if (!this.isAutoRangeYAxis(axisArea.yAxis)) {
                        minimum = axisArea.yAxis.range.minimum;
                        maximum = axisArea.yAxis.range.maximum;
                        if (minimum > maximum) {
                            minimum = axisArea.yAxis.info.minimum;
                            maximum = axisArea.yAxis.info.maximum;
                        }
                    }
                    else {
                        minimum = axisArea.yAxis.info.minimum;
                        maximum = axisArea.yAxis.info.maximum;
                    }
                    this._scrollRangeY = axisArea.yAxis.info.maximum - axisArea.yAxis.info.minimum;
                    this._scrollViewY = maximum - minimum;
                    if (!axisArea.yAxis.core.getStartFromZero() || axisArea.yAxis.logarithmicScale)
                        this.blockScrollValueY = true;
                    else
                        this.blockScrollValueY = false;
                    if (!this.blockScrollValueY) {
                        let value = minimum + Math.abs(axisArea.yAxis.info.minimum);
                        if (axisArea.reverseVert)
                            this.scrollValueY = value;
                        else
                            this.scrollValueY = this._scrollRangeY - value - this._scrollViewY;
                    }
                    else {
                        this.scrollValueY = 0;
                    }
                    scrollFactorY = this.scrollRangeY / this.scrollViewY;
                    this._scrollDpiY = rect.height * scrollFactorY / this.scrollRangeY;
                    return scrollFactorY;
                }
                prepareInfo(rect) {
                    let seriesCollection = this.getSeries();
                    if (seriesCollection.length > 0) {
                        let axisArea = this.area;
                        this.valuesCount = 0;
                        let specXAxis = (this.is(Chart.StiClusteredBarAreaCoreXF)) ? axisArea.yAxis : axisArea.xAxis;
                        let specXTopAxis = (this.is(Chart.StiClusteredBarAreaCoreXF)) ? axisArea.yRightAxis : axisArea.xTopAxis;
                        let specYAxis = (this.is(Chart.StiClusteredBarAreaCoreXF)) ? axisArea.xAxis : axisArea.yAxis;
                        let specYRightAxis = (this.is(Chart.StiClusteredBarAreaCoreXF)) ? axisArea.xTopAxis : axisArea.yRightAxis;
                        specXAxis.info.stripLines = new Chart.StiStripLinesXF();
                        specYAxis.info.stripLines = new Chart.StiStripLinesXF();
                        specYRightAxis.info.stripLines = new Chart.StiStripLinesXF();
                        let isDateTimeValues = false;
                        for (let index = 0; index < seriesCollection.length; index++) {
                            let values = seriesCollection[index].values;
                            if (seriesCollection[index].is(Chart.StiCandlestickSeries))
                                values = seriesCollection[index].valuesOpen;
                            if (values != null) {
                                this.valuesCount = Math.max(values.length, this.valuesCount);
                            }
                            if (seriesCollection[index].core.isDateTimeValues)
                                isDateTimeValues = true;
                        }
                        if (this.is(Chart.StiBoxAndWhiskerAreaCoreXF))
                            this.valuesCount = seriesCollection.length;
                        this.prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis);
                        if (!specYAxis.range.auto && specYAxis.range.maximum > specYAxis.info.maximum)
                            specYAxis.info.maximum = specYAxis.range.maximum;
                        if (!specYAxis.range.auto && specYAxis.range.minimum < specYAxis.info.minimum)
                            specYAxis.info.minimum = specYAxis.range.minimum;
                        if (!specYRightAxis.range.auto && specYRightAxis.range.maximum > specYRightAxis.info.maximum || axisArea.is(Chart.StiParetoArea))
                            specYRightAxis.info.maximum = specYRightAxis.range.maximum;
                        if (!specYRightAxis.range.auto && specYRightAxis.range.minimum < specYRightAxis.info.minimum)
                            specYRightAxis.info.minimum = specYRightAxis.range.minimum;
                        let isScatterSeries = this.area.chart.series.count > 0 && (this.area.chart.series.getByIndex(0).is(Chart.StiScatterSeries));
                        if (!(specYAxis.logarithmicScale && isScatterSeries)) {
                            this.checkStartFromZeroYAxis(specYAxis);
                            this.checkStartFromZeroYAxis(specYRightAxis);
                            this.calculateMinimumAndMaximumYAxis(specYAxis);
                            if (specYRightAxis.range.auto)
                                this.calculateMinimumAndMaximumYAxis(specYRightAxis);
                        }
                        this.calculateMinimumAndMaximumXAxis(specXAxis);
                        this.createStripLinesXAxis(specXAxis);
                        this.createStripLinesYAxis(specYAxis, isDateTimeValues);
                        this.createStripLinesYAxis(specYRightAxis, isDateTimeValues);
                        this.checkStripLinesAndMaximumMinimumXAxis(specXAxis);
                        this.checkStripLinesAndMaximumMinimumYAxis(specYAxis);
                        this.checkStripLinesAndMaximumMinimumYAxis(specYRightAxis);
                        if (axisArea.is(Chart.IStiClusteredBarArea)) {
                            StiAxisAreaCoreXF.rotateStripLines(specXAxis);
                            StiAxisAreaCoreXF.rotateStripLines(specYAxis);
                            StiAxisAreaCoreXF.rotateStripLines(specYRightAxis);
                        }
                        specXTopAxis.info = specXAxis.info.clone();
                        this.checkShowEdgeValues(specXAxis);
                        this.checkShowEdgeValues(specXTopAxis);
                        if (axisArea.reverseHor) {
                            StiAxisAreaCoreXF.rotateStripLines(axisArea.xAxis);
                            StiAxisAreaCoreXF.rotateStripLines(axisArea.xTopAxis);
                        }
                        if (axisArea.reverseVert) {
                            StiAxisAreaCoreXF.rotateStripLines(axisArea.yAxis);
                            StiAxisAreaCoreXF.rotateStripLines(axisArea.yRightAxis);
                        }
                        axisArea.xAxis.info.dpi = rect.width / axisArea.xAxis.info.range;
                        axisArea.xTopAxis.info.dpi = rect.width / axisArea.xTopAxis.info.range;
                        axisArea.yAxis.info.dpi = rect.height / axisArea.yAxis.info.range;
                        axisArea.yRightAxis.info.dpi = rect.height / axisArea.yRightAxis.info.range;
                        this.calculateStepX(axisArea.xAxis, rect.left, rect.right);
                        this.calculateStepX(axisArea.xTopAxis, rect.left, rect.right);
                        this.calculateStepY(axisArea.yAxis, rect.top, rect.bottom);
                        this.calculateStepY(axisArea.yRightAxis, rect.top, rect.bottom);
                        let REFlabelsCollection = { ref: axisArea.xAxis.info.labelsCollection };
                        this.calculatePositions(axisArea.xAxis, REFlabelsCollection, axisArea.xAxis.labels.step > 0 ? Math.trunc(axisArea.xAxis.labels.step) : 1, false);
                        axisArea.xAxis.info.labelsCollection = REFlabelsCollection.ref;
                        REFlabelsCollection = { ref: axisArea.xTopAxis.info.labelsCollection };
                        this.calculatePositions(axisArea.xTopAxis, REFlabelsCollection, axisArea.xTopAxis.labels.step > 0 ? Math.trunc(axisArea.xTopAxis.labels.step) : 1, false);
                        axisArea.xTopAxis.info.labelsCollection = REFlabelsCollection.ref;
                        REFlabelsCollection = { ref: axisArea.yAxis.info.labelsCollection };
                        this.calculatePositions(axisArea.yAxis, REFlabelsCollection, axisArea.yAxis.labels.step > 0 ? Math.trunc(axisArea.yAxis.labels.step) : 1, false);
                        axisArea.yAxis.info.labelsCollection = REFlabelsCollection.ref;
                        REFlabelsCollection = { ref: axisArea.yRightAxis.info.labelsCollection };
                        this.calculatePositions(axisArea.yRightAxis, REFlabelsCollection, axisArea.yRightAxis.labels.step > 0 ? Math.trunc(axisArea.yRightAxis.labels.step) : 1, false);
                        axisArea.yRightAxis.info.labelsCollection = REFlabelsCollection.ref;
                        let REFticksCollection = { ref: axisArea.xAxis.info.ticksCollection };
                        this.calculatePositions(axisArea.xAxis, REFticksCollection, axisArea.xAxis.ticks.step > 0 ? Math.trunc(axisArea.xAxis.ticks.step) : 1, true);
                        axisArea.xAxis.info.ticksCollection = REFticksCollection.ref;
                        REFticksCollection = { ref: axisArea.xTopAxis.info.ticksCollection };
                        this.calculatePositions(axisArea.xTopAxis, REFticksCollection, axisArea.xTopAxis.ticks.step > 0 ? Math.trunc(axisArea.xTopAxis.ticks.step) : 1, true);
                        axisArea.xTopAxis.info.ticksCollection = REFticksCollection.ref;
                        REFticksCollection = { ref: axisArea.yAxis.info.ticksCollection };
                        this.calculatePositions(axisArea.yAxis, REFticksCollection, axisArea.yAxis.ticks.step > 0 ? Math.trunc(axisArea.yAxis.ticks.step) : 1, true);
                        axisArea.yAxis.info.ticksCollection = REFticksCollection.ref;
                        REFticksCollection = { ref: axisArea.yRightAxis.info.ticksCollection };
                        this.calculatePositions(axisArea.yRightAxis, REFticksCollection, axisArea.yRightAxis.ticks.step > 0 ? Math.trunc(axisArea.yRightAxis.ticks.step) : 1, true);
                        axisArea.yRightAxis.info.ticksCollection = REFticksCollection.ref;
                    }
                }
                renderSeries(context, rect, geom, seriesCollection) {
                    let seriesTypes = [];
                    let seriesTypesHash = new Hashtable();
                    for (let ser of seriesCollection) {
                        if (this.isAcceptableSeries(ser.stimulsoft().getType())) {
                            let list = seriesTypesHash.get(ser.stimulsoft().getType());
                            if (list == null) {
                                list = [];
                                seriesTypes.push(list);
                                seriesTypesHash.add(ser.stimulsoft().getType(), list);
                            }
                            list.push(ser);
                        }
                    }
                    for (let seriesType of seriesTypes) {
                        let seriesArray = seriesType.stimulsoft().toArray();
                        if (seriesArray[0].is(Chart.StiStackedBarSeries) ||
                            seriesArray[0].is(Chart.StiStackedColumnSeries) ||
                            seriesArray[0].is(Chart.StiStackedBaseLineSeries)) {
                            let leftSeries = [];
                            let rightSeries = [];
                            for (let series of seriesArray) {
                                if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    leftSeries.push(series);
                                else
                                    rightSeries.push(series);
                            }
                            if (leftSeries.length > 0)
                                leftSeries.stimulsoft().toArray()[0].core.renderSeries(context, rect, geom, leftSeries.stimulsoft().toArray());
                            if (rightSeries.length > 0)
                                rightSeries.stimulsoft().toArray()[0].core.renderSeries(context, rect, geom, rightSeries.stimulsoft().toArray());
                        }
                        else
                            seriesArray[0].core.renderSeries(context, rect, geom, seriesArray);
                    }
                }
                isAutoRangeXAxis(axis) {
                    return axis.range.auto || axis.range.minimum >= axis.range.maximum || axis.logarithmicScale;
                }
                isAutoRangeYAxis(axis) {
                    return axis.range.auto || axis.range.maximum == axis.range.minimum || this.area.isDefaultSeriesTypeFullStackedColumnSeries || axis.logarithmicScale;
                }
                calculateMinimumAndMaximumXAxis(axis) {
                    if (!axis.range.auto) {
                        axis.info.maximum = axis.range.maximum;
                        axis.info.minimum = axis.range.minimum;
                    }
                }
                calculateMinimumAndMaximumYAxis(axis) {
                    if (this.getSeries().length > 0 && this.getSeries()[0].is(Chart.StiGanttSeries)) {
                        if (!axis.range.auto) {
                            axis.info.maximum = axis.range.maximum;
                            axis.info.minimum = axis.range.minimum;
                        }
                        return;
                    }
                    if (!axis.startFromZero && axis.range.auto && (axis.is(Chart.IStiYAxis))) {
                        let range = axis.info.maximum - axis.info.minimum;
                        axis.info.minimum = axis.info.minimum - range * 0.05;
                        axis.info.maximum = axis.info.maximum + range * 0.05;
                    }
                    else {
                        let minDelts = 0.1;
                        if (this.getSeries().length > 0 && this.getSeries()[0].seriesLabels.is(Chart.StiOutsideEndAxisLabels))
                            minDelts = 0.15;
                        let delta = Math.min(minDelts, Math.abs(4 / ((axis.info.maximum + axis.info.minimum) / 2)));
                        axis.info.maximum *= 1 + delta * Math.sign(axis.info.maximum);
                        axis.info.minimum *= 1 - delta * Math.sign(axis.info.minimum);
                    }
                    if (axis.info.minimum == axis.info.maximum) {
                        if (axis.info.maximum == 0)
                            axis.info.maximum = 100;
                        else {
                            axis.info.minimum -= axis.info.minimum * 0.1;
                            axis.info.maximum += axis.info.maximum * 0.1;
                        }
                    }
                }
                getArgumentLabel(line, series) {
                    if (line == null)
                        return "";
                    let axisArea = this.area;
                    if (axisArea.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        return axisArea.xAxis.core.getLabelText(line, series);
                    }
                    else {
                        return axisArea.yAxis.core.getLabelText(line, series);
                    }
                }
                switchOff() {
                    let axisArea = this.area;
                    axisArea.gridLinesHor.visible = false;
                    axisArea.gridLinesVert.visible = false;
                    axisArea.interlacingHor.visible = false;
                    axisArea.interlacingVert.visible = false;
                    axisArea.xAxis.visible = false;
                    axisArea.yAxis.visible = false;
                    axisArea.xTopAxis.visible = false;
                    axisArea.yRightAxis.visible = false;
                    axisArea.yAxis.range.auto = true;
                    axisArea.xAxis.range.auto = true;
                }
                swap(REFvalue1, REFvalue2) {
                    let temp = REFvalue1.ref;
                    REFvalue1.ref = REFvalue2.ref;
                    REFvalue2.ref = temp;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                }
                createStripLinesXAxis(axis) {
                    let getStartFromZero = axis.core.getStartFromZero();
                    let toValue = getStartFromZero ? this.valuesCount + 1 : this.valuesCount;
                    for (let index = getStartFromZero ? 0 : 1; index <= toValue; index++) {
                        axis.info.stripLines.add2(index, index);
                    }
                    let seriesCollection = this.getSeries();
                    for (let series of seriesCollection) {
                        for (let index = 0; index < this.valuesCount; index++) {
                            let valueObject = null;
                            if (series.arguments != null && index < series.arguments.length) {
                                valueObject = series.arguments[index];
                                if (StiString.isNullOrEmpty(valueObject))
                                    continue;
                            }
                            if (valueObject != null) {
                                let finalIndex = getStartFromZero ? 1 + index : index;
                                if (finalIndex < axis.info.stripLines.count)
                                    axis.info.stripLines.getByIndex(finalIndex).valueObject = valueObject;
                            }
                        }
                    }
                }
                checkShowEdgeValues(axis) {
                    if (axis.info.stripLines.count > 0) {
                        let showEdgeValues = axis.is(Chart.IStiXTopAxis) ? axis.area.xTopAxis.showEdgeValues : axis.area.xAxis.showEdgeValues;
                        if (!showEdgeValues || axis.area.is(Chart.IStiClusteredBarArea)) {
                            axis.info.stripLines.getByIndex(0).valueObject = null;
                            axis.info.stripLines.getByIndex(axis.info.stripLines.count - 1).valueObject = null;
                        }
                    }
                }
                createStripLinesYAxis(axis, isDateTimeValues) {
                    if (this.area.isDefaultSeriesTypeFullStackedColumnSeries ||
                        this.area.isDefaultSeriesTypeFullStackedBarSeries) {
                        let positivePresent = false;
                        let negativePresent = false;
                        let seriesCollection = this.getSeries();
                        for (let series of seriesCollection) {
                            for (let value of series.values) {
                                if (value > 0)
                                    positivePresent = true;
                                if (value < 0)
                                    negativePresent = true;
                            }
                        }
                        let minimum = negativePresent ? -100 : 0;
                        let maximum = positivePresent ? 100 : 0;
                        if (minimum == 0 && maximum == 0) {
                            maximum = 100;
                        }
                        let step = axis.labels.step;
                        if (step == 0)
                            step = Chart.StiStripLineCalculatorXF.getInterval(minimum, maximum, 6);
                        axis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLines(minimum, maximum, step, false);
                        for (let stripLine of axis.info.stripLines.list) {
                            stripLine.valueObject = StiString.format("{0}%", stripLine.valueObject);
                        }
                    }
                    else {
                        let step = axis.labels.step;
                        if (step > 0 && axis.info.range > 0 && (axis.info.range / step) > 500)
                            step = 0;
                        if (step == 0) {
                            step = Chart.StiStripLineCalculatorXF.getInterval(axis.info.minimum, axis.info.maximum, 6);
                            let chart = this.area.chart;
                            if (chart.isDashboard)
                                axis.labels.calculatedStep = step;
                        }
                        axis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLines(axis.info.minimum, axis.info.maximum, step, isDateTimeValues);
                    }
                }
                checkStripLinesAndMaximumMinimumXAxis(axis) {
                    if (axis.info.stripLines.count > 0) {
                        axis.info.minimum = axis.info.stripLines.getByIndex(0).value;
                        axis.info.maximum = axis.info.stripLines.getByIndex(axis.info.stripLines.count - 1).value;
                    }
                    else {
                        axis.info.minimum = 0;
                        axis.info.maximum = 1;
                    }
                }
                checkStripLinesAndMaximumMinimumYAxis(axis) {
                    if (axis.info.stripLines.count > 0) {
                        axis.info.maximum = axis.info.stripLines.getByIndex(0).value;
                        axis.info.minimum = axis.info.stripLines.getByIndex(axis.info.stripLines.count - 1).value;
                    }
                    else {
                        axis.info.maximum = 100;
                        axis.info.minimum = 0;
                    }
                }
                calculateStepX(axis, topPosition, bottomPosition) {
                    if (axis.info.stripLines.count >= 2) {
                        axis.info.step = Math.abs(((axis.info.stripLines.getByIndex(0).value - axis.info.stripLines.getByIndex(1).value) * axis.info.dpi));
                        axis.core.calculateStripPositions(topPosition, bottomPosition);
                    }
                    else {
                        axis.info.step = 1;
                        axis.info.stripPositions = [];
                    }
                }
                calculateStepY(axis, topPosition, bottomPosition) {
                    if (axis.info.stripLines.count >= 2) {
                        axis.info.step = Math.abs(((axis.info.stripLines.getByIndex(1).value - axis.info.stripLines.getByIndex(0).value) * axis.info.dpi));
                        axis.core.calculateStripPositions(topPosition, bottomPosition);
                    }
                    else {
                        axis.info.step = 1;
                        axis.info.stripPositions = [];
                    }
                }
                checkStartFromZeroYAxis(axis) {
                    if (axis.core.getStartFromZero()) {
                        if (axis.info.maximum < 0)
                            axis.info.maximum = 0;
                        if (axis.info.minimum > 0)
                            axis.info.minimum = 0;
                    }
                }
                calculatePositions(axis, REFcollection, step, calculationForTicks) {
                    let collection = [];
                    let axisArea = this.area;
                    let revert = false;
                    if (this.area.is(Chart.IStiYAxis)) {
                        revert = axisArea.reverseVert;
                    }
                    else if (this.area.is(Chart.IStiXAxis)) {
                        revert = axisArea.reverseHor;
                    }
                    let stepIndex = 0;
                    let length = axis.info.stripPositions.length;
                    for (let index = 0; index < length; index++) {
                        if (stepIndex == 0) {
                            let label = new Chart.StiStripPositionXF();
                            let stripIndex = revert ? length - index - 1 : index;
                            label.stripLine = axis.info.stripLines.getByIndex(stripIndex);
                            label.position = axis.info.stripPositions[stripIndex];
                            if (revert)
                                collection.stimulsoft().insert(0, label);
                            else
                                collection.push(label);
                        }
                        if (this.area.core.is(Chart.StiScatterAreaCoreXF) && axis.is(Chart.IStiXAxis) && !axis.logarithmicScale)
                            continue;
                        if (this.area.core.is(Chart.StiClusteredBarAreaCoreXF) && axis.is(Chart.IStiXAxis) && !calculationForTicks)
                            continue;
                        if (!(this.area.core.is(Chart.StiClusteredBarAreaCoreXF)) && axis.is(Chart.IStiYAxis) && !calculationForTicks)
                            continue;
                        if (index == (length - 1) && stepIndex != 0) {
                            let xAxis = axis;
                            if (xAxis != null && xAxis.showEdgeValues) {
                                let label = new Chart.StiStripPositionXF();
                                let stripIndex = revert ? 0 : length - 1;
                                label.stripLine = axis.info.stripLines.getByIndex(stripIndex);
                                label.position = axis.info.stripPositions[stripIndex];
                                if (revert)
                                    collection.stimulsoft().insert(0, label);
                                else
                                    collection.push(label);
                            }
                        }
                        stepIndex++;
                        if (stepIndex == step)
                            stepIndex = 0;
                    }
                    REFcollection.ref = collection;
                }
                calculateDivider(axis) {
                    let axisArea = this.area;
                    let stripIndex = 0;
                    if (axis.info.stripLines != null) {
                        for (let stripLine of axis.info.stripLines.list) {
                            if (stripLine.value == 0) {
                                return axis.info.stripPositions[stripIndex];
                            }
                            stripIndex++;
                        }
                    }
                    if (axis.is(Chart.IStiYAxis)) {
                        if (axisArea.reverseVert)
                            return -axis.info.minimum * axis.info.dpi;
                        else
                            return (axis.info.stripPositions == null || axis.info.stripPositions.length == 0) ?
                                (axis.info.minimum * axis.info.dpi) :
                                (axis.info.stripPositions[axis.info.stripPositions.length - 1] + axis.info.minimum * axis.info.dpi);
                    }
                    else if (axis.is(Chart.IStiXAxis)) {
                        if (axisArea.reverseHor)
                            return (axis.info.stripPositions == null || axis.info.stripPositions.length == 0) ?
                                (axis.info.minimum * axis.info.dpi) :
                                (axis.info.stripPositions[axis.info.stripPositions.length - 1] + axis.info.minimum * axis.info.dpi);
                        else
                            return -axis.info.minimum * axis.info.dpi;
                    }
                    else
                        return 0;
                }
                static rotateStripLines(axis) {
                    let lines = new Chart.StiStripLinesXF();
                    for (let line of axis.info.stripLines.list) {
                        lines.insert(0, line);
                    }
                    axis.info.stripLines = lines;
                }
                getDividerX() {
                    let axisArea = this.area;
                    if (this.is(Chart.StiClusteredBarAreaCoreXF) || this.is(Chart.StiScatterAreaCoreXF)) {
                        return this.calculateDivider(axisArea.xAxis);
                    }
                    return 0;
                }
                getDividerTopX() {
                    let axisArea = this.area;
                    if (this.is(Chart.StiClusteredBarAreaCoreXF)) {
                        return this.calculateDivider(axisArea.xTopAxis);
                    }
                    return 0;
                }
                getDividerY() {
                    let axisArea = this.area;
                    if (this.is(Chart.StiClusteredBarAreaCoreXF) && (!(this.is(Chart.StiGanttAreaCoreXF))))
                        return 0;
                    else
                        return this.calculateDivider(axisArea.yAxis);
                }
                getDividerRightY() {
                    let axisArea = this.area;
                    if (this.is(Chart.StiClusteredBarAreaCoreXF) && (!(this.is(Chart.StiGanttAreaCoreXF))))
                        return 0;
                    else
                        return this.calculateDivider(axisArea.yRightAxis);
                }
                get scrollDistanceX() {
                    return this.scrollDpiX * this.scrollValueX;
                }
                get scrollDistanceY() {
                    return this.scrollDpiY * this.scrollValueY;
                }
                get scrollRangeX() {
                    return this._scrollRangeX;
                }
                get scrollRangeY() {
                    return this._scrollRangeY;
                }
                get scrollViewX() {
                    return this._scrollViewX;
                }
                get scrollViewY() {
                    return this._scrollViewY;
                }
                get blockScrollValueX() {
                    return this._blockScrollValueX;
                }
                set blockScrollValueX(value) {
                    this._blockScrollValueX = value;
                }
                get blockScrollValueY() {
                    return this._blockScrollValueY;
                }
                set blockScrollValueY(value) {
                    this._blockScrollValueY = value;
                }
                get scrollValueX() {
                    return this._scrollValueX;
                }
                set scrollValueX(value) {
                    this._scrollValueX = value;
                }
                get scrollValueY() {
                    return this._scrollValueY;
                }
                set scrollValueY(value) {
                    this._scrollValueY = value;
                }
                get scrollDpiX() {
                    return this._scrollDpiX;
                }
                get scrollDpiY() {
                    return this._scrollDpiY;
                }
                get scrollDragStartValue() {
                    return this._scrollDragStartValue;
                }
                set scrollDragStartValue(value) {
                    this._scrollDragStartValue = value;
                }
            }
            Chart.StiAxisAreaCoreXF = StiAxisAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiClusteredColumnAreaCoreXF extends Chart.StiAxisAreaCoreXF {
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let firstLeft = true;
                    let firstRight = true;
                    let seriesLeftAxisY = false;
                    let seriesRightAxisY = false;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    specYRightAxis.info.maximum = 0;
                    specYRightAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let series = seriesCollection[index];
                        let values = series.values;
                        for (let value of values) {
                            if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                if (value != null) {
                                    if (firstLeft) {
                                        seriesLeftAxisY = true;
                                        specYAxis.info.maximum = value;
                                        specYAxis.info.minimum = value;
                                        firstLeft = false;
                                    }
                                    else {
                                        seriesLeftAxisY = true;
                                        specYAxis.info.maximum = Math.max(value, specYAxis.info.maximum);
                                        specYAxis.info.minimum = Math.min(value, specYAxis.info.minimum);
                                    }
                                }
                            }
                            else {
                                if (value != null) {
                                    if (firstRight) {
                                        seriesRightAxisY = true;
                                        specYRightAxis.info.maximum = value;
                                        specYRightAxis.info.minimum = value;
                                        firstRight = false;
                                    }
                                    else {
                                        seriesRightAxisY = true;
                                        specYRightAxis.info.maximum = Math.max(value, specYRightAxis.info.maximum);
                                        specYRightAxis.info.minimum = Math.min(value, specYRightAxis.info.minimum);
                                    }
                                }
                            }
                        }
                    }
                    if (!seriesLeftAxisY) {
                        specYAxis.info.maximum = specYRightAxis.info.maximum;
                        specYAxis.info.minimum = specYRightAxis.info.minimum;
                    }
                    if (!seriesRightAxisY) {
                        specYRightAxis.info.maximum = specYAxis.info.maximum;
                        specYRightAxis.info.minimum = specYAxis.info.minimum;
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ClusteredColumn");
                }
                get position() {
                    return Chart.StiChartAreaPosition.ClusteredColumn;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiClusteredColumnAreaCoreXF = StiClusteredColumnAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiChartAreaPosition = Stimulsoft.Report.Chart.StiChartAreaPosition;
            class StiBoxAndWhiskerAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "BoxAndWhisker");
                }
                get position() {
                    return StiChartAreaPosition.Bubble;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiBoxAndWhiskerAreaCoreXF = StiBoxAndWhiskerAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiConvert = Stimulsoft.Base.StiConvert;
            var StiString = Stimulsoft.System.StiString;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var DateTime = Stimulsoft.System.DateTime;
            class StiScatterAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                constructor(area) {
                    super(area);
                    this.isArgumentDateTime = false;
                }
                isXAxisAutoRange(xAxis) {
                    let axisArea = this.area;
                    return xAxis.range.auto || axisArea.xAxis.range.maximum == axisArea.xAxis.range.minimum || xAxis.logarithmicScale;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    super.prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis);
                    let first = true;
                    specXAxis.info.maximum = 0;
                    specXAxis.info.minimum = 0;
                    this.isArgumentDateTime = false;
                    let seriesCollection = this.getSeries();
                    for (let series of seriesCollection) {
                        if (series.arguments.length > 0 && typeof series.arguments[0] == "string") {
                            let st = series.arguments[0];
                            if (st.stimulsoft().endsWith("AM") || st.stimulsoft().endsWith("PM")) {
                                for (let index = 0; index < series.arguments.length; index++) {
                                    let result = DateTime.fromString(series.arguments[index].toString(), false);
                                    if (result != null) {
                                        series.arguments[index] = result;
                                    }
                                }
                            }
                        }
                        for (let argument of series.arguments) {
                            let value = 0;
                            if (argument instanceof DateTime) {
                                this.isArgumentDateTime = true;
                                value = argument.toOADate();
                            }
                            else if (typeof argument == "string") {
                                let refResult = { ref: 0 };
                                if (Chart.StiSeries.tryParseValue(argument, series.chart.report.culture, refResult)) {
                                    value = refResult.ref;
                                }
                            }
                            else {
                                try {
                                    value = StiConvert.changeType(argument, Number);
                                }
                                catch (_a) {
                                    value = 0;
                                }
                            }
                            if (first) {
                                first = false;
                                specXAxis.info.maximum = value;
                                specXAxis.info.minimum = value;
                            }
                            else {
                                specXAxis.info.maximum = Math.max(specXAxis.info.maximum, value);
                                specXAxis.info.minimum = Math.min(specXAxis.info.minimum, value);
                            }
                        }
                    }
                }
                checkStripLinesAndMaximumMinimumXAxis(axis) {
                    if (axis.info.stripLines.count > 0) {
                        axis.info.minimum = axis.info.stripLines.getByIndex(0).value;
                        axis.info.maximum = axis.info.stripLines.getByIndex(axis.info.stripLines.count - 1).value;
                    }
                    else {
                        axis.info.minimum = 0;
                        axis.info.maximum = 1;
                    }
                }
                createStripLinesXAxis(axis) {
                    if (!(this.isArgumentDateTime) && !axis.logarithmicScale) {
                        if (this.isXAxisAutoRange(axis)) {
                            let range = Math.abs(axis.info.maximum - axis.info.minimum);
                            if (range != 0) {
                                axis.info.maximum += range * 0.05;
                                axis.info.minimum -= range * 0.05;
                            }
                            else {
                                axis.info.maximum *= 1.05;
                                if (axis.info.minimum < 0)
                                    axis.info.minimum *= 1.05;
                                else
                                    axis.info.minimum *= 0.95;
                            }
                            if (axis.core.getStartFromZero())
                                axis.info.minimum = 0;
                            if (axis.info.minimum == axis.info.maximum) {
                                if (axis.info.maximum == 0)
                                    axis.info.maximum = 100;
                                else {
                                    axis.info.minimum -= axis.info.minimum * 0.1;
                                    axis.info.maximum -= axis.info.maximum * 0.1;
                                }
                            }
                        }
                    }
                    let isDateTimeValues = false;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        if (seriesCollection[index].core.isDateTimeValues) {
                            isDateTimeValues = true;
                            break;
                        }
                    }
                    let step = axis.labels.step;
                    if (step == 0)
                        step = Chart.StiStripLineCalculatorXF.getInterval(axis.info.minimum, axis.info.maximum, 6);
                    let xStripLines;
                    if (axis.logarithmicScale) {
                        xStripLines = Chart.StiStripLineCalculatorXF.getStripLinesLogScale(axis.info.minimum, axis.info.maximum);
                    }
                    else {
                        xStripLines = Chart.StiStripLineCalculatorXF.getStripLines(axis.info.minimum, axis.info.maximum, step, isDateTimeValues);
                    }
                    axis.info.stripLines.clear();
                    for (let id = xStripLines.count - 1; id >= 0; id--) {
                        let value = xStripLines.getByIndex(id).value;
                        let valueObject = xStripLines.getByIndex(id).valueObject;
                        if (this.isArgumentDateTime)
                            valueObject = DateTime.fromOADate(value);
                        axis.info.stripLines.add2(valueObject, value);
                    }
                }
                createStripLinesYAxis(axis, isDateTimeValues) {
                    if (this.area.isDefaultSeriesTypeFullStackedColumnSeries ||
                        this.area.isDefaultSeriesTypeFullStackedBarSeries) {
                        let positivePresent = false;
                        let negativePresent = false;
                        let seriesCollection = this.getSeries();
                        for (let series of seriesCollection) {
                            for (let value of series.values) {
                                if (value > 0)
                                    positivePresent = true;
                                if (value < 0)
                                    negativePresent = true;
                            }
                        }
                        let minimum = negativePresent ? -100 : 0;
                        let maximum = positivePresent ? 100 : 0;
                        let step = axis.labels.step;
                        if (step == 0)
                            step = Chart.StiStripLineCalculatorXF.getInterval(minimum, maximum, 6);
                        axis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLines(minimum, maximum, step, false);
                        for (let stripLine of axis.info.stripLines.list) {
                            stripLine.valueObject = StiString.format("{0}%", stripLine.valueObject);
                        }
                    }
                    else {
                        let step = axis.labels.step;
                        if (step > 0 && axis.info.range > 0 && (axis.info.range / step) > 500)
                            step = 0;
                        if (step == 0)
                            step = Chart.StiStripLineCalculatorXF.getInterval(axis.info.minimum, axis.info.maximum, 6);
                        if (axis.logarithmicScale) {
                            axis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLinesLogScale(axis.info.minimum, axis.info.maximum);
                        }
                        else {
                            axis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLines(axis.info.minimum, axis.info.maximum, step, isDateTimeValues);
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Scatter");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Scatter;
                }
            }
            Chart.StiScatterAreaCoreXF = StiScatterAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiChartAreaPosition = Stimulsoft.Report.Chart.StiChartAreaPosition;
            class StiBubbleAreaCoreXF extends Chart.StiScatterAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Bubble");
                }
                get position() {
                    return StiChartAreaPosition.Bubble;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiBubbleAreaCoreXF = StiBubbleAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiCandlestickAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Candlestick");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Candlestick;
                }
                createStripLinesXAxis(axis) {
                    axis.info.stripLines.clear();
                    axis.info.stripLines.add2(0, 0);
                    let seriesCollection = this.getSeries();
                    for (let series of seriesCollection) {
                        for (let argument of series.arguments) {
                            let notExist = true;
                            for (let line of axis.info.stripLines.list) {
                                if (line.valueObject.toString() == argument.toString())
                                    notExist = false;
                            }
                            if (notExist)
                                axis.info.stripLines.add2(argument, axis.info.stripLines.count);
                        }
                    }
                    axis.info.stripLines.add2("", axis.info.stripLines.count);
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    specXAxis.info.maximum = 0;
                    specXAxis.info.minimum = 0;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    let first = true;
                    for (let series of (seriesCollection)) {
                        for (let value of series.valuesOpen) {
                            if (value != null) {
                                if (first) {
                                    first = false;
                                    specYAxis.info.maximum = value;
                                    specYAxis.info.minimum = value;
                                }
                                else {
                                    specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                    specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                                }
                            }
                        }
                        for (let value of series.valuesClose) {
                            if (value != null) {
                                specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                            }
                        }
                        for (let value of series.valuesHigh) {
                            if (value != null) {
                                specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                            }
                        }
                        for (let value of series.valuesLow) {
                            if (value != null) {
                                specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                            }
                        }
                    }
                    specYRightAxis.info.maximum = specYAxis.info.maximum;
                    specYRightAxis.info.minimum = specYAxis.info.minimum;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiCandlestickAreaCoreXF = StiCandlestickAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiClusteredBarAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "ClusteredBar");
                }
                get seriesOrientation() {
                    return Chart.StiChartSeriesOrientation.Horizontal;
                }
                get position() {
                    return Chart.StiChartAreaPosition.ClusteredBar;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiClusteredBarAreaCoreXF = StiClusteredBarAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiAreaAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Area");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Area;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiAreaAreaCoreXF = StiAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiHistogramAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Histogram");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Histogram;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiHistogramAreaCoreXF = StiHistogramAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiLineAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Line");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Line;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiLineAreaCoreXF = StiLineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiParetoAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Pareto");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Pareto;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiParetoAreaCoreXF = StiParetoAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSplineAreaAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "SplineArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.SplineArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSplineAreaAreaCoreXF = StiSplineAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSplineAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Spline");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Spline;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSplineAreaCoreXF = StiSplineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSteppedAreaAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.SteppedArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSteppedAreaAreaCoreXF = StiSteppedAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSteppedLineAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedLine");
                }
                get position() {
                    return Chart.StiChartAreaPosition.SteppedLine;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSteppedLineAreaCoreXF = StiSteppedLineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiWaterfallAreaCoreXF extends Chart.StiAxisAreaCoreXF {
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let firstLeft = true;
                    let currentValue = 0;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let series = seriesCollection[index];
                        let lastDeltaIndex = series.total.visible ? 1 : 0;
                        for (let indexVallue = 0; indexVallue < series.values.length - lastDeltaIndex; indexVallue++) {
                            let value = series.values[indexVallue];
                            if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                if (value != null) {
                                    if (firstLeft) {
                                        currentValue = value;
                                        specYAxis.info.maximum = Math.max(0, value);
                                        specYAxis.info.minimum = Math.min(0, value);
                                        firstLeft = false;
                                    }
                                    else {
                                        currentValue += value;
                                        specYAxis.info.maximum = Math.max(currentValue, specYAxis.info.maximum);
                                        specYAxis.info.minimum = Math.min(currentValue, specYAxis.info.minimum);
                                    }
                                }
                            }
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Waterfall");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Waterfall;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiWaterfallAreaCoreXF = StiWaterfallAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiPieAreaCoreXF extends Chart.StiAreaCoreXF {
                constructor(area) {
                    super(area);
                    this.valuesCount = 0;
                }
                render(context, rect) {
                    this.prepareInfo(rect);
                    let pieAreaGeom = new Chart.StiPieAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    this.renderSeries(context, rect, pieAreaGeom, seriesCollection);
                    return pieAreaGeom;
                }
                renderSeries(context, rect, geom, seriesCollection) {
                    let seriesTypes = [];
                    let seriesTypesHash = new Hashtable();
                    for (let ser of seriesCollection) {
                        let list = seriesTypesHash.get(ser.stimulsoft().getType());
                        if (list == null) {
                            list = [];
                            seriesTypes.push(list);
                            seriesTypesHash.set(ser.stimulsoft().getType(), list);
                        }
                        list.push(ser);
                    }
                    for (let seriesType of seriesTypes) {
                        let seriesArray = seriesType.stimulsoft().toArray();
                        seriesArray[0].core.renderSeries(context, rect, geom, seriesArray);
                    }
                }
                prepareInfo(rect) {
                    this.valuesCount = 0;
                    let seriesCollection = this.getSeries();
                    if (seriesCollection.length > 0) {
                        for (let index = 0; index < seriesCollection.length; index++) {
                            let values = seriesCollection[index].values;
                            if (values != null) {
                                this.valuesCount = Math.max(values.length, this.valuesCount);
                            }
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Pie");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Pie;
                }
            }
            Chart.StiPieAreaCoreXF = StiPieAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiDoughnutAreaCoreXF extends Chart.StiPieAreaCoreXF {
                render(context, rect) {
                    this.prepareInfo(rect);
                    let doughnutAreaGeom = new Chart.StiDoughnutAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    this.renderSeries(context, rect, doughnutAreaGeom, seriesCollection);
                    return doughnutAreaGeom;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Doughnut");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Doughnut;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiDoughnutAreaCoreXF = StiDoughnutAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedBarAreaCoreXF extends Chart.StiClusteredBarAreaCoreXF {
                prepareSeriesRange(seriesType) {
                    let minValues = [];
                    let maxValues = [];
                    let minValuesRight = [];
                    let maxValuesRight = [];
                    let seriesCollection = this.getSeries();
                    for (let indexPoint = 0; indexPoint < this.valuesCount; indexPoint++) {
                        for (let series of seriesCollection) {
                            if (series.stimulsoft().getType() == seriesType) {
                                if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                    minValues.push(0);
                                    maxValues.push(0);
                                    if (indexPoint < series.values.length) {
                                        let value = series.values[indexPoint];
                                        if (value > 0)
                                            maxValues[indexPoint] = maxValues[indexPoint] + value;
                                        else
                                            minValues[indexPoint] = minValues[indexPoint] + value;
                                    }
                                }
                                else {
                                    minValuesRight.push(0);
                                    maxValuesRight.push(0);
                                    if (indexPoint < series.values.length) {
                                        let value = series.values[indexPoint];
                                        if (value > 0)
                                            maxValuesRight[indexPoint] = maxValuesRight[indexPoint] + value;
                                        else
                                            minValuesRight[indexPoint] = minValuesRight[indexPoint] + value;
                                    }
                                }
                            }
                        }
                    }
                    let values = [
                        minValues,
                        maxValues,
                        minValuesRight,
                        maxValuesRight
                    ];
                    return values;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let seriesCollection = this.getSeries();
                    let seriesTypes = new Hashtable();
                    for (let series of seriesCollection) {
                        seriesTypes.set(series.stimulsoft().getType(), series.stimulsoft().getType());
                    }
                    let minValues = [];
                    let maxValues = [];
                    let minValuesRight = [];
                    let maxValuesRight = [];
                    for (let seriesType of seriesTypes.values) {
                        let values = this.prepareSeriesRange(seriesType);
                        let index = 0;
                        for (let value of values[0]) {
                            if (minValues.length <= index)
                                minValues.push(value);
                            else
                                minValues[index] = Math.min(minValues[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[1]) {
                            if (maxValues.length <= index)
                                maxValues.push(value);
                            else
                                maxValues[index] = Math.max(maxValues[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[2]) {
                            if (minValuesRight.length <= index)
                                minValuesRight.push(value);
                            else
                                minValuesRight[index] = Math.min(minValuesRight[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[3]) {
                            if (maxValuesRight.length <= index)
                                maxValuesRight.push(value);
                            else
                                maxValuesRight[index] = Math.max(maxValuesRight[index], value);
                            index++;
                        }
                    }
                    if (minValues.length == 0)
                        minValues = minValuesRight;
                    if (maxValues.length == 0)
                        maxValues = maxValuesRight;
                    if (minValuesRight.length == 0)
                        minValuesRight = minValues;
                    if (maxValuesRight.length == 0)
                        maxValuesRight = maxValues;
                    let firstValue = true;
                    for (let value of minValues) {
                        if (firstValue) {
                            specYAxis.info.minimum = value;
                            firstValue = false;
                        }
                        else
                            specYAxis.info.minimum = Math.min(value, specYAxis.info.minimum);
                    }
                    firstValue = true;
                    for (let value of maxValues) {
                        if (firstValue) {
                            specYAxis.info.maximum = value;
                            firstValue = false;
                        }
                        else
                            specYAxis.info.maximum = Math.max(value, specYAxis.info.maximum);
                    }
                    firstValue = true;
                    for (let value of minValuesRight) {
                        if (firstValue) {
                            specYRightAxis.info.minimum = value;
                            firstValue = false;
                        }
                        else
                            specYRightAxis.info.minimum = Math.min(value, specYRightAxis.info.minimum);
                    }
                    firstValue = true;
                    for (let value of maxValuesRight) {
                        if (firstValue) {
                            specYRightAxis.info.maximum = value;
                            firstValue = false;
                        }
                        else
                            specYRightAxis.info.maximum = Math.max(value, specYRightAxis.info.maximum);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedBar");
                }
                get seriesOrientation() {
                    return Chart.StiChartSeriesOrientation.Horizontal;
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedBar;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedBarAreaCoreXF = StiStackedBarAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedBarAreaCoreXF extends Chart.StiStackedBarAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedBar");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedBar;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedBarAreaCoreXF = StiFullStackedBarAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedColumnAreaCoreXF extends Chart.StiAxisAreaCoreXF {
                prepareSeriesRange(seriesType) {
                    let minValues = [];
                    let maxValues = [];
                    let minValuesRight = [];
                    let maxValuesRight = [];
                    let seriesCollection = this.getSeries();
                    for (let indexPoint = 0; indexPoint < this.valuesCount; indexPoint++) {
                        for (let series of seriesCollection) {
                            if (series.stimulsoft().getType() == seriesType) {
                                if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                    minValues.push(0);
                                    maxValues.push(0);
                                    if (indexPoint < series.values.length) {
                                        let value = series.values[indexPoint];
                                        if (value > 0)
                                            maxValues[indexPoint] = maxValues[indexPoint] + value;
                                        else
                                            minValues[indexPoint] = minValues[indexPoint] + value;
                                    }
                                }
                                else {
                                    minValuesRight.push(0);
                                    maxValuesRight.push(0);
                                    if (indexPoint < series.values.length) {
                                        let value = series.values[indexPoint];
                                        if (value > 0)
                                            maxValuesRight[indexPoint] = maxValuesRight[indexPoint] + value;
                                        else
                                            minValuesRight[indexPoint] = minValuesRight[indexPoint] + value;
                                    }
                                }
                            }
                        }
                    }
                    let values = [
                        minValues,
                        maxValues,
                        minValuesRight,
                        maxValuesRight
                    ];
                    return values;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let seriesCollection = this.getSeries();
                    let seriesTypes = new Hashtable();
                    for (let series of seriesCollection) {
                        seriesTypes.set(series.stimulsoft().getType(), series.stimulsoft().getType());
                    }
                    let minValues = [];
                    let maxValues = [];
                    let minValuesRight = [];
                    let maxValuesRight = [];
                    for (let seriesType of seriesTypes.values) {
                        let values = this.prepareSeriesRange(seriesType);
                        let index = 0;
                        for (let value of values[0]) {
                            if (minValues.length <= index)
                                minValues.push(value);
                            else
                                minValues[index] = Math.min(minValues[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[1]) {
                            if (maxValues.length <= index)
                                maxValues.push(value);
                            else
                                maxValues[index] = Math.max(maxValues[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[2]) {
                            if (minValuesRight.length <= index)
                                minValuesRight.push(value);
                            else
                                minValuesRight[index] = Math.min(minValuesRight[index], value);
                            index++;
                        }
                        index = 0;
                        for (let value of values[3]) {
                            if (maxValuesRight.length <= index)
                                maxValuesRight.push(value);
                            else
                                maxValuesRight[index] = Math.max(maxValuesRight[index], value);
                            index++;
                        }
                    }
                    if (minValues.length == 0)
                        minValues = minValuesRight;
                    if (maxValues.length == 0)
                        maxValues = maxValuesRight;
                    if (minValuesRight.length == 0)
                        minValuesRight = minValues;
                    if (maxValuesRight.length == 0)
                        maxValuesRight = maxValues;
                    let firstValue = true;
                    for (let value of minValues) {
                        if (firstValue) {
                            specYAxis.info.minimum = value;
                            firstValue = false;
                        }
                        else
                            specYAxis.info.minimum = Math.min(value, specYAxis.info.minimum);
                    }
                    firstValue = true;
                    for (let value of maxValues) {
                        if (firstValue) {
                            specYAxis.info.maximum = value;
                            firstValue = false;
                        }
                        else
                            specYAxis.info.maximum = Math.max(value, specYAxis.info.maximum);
                    }
                    firstValue = true;
                    for (let value of minValuesRight) {
                        if (firstValue) {
                            specYRightAxis.info.minimum = value;
                            firstValue = false;
                        }
                        else
                            specYRightAxis.info.minimum = Math.min(value, specYRightAxis.info.minimum);
                    }
                    firstValue = true;
                    for (let value of maxValuesRight) {
                        if (firstValue) {
                            specYRightAxis.info.maximum = value;
                            firstValue = false;
                        }
                        else
                            specYRightAxis.info.maximum = Math.max(value, specYRightAxis.info.maximum);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedColumn");
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedColumn;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedColumnAreaCoreXF = StiStackedColumnAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedColumnAreaCoreXF extends Chart.StiStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedColumn");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedColumn;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedColumnAreaCoreXF = StiFullStackedColumnAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedAreaAreaCoreXF extends Chart.StiFullStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedAreaAreaCoreXF = StiFullStackedAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedLineAreaCoreXF extends Chart.StiFullStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedLine");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedLine;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedLineAreaCoreXF = StiFullStackedLineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedSplineAreaAreaCoreXF extends Chart.StiFullStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedSplineArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedSplineArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedSplineAreaAreaCoreXF = StiFullStackedSplineAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedSplineAreaCoreXF extends Chart.StiFullStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedSpline");
                }
                get position() {
                    return Chart.StiChartAreaPosition.FullStackedSpline;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFullStackedSplineAreaCoreXF = StiFullStackedSplineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            class StiFunnelAreaCoreXF extends Chart.StiAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Funnel");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Funnel;
                }
                render(context, rect) {
                    let areaGeom = new Chart.StiPieAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    this.renderSeries(context, rect, areaGeom, seriesCollection);
                    return areaGeom;
                }
                renderSeries(context, rect, geom, seriesCollection) {
                    let seriesTypes = [];
                    let seriesTypesHash = new Hashtable();
                    for (let ser of seriesCollection) {
                        let list = seriesTypesHash.get(ser.stimulsoft().getType());
                        if (list == null) {
                            list = [];
                            seriesTypes.push(list);
                            seriesTypesHash.set(ser.stimulsoft().getType(), list);
                        }
                        list.push(ser);
                    }
                    for (let seriesType of seriesTypes) {
                        let seriesArray = seriesType.stimulsoft().toArray();
                        seriesArray[0].core.renderSeries(context, rect, geom, seriesArray);
                    }
                }
                prepareInfo(rect) {
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiFunnelAreaCoreXF = StiFunnelAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiGanttAreaCoreXF extends Chart.StiClusteredBarAreaCoreXF {
                createStripLinesXAxis(axis) {
                    axis.info.stripLines.clear();
                    axis.info.stripLines.add2(0, 0);
                    let seriesCollection = this.getSeries();
                    for (let series of seriesCollection) {
                        for (let argument of series.arguments) {
                            let notExist = true;
                            for (let line of axis.info.stripLines.list) {
                                if (line.valueObject != null && line.valueObject.toString() == argument.toString())
                                    notExist = false;
                            }
                            if (notExist)
                                axis.info.stripLines.add2(argument, axis.info.stripLines.count);
                        }
                    }
                    axis.info.stripLines.add2("", axis.info.stripLines.count);
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    specXAxis.info.maximum = 0;
                    specXAxis.info.minimum = 0;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    let first = true;
                    for (let series of (seriesCollection)) {
                        for (let value of series.values) {
                            if (value != null) {
                                if (first) {
                                    first = false;
                                    specYAxis.info.maximum = value;
                                    specYAxis.info.minimum = value;
                                }
                                else {
                                    specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                    specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                                }
                            }
                        }
                        for (let value of series.valuesEnd) {
                            if (value != null) {
                                specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                            }
                        }
                    }
                    specYRightAxis.info.maximum = specYAxis.info.maximum;
                    specYRightAxis.info.minimum = specYAxis.info.minimum;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Gantt");
                }
                get seriesOrientation() {
                    return Chart.StiChartSeriesOrientation.Horizontal;
                }
                get position() {
                    return Chart.StiChartAreaPosition.Gantt;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiGanttAreaCoreXF = StiGanttAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiPictorialAreaCoreXF extends Chart.StiAreaCoreXF {
                render(context, rect) {
                    let pictorialAreaGeom = new Chart.StiPictorialAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    context.pushTranslateTransform(rect.x, rect.y);
                    if (seriesCollection.length > 0)
                        seriesCollection[0].core.renderSeries(context, new RectangleD(0, 0, rect.width, rect.height), pictorialAreaGeom, seriesCollection.stimulsoft().toArray());
                    context.popTransform();
                    return pictorialAreaGeom;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Pictorial");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Pictorial;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiPictorialAreaCoreXF = StiPictorialAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiRadarAreaCoreXF extends Chart.StiAreaCoreXF {
                constructor(area) {
                    super(area);
                    this.valuesCount = 0;
                    this.points = [];
                    this.arguments = [];
                    this.centerPoint = PointD.empty;
                }
                applyStyle(style) {
                    super.applyStyle(style);
                    let radarArea = this.area;
                    if (radarArea.allowApplyStyle) {
                        if (radarArea.interlacingHor != null)
                            radarArea.interlacingHor.core.applyStyle(style);
                        if (radarArea.interlacingVert != null)
                            radarArea.interlacingVert.core.applyStyle(style);
                        if (radarArea.gridLinesHor != null)
                            radarArea.gridLinesHor.core.applyStyle(style);
                        if (radarArea.gridLinesVert != null)
                            radarArea.gridLinesVert.core.applyStyle(style);
                        if (radarArea.xAxis != null)
                            radarArea.xAxis.core.applyStyle(style);
                        if (radarArea.yAxis != null)
                            radarArea.yAxis.core.applyStyle(style);
                        radarArea.brush = new StiEmptyBrush();
                    }
                }
                render(context, areaRect) {
                    let radarArea = this.area;
                    let rect = areaRect.clone();
                    rect = StiRadarAreaCoreXF.centerArea(rect);
                    this.prepareInfo(rect);
                    rect = this.measureLabels(context, rect).clone();
                    rect = StiRadarAreaCoreXF.centerArea(rect).clone();
                    rect = new RectangleD(areaRect.x + (areaRect.width - rect.width) / 2, areaRect.y + (areaRect.height - rect.height) / 2, rect.width, rect.height);
                    this.prepareInfo(rect);
                    let areaGeom = new Chart.StiRadarAreaGeom(this.area, rect, this.valuesCount);
                    let axisGeom = radarArea.yAxis.yCore.render(context, rect);
                    if (axisGeom != null) {
                        areaGeom.createChildGeoms();
                        areaGeom.childGeoms.push(axisGeom);
                    }
                    if (this.area.chart.series.count > 0)
                        this.renderArguments(context, areaGeom, this.area.chart.series.getByIndex(0));
                    let seriesCollection = this.getSeries();
                    this.renderSeries(context, rect, areaGeom, seriesCollection);
                    return areaGeom;
                }
                static centerArea(rect) {
                    if (rect.width > rect.height)
                        rect.width = rect.height;
                    else
                        rect.height = rect.width;
                    return rect;
                }
                measureLabels(context, rect) {
                    if (this.valuesCount == 0)
                        return rect;
                    let radarArea = this.area;
                    if (radarArea.xAxis != null && radarArea.xAxis.visible && radarArea.yAxis.info.stripPositions != null) {
                        let radius = radarArea.yAxis.info.stripPositions[radarArea.yAxis.info.stripPositions.length - 1] + 4 * context.options.zoom;
                        let pointIndex = 0;
                        let arc = 360 / this.valuesCount;
                        let angle = 0;
                        let areaRect = rect.clone();
                        for (let curPoint of this.points) {
                            let argument = pointIndex < this.arguments.length ? this.arguments[pointIndex] : null;
                            let point = new PointD(this.centerPoint.x + radius * curPoint.x, this.centerPoint.y + radius * curPoint.y);
                            let argumentText = radarArea.xAxis.core.getLabelText(argument);
                            let labelRect = radarArea.xAxis.xCore.getLabelRect(context, point, argumentText, angle).clone();
                            if (!labelRect.isEmpty)
                                areaRect = RectangleD.union(areaRect, labelRect);
                            angle += arc;
                            pointIndex++;
                        }
                        let distLeft = rect.left - areaRect.left;
                        let distRight = areaRect.right - rect.right;
                        let distTop = rect.top - areaRect.top;
                        let distBottom = areaRect.bottom - rect.bottom;
                        if (distLeft > 0)
                            rect.width -= distLeft;
                        if (distRight > 0)
                            rect.width -= distRight;
                        if (distTop > 0)
                            rect.height -= distTop;
                        if (distBottom > 0)
                            rect.height -= distBottom;
                    }
                    return rect;
                }
                renderArguments(context, geom, series) {
                    if (this.valuesCount == 0)
                        return;
                    let radarArea = this.area;
                    if (radarArea.xAxis != null && radarArea.xAxis.visible && radarArea.yAxis.info.stripPositions != null) {
                        let radius = radarArea.yAxis.info.stripPositions[radarArea.yAxis.info.stripPositions.length - 1] + 4 * context.options.zoom;
                        let pointIndex = 0;
                        let arc = 360 / this.valuesCount;
                        let angle = 0;
                        for (let curPoint of this.points) {
                            let argument = pointIndex < this.arguments.length ? this.arguments[pointIndex] : null;
                            let point = new PointD(this.centerPoint.x + radius * curPoint.x, this.centerPoint.y + radius * curPoint.y);
                            point.x -= geom.clientRectangle.x;
                            point.y -= geom.clientRectangle.y;
                            let labelGeom = radarArea.xAxis.xCore.renderLabel(context, series, point, argument, angle, pointIndex, this.valuesCount);
                            if (labelGeom != null) {
                                geom.createChildGeoms();
                                geom.childGeoms.push(labelGeom);
                            }
                            angle += arc;
                            pointIndex++;
                        }
                    }
                }
                renderSeries(context, rect, geom, seriesCollection) {
                    let seriesTypes = [];
                    let seriesTypesHash = new Hashtable();
                    for (let ser of seriesCollection) {
                        let list = seriesTypesHash.get(ser.stimulsoft().getType());
                        if (list == null) {
                            list = [];
                            seriesTypes.push(list);
                            seriesTypesHash.set(ser.stimulsoft().getType(), list);
                        }
                        list.push(ser);
                    }
                    for (let seriesType of seriesTypes) {
                        let seriesArray = seriesType.stimulsoft().toArray();
                        seriesArray[0].core.renderSeries(context, rect, geom, seriesArray);
                    }
                }
                prepareInfo(rect) {
                    let radarArea = this.area;
                    this.valuesCount = 0;
                    let seriesCollection = this.getSeries();
                    if (seriesCollection.length > 0) {
                        for (let index = 0; index < seriesCollection.length; index++) {
                            let values = seriesCollection[index].values;
                            if (values != null) {
                                this.valuesCount = Math.max(values.length, this.valuesCount);
                            }
                        }
                    }
                    this.arguments = [];
                    if (seriesCollection.length > 0) {
                        let curSeries = seriesCollection[0];
                        for (let series of seriesCollection) {
                            if (series.arguments.length == this.valuesCount) {
                                curSeries = series;
                                break;
                            }
                        }
                        for (let index = 0; index < this.valuesCount; index++) {
                            if (index < curSeries.arguments.length)
                                this.arguments.push(curSeries.arguments[index].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator));
                        }
                    }
                    else {
                        this.arguments.push("1");
                        this.arguments.push("2");
                        this.arguments.push("3");
                        this.arguments.push("4");
                        this.arguments.push("5");
                    }
                    this.centerPoint = new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2);
                    let arc;
                    if (this.valuesCount > 0)
                        arc = 360 / this.valuesCount;
                    else
                        arc = 360 / 5;
                    this.points = [];
                    let angle = 0;
                    while (angle < 360) {
                        let radAngle = ((angle - 90) * Math.PI / 180);
                        let endPoint = new PointD(Math.cos(radAngle), Math.sin(radAngle));
                        this.points.push(endPoint);
                        angle += arc;
                        if (this.points.length == this.valuesCount)
                            break;
                    }
                    let minimum = 0;
                    let maximum = 0;
                    if (radarArea.yAxis.range.auto) {
                        let firstValue = true;
                        for (let index = 0; index < seriesCollection.length; index++) {
                            let values = seriesCollection[index].values;
                            if (values != null) {
                                for (let value of values) {
                                    if (value == null)
                                        continue;
                                    if (firstValue) {
                                        minimum = value;
                                        maximum = value;
                                        firstValue = false;
                                    }
                                    else {
                                        minimum = Math.min(minimum, value);
                                        maximum = Math.max(maximum, value);
                                    }
                                }
                            }
                        }
                        if (seriesCollection.length == 0)
                            maximum = 1;
                        if (Math.abs(minimum) > maximum)
                            maximum = Math.abs(minimum);
                        if (maximum == 0 && minimum == 0)
                            maximum = 1;
                        minimum = 0;
                    }
                    else {
                        minimum = radarArea.yAxis.range.minimum;
                        maximum = radarArea.yAxis.range.maximum;
                    }
                    this.createStripLinesAxis(radarArea.yAxis, minimum, maximum);
                    if (radarArea.yAxis.info.stripLines != null && radarArea.yAxis.info.stripLines.count > 0) {
                        radarArea.yAxis.info.minimum = radarArea.yAxis.info.stripLines.getByIndex(radarArea.yAxis.info.stripLines.count - 1).value;
                        radarArea.yAxis.info.maximum = radarArea.yAxis.info.stripLines.getByIndex(0).value;
                    }
                    radarArea.yAxis.info.dpi = rect.height * 0.5 / radarArea.yAxis.info.range;
                    this.calculateStep(radarArea.yAxis, 0, rect.height / 2);
                    let REFlabelsCollection = { ref: radarArea.yAxis.info.labelsCollection };
                    this.calculatePositions(radarArea.yAxis, REFlabelsCollection, radarArea.yAxis.labels.step > 0 ? Math.trunc(radarArea.yAxis.labels.step) : 1, false);
                    radarArea.yAxis.info.labelsCollection = REFlabelsCollection.ref;
                    let REFticksCollection = { ref: radarArea.yAxis.info.ticksCollection };
                    this.calculatePositions(radarArea.yAxis, REFticksCollection, radarArea.yAxis.ticks.step > 0 ? Math.trunc(radarArea.yAxis.ticks.step) : 1, true);
                    radarArea.yAxis.info.ticksCollection = REFticksCollection.ref;
                }
                createStripLinesAxis(axis, minimum, maximum) {
                    let radarArea = this.area;
                    let step = radarArea.yAxis.labels.step;
                    if (step == 0)
                        step = Chart.StiStripLineCalculatorXF.getInterval(minimum, maximum, 6);
                    radarArea.yAxis.info.stripLines = Chart.StiStripLineCalculatorXF.getStripLines(minimum, maximum, step, false);
                    for (let stripLine of radarArea.yAxis.info.stripLines.list) {
                        stripLine.valueObject = StiString.format("{0}", stripLine.valueObject);
                    }
                }
                calculateStep(axis, topPosition, bottomPosition) {
                    if (axis.info.stripLines.count >= 2) {
                        axis.info.step = Math.abs(((axis.info.stripLines.getByIndex(1).value - axis.info.stripLines.getByIndex(0).value) * axis.info.dpi));
                        axis.yCore.calculateStripPositions(topPosition, bottomPosition);
                    }
                    else
                        axis.info.step = 1;
                }
                calculatePositions(axis, REFcollection, step, calculationForTicks) {
                    let collection = [];
                    let stepIndex = 0;
                    if (axis.info.stripPositions != null) {
                        let length = axis.info.stripPositions.length;
                        for (let index = 0; index < length; index++) {
                            if (stepIndex == 0) {
                                let label = new Chart.StiStripPositionXF();
                                let stripIndex = index;
                                label.stripLine = axis.info.stripLines.getByIndex(stripIndex);
                                label.position = axis.info.stripPositions[stripIndex];
                                collection.push(label);
                            }
                            stepIndex++;
                            if (stepIndex == step || !calculationForTicks)
                                stepIndex = 0;
                        }
                    }
                    REFcollection.ref = collection;
                }
            }
            Chart.StiRadarAreaCoreXF = StiRadarAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarAreaAreaCoreXF extends Chart.StiRadarAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.RadarArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiRadarAreaAreaCoreXF = StiRadarAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarLineAreaCoreXF extends Chart.StiRadarAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarLine");
                }
                get position() {
                    return Chart.StiChartAreaPosition.RadarLine;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiRadarLineAreaCoreXF = StiRadarLineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarPointAreaCoreXF extends Chart.StiRadarAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarPoint");
                }
                get position() {
                    return Chart.StiChartAreaPosition.RadarPoint;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiRadarPointAreaCoreXF = StiRadarPointAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRangeAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Range");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Range;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let firstLeft = true;
                    let firstRight = true;
                    let seriesLeftAxisY = false;
                    let seriesRightAxisY = false;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    specYRightAxis.info.maximum = 0;
                    specYRightAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let series = seriesCollection[index];
                        let values = series.values;
                        let valuesEnd = series.valuesEnd;
                        let count = Math.min(values.length, valuesEnd.length);
                        for (let indexValues = 0; indexValues < count; indexValues++) {
                            let value = values[indexValues] != null ? values[indexValues].stimulsoft().toNumber() : 0;
                            let valueEnd = valuesEnd[indexValues] != null ? valuesEnd[indexValues].stimulsoft().toNumber() : 0;
                            let valueMax = Math.max(value, valueEnd);
                            let valueMin = Math.min(value, valueEnd);
                            if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                if (firstLeft) {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = valueMax;
                                    specYAxis.info.minimum = valueMin;
                                    firstLeft = false;
                                }
                                else {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = Math.max(valueMax, specYAxis.info.maximum);
                                    specYAxis.info.minimum = Math.min(valueMin, specYAxis.info.minimum);
                                }
                            }
                            else {
                                if (firstRight) {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = valueMax;
                                    specYRightAxis.info.minimum = valueMin;
                                    firstRight = false;
                                }
                                else {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = Math.max(valueMax, specYRightAxis.info.maximum);
                                    specYRightAxis.info.minimum = Math.min(valueMin, specYRightAxis.info.minimum);
                                }
                            }
                        }
                    }
                    if (!seriesLeftAxisY) {
                        specYAxis.info.maximum = specYRightAxis.info.maximum;
                        specYAxis.info.minimum = specYRightAxis.info.minimum;
                    }
                    if (!seriesRightAxisY) {
                        specYRightAxis.info.maximum = specYAxis.info.maximum;
                        specYRightAxis.info.minimum = specYAxis.info.minimum;
                    }
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiRangeAreaCoreXF = StiRangeAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRangeBarAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                createStripLinesXAxis(axis) {
                    axis.info.stripLines.clear();
                    axis.info.stripLines.add2(0, 0);
                    let seriesCollection = this.getSeries();
                    for (let series of seriesCollection) {
                        for (let argument of series.arguments) {
                            let notExist = true;
                            for (let line of axis.info.stripLines.list) {
                                if (line.valueObject.toString() == argument.toString())
                                    notExist = false;
                            }
                            if (notExist)
                                axis.info.stripLines.add2(argument, axis.info.stripLines.count);
                        }
                    }
                    axis.info.stripLines.add2("", axis.info.stripLines.count);
                    if (axis.info.stripLines.count > 0) {
                        if (!axis.area.xAxis.showEdgeValues) {
                            axis.info.stripLines.getByIndex(0).valueObject = "";
                            axis.info.stripLines.getByIndex(axis.info.stripLines.count - 1).valueObject = "";
                        }
                    }
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    specXAxis.info.maximum = 0;
                    specXAxis.info.minimum = 0;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    let first = true;
                    for (let series of (seriesCollection)) {
                        for (let value of series.values) {
                            if (value != null) {
                                if (first) {
                                    first = false;
                                    specYAxis.info.maximum = value;
                                    specYAxis.info.minimum = value;
                                }
                                else {
                                    specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                    specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                                }
                            }
                        }
                        for (let value of series.valuesEnd) {
                            if (value != null) {
                                specYAxis.info.maximum = Math.max(specYAxis.info.maximum, value);
                                specYAxis.info.minimum = Math.min(specYAxis.info.minimum, value);
                            }
                        }
                    }
                    specYRightAxis.info.maximum = specYAxis.info.maximum;
                    specYRightAxis.info.minimum = specYAxis.info.minimum;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "RangeBar");
                }
                get position() {
                    return Chart.StiChartAreaPosition.RangeBar;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiRangeBarAreaCoreXF = StiRangeBarAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSplineRangeAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "SplineRange");
                }
                get position() {
                    return Chart.StiChartAreaPosition.SplineRange;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let firstLeft = true;
                    let firstRight = true;
                    let seriesLeftAxisY = false;
                    let seriesRightAxisY = false;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    specYRightAxis.info.maximum = 0;
                    specYRightAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let series = seriesCollection[index];
                        let values = series.values;
                        let valuesEnd = series.valuesEnd;
                        let count = Math.min(values.length, valuesEnd.length);
                        for (let indexValues = 0; indexValues < count; indexValues++) {
                            let value = values[indexValues] != null ? values[indexValues].stimulsoft().toNumber() : 0;
                            let valueEnd = valuesEnd[indexValues] != null ? valuesEnd[indexValues].stimulsoft().toNumber() : 0;
                            let valueMax = Math.max(value, valueEnd);
                            let valueMin = Math.min(value, valueEnd);
                            if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                if (firstLeft) {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = valueMax;
                                    specYAxis.info.minimum = valueMin;
                                    firstLeft = false;
                                }
                                else {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = Math.max(valueMax, specYAxis.info.maximum);
                                    specYAxis.info.minimum = Math.min(valueMin, specYAxis.info.minimum);
                                }
                            }
                            else {
                                if (firstRight) {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = valueMax;
                                    specYRightAxis.info.minimum = valueMin;
                                    firstRight = false;
                                }
                                else {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = Math.max(valueMax, specYRightAxis.info.maximum);
                                    specYRightAxis.info.minimum = Math.min(valueMin, specYRightAxis.info.minimum);
                                }
                            }
                        }
                    }
                    if (!seriesLeftAxisY) {
                        specYAxis.info.maximum = specYRightAxis.info.maximum;
                        specYAxis.info.minimum = specYRightAxis.info.minimum;
                    }
                    if (!seriesRightAxisY) {
                        specYRightAxis.info.maximum = specYAxis.info.maximum;
                        specYRightAxis.info.minimum = specYAxis.info.minimum;
                    }
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSplineRangeAreaCoreXF = StiSplineRangeAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSteppedRangeAreaCoreXF extends Chart.StiClusteredColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedRange");
                }
                get position() {
                    return Chart.StiChartAreaPosition.SteppedRange;
                }
                prepareRange(specXAxis, specXTopAxis, specYAxis, specYRightAxis) {
                    let firstLeft = true;
                    let firstRight = true;
                    let seriesLeftAxisY = false;
                    let seriesRightAxisY = false;
                    specYAxis.info.maximum = 0;
                    specYAxis.info.minimum = 0;
                    specYRightAxis.info.maximum = 0;
                    specYRightAxis.info.minimum = 0;
                    let seriesCollection = this.getSeries();
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let series = seriesCollection[index];
                        let values = series.values;
                        let valuesEnd = series.valuesEnd;
                        let count = Math.min(values.length, valuesEnd.length);
                        for (let indexValues = 0; indexValues < count; indexValues++) {
                            let value = values[indexValues] != null ? values[indexValues].stimulsoft().toNumber() : 0;
                            let valueEnd = valuesEnd[indexValues] != null ? valuesEnd[indexValues].stimulsoft().toNumber() : 0;
                            let valueMax = Math.max(value, valueEnd);
                            let valueMin = Math.min(value, valueEnd);
                            if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                if (firstLeft) {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = valueMax;
                                    specYAxis.info.minimum = valueMin;
                                    firstLeft = false;
                                }
                                else {
                                    seriesLeftAxisY = true;
                                    specYAxis.info.maximum = Math.max(valueMax, specYAxis.info.maximum);
                                    specYAxis.info.minimum = Math.min(valueMin, specYAxis.info.minimum);
                                }
                            }
                            else {
                                if (firstRight) {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = valueMax;
                                    specYRightAxis.info.minimum = valueMin;
                                    firstRight = false;
                                }
                                else {
                                    seriesRightAxisY = true;
                                    specYRightAxis.info.maximum = Math.max(valueMax, specYRightAxis.info.maximum);
                                    specYRightAxis.info.minimum = Math.min(valueMin, specYRightAxis.info.minimum);
                                }
                            }
                        }
                    }
                    if (!seriesLeftAxisY) {
                        specYAxis.info.maximum = specYRightAxis.info.maximum;
                        specYAxis.info.minimum = specYRightAxis.info.minimum;
                    }
                    if (!seriesRightAxisY) {
                        specYRightAxis.info.maximum = specYAxis.info.maximum;
                        specYRightAxis.info.minimum = specYAxis.info.minimum;
                    }
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSteppedRangeAreaCoreXF = StiSteppedRangeAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedAreaAreaCoreXF extends Chart.StiStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedAreaAreaCoreXF = StiStackedAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedLineAreaCoreXF extends Chart.StiStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedLine");
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedLine;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedLineAreaCoreXF = StiStackedLineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedSplineAreaAreaCoreXF extends Chart.StiStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedSplineArea");
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedSplineArea;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedSplineAreaAreaCoreXF = StiStackedSplineAreaAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedSplineAreaCoreXF extends Chart.StiStackedColumnAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedSpline");
                }
                get position() {
                    return Chart.StiChartAreaPosition.StackedSpline;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStackedSplineAreaCoreXF = StiStackedSplineAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStockAreaCoreXF extends Chart.StiCandlestickAreaCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Stock");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Stock;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiStockAreaCoreXF = StiStockAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSunburstAreaCoreXF extends Chart.StiAreaCoreXF {
                render(context, rect) {
                    let areaGeom = new Chart.StiSunburstAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    if (seriesCollection.length > 0)
                        seriesCollection[0].core.renderSeries(context, rect, areaGeom, seriesCollection);
                    return areaGeom;
                }
                prepareInfo(rect) {
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Sunburst");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Sunburst;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiSunburstAreaCoreXF = StiSunburstAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiValueHelper = Stimulsoft.Base.Helpers.StiValueHelper;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiTreemapAreaCoreXF extends Chart.StiAreaCoreXF {
                render(context, rect) {
                    let treeAreaGeom = new Chart.StiTreemapAreaGeom(this.area, rect);
                    let seriesCollection = this.getSeries();
                    let mergedData = [];
                    for (let series of seriesCollection) {
                        let listValues = [];
                        for (let value of series.values)
                            listValues.push(StiValueHelper.tryToNumber(value));
                        mergedData.push(listValues.stimulsoft().toList().sum());
                    }
                    let rectSeries = new RectangleD(0, 0, rect.width, rect.height);
                    let normalizeData = this.area.core.normalizeDataForArea(mergedData, rectSeries.width * rectSeries.height);
                    let rects = this.area.core.squarify(normalizeData, [], rectSeries, []);
                    this.renderSeries(context, rects, rectSeries, treeAreaGeom, seriesCollection);
                    return treeAreaGeom;
                }
                renderSeries(context, boxes, boxRoot, geom, seriesCollection) {
                    for (let index = 0; index < seriesCollection.length; index++) {
                        if (boxes.length - 1 >= index)
                            seriesCollection[index].core.renderSeries(context, boxes[index], geom, seriesCollection.stimulsoft().toArray());
                    }
                }
                cutArea(container, area) {
                    let newcontainer;
                    if (container.width >= container.height) {
                        let areawidth = area / container.height;
                        let newwidth = container.width - areawidth;
                        newcontainer = new RectangleD(container.x + areawidth, container.y, newwidth, container.height);
                    }
                    else {
                        let areaheight = area / container.width;
                        let newheight = container.height - areaheight;
                        newcontainer = new RectangleD(container.x, container.y + areaheight, container.width, newheight);
                    }
                    return newcontainer;
                }
                squarify(data, currentrow, container, stack) {
                    if (data.length == 0) {
                        stack.stimulsoft().addRange(this.getCoordinates(container, currentrow));
                        return stack;
                    }
                    let length = Math.min(container.width, container.height);
                    let nextdatapoint = data[0];
                    if (this.improvesRatio(currentrow, nextdatapoint, length)) {
                        currentrow.push(nextdatapoint);
                        this.squarify(data.stimulsoft().toList().skip(1), currentrow, container, stack);
                    }
                    else {
                        let newcontainer = this.cutArea(container, currentrow.stimulsoft().toList().sum());
                        stack.stimulsoft().addRange(this.getCoordinates(container, currentrow));
                        let newRow = [];
                        this.squarify(data, newRow, newcontainer, stack);
                    }
                    return stack;
                }
                improvesRatio(currentrow, nextnode, length) {
                    if (currentrow.length == 0) {
                        return true;
                    }
                    let newrow = currentrow.stimulsoft().clone();
                    newrow.push(nextnode);
                    let currentratio = this.calculateRatio(currentrow, length);
                    let newratio = this.calculateRatio(newrow, length);
                    return currentratio >= newratio;
                }
                calculateRatio(row, length) {
                    let sum = row.stimulsoft().toList().sum();
                    let v1 = Math.pow(length, 2) * row.stimulsoft().toList().max() / Math.pow(sum, 2);
                    let v2 = Math.pow(sum, 2) / (Math.pow(length, 2) * row.stimulsoft().toList().min());
                    return Math.max(v1, v2);
                }
                normalizeDataForArea(data, area) {
                    let normalizeddata = [];
                    let sum = data.stimulsoft().toList().sum();
                    if (sum == 0)
                        return normalizeddata;
                    let multiplier = area / sum;
                    for (let index = 0; index < data.length; index++) {
                        normalizeddata.push(data[index] * multiplier);
                    }
                    return normalizeddata;
                }
                getCoordinates(rootContainer, rowData) {
                    let coordinates = [];
                    let subxoffset = rootContainer.x;
                    let subyoffset = rootContainer.y;
                    let areawidth = rowData.stimulsoft().toList().sum() / rootContainer.height;
                    let areaheight = rowData.stimulsoft().toList().sum() / rootContainer.width;
                    if (rootContainer.width >= rootContainer.height) {
                        for (let i = 0; i < rowData.length; i++) {
                            coordinates.push(new RectangleD(subxoffset, subyoffset, areawidth, (rowData[i] / areawidth)));
                            subyoffset = subyoffset + rowData[i] / areawidth;
                        }
                    }
                    else {
                        for (let i = 0; i < rowData.length; i++) {
                            coordinates.push(new RectangleD(subxoffset, subyoffset, (rowData[i] / areaheight), areaheight));
                            subxoffset = subxoffset + (rowData[i] / areaheight);
                        }
                    }
                    return coordinates;
                }
                prepareInfo(rect) {
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Treemap");
                }
                get position() {
                    return Chart.StiChartAreaPosition.Treemap;
                }
                constructor(area) {
                    super(area);
                }
            }
            Chart.StiTreemapAreaCoreXF = StiTreemapAreaCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
            var SizeD = Stimulsoft.System.Drawing.Size;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisCoreXF {
                constructor(axis) {
                    this._isMouseOverDecreaseButton = false;
                    this._isMouseOverIncreaseButton = false;
                    this._isMouseOverTrackBar = false;
                    this._axis = axis;
                }
                implements() {
                    if (!StiAxisCoreXF.implementsStiAxisCoreXF)
                        StiAxisCoreXF.implementsStiAxisCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiAxisCoreXF
                        ];
                    return StiAxisCoreXF.implementsStiAxisCoreXF;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get isMouseOverDecreaseButton() {
                    return this._isMouseOverDecreaseButton;
                }
                set isMouseOverDecreaseButton(value) {
                    this._isMouseOverDecreaseButton = value;
                }
                get isMouseOverIncreaseButton() {
                    return this._isMouseOverIncreaseButton;
                }
                set isMouseOverIncreaseButton(value) {
                    this._isMouseOverIncreaseButton = value;
                }
                get isMouseOverTrackBar() {
                    return this._isMouseOverTrackBar;
                }
                set isMouseOverTrackBar(value) {
                    this._isMouseOverTrackBar = value;
                }
                applyStyle(style) {
                    if (this.axis.allowApplyStyle) {
                        this.axis.lineColor = style.core.axisLineColor;
                        this.axis.labels.core.applyStyle(style);
                        this.axis.title.core.applyStyle(style);
                    }
                }
                getStartFromZero() {
                    if (this.axis.area.axisCore.valuesCount == 1)
                        return true;
                    if (this.axis != null && this.axis.range != null && (!this.axis.range.auto))
                        return true;
                    return this.axis != null ? this.axis.startFromZero : true;
                }
                render(context, rect) {
                    return null;
                }
                renderView(context, rect) {
                    return null;
                }
                calculateStripPositions(topPosition, bottomPosition) {
                    bottomPosition -= topPosition;
                    topPosition = 0;
                    if (this.axis.info.stripLines == null || this.axis.info.stripLines.count < 2) {
                        this.axis.info.stripPositions = [];
                    }
                    else {
                        let isScatterSeries = false;
                        if (this.axis.area.chart.series.count > 0 && this.axis.area.chart.series.getByIndex(0).is(Chart.StiScatterSeries))
                            isScatterSeries = true;
                        if (this.axis.logarithmicScale && isScatterSeries) {
                            let countStrip = this.axis.info.stripLines.count;
                            this.axis.info.stripPositions = StiArray.create(Number, this.axis.info.stripLines.count);
                            this.axis.info.stripPositions[0] = topPosition;
                            this.axis.info.stripPositions[this.axis.info.stripPositions.length - 1] = bottomPosition;
                            let startValue = this.axis.info.stripLines.getByIndex(0).value;
                            let endValue = this.axis.info.stripLines.getByIndex(countStrip - 1).value;
                            let decadeX = bottomPosition / (Math.log10(endValue) - Math.log10(startValue));
                            for (let index = 1; index < this.axis.info.stripPositions.length - 1; index++) {
                                let x = Math.abs(Math.log10(Math.abs(this.axis.info.stripLines.getByIndex(index).value)) * decadeX
                                    - Math.log10(Math.abs(this.axis.info.stripLines.getByIndex(index - 1).value)) * decadeX);
                                this.axis.info.stripPositions[index] = topPosition + x;
                                topPosition = this.axis.info.stripPositions[index];
                            }
                        }
                        else {
                            this.axis.info.stripPositions = StiArray.create(Number, this.axis.info.stripLines.count);
                            this.axis.info.stripPositions[0] = topPosition;
                            this.axis.info.stripPositions[this.axis.info.stripPositions.length - 1] = bottomPosition;
                            for (let index = 1; index < this.axis.info.stripPositions.length - 1; index++) {
                                this.axis.info.stripPositions[index] = topPosition + index * this.axis.info.step;
                            }
                        }
                    }
                }
                getTicksMaxLength(context) {
                    return this.axis.core.ticksMaxLength * context.options.zoom;
                }
                getArrowHeight(context) {
                    return this.axis.core.arrowHeight * 4 * context.options.zoom;
                }
                getLabelsSpaceAxis(context) {
                    return 5 * context.options.zoom;
                }
                getLabelsTwoLinesDestination(context) {
                    return this.axis.labels.font.sizeInPoints * 2 * context.options.zoom;
                }
                getFontGeom(context) {
                    let font = StiFontGeom.changeFontSize(this.axis.labels.font, this.axis.labels.font.size * context.options.zoom);
                    return font;
                }
                getTextAlignment() {
                    if (this.axis.is(Chart.IStiYAxis)) {
                        let yAxis = this.axis;
                        if (this.axis.labels.placement == Chart.StiLabelsPlacement.TwoLines) {
                            if (yAxis.core.isLeftSide)
                                return StiHorAlignment.Right;
                            if (yAxis.core.isRightSide)
                                return StiHorAlignment.Left;
                        }
                    }
                    return this.axis.labels.textAlignment;
                }
                getStringFormatGeom(context) {
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    if (!this.axis.labels.wordWrap)
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    if (this.axis.labels.width > 0) {
                        let alignment = this.getTextAlignment();
                        if (alignment == StiHorAlignment.Left)
                            sf.alignment = StringAlignment.Near;
                        else if (alignment == StiHorAlignment.Right)
                            sf.alignment = StringAlignment.Far;
                        else if (alignment == StiHorAlignment.Center)
                            sf.alignment = StringAlignment.Center;
                    }
                    return sf;
                }
                getAxisTitleSize(context) {
                    if (StiString.isNullOrEmpty(this.axis.title.text))
                        return SizeD.empty;
                    let font = StiFontGeom.changeFontSize(this.axis.title.font, this.axis.title.font.size * context.options.zoom);
                    let sizeD = context.measureString(this.axis.title.text, font);
                    switch (this.axis.title.direction) {
                        case Chart.StiDirection.LeftToRight:
                        case Chart.StiDirection.RightToLeft:
                            return sizeD;
                        case Chart.StiDirection.BottomToTop:
                        case Chart.StiDirection.TopToBottom:
                            return new SizeD(sizeD.height, sizeD.width);
                    }
                    return SizeD.empty;
                }
                getAngleTitle() {
                    let angle = 0;
                    switch (this.axis.title.direction) {
                        case Chart.StiDirection.LeftToRight:
                            angle = 0;
                            break;
                        case Chart.StiDirection.RightToLeft:
                            angle = 180;
                            break;
                        case Chart.StiDirection.BottomToTop:
                            angle = -90;
                            break;
                        case Chart.StiDirection.TopToBottom:
                            angle = 90;
                            break;
                    }
                    return angle;
                }
                getCorrectionFontSize(axisRect, titleRect, currentFontSize) {
                    switch (this.axis.title.direction) {
                        case Chart.StiDirection.LeftToRight:
                        case Chart.StiDirection.RightToLeft:
                            if (axisRect.width < titleRect.width) {
                                currentFontSize = axisRect.width / titleRect.width * currentFontSize;
                            }
                            break;
                        case Chart.StiDirection.BottomToTop:
                        case Chart.StiDirection.TopToBottom:
                            if (axisRect.height < titleRect.height) {
                                currentFontSize = axisRect.height / titleRect.height * currentFontSize;
                            }
                            break;
                    }
                    return currentFontSize;
                }
                checkUseMaxWidth(axisRect, titleRect, RefMaxWidth) {
                    RefMaxWidth.ref = 0;
                    switch (this.axis.title.direction) {
                        case Chart.StiDirection.LeftToRight:
                        case Chart.StiDirection.RightToLeft:
                            if (axisRect.width < titleRect.width) {
                                RefMaxWidth.ref = axisRect.width;
                                return true;
                            }
                            break;
                        case Chart.StiDirection.BottomToTop:
                        case Chart.StiDirection.TopToBottom:
                            if (axisRect.height < titleRect.height) {
                                RefMaxWidth.ref = axisRect.width;
                                return true;
                            }
                            break;
                    }
                    return false;
                }
                get ticksMaxLength() {
                    if (this.axis.visible) {
                        return Math.max(this.axis.ticks.visible ? this.axis.ticks.length : 0, this.axis.ticks.minorVisible ? this.axis.ticks.minorLength : 0);
                    }
                    else
                        return 0;
                }
                get arrowWidth() {
                    return 3;
                }
                get arrowHeight() {
                    if (this.is(Chart.StiXAxisCoreXF)) {
                        if (this.axis.area.reverseHor)
                            return -5;
                        else
                            return 5;
                    }
                    if (this.is(Chart.StiYAxisCoreXF)) {
                        if (this.axis.area.reverseVert)
                            return -5;
                        else
                            return 5;
                    }
                    return 0;
                }
                get axis() {
                    return this._axis;
                }
                set axis(value) {
                    this._axis = value;
                }
                get info() {
                    return this.axis.info;
                }
                set info(value) {
                    this.axis.info = value;
                }
            }
            StiAxisCoreXF.defaultScrollBarSize = 12;
            StiAxisCoreXF.defaultScrollBarSmallFactor = 0.01;
            StiAxisCoreXF.defaultScrollBarFirstRecallTime = 0.3;
            StiAxisCoreXF.defaultScrollBarOtherRecallTime = 0.05;
            Chart.StiAxisCoreXF = StiAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisInfoXF {
                constructor() {
                    this.dpi = 0;
                    this.step = 0;
                    this.stripPositions = null;
                    this.ticksCollection = null;
                    this.labelsCollection = null;
                    this.minimum = 0;
                    this._maximum = 0;
                }
                implements() {
                    if (!StiAxisInfoXF.implementsStiAxisInfoXF)
                        StiAxisInfoXF.implementsStiAxisInfoXF = [
                            ICloneable,
                            Chart.IStiAxisInfoXF
                        ];
                    return StiAxisInfoXF.implementsStiAxisInfoXF;
                }
                clone() {
                    let axis = this.stimulsoft().memberwiseClone();
                    axis.stripLines = this.stripLines.clone();
                    return axis;
                }
                get range() {
                    return this.maximum - this.minimum;
                }
                get maximum() {
                    return this._maximum;
                }
                set maximum(value) {
                    this._maximum = value;
                }
            }
            Chart.StiAxisInfoXF = StiAxisInfoXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiAxisLabelInfoXF {
                constructor() {
                    this.clientRectangle = RectangleD.empty;
                    this.textPoint = PointD.empty;
                }
            }
            Chart.StiAxisLabelInfoXF = StiAxisLabelInfoXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisLabelsCoreXF {
                constructor(labels) {
                    this._labels = labels;
                }
                implements() {
                    if (!StiAxisLabelsCoreXF.implementsStiAxisLabelsCoreXF)
                        StiAxisLabelsCoreXF.implementsStiAxisLabelsCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiAxisLabelsCoreXF
                        ];
                    return StiAxisLabelsCoreXF.implementsStiAxisLabelsCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.labels.allowApplyStyle) {
                        this.labels.color = style.core.axisLabelsColor;
                    }
                }
                get labels() {
                    return this._labels;
                }
                set labels(value) {
                    this._labels = value;
                }
            }
            Chart.StiAxisLabelsCoreXF = StiAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAxisTitleCoreXF {
                constructor(title) {
                    this._title = title;
                }
                implements() {
                    if (!StiAxisTitleCoreXF.implementsStiAxisTitleCoreXF)
                        StiAxisTitleCoreXF.implementsStiAxisTitleCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiAxisTitleCoreXF
                        ];
                    return StiAxisTitleCoreXF.implementsStiAxisTitleCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.title.allowApplyStyle) {
                        this.title.color = style.core.axisTitleColor;
                    }
                }
                get title() {
                    return this._title;
                }
                set title(value) {
                    this._title = value;
                }
            }
            Chart.StiAxisTitleCoreXF = StiAxisTitleCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var DateTime = Stimulsoft.System.DateTime;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
            var StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
            var StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
            var StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
            class StiXAxisCoreXF extends Chart.StiAxisCoreXF {
                constructor(axis) {
                    super(axis);
                }
                getStartFromZero() {
                    if (this.axis.info.labelsCollection != null && this.isArgumentDateTime1(this.axis.info.labelsCollection) &&
                        ((this.axis.area.is(Chart.StiScatterArea)) || (this.axis.area.is(Chart.StiGanttArea))))
                        return false;
                    return super.getStartFromZero();
                }
                render(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    let axisRect = this.getAxisRect(context, rect, false, false, true, false).clone();
                    axisRect.x = 0;
                    axisRect.y = 0;
                    if (this.axis.interaction.showScrollBar &&
                        ((this.axis.is(Chart.IStiXTopAxis) && this.axis.area.reverseVert)))
                        axisRect.y += Chart.StiAxisCoreXF.defaultScrollBarSize * context.options.zoom;
                    let geom = new Chart.StiXAxisGeom(this.axis, axisRect, false);
                    this.renderLabels(context, axisRect, geom);
                    this.renderTitle(context, axisRect, geom);
                    return geom;
                }
                renderView(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    let axisRect = this.getAxisRect(context, rect, false, false, true, true).clone();
                    return new Chart.StiXAxisViewGeom(this.axis, axisRect, false);
                }
                renderScrollBar(context, axisRect, axisGeom) {
                    if (this.axis.interaction.showScrollBar) {
                        let scrollBarRect = axisRect.clone();
                        scrollBarRect.x = 0;
                        scrollBarRect.height = Chart.StiAxisCoreXF.defaultScrollBarSize * context.options.zoom;
                        if ((this.axis.is(Chart.IStiXTopAxis) && (!this.axis.area.reverseVert)) ||
                            (this.axis.is(Chart.IStiXBottomAxis) && (this.axis.area.reverseVert)))
                            scrollBarRect.y = axisRect.height - scrollBarRect.height;
                        else
                            scrollBarRect.y = 0;
                        let scrollBarGeom = new Chart.StiHorzScrollBarGeom(this.axis, scrollBarRect);
                        axisGeom.createChildGeoms();
                        axisGeom.childGeoms.push(scrollBarGeom);
                        scrollBarRect.x = 0;
                        scrollBarRect.y = 0;
                        scrollBarRect.inflate(-2, -2);
                        if (this.axis.interaction.rangeScrollEnabled) {
                            let leftButtonRect = scrollBarRect.clone();
                            leftButtonRect.width = scrollBarRect.height;
                            let leftButtonGeom = new Chart.StiLeftButtonGeom(this.axis, leftButtonRect);
                            scrollBarGeom.createChildGeoms();
                            scrollBarGeom.childGeoms.push(leftButtonGeom);
                            let rightButtonRect = scrollBarRect.clone();
                            rightButtonRect.width = scrollBarRect.height;
                            rightButtonRect.x = scrollBarRect.right - rightButtonRect.width;
                            let rightButtonGeom = new Chart.StiRightButtonGeom(this.axis, rightButtonRect);
                            scrollBarGeom.createChildGeoms();
                            scrollBarGeom.childGeoms.push(rightButtonGeom);
                            scrollBarRect.inflate(-scrollBarRect.height - 2, 0);
                        }
                        let trackBarRect = scrollBarRect.clone();
                        let rollAxis = this.axis.area.xAxis;
                        let axisCore = this.axis.area.core;
                        if (!rollAxis.range.auto) {
                            let dpi = scrollBarRect.width / axisCore.scrollRangeX;
                            let x = axisCore.scrollValueX * dpi;
                            let width = axisCore.scrollViewX < axisCore.scrollRangeX ?
                                axisCore.scrollViewX * dpi : axisCore.scrollRangeX * dpi;
                            trackBarRect = new RectangleD(x + scrollBarRect.x, scrollBarRect.y, width, scrollBarRect.height);
                        }
                        let trackBarGeom = new Chart.StiHorzTrackBarGeom(this.axis, trackBarRect, scrollBarGeom);
                        scrollBarGeom.createChildGeoms();
                        scrollBarGeom.childGeoms.push(trackBarGeom);
                    }
                }
                renderCenter(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    if (this.axis.area.yAxis.info.minimum >= 0)
                        return null;
                    let axisRect = this.getCenterAxisRect(context, rect, false, false, true).clone();
                    axisRect.x = 0;
                    axisRect.y = 0;
                    return new Chart.StiXAxisGeom(this.axis, axisRect, true);
                }
                renderCenterView(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    if (this.axis.area.yAxis.info.minimum >= 0)
                        return null;
                    let axisRect = this.getCenterAxisRect(context, rect, false, false, true).clone();
                    let axisGeom = new Chart.StiXAxisViewGeom(this.axis, axisRect, true);
                    return axisGeom;
                }
                getLabelText(line, series) {
                    return this.getLabelText2(line.valueObject, line.value, series);
                }
                getLabelText2(objectValue, value, series) {
                    if (objectValue == null)
                        objectValue = "";
                    this.storedCulture = CultureInfo.currentCulture;
                    let culture = this.axis.area.chart.report.culture;
                    try {
                        if (this.axis.labels.formatService != null && !(this.axis.labels.formatService.is(StiGeneralFormatService))) {
                            if (objectValue instanceof DateTime) {
                                if (this.axis.labels.formatService.is(StiDateFormatService) || this.axis.labels.formatService.is(StiTimeFormatService))
                                    return `${this.axis.labels.textBefore}${this.axis.labels.formatService.format(objectValue)}${this.axis.labels.textAfter}`;
                                else
                                    return `${this.axis.labels.textBefore}${objectValue}${this.axis.labels.textAfter}`;
                            }
                            return `${this.axis.labels.textBefore}${this.axis.labels.formatService.format(value)}${this.axis.labels.textAfter}`;
                        }
                        if (!StiString.isNullOrEmpty(this.axis.area.chart.report.culture)) {
                            CultureInfo.currentCulture = CultureInfo.cultures[culture];
                        }
                        let format = "";
                        if (series != null)
                            format = series.format;
                        if (format == null || format.trim().length == 0)
                            format = this.axis.labels.format;
                        if (format != null && format.trim().length != 0) {
                            if (typeof objectValue == "string") {
                                let strValue = objectValue;
                                let result = strValue.stimulsoft().toNumber();
                                if (strValue.length > 0 && !isNaN(result)) {
                                    objectValue = result;
                                }
                                else {
                                    let resultDateTime = DateTime.fromString(objectValue.toString(), false);
                                    if (resultDateTime != null) {
                                        objectValue = resultDateTime;
                                    }
                                }
                            }
                            else if (objectValue == null)
                                return "";
                            if (!Chart.StiChartOptions.oldChartPercentMode && format.stimulsoft().startsWith("P")) {
                                let signs = 0;
                                if (format.length > 1) {
                                    signs = format.stimulsoft().remove(0, 1).stimulsoft().toNumber();
                                }
                                return StiString.format("{0}{1:N" + signs.toString() + "}{2}{3}", this.axis.labels.textBefore, objectValue, "%", this.axis.labels.textAfter);
                            }
                            else
                                return StiString.format("{0}{1:" + format + "}{2}", this.axis.labels.textBefore, objectValue, this.axis.labels.textAfter);
                        }
                        return StiString.format("{0}{1}{2}", this.axis.labels.textBefore, objectValue, this.axis.labels.textAfter);
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    finally {
                        if (!StiString.isNullOrEmpty(culture)) {
                            CultureInfo.currentCulture = this.storedCulture;
                        }
                    }
                    return objectValue.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                get isLabelsAngleByWidth() {
                    return this.axis.labels.angle < 30 || this.axis.labels.angle > 150;
                }
                checkAutoAngleLabels(context, rect) {
                    if (this.axis.labels.placement != Chart.StiLabelsPlacement.AutoRotation)
                        return false;
                    let infos = [];
                    if (this.axis.info.labelsCollection != null) {
                        let sf = this.getStringFormatGeom(context);
                        let font = this.getFontGeom(context);
                        let rotationMode = StiRotationMode.CenterCenter;
                        let angle = -this.axis.labels.angle;
                        let point = PointD.empty;
                        if (this.isTopSide)
                            rotationMode = StiRotationMode.CenterBottom;
                        else
                            rotationMode = StiRotationMode.LeftCenter;
                        let maxLabelWidth = 0;
                        let index = 0;
                        let sideFlag = this.axis.area.reverseVert ? this.isBottomSide : this.isTopSide;
                        for (let label of this.axis.info.labelsCollection) {
                            if (sideFlag && this.axis.area.yRightAxis.arrowStyle != Chart.StiArrowStyle.None && index == 0) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            if (sideFlag && this.axis.area.yAxis.arrowStyle != Chart.StiArrowStyle.None && index == this.axis.info.stripLines.count - 1) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            let text = this.getLabelText(label.stripLine, null);
                            let posX = label.position;
                            if (this.isTopSide) {
                                point = new PointD(posX, rect.height - (this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context)));
                            }
                            else {
                                point = new PointD(posX, (this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context)));
                            }
                            if (this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                                let textRectF = context.measureRotatedString3(text, font, point, sf, rotationMode, angle, Math.trunc(this.axis.labels.width * context.options.zoom));
                                let info = new Chart.StiAxisLabelInfoXF();
                                info.angle = angle;
                                info.clientRectangle = textRectF;
                                info.rotationMode = rotationMode;
                                info.textPoint = point;
                                info.text = text;
                                info.stripLine = label.stripLine;
                                infos.push(info);
                                if (this.isLabelsAngleByWidth) {
                                    maxLabelWidth = Math.max(maxLabelWidth, textRectF.width);
                                }
                            }
                            else {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                            }
                            index++;
                        }
                        for (let index = 1; index < infos.length; index++) {
                            let rect1 = infos[index - 1].clientRectangle;
                            let rectRound1 = new RectangleD(rect1.x, rect1.y, Math.ceil(rect1.width), Math.ceil(rect1.height));
                            let rect2 = infos[index].clientRectangle;
                            let rectRotationHeight = rect1.height / Math.sqrt(2) + rect1.width / Math.sqrt(2);
                            if (rectRotationHeight > this.axis.area.chart.stimulsoft().as(Stimulsoft.Report.Components.StiChart).core.fullRectangle.height / 4)
                                return false;
                            if (rectRound1.intersectsWith(rect2))
                                return true;
                        }
                    }
                    return false;
                }
                measureStripLines(context, rect) {
                    let infos = [];
                    let rotationMode = null;
                    let angle = -this.axis.labels.angle;
                    let isAutoAngleLabels = this.checkAutoAngleLabels(context, rect);
                    if (isAutoAngleLabels) {
                        angle = -45;
                        rotationMode = this.axis.is(Chart.IStiXTopAxis) ? StiRotationMode.LeftBottom : StiRotationMode.RightTop;
                    }
                    if (this.axis.info.labelsCollection != null && this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let maxLabelWidth = 0;
                        let index = 0;
                        for (let label of this.axis.info.labelsCollection) {
                            let sideFlag = this.axis.area.reverseVert ? this.isBottomSide : this.isTopSide;
                            if (sideFlag && this.axis.area.yRightAxis.arrowStyle != Chart.StiArrowStyle.None && index == 0) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            if (sideFlag && this.axis.area.yAxis.arrowStyle != Chart.StiArrowStyle.None && index == this.axis.info.stripLines.count - 1) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            let text = this.getLabelText(label.stripLine, null);
                            let posX = label.position;
                            if (this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                                let sf = this.getStringFormatGeom(context);
                                let font = this.getFontGeom(context);
                                rotationMode = StiRotationMode.CenterCenter;
                                let point = PointD.empty;
                                if (this.isTopSide) {
                                    point = new PointD(posX, rect.height - (this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context)));
                                    if (angle == 0)
                                        rotationMode = StiRotationMode.CenterBottom;
                                    else
                                        rotationMode = StiRotationMode.LeftCenter;
                                }
                                else {
                                    point = new PointD(posX, (this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context)));
                                    if (angle == 0)
                                        rotationMode = StiRotationMode.CenterTop;
                                    else
                                        rotationMode = StiRotationMode.RightCenter;
                                }
                                if (this.axis.labels.placement == Chart.StiLabelsPlacement.TwoLines && ((index & 1) != 0)) {
                                    if (this.isTopSide)
                                        point.y -= this.getLabelsTwoLinesDestination(context);
                                    if (this.isBottomSide)
                                        point.y += this.getLabelsTwoLinesDestination(context);
                                }
                                let textRectF = context.measureRotatedString3(text, font, point, sf, rotationMode, angle, Math.trunc(this.axis.labels.width * context.options.zoom));
                                let info = new Chart.StiAxisLabelInfoXF();
                                info.angle = angle;
                                info.clientRectangle = textRectF;
                                info.rotationMode = rotationMode;
                                info.textPoint = point;
                                info.text = text;
                                info.stripLine = label.stripLine;
                                infos.push(info);
                                if (this.isLabelsAngleByWidth) {
                                    maxLabelWidth = Math.max(maxLabelWidth, textRectF.width);
                                }
                            }
                            else {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                            }
                            index++;
                        }
                        let labelsStep = 1;
                        if (this.axis.range.auto) {
                            if (isAutoAngleLabels) {
                                maxLabelWidth = this.axis.labels.font.getHeight() * 1.4 * context.options.zoom;
                                let widthPerLabel = rect.width / this.axis.info.stripLines.count;
                                labelsStep = Math.ceil(maxLabelWidth / widthPerLabel);
                            }
                            else {
                                if (!this.isLabelsAngleByWidth)
                                    maxLabelWidth = this.axis.labels.font.sizeInPoints * 1.5 * context.options.zoom;
                                let widthPerLabel = rect.width / this.axis.info.stripLines.count;
                                let count = maxLabelWidth / widthPerLabel;
                                if (count > 1) {
                                    labelsStep = Math.trunc(Chart.StiStripLineCalculatorXF.getInterval(0, this.axis.info.labelsCollection.length, 6));
                                    if (this.axis.logarithmicScale)
                                        labelsStep = 1;
                                }
                            }
                        }
                        else
                            labelsStep = Math.trunc(Math.max(1, this.axis.step));
                        let twoLinesLabels = false;
                        let posYTwoLine = 0;
                        let posYOneLine = 0;
                        if (this.axis.labels.placement == Chart.StiLabelsPlacement.TwoLines && infos.length > 1) {
                            posYOneLine = infos[0].textPoint.y;
                            posYTwoLine = infos[1].textPoint.y;
                        }
                        if (labelsStep == 1 || this.axis.labels.step != 0)
                            return infos;
                        else {
                            let labelsIndex = 0;
                            let infos2 = [];
                            for (let info of infos) {
                                if (labelsIndex == 0) {
                                    if (this.axis.labels.placement == Chart.StiLabelsPlacement.TwoLines && infos.length > 1) {
                                        if (twoLinesLabels) {
                                            info.textPoint.y = posYTwoLine;
                                            twoLinesLabels = false;
                                        }
                                        else {
                                            info.textPoint.y = posYOneLine;
                                            twoLinesLabels = true;
                                        }
                                    }
                                    infos2.push(info);
                                }
                                labelsIndex++;
                                if (labelsIndex == labelsStep)
                                    labelsIndex = 0;
                            }
                            return infos2;
                        }
                    }
                    return infos;
                }
                getCenterAxisRect(context, rect, includeAxisArrow, includeLabelsHeight, isDrawing) {
                    if (this.axis.area.yAxis.info.minimum >= 0)
                        return RectangleD.empty;
                    let posY = -this.getTicksMaxLength(context);
                    return new RectangleD(0, posY, rect.width, this.getTicksMaxLength(context));
                }
                getAxisRect(context, rect, includeAxisArrow, includeLabelsWidth, isDrawing, includeScrollBar) {
                    let axisRect = RectangleD.empty;
                    if (!this.axis.visible)
                        return axisRect;
                    let infos = this.measureStripLines(context, rect);
                    if (infos.length == 0) {
                        if (this.isTopSide)
                            axisRect = new RectangleD(0, -this.getTicksMaxLength(context), rect.width, this.getTicksMaxLength(context));
                        else
                            axisRect = new RectangleD(0, rect.height, rect.width, this.getTicksMaxLength(context));
                    }
                    else {
                        for (let info of infos) {
                            if (info.clientRectangle.isEmptyF)
                                continue;
                            if (axisRect.isEmpty)
                                axisRect = info.clientRectangle;
                            else
                                axisRect = RectangleD.union(axisRect, info.clientRectangle);
                        }
                        if (this.axis.interaction.showScrollBar && includeScrollBar)
                            axisRect.height += Chart.StiAxisCoreXF.defaultScrollBarSize * context.options.zoom;
                        axisRect.height += this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context);
                        let axisRect2 = axisRect.clone();
                        if (this.isTopSide)
                            axisRect = new RectangleD(0, -axisRect.height, rect.width, axisRect.height);
                        if (this.isBottomSide)
                            axisRect = new RectangleD(0, rect.height, rect.width, axisRect.height);
                        if (includeLabelsWidth) {
                            axisRect.x = axisRect2.x;
                            axisRect.width = axisRect2.width;
                        }
                    }
                    if (this.axis.arrowStyle != Chart.StiArrowStyle.None && includeAxisArrow) {
                        let arrowHeight = this.getArrowHeight(context);
                        if (this.axis.area.reverseHor)
                            arrowHeight = -arrowHeight;
                        axisRect = RectangleD.union(axisRect, new RectangleD(rect.width, axisRect.y + axisRect.height / 2, arrowHeight, 1));
                    }
                    let titleSize = this.getAxisTitleSize(context);
                    if (!titleSize.isEmpty && this.axis.title.position == Chart.StiTitlePosition.Outside) {
                        axisRect.height += titleSize.height;
                        if (axisRect.width == 0)
                            axisRect.width = titleSize.width;
                        if (this.isTopSide)
                            axisRect.y -= titleSize.height;
                    }
                    return axisRect;
                }
                renderLabels(context, rect, geom) {
                    if (this.axis.info.stripLines != null && this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let infos = this.measureStripLines(context, rect);
                        geom.createChildGeoms();
                        let axisX = this.axis.area.xAxis;
                        if (this.isArgumentDateTime2(infos) && axisX != null && axisX.dateTimeStep.step != Chart.StiTimeDateStep.None) {
                            let date;
                            let dateNext;
                            let tempLabels = axisX.info.labelsCollection;
                            let infosFirstLine = [];
                            let text = "";
                            let first = true;
                            let startX = 0;
                            for (let index = 0; index < tempLabels.length; index++) {
                                if (tempLabels[index].stripLine.valueObject == null)
                                    continue;
                                date = tempLabels[index].stripLine.valueObject;
                                if (index < tempLabels.length - 2 && !(axisX.area.is(Chart.StiScatterArea))) {
                                    dateNext = tempLabels[index + 1].stripLine.valueObject;
                                }
                                else {
                                    dateNext = date;
                                }
                                if (first) {
                                    startX = tempLabels[index].position;
                                    first = false;
                                }
                                switch (this.axis.area.xAxis.dateTimeStep.step) {
                                    case Chart.StiTimeDateStep.Day:
                                        if (date.toString("yyyyMMMMdd") != dateNext.toString("yyyyMMMMdd") || index == tempLabels.length - 2)
                                            text = date.toString("dd");
                                        break;
                                    case Chart.StiTimeDateStep.Hour:
                                        if (date.toString("yyyyMMMMddHH") != dateNext.toString("yyyyMMMMddHH") || index == tempLabels.length - 2)
                                            text = date.toString("HH");
                                        break;
                                    case Chart.StiTimeDateStep.Minute:
                                        if (date.toString("yyyyMMMMddHHmm") != dateNext.toString("yyyyMMMMddHHmm") || index == tempLabels.length - 2)
                                            text = date.toString("mm");
                                        break;
                                    case Chart.StiTimeDateStep.Month:
                                        if (date.toString("yyyyMMMM") != dateNext.toString("yyyyMMMM") || index == tempLabels.length - 2)
                                            text = StiLocalization.get("A_WebViewer", "Month" + date.toString("MMMM"));
                                        break;
                                    case Chart.StiTimeDateStep.Second:
                                        if (date.toString("yyyyMMMMddHHmmss") != dateNext.toString("yyyyMMMMddHHmmss") || index == tempLabels.length - 2)
                                            text = date.toString("ss");
                                        break;
                                    case Chart.StiTimeDateStep.Year:
                                        if (date.toString("yyyy") != dateNext.toString("yyyy") || index == tempLabels.length - 2)
                                            text = date.toString("yyyy");
                                        break;
                                }
                                if (text != "") {
                                    let point = new PointD((tempLabels[index].position + startX) / 2, (this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context)));
                                    let angle = 0;
                                    let info = new Chart.StiAxisLabelInfoXF();
                                    info.angle = angle;
                                    info.clientRectangle = context.measureRotatedString3(text, this.getFontGeom(context), point, this.getStringFormatGeom(context), StiRotationMode.CenterCenter, angle, Math.trunc(this.axis.labels.width * context.options.zoom));
                                    info.rotationMode = StiRotationMode.CenterCenter;
                                    info.stripLine = tempLabels[index].stripLine;
                                    info.text = text;
                                    info.textPoint = point;
                                    infosFirstLine.push(info);
                                    first = true;
                                    text = "";
                                }
                            }
                            first = true;
                            let infosSecondLine = [];
                            for (let index = 0; index < infosFirstLine.length - 1; index++) {
                                date = infosFirstLine[index].stripLine.valueObject;
                                dateNext = infosFirstLine[index + 1].stripLine.valueObject;
                                if (first) {
                                    startX = infosFirstLine[index].textPoint.x;
                                    first = false;
                                }
                                switch (this.axis.area.xAxis.dateTimeStep.step) {
                                    case Chart.StiTimeDateStep.Day:
                                        if (date.toString("yyyyMMMM") != dateNext.toString("yyyyMMMM") || index == infosFirstLine.length - 2)
                                            text = StiLocalization.get("A_WebViewer", "Month" + date.toString("MMMM"));
                                        break;
                                    case Chart.StiTimeDateStep.Hour:
                                        if (date.toString("yyyyMMMMdd") != dateNext.toString("yyyyMMMMdd") || index == infosFirstLine.length - 2)
                                            text = date.toString("dd");
                                        break;
                                    case Chart.StiTimeDateStep.Minute:
                                        if (date.toString("yyyyMMMMddhh") != dateNext.toString("yyyyMMMMddhh") || index == infosFirstLine.length - 2)
                                            text = date.toString("hh");
                                        break;
                                    case Chart.StiTimeDateStep.Month:
                                        if (date.toString("yyyy") != dateNext.toString("yyyy") || index == infosFirstLine.length - 2)
                                            text = date.toString("yyyy");
                                        break;
                                    case Chart.StiTimeDateStep.Second:
                                        if (date.toString("yyyyMMMMddhhmm") != dateNext.toString("yyyyMMMMddhhmm") || index == infosFirstLine.length - 2)
                                            text = date.toString("mm");
                                        break;
                                    case Chart.StiTimeDateStep.Year:
                                        if (date.toString("yyyy") != dateNext.toString("yyyy") || index == infosFirstLine.length - 2)
                                            continue;
                                        break;
                                }
                                if (text != "") {
                                    let point = new PointD((infosFirstLine[index + 1].textPoint.x + startX) / 2, (this.getTicksMaxLength(context) + 2 * this.getLabelsSpaceAxis(context)));
                                    let angle = 0;
                                    let info = new Chart.StiAxisLabelInfoXF();
                                    info.angle = angle;
                                    info.clientRectangle = context.measureRotatedString3(text, this.getFontGeom(context), point, this.getStringFormatGeom(context), StiRotationMode.CenterCenter, angle, Math.trunc(this.axis.labels.width * context.options.zoom));
                                    info.rotationMode = StiRotationMode.CenterTop;
                                    info.stripLine = infosFirstLine[index].stripLine;
                                    info.text = text;
                                    info.textPoint = point;
                                    infosSecondLine.push(info);
                                    first = true;
                                    text = "";
                                }
                            }
                            infosFirstLine.stimulsoft().addRange(infosSecondLine);
                            for (let info of infosFirstLine) {
                                if (!info.clientRectangle.isEmpty) {
                                    let labelGeom = new Chart.StiAxisLabelGeom(this.axis, info.clientRectangle, info.textPoint, info.text, info.stripLine, info.angle, info.rotationMode);
                                    geom.childGeoms.push(labelGeom);
                                }
                            }
                        }
                        else {
                            for (let info of infos) {
                                if (!info.clientRectangle.isEmpty) {
                                    let labelGeom = new Chart.StiAxisLabelGeom(this.axis, info.clientRectangle, info.textPoint, info.text, info.stripLine, info.angle, info.rotationMode);
                                    geom.childGeoms.push(labelGeom);
                                }
                            }
                        }
                    }
                }
                renderTitle(context, axisRect, geom) {
                    if (StiString.isNullOrEmpty(this.axis.title.text))
                        return;
                    let titleSize = this.getAxisTitleSize(context);
                    let titleRect = RectangleD.empty;
                    if (this.isTopSide) {
                        switch (this.axis.title.alignment) {
                            case StringAlignment.Near:
                                titleRect = new RectangleD(0, 0, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Center:
                                titleRect = new RectangleD((axisRect.width - titleSize.width) / 2, 0, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Far:
                                titleRect = new RectangleD(axisRect.width - titleSize.width, 0, titleSize.width, titleSize.height);
                                break;
                        }
                        if (this.axis.title.position == Chart.StiTitlePosition.Inside)
                            titleRect.y += axisRect.height;
                    }
                    if (this.isBottomSide) {
                        switch (this.axis.title.alignment) {
                            case StringAlignment.Near:
                                titleRect = new RectangleD(0, axisRect.height - titleSize.height, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Center:
                                titleRect = new RectangleD((axisRect.width - titleSize.width) / 2, axisRect.height - titleSize.height, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Far:
                                titleRect = new RectangleD(axisRect.width - titleSize.width, axisRect.height - titleSize.height, titleSize.width, titleSize.height);
                                break;
                        }
                        if (this.axis.title.position == Chart.StiTitlePosition.Inside)
                            titleRect.y -= axisRect.height;
                    }
                    let fontSize = this.axis.title.font.size * context.options.zoom;
                    let RefMaxWidth = { ref: 0 };
                    if (this.axis.area.chart.isDashboard && this.checkUseMaxWidth(axisRect, titleRect, RefMaxWidth))
                        fontSize = this.getCorrectionFontSize(axisRect, titleRect, fontSize);
                    let font = StiFontGeom.changeFontSize(this.axis.title.font, fontSize);
                    let angle = this.getAngleTitle();
                    let titleGeom = new Chart.StiAxisTitleGeom(this.axis, titleRect, angle, this.axis.title.alignment, font);
                    geom.createChildGeoms();
                    geom.childGeoms.push(titleGeom);
                }
                isArgumentDateTime1(positions) {
                    for (let position of positions) {
                        if (position.stripLine.valueObject != null && position.stripLine.valueObject instanceof DateTime) {
                            return true;
                        }
                    }
                    return false;
                }
                isArgumentDateTime2(infos) {
                    for (let info of infos) {
                        if (info.stripLine.valueObject != null && info.stripLine.valueObject instanceof DateTime) {
                            return true;
                        }
                    }
                    return false;
                }
                get dock() {
                    return null;
                }
                get isTopSide() {
                    return (this.dock == Chart.StiXAxisDock.Top && (!this.axis.area.reverseVert)) ||
                        (this.dock == Chart.StiXAxisDock.Bottom && this.axis.area.reverseVert);
                }
                get isBottomSide() {
                    return (this.dock == Chart.StiXAxisDock.Bottom && (!this.axis.area.reverseVert)) ||
                        (this.dock == Chart.StiXAxisDock.Top && this.axis.area.reverseVert);
                }
            }
            Chart.StiXAxisCoreXF = StiXAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiXBottomAxisCoreXF extends Chart.StiXAxisCoreXF {
                get dock() {
                    return Chart.StiXAxisDock.Bottom;
                }
                constructor(axis) {
                    super(axis);
                }
            }
            Chart.StiXBottomAxisCoreXF = StiXBottomAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiXTopAxisCoreXF extends Chart.StiXAxisCoreXF {
                get dock() {
                    return Chart.StiXAxisDock.Top;
                }
                constructor(axis) {
                    super(axis);
                }
            }
            Chart.StiXTopAxisCoreXF = StiXTopAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiTimeFormatService = Stimulsoft.Report.Components.TextFormats.StiTimeFormatService;
            var StiDateFormatService = Stimulsoft.Report.Components.TextFormats.StiDateFormatService;
            var DateTime = Stimulsoft.System.DateTime;
            var StiString = Stimulsoft.System.StiString;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
            var List = Stimulsoft.System.Collections.List;
            var CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
            var StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
            class StiYAxisCoreXF extends Chart.StiAxisCoreXF {
                constructor(axis) {
                    super(axis);
                }
                render(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    let axisRect = this.getAxisRect(context, rect, false, false, true, false).clone();
                    axisRect.x = 0;
                    axisRect.y = 0;
                    if (this.axis.interaction.showScrollBar &&
                        ((this.axis.is(Chart.IStiYLeftAxis) && this.axis.area.reverseHor)))
                        axisRect.x += Chart.StiAxisCoreXF.defaultScrollBarSize * context.options.zoom;
                    let geom = new Chart.StiYAxisGeom(this.axis, axisRect.clone(), false);
                    this.renderLabels(context, axisRect.clone(), geom);
                    if (!this.axis.range.auto) {
                        if (this.axis.area.reverseVert) {
                            axisRect.y = ((this.axis.info.minimum - this.axis.range.minimum) * this.axis.info.dpi);
                        }
                        else {
                            axisRect.y = ((this.axis.info.maximum - this.axis.range.maximum) * this.axis.info.dpi);
                        }
                        axisRect.height = ((this.axis.range.maximum - this.axis.range.minimum) * this.axis.info.dpi);
                    }
                    this.renderTitle(context, axisRect, geom);
                    return geom;
                }
                renderView(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    let axisRect = this.getAxisRect(context, rect, false, false, true, true).clone();
                    return new Chart.StiYAxisViewGeom(this.axis.stimulsoft().as(Chart.IStiYAxis), axisRect, false);
                }
                renderScrollBar(context, axisRect, axisGeom) {
                }
                renderCenter(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    if (this.axis.area.xAxis.info.minimum >= 0)
                        return null;
                    let axisRect = this.getCenterAxisRect(context, rect, false, false, true).clone();
                    axisRect.x = 0;
                    axisRect.y = 0;
                    let geom = new Chart.StiYAxisGeom(this.axis, axisRect, true);
                    return geom;
                }
                renderCenterView(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    if (this.axis.area.xAxis.info.minimum >= 0)
                        return null;
                    let axisRect = this.getCenterAxisRect(context, rect, false, false, true).clone();
                    let geom = new Chart.StiYAxisViewGeom(this.axis, axisRect, true);
                    return geom;
                }
                setTotalNumberCapacity() {
                    let numberService = this.axis.labels.formatService.as(StiNumberFormatService);
                    if (numberService != null) {
                        let step = this.axis.labels.calculatedStep;
                        let sign = step < 1 ? -1 : 1;
                        numberService.totalNumberCapacity = Math.floor(sign * Math.log10(step) + 1);
                    }
                }
                getLabelText(line, series) {
                    let value = line.valueObject;
                    if (value == null)
                        value = "";
                    try {
                        if (this.axis.labels.formatService != null) {
                            this.setTotalNumberCapacity();
                            if (value instanceof DateTime) {
                                if (this.axis.labels.formatService.is(StiDateFormatService) || this.axis.labels.formatService.is(StiTimeFormatService))
                                    return `${this.axis.labels.textBefore}${this.axis.labels.formatService.format(value)}${this.axis.labels.textAfter}`;
                                else
                                    return `${this.axis.labels.textBefore}${value}${this.axis.labels.textAfter}`;
                            }
                            return `${this.axis.labels.textBefore}${this.axis.labels.formatService.format(line.value)}${this.axis.labels.textAfter}`;
                        }
                        if (this.axis.labels.format != null && this.axis.labels.format.trim().length != 0) {
                            this.storedCulture = CultureInfo.currentCulture;
                            let culture = this.axis.area.chart.report.culture;
                            if (!StiString.isNullOrEmpty(this.axis.area.chart.report.culture)) {
                                CultureInfo.currentCulture = CultureInfo.cultures[culture];
                            }
                            try {
                                if (typeof value == "string") {
                                    value = value.stimulsoft().toNumber();
                                }
                                if (!Chart.StiChartOptions.oldChartPercentMode && this.axis.labels.format.stimulsoft().startsWith("P")) {
                                    let signs = 0;
                                    if (this.axis.labels.format.length > 1) {
                                        signs = parseInt(this.axis.labels.format.stimulsoft().remove(0, 1));
                                    }
                                    return StiString.format("{0}{1:N" + signs.toString() + "}{2}{3}", this.axis.labels.textBefore, value, "%", this.axis.labels.textAfter);
                                }
                                else
                                    return StiString.format("{0}{1:" + this.axis.labels.format + "}{2}", this.axis.labels.textBefore, value, this.axis.labels.textAfter);
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                            finally {
                                if (!StiString.isNullOrEmpty(culture)) {
                                    CultureInfo.currentCulture = this.storedCulture;
                                }
                            }
                        }
                        return StiString.format("{0}{1}{2}", this.axis.labels.textBefore, value, this.axis.labels.textAfter);
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    return value.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                measureStripLines(context, rect) {
                    let infos = [];
                    if (this.axis.info.labelsCollection != null && this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let titleSize = this.getAxisTitleSize(context);
                        let index = 0;
                        for (let label of this.axis.info.labelsCollection) {
                            let sideFlag = this.axis.area.reverseHor ? this.isLeftSide : this.isRightSide;
                            if (sideFlag && this.axis.area.xTopAxis.arrowStyle != Chart.StiArrowStyle.None && index == 0) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            if (sideFlag && this.axis.area.xAxis.arrowStyle != Chart.StiArrowStyle.None && index == this.axis.info.stripLines.count - 1) {
                                infos.push(new Chart.StiAxisLabelInfoXF());
                                index++;
                                continue;
                            }
                            let text = this.getLabelText(label.stripLine, null);
                            let posY = label.position;
                            let sf = context.getGenericStringFormat();
                            let font = StiFontGeom.changeFontSize(this.axis.labels.font, this.axis.labels.font.size * context.options.zoom);
                            let alignment = this.getTextAlignment();
                            let rotationMode = StiRotationMode.LeftCenter;
                            let angle = -this.axis.labels.angle;
                            let point = PointD.empty;
                            if (this.isLeftSide) {
                                if (alignment == StiHorAlignment.Left) {
                                    rotationMode = StiRotationMode.LeftCenter;
                                    point = new PointD(titleSize.width, posY);
                                    angle = 0;
                                }
                                else if (alignment == StiHorAlignment.Center) {
                                    rotationMode = StiRotationMode.CenterCenter;
                                    point = new PointD((rect.width - titleSize.width) / 2, posY);
                                    angle = 0;
                                }
                                else {
                                    rotationMode = StiRotationMode.RightCenter;
                                    point = new PointD((rect.width - this.getTicksMaxLength(context) - this.getLabelsSpaceAxis(context)), posY);
                                }
                            }
                            else {
                                if (alignment == StiHorAlignment.Left) {
                                    rotationMode = StiRotationMode.LeftCenter;
                                    point = new PointD(this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context), posY);
                                }
                                else if (alignment == StiHorAlignment.Center) {
                                    rotationMode = StiRotationMode.CenterCenter;
                                    point = new PointD((rect.width - titleSize.width) / 2, posY);
                                    angle = 0;
                                }
                                else {
                                    rotationMode = StiRotationMode.RightCenter;
                                    point = new PointD(rect.width - titleSize.width, posY);
                                    angle = 0;
                                }
                            }
                            if (this.axis.labels.placement == Chart.StiLabelsPlacement.TwoLines && ((index & 1) != 0)) {
                                if (this.isLeftSide)
                                    point.x -= this.getLabelsTwoLinesDestination(context);
                                if (this.isRightSide)
                                    point.x += this.getLabelsTwoLinesDestination(context);
                            }
                            let textRectF = context.measureRotatedString3(text, font, point, sf, rotationMode, angle, (this.axis.labels.width * context.options.zoom));
                            let customWidth = this.axis.labels.width * context.options.zoom;
                            if (customWidth != 0) {
                                switch (rotationMode.toString()) {
                                    case "3":
                                    case "4":
                                    case "5":
                                        textRectF.x -= (customWidth - textRectF.width) / 2;
                                        break;
                                    case "6":
                                    case "7":
                                    case "8":
                                        textRectF.x -= customWidth - textRectF.width;
                                        break;
                                }
                                textRectF.width = customWidth;
                            }
                            let info = new Chart.StiAxisLabelInfoXF();
                            info.angle = angle;
                            info.clientRectangle = textRectF;
                            info.rotationMode = rotationMode;
                            info.textPoint = point;
                            info.text = text;
                            info.stripLine = label.stripLine;
                            infos.push(info);
                            index++;
                        }
                    }
                    if (this.axis.range.auto) {
                        let maxLabelHeight = this.axis.labels.font.getHeight() * context.options.zoom;
                        let heightPerLabel = rect.height / this.axis.info.stripLines.count;
                        let labelsStep = Math.ceil(maxLabelHeight / heightPerLabel);
                        let labelsIndex = 0;
                        let infos2 = new List();
                        infos.reverse();
                        for (let index = 0; index < infos.length; index++) {
                            if (labelsIndex == 0) {
                                infos2.push(infos[index]);
                            }
                            labelsIndex++;
                            if (labelsIndex == labelsStep)
                                labelsIndex = 0;
                        }
                        return infos2;
                    }
                    return infos;
                }
                getCenterAxisRect(context, rect, includeAxisArrow, includeLabelsHeight, isDrawing) {
                    if (this.axis.area.xAxis.info.minimum >= 0)
                        return RectangleD.empty;
                    let posX = -this.getTicksMaxLength(context);
                    return new RectangleD(posX, 0, this.getTicksMaxLength(context), rect.height);
                }
                getAxisRect(context, rect, includeAxisArrow, includeLabelsHeight, isDrawing, includeScrollBar) {
                    let axisRect = RectangleD.empty;
                    if (!this.axis.visible)
                        return axisRect;
                    let infos = this.measureStripLines(context, rect);
                    if (infos.length == 0) {
                        if (this.isLeftSide)
                            axisRect = new RectangleD(-this.getTicksMaxLength(context), 0, this.getTicksMaxLength(context), rect.height);
                        else
                            axisRect = new RectangleD(rect.width, 0, this.getTicksMaxLength(context), rect.height);
                    }
                    else {
                        for (let info of infos) {
                            if (info.clientRectangle.isEmpty)
                                continue;
                            if (axisRect.isEmpty)
                                axisRect = info.clientRectangle.clone();
                            else
                                axisRect = RectangleD.union(axisRect, info.clientRectangle);
                        }
                        if (this.axis.interaction.showScrollBar && includeScrollBar)
                            axisRect.width += Chart.StiAxisCoreXF.defaultScrollBarSize * context.options.zoom;
                        axisRect.width += this.getTicksMaxLength(context) + this.getLabelsSpaceAxis(context);
                        let axisRect2 = axisRect.clone();
                        if (this.isLeftSide)
                            axisRect = new RectangleD(-axisRect.width, 0, axisRect.width, rect.height);
                        if (this.isRightSide)
                            axisRect = new RectangleD(rect.width, 0, axisRect.width, rect.height);
                        if (includeLabelsHeight) {
                            axisRect.y = axisRect2.y;
                            axisRect.height = axisRect2.height;
                        }
                    }
                    if (this.axis.arrowStyle != Chart.StiArrowStyle.None && includeAxisArrow) {
                        let arrowHeight = this.getArrowHeight(context);
                        if (this.axis.area.reverseVert)
                            arrowHeight = -arrowHeight;
                        axisRect = RectangleD.union(axisRect, new RectangleD(axisRect.x, -arrowHeight, 1, arrowHeight));
                    }
                    let titleSize = this.getAxisTitleSize(context);
                    if (!titleSize.isEmpty && this.axis.title.position == Chart.StiTitlePosition.Outside) {
                        axisRect.width += titleSize.width;
                        if (this.isLeftSide)
                            axisRect.x -= titleSize.width;
                    }
                    return axisRect;
                }
                renderLabels(context, rect, geom) {
                    if (this.axis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let infos = this.measureStripLines(context, rect);
                        geom.createChildGeoms();
                        for (let info of infos) {
                            if (!info.clientRectangle.isEmpty) {
                                let labelGeom = new Chart.StiAxisLabelGeom(this.axis, info.clientRectangle, info.textPoint, info.text, info.stripLine, info.angle, info.rotationMode);
                                geom.childGeoms.push(labelGeom);
                            }
                        }
                    }
                }
                renderTitle(context, axisRect, geom) {
                    if (StiString.isNullOrEmpty(this.axis.title.text))
                        return;
                    let titleSize = this.getAxisTitleSize(context);
                    let titleRect = RectangleD.empty;
                    if (this.isLeftSide) {
                        switch (this.axis.title.alignment) {
                            case StringAlignment.Near:
                                titleRect = new RectangleD(0, axisRect.height - titleSize.height + axisRect.y, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Center:
                                titleRect = new RectangleD(0, (axisRect.height - titleSize.height) / 2 + axisRect.y, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Far:
                                titleRect = new RectangleD(0, axisRect.y, titleSize.width, titleSize.height);
                                break;
                        }
                        if (this.axis.title.position == Chart.StiTitlePosition.Inside)
                            titleRect.x += axisRect.width;
                    }
                    if (this.isRightSide) {
                        switch (this.axis.title.alignment) {
                            case StringAlignment.Near:
                                titleRect = new RectangleD(axisRect.width - titleSize.width, axisRect.height - titleSize.height + axisRect.y, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Center:
                                titleRect = new RectangleD(axisRect.width - titleSize.width, (axisRect.height - titleSize.height) / 2 + axisRect.y, titleSize.width, titleSize.height);
                                break;
                            case StringAlignment.Far:
                                titleRect = new RectangleD(axisRect.width - titleSize.width, axisRect.y, titleSize.width, titleSize.height);
                                break;
                        }
                        if (this.axis.title.position == Chart.StiTitlePosition.Inside)
                            titleRect.x -= axisRect.width;
                    }
                    let fontSize = this.axis.title.font.size * context.options.zoom;
                    let RefMaxWidth = { ref: 0 };
                    if (this.axis.area.chart.isDashboard && this.checkUseMaxWidth(axisRect, titleRect, RefMaxWidth))
                        fontSize = this.getCorrectionFontSize(axisRect, titleRect, fontSize);
                    let font = StiFontGeom.changeFontSize(this.axis.title.font, fontSize);
                    let angle = this.getAngleTitle();
                    let titleGeom = new Chart.StiAxisTitleGeom(this.axis, titleRect, angle, this.axis.title.alignment, font);
                    geom.createChildGeoms();
                    geom.childGeoms.push(titleGeom);
                }
                get dock() {
                    return null;
                }
                get isLeftSide() {
                    return (this.dock == Chart.StiYAxisDock.Left && (!this.axis.area.reverseHor)) ||
                        (this.dock == Chart.StiYAxisDock.Right && this.axis.area.reverseHor);
                }
                get isRightSide() {
                    return (this.dock == Chart.StiYAxisDock.Right && (!this.axis.area.reverseHor)) ||
                        (this.dock == Chart.StiYAxisDock.Left && this.axis.area.reverseHor);
                }
            }
            Chart.StiYAxisCoreXF = StiYAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiYLeftAxisCoreXF extends Chart.StiYAxisCoreXF {
                get dock() {
                    return Chart.StiYAxisDock.Left;
                }
                constructor(axis) {
                    super(axis);
                }
            }
            Chart.StiYLeftAxisCoreXF = StiYLeftAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiYRightAxisCoreXF extends Chart.StiYAxisCoreXF {
                get dock() {
                    return Chart.StiYAxisDock.Right;
                }
                getStartFromZero() {
                    if (this.axis.area.axisCore.valuesCount == 1)
                        return true;
                    if (this.axis != null && this.axis.range != null && (!this.axis.range.auto))
                        return false;
                    return this.axis != null ? this.axis.startFromZero : true;
                }
                constructor(axis) {
                    super(axis);
                }
            }
            Chart.StiYRightAxisCoreXF = StiYRightAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var DateTime = Stimulsoft.System.DateTime;
            class StiStripLineCalculatorXF {
                static getInterval1(interval) {
                    let tick = Math.abs(interval);
                    let count = 0;
                    if (interval > 1) {
                        while (tick > 1) {
                            tick /= 10;
                            count++;
                        }
                        if (tick < 0.15)
                            tick = 0.1;
                        else if (tick < 0.3)
                            tick = 0.2;
                        else if (tick < 0.75)
                            tick = 0.5;
                        else
                            tick = 1.0;
                        while (count > 0) {
                            tick *= 10;
                            count--;
                        }
                    }
                    else if (interval > 0) {
                        while ((tick * 10) < 1) {
                            tick *= 10;
                            count++;
                        }
                        if (tick < 0.15)
                            tick = 0.1;
                        else if (tick < 0.3)
                            tick = 0.2;
                        else if (tick < 0.75)
                            tick = 0.5;
                        else
                            tick = 1.0;
                        while (count > 0) {
                            tick /= 10;
                            count--;
                        }
                    }
                    return tick;
                }
                static getInterval(minValue, maxValue, num) {
                    if (maxValue == minValue)
                        return 0;
                    return StiStripLineCalculatorXF.getInterval1((maxValue - minValue) / num);
                }
                static getStripLines(minValue, maxValue, step, asDateTimeValue) {
                    let list = new Chart.StiStripLinesXF();
                    if (minValue == maxValue)
                        return list;
                    let minValueD = minValue;
                    let maxValueD = maxValue;
                    let stepD = step;
                    let pos = 0;
                    pos = Math.trunc(minValueD / stepD) * stepD;
                    while (minValueD < pos + stepD)
                        pos -= stepD;
                    let stepCountAfterComma = this.getCountAfterComma(stepD);
                    let posCountAfterComma = this.getCountAfterComma(pos);
                    let countAfterComma = Math.max(stepCountAfterComma, posCountAfterComma);
                    while (pos < maxValueD) {
                        pos += stepD;
                        if (countAfterComma > 0)
                            pos = Math.round2(pos, countAfterComma);
                        if (asDateTimeValue)
                            list.insert(0, new Chart.StiStripLineXF(DateTime.fromOADate(pos), pos));
                        else
                            list.insert(0, new Chart.StiStripLineXF(pos.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), pos));
                    }
                    return list;
                }
                static getCountAfterComma(num) {
                    let stringStepValue = num.toString().stimulsoft().replaceAll(",", ".");
                    let indexComma = stringStepValue.indexOf(".");
                    let countAfterComma = 0;
                    if (indexComma > 0)
                        countAfterComma = stringStepValue.substring(indexComma).length - 1;
                    return countAfterComma;
                }
                static getStripLinesLogScale(minValue, maxValue) {
                    let list = new Chart.StiStripLinesXF();
                    if (minValue == maxValue)
                        return list;
                    let minValueD = minValue;
                    let maxValueD = maxValue;
                    let minValueScale = 1;
                    let maxValueScale = 1;
                    if (0 < minValue && minValue < 1) {
                        while (minValueD < minValueScale) {
                            minValueScale /= 10;
                        }
                    }
                    if (minValue > 1) {
                        while (minValueD > minValueScale) {
                            minValueScale *= 10;
                        }
                        minValueScale /= 10;
                    }
                    if (0 < maxValueD && maxValueD < 1) {
                        while (maxValueScale > maxValueD) {
                            maxValueScale /= 10;
                        }
                        maxValueScale *= 10;
                    }
                    if (maxValueD > 1) {
                        while (maxValueD > maxValueScale) {
                            maxValueScale *= 10;
                        }
                    }
                    let pos = minValueScale;
                    let startStepValue = pos;
                    let index = 1;
                    while (pos <= maxValueScale) {
                        list.insert(0, new Chart.StiStripLineXF(pos.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), pos));
                        pos += startStepValue;
                        index++;
                        if (index == 10) {
                            index = 1;
                            startStepValue = pos;
                        }
                    }
                    return list;
                }
            }
            Chart.StiStripLineCalculatorXF = StiStripLineCalculatorXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStripLineXF {
                constructor(valueObject, value) {
                    this._valueObject = null;
                    this.valueObj = 0;
                    this.valueObject = valueObject;
                    this.valueObj = value;
                }
                implements() {
                    if (!StiStripLineXF.implementsStiStripLineXF)
                        StiStripLineXF.implementsStiStripLineXF = [
                            ICloneable,
                            Chart.IStiStripLinesXF
                        ];
                    return StiStripLineXF.implementsStiStripLineXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get valueObject() {
                    return this._valueObject;
                }
                set valueObject(value) {
                    this._valueObject = value;
                }
                get value() {
                    return this.valueObj;
                }
                set value(value) {
                    this.valueObj = value;
                }
            }
            Chart.StiStripLineXF = StiStripLineXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            class StiStripLinesXF extends CollectionBase {
                implements() {
                    if (!StiStripLinesXF.implementsStiStripLinesXF)
                        StiStripLinesXF.implementsStiStripLinesXF = [
                            ICloneable,
                            Chart.IStiStripLinesXF
                        ];
                    return StiStripLinesXF.implementsStiStripLinesXF;
                }
                clone() {
                    let newLines = new StiStripLinesXF();
                    for (let line of this.list) {
                        let lineClone = line.clone();
                        newLines.add(lineClone);
                    }
                    return newLines;
                }
                add2(valueObject, value) {
                    this.add(new Chart.StiStripLineXF(valueObject, value));
                }
            }
            Chart.StiStripLinesXF = StiStripLinesXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStripPositionXF {
                implements() {
                    if (!StiStripPositionXF.implementsStiStripPositionXF)
                        StiStripPositionXF.implementsStiStripPositionXF = [
                            Chart.IStiStripPositionXF
                        ];
                    return StiStripPositionXF.implementsStiStripPositionXF;
                }
            }
            Chart.StiStripPositionXF = StiStripPositionXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiChartTitleCoreXF {
                constructor(chartTitle) {
                    this._chartTitle = chartTitle;
                }
                implements() {
                    if (!StiChartTitleCoreXF.implementsStiChartTitleCoreXF)
                        StiChartTitleCoreXF.implementsStiChartTitleCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiChartTitleCoreXF
                        ];
                    return StiChartTitleCoreXF.implementsStiChartTitleCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.chartTitle.allowApplyStyle) {
                        this.chartTitle.brush = new StiSolidBrush(style.core.axisTitleColor);
                    }
                }
                render(context, chartTitle, rect) {
                    if (!chartTitle.visible)
                        return null;
                    let font = new StiFontGeom(chartTitle.font.fontFamily.name, chartTitle.font.size, chartTitle.font.style, chartTitle.font.unit);
                    let sf = context.getDefaultStringFormat();
                    sf.alignment = chartTitle.alignment;
                    let fullRectangle = context.measureRotatedString2(chartTitle.text, font, rect, sf, StiRotationMode.CenterCenter, chartTitle.dock, 0);
                    switch (chartTitle.dock) {
                        case Chart.StiChartTitleDock.Top:
                            fullRectangle.height += chartTitle.spacing;
                            fullRectangle.height *= context.options.zoom;
                            fullRectangle.y = rect.y;
                            if (chartTitle.alignment != StringAlignment.Center)
                                fullRectangle.width *= context.options.zoom;
                            if (chartTitle.alignment == StringAlignment.Near)
                                fullRectangle.x = rect.x;
                            if (chartTitle.alignment == StringAlignment.Center)
                                fullRectangle.x = rect.x + rect.width / 2 - fullRectangle.width / 2;
                            if (chartTitle.alignment == StringAlignment.Far)
                                fullRectangle.x = rect.x + rect.width - fullRectangle.width;
                            break;
                        case Chart.StiChartTitleDock.Right:
                            fullRectangle.width += chartTitle.spacing;
                            fullRectangle.width *= context.options.zoom;
                            fullRectangle.x = rect.x + rect.width - fullRectangle.width;
                            if (chartTitle.alignment != StringAlignment.Center)
                                fullRectangle.height *= context.options.zoom;
                            if (chartTitle.alignment == StringAlignment.Near)
                                fullRectangle.y = rect.y;
                            if (chartTitle.alignment == StringAlignment.Center)
                                fullRectangle.y = rect.y + rect.height / 2 - fullRectangle.height / 2;
                            if (chartTitle.alignment == StringAlignment.Far)
                                fullRectangle.y = rect.y + rect.height - fullRectangle.height;
                            break;
                        case Chart.StiChartTitleDock.Bottom:
                            fullRectangle.height += chartTitle.spacing;
                            fullRectangle.height *= context.options.zoom;
                            fullRectangle.y = rect.y + rect.height - fullRectangle.height;
                            if (chartTitle.alignment != StringAlignment.Center)
                                fullRectangle.width *= context.options.zoom;
                            if (chartTitle.alignment == StringAlignment.Near)
                                fullRectangle.x = rect.x + rect.width - fullRectangle.width;
                            if (chartTitle.alignment == StringAlignment.Center)
                                fullRectangle.x = rect.x + rect.width / 2 - fullRectangle.width / 2;
                            if (chartTitle.alignment == StringAlignment.Far)
                                fullRectangle.x = rect.x;
                            break;
                        case Chart.StiChartTitleDock.Left:
                            fullRectangle.width += chartTitle.spacing;
                            fullRectangle.width *= context.options.zoom;
                            fullRectangle.x = rect.x;
                            if (chartTitle.alignment != StringAlignment.Center)
                                fullRectangle.height *= context.options.zoom;
                            if (chartTitle.alignment == StringAlignment.Near)
                                fullRectangle.y = rect.y + rect.height - fullRectangle.height;
                            if (chartTitle.alignment == StringAlignment.Center)
                                fullRectangle.y = rect.y + rect.height / 2 - fullRectangle.height / 2;
                            if (chartTitle.alignment == StringAlignment.Far)
                                fullRectangle.y = rect.y;
                            break;
                    }
                    return new Chart.StiChartTitleGeom(chartTitle, fullRectangle);
                }
                get chartTitle() {
                    return this._chartTitle;
                }
                set chartTitle(value) {
                    this._chartTitle = value;
                }
            }
            Chart.StiChartTitleCoreXF = StiChartTitleCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var ICloneable = Stimulsoft.System.ICloneable;
            var DateTime = Stimulsoft.System.DateTime;
            class StiConstantLinesCoreXF {
                constructor(constantLines) {
                    this._constantLines = constantLines;
                }
                implements() {
                    if (!StiConstantLinesCoreXF.implementsStiConstantLinesCoreXF)
                        StiConstantLinesCoreXF.implementsStiConstantLinesCoreXF = [Chart.IStiApplyStyle, ICloneable, Chart.IStiConstantLinesCoreXF];
                    return StiConstantLinesCoreXF.implementsStiConstantLinesCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.constantLines.allowApplyStyle) {
                        this.constantLines.lineColor = style.core.seriesLabelsColor;
                    }
                }
                renderXConstantLines(geom, rect) {
                    let area = geom.area;
                    if (area == null)
                        return;
                    let value;
                    let result = DateTime.fromString(this.constantLines.axisValue, false);
                    if (result != null) {
                        value = result.toOADate();
                    }
                    else {
                        try {
                            value = this.constantLines.axisValue.stimulsoft().toNumber();
                        }
                        catch (e) {
                            Stimulsoft.System.StiError.showError(e, false);
                            value = 0;
                        }
                    }
                    if (area.reverseVert)
                        value = -value;
                    let left = 0;
                    if (area.xAxis.logarithmicScale && area.xAxis.info.stripLines.count > 0) {
                        let countStrip = area.xAxis.info.stripLines.count;
                        let startPoint = area.reverseHor ? countStrip - 1 : 0;
                        let endPoint = area.reverseHor ? 0 : countStrip - 1;
                        let startValue = area.xAxis.info.stripLines.getByIndex(startPoint).value;
                        let endValue = area.xAxis.info.stripLines.getByIndex(endPoint).value;
                        let decadeX = Math.abs(rect.width / (Math.log10(endValue) - Math.log10(startValue)));
                        left = Math.abs(Math.log10(value) * decadeX - Math.log10(area.xAxis.info.stripLines.getByIndex(startPoint).value) * decadeX);
                    }
                    else {
                        left = area.axisCore.getDividerX() + value * area.xAxis.info.dpi;
                        for (let tick of area.xAxis.info.stripLines.list) {
                            if (tick.valueObject != null && tick.valueObject.toString() == this.constantLines.axisValue) {
                                value = tick.value;
                                if (area.reverseHor)
                                    value = -value;
                                left = (value * area.xAxis.info.dpi) + area.axisCore.getDividerX();
                            }
                        }
                    }
                    let point = new PointD(0, 0);
                    let mode = StiRotationMode.LeftTop;
                    switch (this.constantLines.position) {
                        case Chart.StiConstantLines_StiTextPosition.LeftTop:
                            mode = StiRotationMode.LeftBottom;
                            point = new PointD(left + this.constantLines.lineWidth / 2, 0);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.LeftBottom:
                            mode = StiRotationMode.LeftTop;
                            point = new PointD(left - this.constantLines.lineWidth / 2, 0);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.CenterTop:
                            mode = StiRotationMode.CenterBottom;
                            point = new PointD(left + this.constantLines.lineWidth / 2, rect.height / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.CenterBottom:
                            mode = StiRotationMode.CenterTop;
                            point = new PointD(left - this.constantLines.lineWidth / 2, rect.height / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.RightTop:
                            mode = StiRotationMode.RightBottom;
                            point = new PointD(left + this.constantLines.lineWidth / 2, rect.height);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.RightBottom:
                            mode = StiRotationMode.RightTop;
                            point = new PointD(left - this.constantLines.lineWidth / 2, rect.height);
                            break;
                    }
                    let lineGeom = new Chart.StiConstantLinesVerticalGeom(this.constantLines, new RectangleD(left, 0, left, rect.height), point, mode);
                    geom.createChildGeoms();
                    geom.childGeoms.push(lineGeom);
                }
                renderYConstantLines(geom, rect) {
                    let area = geom.area;
                    if (area == null)
                        return;
                    let value;
                    try {
                        value = this.constantLines.axisValue.stimulsoft().toNumber();
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                        value = 0;
                    }
                    if (area.reverseVert)
                        value = -value;
                    let top;
                    if (area.yAxis.logarithmicScale) {
                        let countStrip = area.yAxis.info.stripLines.count;
                        let startPoint = 0;
                        let endPoint = countStrip - 1;
                        let startValue = area.yAxis.info.stripLines.getByIndex(startPoint).value;
                        let endValue = area.yAxis.info.stripLines.getByIndex(endPoint).value;
                        let decadeY = Math.abs(rect.height / (Math.log10(endValue) - Math.log10(startValue)));
                        top = Math.abs(Math.log10(area.yAxis.info.stripLines.getByIndex(startPoint).value) * decadeY - Math.log10(value) * decadeY);
                    }
                    else {
                        if (this.constantLines.orientation == Chart.StiConstantLines_StiOrientation.Horizontal)
                            top = area.axisCore.getDividerY() - value * area.yAxis.info.dpi;
                        else
                            top = area.axisCore.getDividerRightY() - value * area.yRightAxis.info.dpi;
                    }
                    let point = new PointD(0, 0);
                    let mode = StiRotationMode.LeftTop;
                    switch (this.constantLines.position) {
                        case Chart.StiConstantLines_StiTextPosition.LeftTop:
                            mode = StiRotationMode.LeftBottom;
                            point = new PointD(-rect.x, top - this.constantLines.lineWidth / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.LeftBottom:
                            mode = StiRotationMode.LeftTop;
                            point = new PointD(-rect.x, top + this.constantLines.lineWidth / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.CenterTop:
                            mode = StiRotationMode.CenterBottom;
                            point = new PointD(rect.width / 2, top - this.constantLines.lineWidth / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.CenterBottom:
                            mode = StiRotationMode.CenterTop;
                            point = new PointD(rect.width / 2, top + this.constantLines.lineWidth / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.RightTop:
                            mode = StiRotationMode.RightBottom;
                            point = new PointD(rect.width, top - this.constantLines.lineWidth / 2);
                            break;
                        case Chart.StiConstantLines_StiTextPosition.RightBottom:
                            mode = StiRotationMode.RightTop;
                            point = new PointD(rect.width, top + this.constantLines.lineWidth / 2);
                            break;
                    }
                    let lineGeom = new Chart.StiConstantLinesYGeom(this.constantLines, new RectangleD(0, top, rect.width, top), point, mode);
                    geom.createChildGeoms();
                    geom.childGeoms.push(lineGeom);
                }
                render(context, geom, rect) {
                    if (!this.constantLines.visible)
                        return;
                    if (this.constantLines.orientation == Chart.StiConstantLines_StiOrientation.Vertical)
                        this.renderXConstantLines(geom, rect);
                    if (this.constantLines.orientation == Chart.StiConstantLines_StiOrientation.Horizontal || this.constantLines.orientation == Chart.StiConstantLines_StiOrientation.HorizontalRight)
                        this.renderYConstantLines(geom, rect);
                }
                get constantLines() {
                    return this._constantLines;
                }
                set constantLines(value) {
                    this._constantLines = value;
                }
            }
            Chart.StiConstantLinesCoreXF = StiConstantLinesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiGridLinesCoreXF {
                constructor(gridLines) {
                    this._gridLines = gridLines;
                }
                implements() {
                    if (!StiGridLinesCoreXF.implementsStiGridLinesCoreXF)
                        StiGridLinesCoreXF.implementsStiGridLinesCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiGridLinesCoreXF
                        ];
                    return StiGridLinesCoreXF.implementsStiGridLinesCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.gridLines.allowApplyStyle) {
                        if (this.gridLines.stimulsoft().is(Chart.IStiGridLinesVert)) {
                            this.gridLines.color = style.core.gridLinesVertColor;
                            this.gridLines.minorColor = style.core.gridLinesVertColor;
                        }
                        else {
                            this.gridLines.color = style.core.gridLinesHorColor;
                            this.gridLines.minorColor = style.core.gridLinesHorColor;
                        }
                    }
                }
                get gridLines() {
                    return this._gridLines;
                }
                set gridLines(value) {
                    this._gridLines = value;
                }
            }
            Chart.StiGridLinesCoreXF = StiGridLinesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarGridLinesCoreXF {
                constructor(gridLines) {
                    this._gridLines = gridLines;
                }
                implements() {
                    if (!StiRadarGridLinesCoreXF.implementsStiRadarGridLinesCoreXF)
                        StiRadarGridLinesCoreXF.implementsStiRadarGridLinesCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiRadarGridLinesCoreXF
                        ];
                    return StiRadarGridLinesCoreXF.implementsStiRadarGridLinesCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.gridLines.allowApplyStyle) {
                        if (this.gridLines.stimulsoft().is(Chart.IStiRadarGridLinesVert)) {
                            this.gridLines.color = style.core.gridLinesVertColor;
                        }
                        else {
                            this.gridLines.color = style.core.gridLinesHorColor;
                        }
                    }
                }
                get gridLines() {
                    return this._gridLines;
                }
                set gridLines(value) {
                    this._gridLines = value;
                }
            }
            Chart.StiRadarGridLinesCoreXF = StiRadarGridLinesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiInterlacingCoreXF {
                constructor(interlacing) {
                    this._interlacing = interlacing;
                }
                implements() {
                    if (!StiInterlacingCoreXF.implementsStiInterlacingCoreXF)
                        StiInterlacingCoreXF.implementsStiInterlacingCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiInterlacingCoreXF
                        ];
                    return StiInterlacingCoreXF.implementsStiInterlacingCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.interlacing.allowApplyStyle) {
                        if (this.interlacing.stimulsoft().is(Chart.IStiInterlacingVert)) {
                            this.interlacing.interlacedBrush = style.core.interlacingVertBrush;
                        }
                        else {
                            this.interlacing.interlacedBrush = style.core.interlacingHorBrush;
                        }
                    }
                }
                get interlacing() {
                    return this._interlacing;
                }
                set interlacing(value) {
                    this._interlacing = value;
                }
            }
            Chart.StiInterlacingCoreXF = StiInterlacingCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var List = Stimulsoft.System.Collections.List;
            var PointD = Stimulsoft.System.Drawing.Point;
            var SizeD = Stimulsoft.System.Drawing.Size;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var RectangleF = Stimulsoft.System.Drawing.Rectangle;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiChartSeriesOrientation = Stimulsoft.Report.Chart.StiChartSeriesOrientation;
            class StiLegendCoreXF {
                constructor(legend) {
                    this._legend = legend;
                }
                implements() {
                    if (!StiLegendCoreXF.implementsStiLegendCoreXF)
                        StiLegendCoreXF.implementsStiLegendCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiLegendCoreXF
                        ];
                    return StiLegendCoreXF.implementsStiLegendCoreXF;
                }
                applyStyle(style) {
                    if (this.legend.allowApplyStyle) {
                        this.legend.brush = style.core.legendBrush.clone();
                        this.legend.labelsColor = style.core.legendLabelsColor;
                        this.legend.titleColor = style.core.legendTitleColor;
                        this.legend.borderColor = style.core.legendBorderColor;
                        this.legend.showShadow = style.core.legendShowShadow;
                        this.legend.font = style.core.legendFont;
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                render(context, rect) {
                    let realCountItems;
                    let REFrealCountItems = { ref: realCountItems };
                    let seriesItems = this.getLegendItems(REFrealCountItems);
                    realCountItems = REFrealCountItems.ref;
                    if ((!this.legend.visible) || seriesItems.length == 0)
                        return null;
                    let countColumns;
                    let countRows;
                    let REFcountColumns = { ref: countColumns };
                    let REFcountRows = { ref: countRows };
                    let legendSize = this.getLegendSize(context, rect, REFcountColumns, REFcountRows);
                    countColumns = REFcountColumns.ref;
                    countRows = REFcountRows.ref;
                    let legendRect = new RectangleD(rect.x, rect.y, legendSize.width, legendSize.height);
                    let legendClientRect = legendRect.clone();
                    legendClientRect.location = new PointD(0, 0);
                    let titleGeom = null;
                    if (!StiString.isNullOrEmpty(this.legend.title)) {
                        let titleSize = this.getTitleSize(context);
                        let titleRect = legendRect.clone();
                        titleRect.location = new PointD(0, 0);
                        titleRect.height = titleSize.height;
                        titleGeom = new Chart.StiLegendTitleGeom(this.legend, titleRect);
                        legendClientRect.y += titleRect.height;
                        legendClientRect.height -= titleRect.height;
                    }
                    let legendGeom = new Chart.StiLegendGeom(this.legend, legendRect, seriesItems);
                    if (titleGeom != null) {
                        legendGeom.createChildGeoms();
                        legendGeom.childGeoms.push(titleGeom);
                        legendGeom.legendTitleGeom = titleGeom;
                    }
                    let scaledHorSpacing = this.legend.horSpacing * context.options.zoom;
                    let scaledVertSpacing = this.legend.vertSpacing * context.options.zoom;
                    if (legendRect.width > 0 && legendRect.height > 0) {
                        if (this.legend.columns == 0) {
                            let startX = scaledHorSpacing + legendClientRect.x;
                            let startY = scaledVertSpacing + legendClientRect.y;
                            let posX = startX;
                            let posY = startY;
                            let itemWidthMax = 0;
                            let itemHeighthMax = 0;
                            let matrixIndexItem = this.getMatrixIndexItem(countColumns, countRows, seriesItems.length);
                            for (let indexColumn = 0; indexColumn < matrixIndexItem.length; indexColumn++) {
                                for (let indexRow = 0; indexRow < matrixIndexItem[0].length; indexRow++) {
                                    let indexItem = matrixIndexItem[indexColumn][indexRow];
                                    if (indexItem >= 0) {
                                        let seriesItem = seriesItems[indexItem];
                                        let itemSize = this.getItemRealSize(context, seriesItem);
                                        itemWidthMax = Math.max(itemWidthMax, itemSize.width);
                                        itemHeighthMax = Math.max(itemHeighthMax, itemSize.height);
                                        let itemRect = new RectangleF(posX, posY, itemSize.width, itemSize.height);
                                        let itemGeom = new Chart.StiLegendItemGeom(this.legend, seriesItem, itemRect, seriesItem.colorIndex, realCountItems, seriesItem.index);
                                        legendGeom.createChildGeoms();
                                        legendGeom.childGeoms.push(itemGeom);
                                    }
                                    posY += itemHeighthMax + scaledVertSpacing;
                                }
                                posY = startY;
                                posX += itemWidthMax + scaledHorSpacing;
                                itemWidthMax = 0;
                            }
                        }
                        else {
                            let startX = 0;
                            let startY = 0;
                            let itemSize = this.getItemSize1(context, seriesItems, 0);
                            if (this.legend.direction == Chart.StiLegendDirection.LeftToRight || this.legend.direction == Chart.StiLegendDirection.TopToBottom) {
                                startX = scaledHorSpacing + legendClientRect.x;
                                startY = scaledVertSpacing + legendClientRect.y;
                            }
                            else if (this.legend.direction == Chart.StiLegendDirection.RightToLeft) {
                                startX = legendClientRect.right - scaledHorSpacing - itemSize.width;
                                startY = scaledVertSpacing + legendClientRect.y;
                            }
                            else if (this.legend.direction == Chart.StiLegendDirection.BottomToTop) {
                                startX = scaledHorSpacing + legendClientRect.x;
                                startY = legendClientRect.bottom - scaledVertSpacing - itemSize.height;
                            }
                            let posX = startX;
                            let posY = startY;
                            let columnIndex = 0;
                            let colorIndex = 0;
                            for (let seriesItem of seriesItems) {
                                itemSize = this.getItemSize2(context, seriesItems, seriesItem);
                                let itemRect = new RectangleD(posX, posY, itemSize.width, itemSize.height);
                                let itemGeom = new Chart.StiLegendItemGeom(this.legend, seriesItem, itemRect, seriesItem.colorIndex, realCountItems, seriesItem.index);
                                legendGeom.createChildGeoms();
                                legendGeom.childGeoms.push(itemGeom);
                                columnIndex++;
                                if (this.legend.direction == Chart.StiLegendDirection.TopToBottom) {
                                    posY += scaledVertSpacing + itemRect.height;
                                    if (columnIndex == this.legend.columns) {
                                        posY = startY;
                                        posX += itemSize.width + scaledHorSpacing;
                                        columnIndex = 0;
                                    }
                                }
                                else if (this.legend.direction == Chart.StiLegendDirection.LeftToRight) {
                                    posX += scaledHorSpacing + itemRect.width;
                                    if (columnIndex == this.legend.columns) {
                                        posX = startX;
                                        posY += itemSize.height + scaledVertSpacing;
                                        columnIndex = 0;
                                    }
                                }
                                else if (this.legend.direction == Chart.StiLegendDirection.RightToLeft) {
                                    itemSize = this.getItemSize1(context, seriesItems, colorIndex + 1);
                                    posX -= scaledHorSpacing + itemSize.width;
                                    if (columnIndex == this.legend.columns) {
                                        posX = startX;
                                        posY += itemSize.height + scaledVertSpacing;
                                        columnIndex = 0;
                                    }
                                }
                                else if (this.legend.direction == Chart.StiLegendDirection.BottomToTop) {
                                    posY -= scaledVertSpacing + itemRect.height;
                                    if (columnIndex == this.legend.columns) {
                                        posY = startY;
                                        posX += itemSize.width + scaledHorSpacing;
                                        columnIndex = 0;
                                    }
                                }
                                colorIndex++;
                            }
                        }
                    }
                    return legendGeom;
                }
                getMatrixIndexItem(countColumns, countRows, countItems) {
                    let matrixIndexItem = StiArray.create2(Number, countColumns, countRows);
                    if (this.legend.direction == Chart.StiLegendDirection.TopToBottom) {
                        let index = 0;
                        for (let indexRow = 0; indexRow < countRows; indexRow++) {
                            for (let indexColumn = 0; indexColumn < countColumns; indexColumn++) {
                                matrixIndexItem[indexColumn][indexRow] = index < countItems ? index : -1;
                                index++;
                            }
                        }
                    }
                    else if (this.legend.direction == Chart.StiLegendDirection.BottomToTop) {
                        let index = 0;
                        for (let indexRow = countRows - 1; indexRow >= 0; indexRow--) {
                            for (let indexColumn = 0; indexColumn < countColumns; indexColumn++) {
                                matrixIndexItem[indexColumn][indexRow] = index < countItems ? index : -1;
                                index++;
                            }
                        }
                    }
                    else if (this.legend.direction == Chart.StiLegendDirection.LeftToRight) {
                        let index = 0;
                        for (let indexColumn = 0; indexColumn < countColumns; indexColumn++) {
                            for (let indexRow = 0; indexRow < countRows; indexRow++) {
                                matrixIndexItem[indexColumn][indexRow] = index < countItems ? index : -1;
                                index++;
                            }
                        }
                    }
                    else if (this.legend.direction == Chart.StiLegendDirection.RightToLeft) {
                        let index = 0;
                        for (let indexColumn = countColumns - 1; indexColumn >= 0; indexColumn--) {
                            for (let indexRow = 0; indexRow < countRows; indexRow++) {
                                matrixIndexItem[indexColumn][indexRow] = index < countItems ? index : -1;
                                index++;
                            }
                        }
                    }
                    return matrixIndexItem;
                }
                getArgumentText(series, index) {
                    if (series.arguments.length > index && series.arguments[index] != null) {
                        return series.arguments[index].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                getLegendItemColumn(seriesItems, seriesItem) {
                    let seriesIndex = 0;
                    let columnIndex = 0;
                    for (let item of seriesItems) {
                        if (item == seriesItem)
                            break;
                        seriesIndex++;
                        if (seriesIndex >= this.legend.columns) {
                            seriesIndex = 0;
                            columnIndex++;
                        }
                    }
                    if (this.legend.direction == Chart.StiLegendDirection.TopToBottom || this.legend.direction == Chart.StiLegendDirection.BottomToTop)
                        return columnIndex;
                    return seriesIndex;
                }
                getTitleSize(context) {
                    if (StiString.isNullOrEmpty(this.legend.title))
                        return new SizeD(0, 0);
                    let newFont = StiFontGeom.changeFontSize(this.legend.titleFont, this.legend.titleFont.size * context.options.zoom);
                    let sf = context.getDefaultStringFormat();
                    sf.formatFlags = 0;
                    let size = context.measureString(this.legend.title, newFont);
                    size.width++;
                    return size;
                }
                getItemSize1(context, seriesItems, seriesIndex) {
                    if (seriesIndex >= 0 && seriesIndex < seriesItems.length) {
                        let seriesItem = seriesItems[seriesIndex];
                        return this.getItemSize2(context, seriesItems, seriesItem);
                    }
                    return new SizeD(0, 0);
                }
                getItemSize2(context, seriesItems, seriesItem) {
                    let itemWidth = 0;
                    let itemHeight = 0;
                    let seriesItemColumn = this.getLegendItemColumn(seriesItems, seriesItem);
                    let newFont = StiFontGeom.changeFontSize(this.legend.font, this.legend.font.size * context.options.zoom);
                    for (let item of seriesItems) {
                        if (this.getLegendItemColumn(seriesItems, item) == seriesItemColumn) {
                            let sizeStr = context.measureString(item.text, newFont);
                            itemWidth = Math.max(sizeStr.width, itemWidth + 2);
                            itemHeight = Math.max(sizeStr.height, itemHeight);
                        }
                    }
                    if (this.legend.markerVisible) {
                        itemWidth = Math.max(this.legend.markerSize.width * context.options.zoom, itemWidth) + this.legend.markerSize.width * context.options.zoom;
                        itemHeight = Math.max(this.legend.markerSize.height * context.options.zoom, itemHeight);
                    }
                    return new SizeD(itemWidth, itemHeight);
                }
                getItemRealSize(context, seriesItem) {
                    let newFont = StiFontGeom.changeFontSize(this.legend.font, this.legend.font.size * context.options.zoom);
                    let sizeStr = context.measureString(seriesItem.text, newFont);
                    let itemWidth = sizeStr.width;
                    let itemHeight = sizeStr.height;
                    if (this.legend.markerVisible) {
                        itemWidth += this.legend.markerSize.width * context.options.zoom;
                        itemHeight = Math.max(this.legend.markerSize.height * context.options.zoom, itemHeight);
                    }
                    return new SizeD(itemWidth, itemHeight);
                }
                getItemsSize(context, seriesItems) {
                    let scaledHorSpacing = this.legend.horSpacing * context.options.zoom;
                    let itemWidth = 0;
                    let itemHeight = 0;
                    let columnsCount = this.legend.columns;
                    if (this.legend.direction == Chart.StiLegendDirection.TopToBottom || this.legend.direction == Chart.StiLegendDirection.BottomToTop) {
                        columnsCount = Math.trunc((seriesItems.length - 1) / this.legend.columns) + 1;
                    }
                    for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
                        for (let item of seriesItems) {
                            if (this.getLegendItemColumn(seriesItems, item) == columnIndex) {
                                let itemSize = this.getItemSize2(context, seriesItems, item);
                                itemWidth += itemSize.width + scaledHorSpacing;
                                itemHeight = Math.max(itemSize.height, itemHeight);
                                break;
                            }
                        }
                    }
                    return new SizeD(itemWidth, itemHeight);
                }
                getItemsAutoSize(context, seriesItems, rect, countColumns, countRows) {
                    let isVertOrientaion = this.legend.direction == Chart.StiLegendDirection.TopToBottom || this.legend.direction == Chart.StiLegendDirection.BottomToTop;
                    let scaledHorSpacing = this.legend.horSpacing * context.options.zoom;
                    let scaledVertSpacing = this.legend.vertSpacing * context.options.zoom;
                    let newFont = StiFontGeom.changeFontSize(this.legend.font, this.legend.font.size * context.options.zoom);
                    let indexColumn = 0;
                    let indexRow = 0;
                    let widthColumns = new List();
                    let heightRows = new List();
                    let itemHeightMax = 0;
                    let maxColumns = null;
                    for (let index = 0; index < seriesItems.length; index++) {
                        let itemCurrent = seriesItems[index];
                        let sizeStr = context.measureString(itemCurrent.text, newFont);
                        let itemCurrentWidth = sizeStr.width + scaledHorSpacing;
                        let itemCurrentHeight = sizeStr.height + scaledVertSpacing;
                        if (this.legend.markerVisible) {
                            itemCurrentWidth += this.legend.markerSize.width * context.options.zoom;
                            itemCurrentHeight = Math.max(this.legend.markerSize.height * context.options.zoom + scaledVertSpacing, itemCurrentHeight);
                        }
                        itemHeightMax = Math.max(itemCurrentHeight, itemHeightMax);
                        if (isVertOrientaion) {
                            if (widthColumns.length - 1 < indexColumn && maxColumns == null ||
                                widthColumns.length - 1 < indexColumn && maxColumns != null && indexColumn <= maxColumns) {
                                widthColumns.push(itemCurrentWidth);
                            }
                            else if (widthColumns[indexColumn] < itemCurrentWidth) {
                                widthColumns[indexColumn] = itemCurrentWidth;
                                widthColumns.removeRange(indexColumn + 1, widthColumns.length - (indexColumn + 1));
                                index = -1;
                                indexColumn = 0;
                                indexRow = 0;
                                continue;
                            }
                            indexColumn++;
                            if (maxColumns != null && maxColumns <= indexColumn) {
                                indexColumn = 0;
                                indexRow++;
                            }
                            if (widthColumns.sum() + scaledHorSpacing > rect.width && widthColumns.length > 1) {
                                indexColumn = 0;
                                indexRow++;
                                if (index > 0)
                                    index--;
                                if (widthColumns.length > 0) {
                                    widthColumns.removeAt(widthColumns.length - 1);
                                    maxColumns = widthColumns.length;
                                }
                            }
                        }
                        else {
                            if (heightRows.length - 1 < indexRow)
                                heightRows.push(itemCurrentHeight);
                            indexRow++;
                            if (widthColumns.length - 1 < indexColumn) {
                                widthColumns.push(itemCurrentWidth);
                            }
                            else {
                                widthColumns[indexColumn] = Math.max(widthColumns[indexColumn], itemCurrentWidth);
                            }
                            if (heightRows.sum() + scaledVertSpacing > rect.height && heightRows.length > 1) {
                                indexColumn++;
                                indexRow = 0;
                                if (index > 0)
                                    index--;
                                if (heightRows.length > 0)
                                    heightRows.removeAt(heightRows.length - 1);
                            }
                        }
                    }
                    countColumns.ref = widthColumns.length;
                    if (isVertOrientaion)
                        countRows.ref = Math.ceil(seriesItems.length / widthColumns.length);
                    else
                        countRows.ref = heightRows.length;
                    return new SizeD(widthColumns.sum() + scaledHorSpacing, countRows.ref * itemHeightMax + scaledVertSpacing);
                }
                getSeriesSize(context, rect, countColumns, countRows) {
                    let scaledHorSpacing = this.legend.horSpacing * context.options.zoom;
                    let scaledVertSpacing = this.legend.vertSpacing * context.options.zoom;
                    let REFrealItemsCount = { ref: 0 };
                    let seriesItems = this.getLegendItems(REFrealItemsCount);
                    let realItemsCount = REFrealItemsCount.ref;
                    let width = 0;
                    let height = 0;
                    if (this.legend.columns == 0) {
                        let itemSize = this.getItemsAutoSize(context, seriesItems, rect, countColumns, countRows);
                        width = itemSize.width;
                        height = itemSize.height;
                    }
                    else {
                        countRows.ref = 0;
                        countColumns.ref = this.legend.columns;
                        let itemSize = this.getItemsSize(context, seriesItems);
                        switch (this.legend.direction) {
                            case Chart.StiLegendDirection.TopToBottom:
                            case Chart.StiLegendDirection.BottomToTop: {
                                width = itemSize.width + scaledHorSpacing;
                                let columnsCount = this.legend.columns;
                                if (columnsCount > realItemsCount)
                                    columnsCount = realItemsCount;
                                height = (itemSize.height + scaledVertSpacing) * columnsCount + scaledVertSpacing;
                                break;
                            }
                            case Chart.StiLegendDirection.LeftToRight:
                            case Chart.StiLegendDirection.RightToLeft: {
                                let count = Math.ceil(realItemsCount / this.legend.columns);
                                if (count * this.legend.columns < realItemsCount)
                                    count++;
                                width = itemSize.width + scaledHorSpacing;
                                height = (itemSize.height + scaledVertSpacing) * count + scaledVertSpacing;
                                break;
                            }
                        }
                    }
                    return new SizeD(width, height);
                }
                getLegendSize(context, rect, countColumns, countRows) {
                    let titleSize = this.getTitleSize(context);
                    let REFcountColumns = { ref: countColumns };
                    let REFcountRows = { ref: countRows };
                    let seriesSize = this.getSeriesSize(context, rect, REFcountColumns, REFcountRows);
                    countColumns.ref = REFcountColumns.ref;
                    countRows.ref = REFcountRows.ref;
                    let size = new SizeD(Math.max(titleSize.width, seriesSize.width), titleSize.height + seriesSize.height);
                    let width = 0;
                    let height = 0;
                    if (this.legend.chart != null) {
                        width = this.legend.chart.convertToHInches(this.legend.size.width * context.options.zoom);
                        height = this.legend.chart.convertToHInches(this.legend.size.height * context.options.zoom);
                    }
                    else {
                        width = (this.legend.size.width * context.options.zoom);
                        height = (this.legend.size.height * context.options.zoom);
                    }
                    if (width != 0)
                        size.width = width;
                    if (height != 0)
                        size.height = height;
                    size.width = Math.round(size.width);
                    size.height = Math.round(size.height);
                    return size;
                }
                getLegendItems(REFcount) {
                    let count = 0;
                    let seriesCollection = this.legend.chart.area.core.getSeries().stimulsoft().toList();
                    let axisArea = this.legend.chart.area.as(Chart.IStiAxisArea);
                    let list = [];
                    if (this.legend.chart.area.colorEach ||
                        seriesCollection.any(s => s.is(Chart.IStiFunnelSeries)) ||
                        seriesCollection.any(s => s.is(Chart.IStiPictorialSeries)) ||
                        seriesCollection.any(s => s.is(Chart.IStiDoughnutSeries))) {
                        let valuesCount = 0;
                        for (let series of seriesCollection) {
                            valuesCount = Math.max(series.values.length, valuesCount);
                        }
                        let colorIndex = 0;
                        for (let series of seriesCollection) {
                            if (this.legend.chart.area.core.isAcceptableSeries(series.stimulsoft().getType())) {
                                for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                                    if (series.showInLegend && series.values != null) {
                                        let revert = axisArea != null && (axisArea.reverseHor || axisArea.axisCore.seriesOrientation == StiChartSeriesOrientation.Horizontal);
                                        if (pointIndex >= series.values.length)
                                            continue;
                                        let currentPointIndex = revert ? series.values.length - pointIndex - 1 : pointIndex;
                                        let value = series.values[currentPointIndex];
                                        if (value != null) {
                                            let pieSeries = series.stimulsoft().as(Chart.IStiPieSeries);
                                            let funnelSeries = series.stimulsoft().as(Chart.IStiFunnelSeries);
                                            let doughnutSeries = series.stimulsoft().as(Chart.IStiDoughnutSeries);
                                            if (!((pieSeries != null && !pieSeries.showZeros
                                                || doughnutSeries != null && !doughnutSeries.showZeros
                                                || funnelSeries != null && !funnelSeries.showZeros)
                                                && value == 0)) {
                                                list.push(new Chart.StiLegendItemCoreXF(this.legend.chart.seriesLabels.core.getLabelText(series, value, this.getArgumentText(series, currentPointIndex), series.core.getTag(currentPointIndex), series.coreTitle, true), series, currentPointIndex, colorIndex));
                                            }
                                        }
                                    }
                                    count++;
                                    colorIndex++;
                                }
                            }
                        }
                    }
                    else {
                        if (this.legend.chart.area.is2(Chart.IStiSunburstArea)) {
                            if (seriesCollection.length >= 1) {
                                let mainseries = seriesCollection[0];
                                let argumentSeries = mainseries.arguments.stimulsoft().toList().groupBy(v => v).select(x => x.key).toList();
                                let index = 0;
                                for (let argument of argumentSeries) {
                                    let argumentText = argument.toString();
                                    if (!StiString.isNullOrEmpty(argumentText))
                                        list.push(new Chart.StiLegendItemCoreXF(argumentText, mainseries, index, index));
                                    index++;
                                    count++;
                                }
                            }
                        }
                        else if (this.legend.chart.area.is2(Chart.IStiBoxAndWhiskerArea)) {
                            if (seriesCollection.length >= 1) {
                                let mainseries = seriesCollection[0];
                                let index = 0;
                                for (let series of seriesCollection) {
                                    list.push(new Chart.StiLegendItemCoreXF(series.coreTitle, mainseries, index, index));
                                    index++;
                                    count++;
                                }
                            }
                        }
                        else if (this.legend.chart.area.is2(Chart.IStiWaterfallArea)) {
                            if (seriesCollection.length >= 1) {
                                let mainseries = seriesCollection[0];
                                list.push(new Chart.StiLegendItemCoreXF(StiLocalization.get("PropertyMain", "Positive"), mainseries, 0, 0));
                                list.push(new Chart.StiLegendItemCoreXF(StiLocalization.get("PropertyMain", "Negative"), mainseries, 0, 1));
                                list.push(new Chart.StiLegendItemCoreXF(mainseries.total.text, mainseries, 0, 2));
                                count = 3;
                            }
                        }
                        else {
                            for (let series of seriesCollection) {
                                if (this.legend.chart.area.core.isAcceptableSeries(series.stimulsoft().getType())) {
                                    if (series.showInLegend && !(this.legend.hideSeriesWithEmptyTitle && StiString.isNullOrEmpty(series.coreTitle) && !this.legend.chart.isDesigning)) {
                                        list.push(new Chart.StiLegendItemCoreXF(series.coreTitle, series, -1, 0));
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    REFcount.ref = count;
                    return list;
                }
                get legend() {
                    return this._legend;
                }
                set legend(value) {
                    this._legend = value;
                }
            }
            Chart.StiLegendCoreXF = StiLegendCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiLegendItemCoreXF {
                constructor(text, series, index, colorIndex) {
                    this._index = -1;
                    this._colorIndex = 0;
                    this._text = text;
                    this._series = series;
                    this._index = index;
                    this._colorIndex = colorIndex;
                }
                get text() {
                    return this._text;
                }
                get series() {
                    return this._series;
                }
                get index() {
                    return this._index;
                }
                get colorIndex() {
                    return this._colorIndex;
                }
            }
            Chart.StiLegendItemCoreXF = StiLegendItemCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var StiScaleAnimation = Stimulsoft.Base.Context.Animation.StiScaleAnimation;
            var Point = Stimulsoft.System.Drawing.Point;
            var List = Stimulsoft.System.Collections.List;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var SizeF = Stimulsoft.System.Drawing.Size;
            class StiMarkerCoreXF {
                constructor(marker) {
                    this.marker = marker;
                }
                implements() {
                    if (!StiMarkerCoreXF.implementsStiMarkerCoreXF)
                        StiMarkerCoreXF.implementsStiMarkerCoreXF = [
                            ICloneable,
                            Chart.IStiMarkerCoreXF
                        ];
                    return StiMarkerCoreXF.implementsStiMarkerCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                drawMarkers(context, points, showShadow) {
                    if (points.length == 0)
                        return;
                    if (this.marker != null && this.marker.visible) {
                        context.pushSmoothingModeToAntiAlias();
                        let chartZoom = context.options.zoom;
                        for (let point of points) {
                            this.marker.core.draw(context, this.marker, point, chartZoom, showShadow, false, false, false, "", null, null);
                        }
                        context.popSmoothingMode();
                    }
                }
                static getMarkerRect(position, markerSize, zoom) {
                    let dx = markerSize * zoom / 2;
                    return new RectangleD(position.x - dx, position.y - dx, dx * 2, dx * 2);
                }
                draw(context, marker, position, zoom, showShadow, isMouseOver, isTooltipMode, isAnimation, toolTip, tag, interaction) {
                    let shadowBrush = new StiSolidBrush(Color.fromArgb(55, Color.black));
                    let rect = StiMarkerCoreXF.getMarkerRect(position, marker.size, zoom).clone();
                    if (showShadow) {
                        rect.x += 2 * zoom;
                        rect.y += 2 * zoom;
                        this.drawPoint(context, rect.x + rect.width / 2, rect.y + rect.height / 2, zoom, shadowBrush, null, marker.type, marker.icon, marker.size, marker.angle, false, isAnimation, toolTip, null, null);
                        rect.x -= 2 * zoom;
                        rect.y -= 2 * zoom;
                    }
                    let brush = marker.brush;
                    if (isAnimation && isTooltipMode && !marker.visible) {
                        let color = marker.brush == null ? Color.lightGray : StiBrush.toColor(marker.brush);
                        brush = new StiSolidBrush(Color.fromArgb(0, color.r, color.g, color.b));
                        isAnimation = false;
                    }
                    let pen = isTooltipMode ? null : new StiPenGeom(marker.borderColor);
                    if (marker.visible || isTooltipMode)
                        this.drawPoint(context, rect.x + rect.width / 2, rect.y + rect.height / 2, zoom, brush, pen, marker.type, marker.icon, marker.size, marker.angle, isMouseOver, isAnimation, toolTip, tag, interaction);
                }
                drawLine(context, x1, y1, x2, y2, scale, brushMarker, penMarker, markerType, markerStep, markerSize, angle) {
                    this.drawLines(context, [new PointD(x1, y1), new PointD(x2, y2)], scale, brushMarker, penMarker, markerType, markerStep, markerSize, angle);
                }
                drawLines(context, points, scale, brushMarker, penMarker, markerType, markerStep, markerSize, angle) {
                    context.pushSmoothingModeToAntiAlias();
                    if (points.length < 2)
                        return;
                    let pos = 0;
                    for (let index = 0; index < points.length - 1; index++) {
                        let point = points[index];
                        let nextPoint = points[index + 1];
                        if (point == null || nextPoint == null)
                            continue;
                        let x1 = point.x;
                        let y1 = point.y;
                        let x2 = nextPoint.x;
                        let y2 = nextPoint.y;
                        let dx = x2 - x1;
                        let dy = y2 - y1;
                        let length = Math.sqrt(dx * dx + dy * dy);
                        let step = markerStep;
                        while (pos < length) {
                            let x = x1 + dx * pos / length;
                            let y = y1 + dy * pos / length;
                            this.drawPoint(context, x, y, scale, brushMarker, penMarker, markerType, this.marker.icon, markerSize, angle, false, false, "", null, null);
                            pos += step * scale;
                        }
                        pos -= length;
                    }
                    context.popSmoothingMode();
                }
                drawPoint(context, x, y, scale, brush, pen, markerType, icon, markerSize, angle, isMouseOver, isAnimation, toolTip, tag, interaction) {
                    let step = markerSize * scale / 2;
                    let x1 = x - step;
                    let x2 = x + step;
                    let y1 = y - step;
                    let y2 = y + step;
                    if (icon != null) {
                        let rect = new Rectangle(x1, y1, markerSize * scale, markerSize * scale);
                        Report.StiFontIconsHelper.drawDirectionIcons(context, brush, rect, new SizeF(rect.height, rect.height), icon, toolTip, false);
                        return;
                    }
                    switch (markerType) {
                        case Chart.StiMarkerType.Star5:
                            this.drawPolygon(context, brush, pen, x, y, step, 10, angle, true, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Star6:
                            this.drawPolygon(context, brush, pen, x, y, step, 12, angle, true, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Star7:
                            this.drawPolygon(context, brush, pen, x, y, step, 14, angle, true, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Star8:
                            this.drawPolygon(context, brush, pen, x, y, step, 16, angle, true, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Hexagon:
                            this.drawPolygon(context, brush, pen, x, y, step, 6, 30 + angle, false, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Rectangle:
                            this.drawPolygon(context, brush, pen, x, y, step, 4, 45 + angle, false, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                        case Chart.StiMarkerType.Circle:
                            if (isAnimation) {
                                let animation = new StiScaleAnimation(0, 0, 0, 0, 0, 0, Chart.StiChartHelper.globalDurationElement, TimeSpan.zero);
                                context.fillDrawAnimationEllipse(brush, pen, x1, y1, x2 - x1, y2 - y1, toolTip, tag, animation, interaction);
                            }
                            else {
                                if (brush != null)
                                    context.fillEllipse3(brush, x1, y1, x2 - x1, y2 - y1, toolTip, interaction);
                                if (isMouseOver)
                                    context.fillEllipse3(Chart.StiMouseOverHelper.getMouseOverColor(), x1, y1, x2 - x1, y2 - y1, toolTip, null);
                                if (pen != null)
                                    context.drawEllipse(pen, x1, y1, x2 - x1, y2 - y1);
                            }
                            break;
                        case Chart.StiMarkerType.HalfCircle: {
                            let rect = new Rectangle(x1, y1, x2 - x1, y2 - y1);
                            let rectEmpty = new Rectangle(0, 0, x2 - x1, y2 - y1);
                            let path = new List();
                            path.push(new StiArcSegmentGeom(new Rectangle(rectEmpty.x, rectEmpty.top + rectEmpty.height / 4, rectEmpty.width, rectEmpty.height), 360, -180));
                            path.push(new StiLineSegmentGeom(new Point(rectEmpty.x, rectEmpty.bottom - rectEmpty.height / 4), new Point(rectEmpty.right, rectEmpty.bottom - rectEmpty.height / 4)));
                            context.pushTranslateTransform(rect.x + rect.width / 2, rect.y + rect.height / 2);
                            context.pushRotateTransform(angle);
                            context.pushTranslateTransform(-rect.width / 2, -rect.height / 2);
                            if (isAnimation) {
                                let animation = new StiScaleAnimation(0, 0, 0, 0, 0, 0, Chart.StiChartHelper.globalDurationElement, TimeSpan.zero);
                                context.fillDrawAnimationPath(brush, pen, path, rect, tag, animation, interaction);
                            }
                            else {
                                if (brush != null)
                                    context.fillPath2(brush, path, rectEmpty, null, toolTip.toString());
                                if (isMouseOver)
                                    context.fillPath2(Chart.StiMouseOverHelper.getMouseOverColor(), path, rect, null, toolTip.toString());
                                if (pen != null)
                                    context.drawPath(pen, path, rectEmpty);
                            }
                            context.popTransform();
                            context.popTransform();
                            context.popTransform();
                            break;
                        }
                        case Chart.StiMarkerType.Triangle:
                            this.drawPolygon(context, brush, pen, x, y, step, 3, angle, false, isMouseOver, isAnimation, toolTip, tag, interaction);
                            break;
                    }
                }
                drawPolygon(context, fillBrush, borderPen, centerX, centerY, radius, count, startAngle, isStar, isMouseOver, isAnimation, toolTip, tag, interaction) {
                    startAngle = -startAngle;
                    let path = [];
                    let angle = -90 + startAngle;
                    let points = StiArray.create(PointD, count + 1, true);
                    if (isStar) {
                        for (let index = 0; index < count; index += 2) {
                            points[index].x = centerX + radius * Math.cos(angle * Math.PI / 180);
                            points[index].y = centerY + radius * Math.sin(angle * Math.PI / 180);
                            angle += 360 / count;
                            points[index + 1].x = centerX + radius / 2 * Math.cos(angle * Math.PI / 180);
                            points[index + 1].y = centerY + radius / 2 * Math.sin(angle * Math.PI / 180);
                            angle += 360 / count;
                        }
                    }
                    else {
                        for (let index = 0; index < count; index++) {
                            points[index].x = centerX + radius * Math.cos(angle * Math.PI / 180);
                            points[index].y = centerY + radius * Math.sin(angle * Math.PI / 180);
                            angle += 360 / count;
                        }
                    }
                    points[count] = points[0];
                    path.push(new StiLinesSegmentGeom(points));
                    if (isAnimation) {
                        let animation = new StiScaleAnimation(0, 0, 0, 0, 0, 0, Chart.StiChartHelper.globalDurationElement, TimeSpan.zero);
                        context.fillDrawAnimationPath(fillBrush, borderPen, path, StiPathGeom.getBoundsState, tag, animation, interaction);
                    }
                    else {
                        let toolTipText = toolTip != null ? toolTip.toString() : null;
                        if (fillBrush != null)
                            context.fillPath2(fillBrush, path, StiPathGeom.getBoundsState, null, toolTipText);
                        if (isMouseOver)
                            context.fillPath2(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null, toolTipText);
                        if (borderPen != null)
                            context.drawPath(borderPen, path, null);
                    }
                }
            }
            Chart.StiMarkerCoreXF = StiMarkerCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarAxisCoreXF {
                constructor(axis) {
                    this._axis = axis;
                }
                implements() {
                    if (!StiRadarAxisCoreXF.implementsStiRadarAxisCoreXF)
                        StiRadarAxisCoreXF.implementsStiRadarAxisCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiRadarAxisCoreXF
                        ];
                    return StiRadarAxisCoreXF.implementsStiRadarAxisCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                }
                get axis() {
                    return this._axis;
                }
                set axis(value) {
                    this._axis = value;
                }
            }
            Chart.StiRadarAxisCoreXF = StiRadarAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiEmptyBrush = Stimulsoft.Base.Drawing.StiEmptyBrush;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarAxisLabelsCoreXF {
                constructor(labels) {
                    this._labels = labels;
                }
                implements() {
                    if (!StiRadarAxisLabelsCoreXF.implementsStiRadarAxisLabelsCoreXF)
                        StiRadarAxisLabelsCoreXF.implementsStiRadarAxisLabelsCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiRadarAxisLabelsCoreXF
                        ];
                    return StiRadarAxisLabelsCoreXF.implementsStiRadarAxisLabelsCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.labels.allowApplyStyle) {
                        this.labels.color = style.core.seriesLabelsColor;
                        this.labels.brush = new StiEmptyBrush();
                    }
                }
                get labels() {
                    return this._labels;
                }
                set labels(value) {
                    this._labels = value;
                }
            }
            Chart.StiRadarAxisLabelsCoreXF = StiRadarAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiXRadarAxisCoreXF extends Chart.StiRadarAxisCoreXF {
                constructor(axis) {
                    super(axis);
                }
                implements() {
                    if (!StiXRadarAxisCoreXF.implementsStiXRadarAxisCoreXF)
                        StiXRadarAxisCoreXF.implementsStiXRadarAxisCoreXF = [
                            Chart.IStiXRadarAxisCoreXF
                        ];
                    return StiXRadarAxisCoreXF.implementsStiXRadarAxisCoreXF;
                }
                applyStyle(style) {
                    if (this.axis.allowApplyStyle) {
                        this.axis.labels.core.applyStyle(style);
                    }
                }
                renderLabel(context, series, point, argument, angle, colorIndex, colorCount) {
                    let argumentText = this.getLabelText(argument);
                    let rect = this.getLabelRect(context, point, argumentText, 0).clone();
                    rect.x = -rect.width / 2;
                    rect.y = -rect.height / 2;
                    let labelRect = this.getLabelRect(context, point, argumentText, angle).clone();
                    let borderColor = this.axis.labels.borderColor;
                    let labelBrush = new StiSolidBrush(this.axis.labels.color);
                    return new Chart.StiXRadarAxisLabelGeom(this.axis, argumentText, labelBrush, borderColor, angle, rect, labelRect, point);
                }
                getLabelText(value) {
                    try {
                        if (value == null)
                            value = "";
                        let xAxis = this.axis;
                        if (xAxis.labels.format != null && xAxis.labels.format.trim().length != 0) {
                            try {
                                if (typeof value == "string") {
                                }
                                if (!Chart.StiChartOptions.oldChartPercentMode && xAxis.labels.format.stimulsoft().startsWith("P")) {
                                    let signs = 0;
                                    if (xAxis.labels.format.length > 1) {
                                    }
                                    return StiString.format("{0}{1:N" + signs.toString() + "}{2}{3}", xAxis.labels.textBefore, value, "%", xAxis.labels.textAfter);
                                }
                                else
                                    return StiString.format("{0}{1:" + xAxis.labels.format + "}{2}", xAxis.labels.textBefore, value, xAxis.labels.textAfter);
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                        }
                        return StiString.format("{0}{1}{2}", xAxis.labels.textBefore, value, xAxis.labels.textAfter);
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    return value.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                getLabelRect(context, point, text, angle) {
                    let font = StiFontGeom.changeFontSize(this.axis.labels.font, this.axis.labels.font.size * context.options.zoom);
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    if (!this.axis.labels.wordWrap)
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    return context.measureRotatedString3(text, font, point, sf, StiRotationMode.CenterBottom, angle, Math.trunc(this.axis.labels.width * context.options.zoom));
                }
                get xAxis() {
                    return this.axis;
                }
            }
            Chart.StiXRadarAxisCoreXF = StiXRadarAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiHorAlignment = Stimulsoft.Base.Drawing.StiHorAlignment;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiNumberFormatService = Stimulsoft.Report.Components.TextFormats.StiNumberFormatService;
            class StiYRadarAxisCoreXF extends Chart.StiRadarAxisCoreXF {
                constructor(axis) {
                    super(axis);
                }
                implements() {
                    if (!StiYRadarAxisCoreXF.implementsStiYRadarAxisCoreXF)
                        StiYRadarAxisCoreXF.implementsStiYRadarAxisCoreXF = [
                            Chart.IStiYRadarAxisCoreXF
                        ];
                    return StiYRadarAxisCoreXF.implementsStiYRadarAxisCoreXF;
                }
                applyStyle(style) {
                    if (this.axis.allowApplyStyle) {
                        this.yAxis.lineColor = style.core.axisLineColor;
                        this.yAxis.labels.core.applyStyle(style);
                    }
                }
                render(context, rect) {
                    if (!this.axis.visible)
                        return null;
                    let axisRect = this.getAxisRect(context, rect).clone();
                    let geom = new Chart.StiRadarAxisGeom(this.axis, axisRect);
                    this.renderLabels(context, axisRect, geom);
                    return geom;
                }
                measureStripLines(context, rect) {
                    let infos = [];
                    if (this.yAxis.info.labelsCollection != null && this.yAxis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let index = 0;
                        for (let label of this.yAxis.info.labelsCollection) {
                            let text = this.getLabelText(label.stripLine);
                            let posY = label.position;
                            let sf = context.getGenericStringFormat();
                            let font = StiFontGeom.changeFontSize(this.yAxis.labels.font, this.yAxis.labels.font.size * context.options.zoom);
                            let alignment = this.getTextAlignment();
                            let rotationMode;
                            let angle = -this.yAxis.labels.angle;
                            let point = PointD.empty;
                            if (alignment == StiHorAlignment.Left) {
                                rotationMode = StiRotationMode.LeftCenter;
                                point = new PointD(0, posY);
                                angle = 0;
                            }
                            else {
                                rotationMode = StiRotationMode.RightCenter;
                                point = new PointD((rect.width - this.getTicksMaxLength(context) - this.getLabelsSpaceAxis(context)), posY);
                            }
                            if (this.yAxis.labels.placement == Chart.StiLabelsPlacement.TwoLines && ((index & 1) != 0)) {
                                point.x -= this.getLabelsTwoLinesDestination(context);
                            }
                            let textRectF = context.measureRotatedString3(text, font, point, sf, rotationMode, angle, Math.trunc(this.yAxis.labels.width * context.options.zoom));
                            let info = new Chart.StiAxisLabelInfoXF();
                            info.angle = angle;
                            info.clientRectangle = textRectF.clone();
                            info.rotationMode = rotationMode;
                            info.textPoint = point;
                            info.text = text;
                            info.stripLine = label.stripLine;
                            infos.push(info);
                            index++;
                        }
                    }
                    return infos;
                }
                renderLabels(context, rect, geom) {
                    if (this.yAxis.labels.placement != Chart.StiLabelsPlacement.None) {
                        let infos = this.measureStripLines(context, rect);
                        geom.createChildGeoms();
                        for (let info of infos) {
                            if (!info.clientRectangle.isEmpty) {
                                let labelGeom = new Chart.StiYRadarAxisLabelGeom(this.yAxis, info.clientRectangle, info.textPoint, info.text, info.stripLine, info.angle, info.rotationMode);
                                geom.childGeoms.push(labelGeom);
                            }
                        }
                    }
                }
                calculateStripPositions(topPosition, bottomPosition) {
                    bottomPosition -= topPosition;
                    topPosition = 0;
                    if (this.yAxis.info.stripLines == null || this.yAxis.info.stripLines.count < 2) {
                        this.yAxis.info.stripPositions = [];
                    }
                    else {
                        this.yAxis.info.stripPositions = StiArray.create(Number, this.yAxis.info.stripLines.count);
                        this.yAxis.info.stripPositions[0] = topPosition;
                        this.yAxis.info.stripPositions[this.yAxis.info.stripPositions.length - 1] = bottomPosition;
                        for (let index = 1; index < this.yAxis.info.stripPositions.length - 1; index++) {
                            this.yAxis.info.stripPositions[index] = topPosition + index * this.yAxis.info.step;
                        }
                    }
                }
                getAxisRect(context, rect) {
                    let axisRect = new RectangleD(rect.width / 2 - this.getTicksMaxLength(context), 0, this.getTicksMaxLength(context), rect.height / 2);
                    return axisRect;
                }
                getTicksMaxLength(context) {
                    return this.yAxis.yCore.ticksMaxLength * context.options.zoom;
                }
                getLabelsSpaceAxis(context) {
                    return 5 * context.options.zoom;
                }
                getLabelsTwoLinesDestination(context) {
                    return this.yAxis.labels.font.sizeInPoints * 2 * context.options.zoom;
                }
                getTextAlignment() {
                    if (this.yAxis.labels.placement == Chart.StiLabelsPlacement.TwoLines) {
                        return StiHorAlignment.Right;
                    }
                    return this.yAxis.labels.textAlignment;
                }
                setTotalNumberCapacity() {
                    let numberService = this.yAxis.labels.formatService.as(StiNumberFormatService);
                    if (numberService != null) {
                        let step = this.yAxis.labels.calculatedStep;
                        let sign = step < 1 ? -1 : 1;
                        numberService.totalNumberCapacity = Math.floor(sign * Math.log10(step) + 1);
                    }
                }
                getLabelText(line) {
                    let value = line.valueObject;
                    try {
                        if (this.yAxis.labels.formatService != null) {
                            this.setTotalNumberCapacity();
                            return `${this.yAxis.labels.textBefore}${this.yAxis.labels.formatService.format(line.value)}${this.yAxis.labels.textAfter}`;
                        }
                        if (this.yAxis.labels.format != null && this.yAxis.labels.format.trim().length != 0) {
                            try {
                                if (typeof value == "string") {
                                }
                                if (!Chart.StiChartOptions.oldChartPercentMode && this.yAxis.labels.format.stimulsoft().startsWith("P")) {
                                    let signs = 0;
                                    if (this.yAxis.labels.format.length > 1) {
                                    }
                                    return StiString.format("{0}{1:N" + signs.toString() + "}{2}{3}", this.yAxis.labels.textBefore, value, "%", this.yAxis.labels.textAfter);
                                }
                                else
                                    return StiString.format("{0}{1:" + this.yAxis.labels.format + "}{2}", this.yAxis.labels.textBefore, value, this.yAxis.labels.textAfter);
                            }
                            catch (e) {
                                Stimulsoft.System.StiError.showError(e, false);
                            }
                        }
                        return StiString.format("{0}{1}{2}", this.yAxis.labels.textBefore, value, this.yAxis.labels.textAfter);
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    return value.toString().replace(".", ",").stimulsoft().replaceAll(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                getStringFormatGeom(context) {
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    if (this.yAxis.labels.width > 0) {
                        let alignment = this.getTextAlignment();
                        if (alignment == StiHorAlignment.Left)
                            sf.alignment = StringAlignment.Near;
                        else if (alignment == StiHorAlignment.Right)
                            sf.alignment = StringAlignment.Far;
                        else if (alignment == StiHorAlignment.Center)
                            sf.alignment = StringAlignment.Center;
                    }
                    return sf;
                }
                getFontGeom(context) {
                    let font = StiFontGeom.changeFontSize(this.yAxis.labels.font, this.yAxis.labels.font.size * context.options.zoom);
                    return font;
                }
                get yAxis() {
                    return this.axis;
                }
                get info() {
                    return this.yAxis.info;
                }
                set info(value) {
                    this.yAxis.info = value;
                }
                get ticksMaxLength() {
                    if (this.axis.visible) {
                        return Math.max(this.yAxis.ticks.visible ? this.yAxis.ticks.length : 0, this.yAxis.ticks.minorVisible ? this.yAxis.ticks.minorLength : 0);
                    }
                    else
                        return 0;
                }
            }
            Chart.StiYRadarAxisCoreXF = StiYRadarAxisCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSeriesCoreXF {
                constructor(series) {
                    this.isMouseOverSeriesElementHashtable = null;
                    this._isMouseOver = false;
                    this._isDateTimeValues = false;
                    this._isDateTimeArguments = false;
                    this._series = series;
                }
                implements() {
                    if (!StiSeriesCoreXF.implementsStiSeriesCoreXF)
                        StiSeriesCoreXF.implementsStiSeriesCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyleSeries,
                            Chart.IStiSeriesCoreXF
                        ];
                    return StiSeriesCoreXF.implementsStiSeriesCoreXF;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style, color) {
                    if (this.series.allowApplyStyle) {
                        this.series.showShadow = style.core.seriesShowShadow;
                        if (this.series.seriesLabels != null)
                            this.series.seriesLabels.core.applyStyle(style);
                    }
                }
                checkLabelsRect(labels, geom, labelsRect) {
                    return this.checkLabelsRect2(labels, geom.clientRectangle, labelsRect);
                }
                checkLabelsRect2(labels, rect, labelsRect) {
                    if (labels != null && labels.preventIntersection) {
                        if (labelsRect.x < 0)
                            labelsRect.x = 0;
                        if (labelsRect.y < 0)
                            labelsRect.y = 14;
                        if (labelsRect.right > rect.width)
                            labelsRect.x = rect.width - labelsRect.width;
                        if (labelsRect.bottom > rect.height)
                            labelsRect.y = rect.height - labelsRect.height;
                        let rectangle = this.getDrawRectangle(labelsRect.clone(), labels.angle);
                        if (rectangle.y < 0) {
                            labelsRect.y = rectangle.height / 2;
                            return labelsRect;
                        }
                        if (rectangle.y + rectangle.height > rect.height)
                            labelsRect.y -= rectangle.height / 2;
                    }
                    return labelsRect;
                }
                getDrawRectangle(labelsRect, angle) {
                    let point1 = new PointD(labelsRect.left, labelsRect.top);
                    let point2 = new PointD(labelsRect.right, labelsRect.top);
                    let point3 = new PointD(labelsRect.right, labelsRect.bottom);
                    let point4 = new PointD(labelsRect.left, labelsRect.bottom);
                    let pointCenter = new PointD((labelsRect.left + labelsRect.right) / 2, (labelsRect.top + labelsRect.bottom) / 2);
                    let pointRotate1 = this.rotatePoint(point1, pointCenter, angle);
                    let pointRotate2 = this.rotatePoint(point2, pointCenter, angle);
                    let pointRotate3 = this.rotatePoint(point3, pointCenter, angle);
                    let pointRotate4 = this.rotatePoint(point4, pointCenter, angle);
                    let minY = Math.min(Math.min(pointRotate1.y, pointRotate2.y), Math.min(pointRotate3.y, pointRotate4.y));
                    let maxY = Math.max(Math.max(pointRotate1.y, pointRotate2.y), Math.max(pointRotate3.y, pointRotate4.y));
                    let minX = Math.min(Math.min(pointRotate1.x, pointRotate2.x), Math.min(pointRotate3.x, pointRotate4.x));
                    let maxX = Math.max(Math.max(pointRotate1.x, pointRotate2.x), Math.max(pointRotate3.x, pointRotate4.x));
                    return new RectangleD(minX, minY, maxX - minX, maxY - minY);
                }
                rotatePoint(pointToRotate, centerPoint, angleInDegrees) {
                    let angleInRadians = angleInDegrees * (Math.PI / 180);
                    let cosTheta = Math.cos(angleInRadians);
                    let sinTheta = Math.sin(angleInRadians);
                    return new PointD(Math.trunc(cosTheta * (pointToRotate.x - centerPoint.x) - sinTheta * (pointToRotate.y - centerPoint.y) + centerPoint.x), Math.trunc(sinTheta * (pointToRotate.x - centerPoint.x) + cosTheta * (pointToRotate.y - centerPoint.y) + centerPoint.y));
                }
                checkIntersectionLabels(geom) {
                    let childGeoms = geom.childGeoms;
                    let labelGeoms = [];
                    if (childGeoms != null) {
                        for (let cellGeom of childGeoms) {
                            if (cellGeom.is(Chart.StiSeriesLabelsGeom))
                                labelGeoms.push(cellGeom);
                        }
                    }
                    let count = labelGeoms.length;
                    let intersection = true;
                    let indexCheck = 0;
                    while (intersection && indexCheck < 29) {
                        indexCheck++;
                        for (let index1 = 0; index1 < count; index1++) {
                            for (let index2 = 0; index2 < count; index2++) {
                                if (index2 == index1)
                                    continue;
                                let rect1 = this.getDrawRectangle(labelGeoms[index1].clientRectangle.clone(), labelGeoms[index1].seriesLabels.angle);
                                let rect2 = this.getDrawRectangle(labelGeoms[index2].clientRectangle.clone(), labelGeoms[index2].seriesLabels.angle);
                                let isChanged1 = false;
                                let isChanged2 = false;
                                let overlay = rect1.height - Math.abs(rect2.y - rect1.y) + 2;
                                if (rect1.intersectsWith(rect2)) {
                                    if (rect1.y > rect2.y) {
                                        rect1.y += overlay / 2;
                                        rect2.y -= overlay / 2;
                                        isChanged1 = true;
                                        isChanged2 = true;
                                    }
                                    else {
                                        rect1.y -= overlay / 2;
                                        rect2.y += overlay / 2;
                                        isChanged1 = true;
                                        isChanged2 = true;
                                    }
                                }
                                if (rect1.y < 0) {
                                    rect1.y = 0;
                                    isChanged1 = true;
                                }
                                if (rect2.y < 2) {
                                    rect2.y = 0;
                                    isChanged2 = true;
                                }
                                if ((rect1.y + rect1.height) > geom.clientRectangle.height) {
                                    rect1.y = geom.clientRectangle.height - rect1.height - 2;
                                    isChanged1 = true;
                                }
                                if ((rect2.y + overlay / 2 + rect2.height) > geom.clientRectangle.height) {
                                    rect2.y = geom.clientRectangle.height - rect2.height - 2;
                                    isChanged2 = true;
                                }
                                if (isChanged1)
                                    labelGeoms[index1].clientRectangle = this.getDrawRectangle(rect1.clone(), -labelGeoms[index1].seriesLabels.angle);
                                if (isChanged2)
                                    labelGeoms[index2].clientRectangle = this.getDrawRectangle(rect2.clone(), -labelGeoms[index2].seriesLabels.angle);
                            }
                        }
                    }
                }
                getLabelRectangle(angle, rect) {
                    let hypotenuse = Math.pow(Math.pow(rect.width, 2) + Math.pow(rect.height, 2), 0.5);
                    let angleDelt = Math.atan(rect.height / rect.width) / Math.PI * 180;
                    angle += angleDelt;
                    return new RectangleD(rect.x, rect.y, (hypotenuse * Math.cos(angle * Math.PI / 180)), (hypotenuse * Math.sin(angle * Math.PI / 180)));
                }
                renderSeries(context, rect, geom, seriesArray) {
                }
                getSeriesBrush(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    if ((this.series.chart.area.colorEach || this.is(Chart.StiBoxAndWhiskerSeriesCoreXF) || this.is(Chart.StiDoughnutSeriesCoreXF) || this.is(Chart.StiSunburstSeriesCoreXF) ||
                        this.is(Chart.StiPictorialSeriesCoreXF) || this.is(Chart.StiWaterfallSeriesCoreXF)) && StiString.isNullOrEmpty(this.series.autoSeriesColorDataColumn)) {
                        let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                        let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                        let seriesBrush = styleCore.getColumnBrush(color);
                        if (this.series.chart.area.is(Chart.IStiClusteredBarArea)) {
                            if (seriesBrush.is(StiGradientBrush))
                                seriesBrush.angle += 90;
                            if (seriesBrush.is(StiGlareBrush))
                                seriesBrush.angle += 90;
                        }
                        return seriesBrush;
                    }
                    return null;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    if (this.series.chart.area.colorEach && this.series.allowApplyStyle || this.is(Chart.StiBoxAndWhiskerSeriesCoreXF) || this.is(Chart.StiDoughnutSeriesCoreXF) || this.is(Chart.StiSunburstSeriesCoreXF)) {
                        let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                        let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                        return styleCore.getColumnBorder(color);
                    }
                    return null;
                }
                getSeriesLabels() {
                    if (this.series.showSeriesLabels == Chart.StiShowSeriesLabels.FromChart)
                        return this.series.chart.seriesLabels.stimulsoft().as(Chart.IStiAxisSeriesLabels);
                    if (this.series.showSeriesLabels == Chart.StiShowSeriesLabels.FromSeries)
                        return this.series.seriesLabels.stimulsoft().as(Chart.IStiAxisSeriesLabels);
                    return null;
                }
                getTag(tagIndex) {
                    if (this.series.tags != null && tagIndex < this.series.tags.length && this.series.tags[tagIndex] != null)
                        return this.series.tags[tagIndex].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    else
                        return "";
                }
                getIsMouseOverSeriesElement(seriesIndex) {
                    if (this.isMouseOverSeriesElementHashtable == null)
                        return false;
                    return this.isMouseOverSeriesElementHashtable.get(seriesIndex) == StiSeriesCoreXF.trueObject;
                }
                setIsMouseOverSeriesElement(seriesIndex, value) {
                    if (this.isMouseOverSeriesElementHashtable == null)
                        this.isMouseOverSeriesElementHashtable = new Hashtable();
                    this.isMouseOverSeriesElementHashtable.set(seriesIndex, value ? StiSeriesCoreXF.trueObject : StiSeriesCoreXF.falseObject);
                }
                get isMouseOver() {
                    return this._isMouseOver;
                }
                set isMouseOver(value) {
                    this._isMouseOver = value;
                }
                get localizedName() {
                    return null;
                }
                get isDateTimeValues() {
                    return this._isDateTimeValues;
                }
                set isDateTimeValues(value) {
                    this._isDateTimeValues = value;
                }
                get isDateTimeArguments() {
                    return this._isDateTimeArguments;
                }
                set isDateTimeArguments(value) {
                    this._isDateTimeArguments = value;
                }
                get series() {
                    return this._series;
                }
                set series(value) {
                    this._series = value;
                }
                get interaction() {
                    return this.series.interaction;
                }
                set interaction(value) {
                    this.series.interaction = value;
                }
            }
            StiSeriesCoreXF.falseObject = {};
            StiSeriesCoreXF.trueObject = {};
            Chart.StiSeriesCoreXF = StiSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var PointF = Stimulsoft.System.Drawing.Point;
            var List = Stimulsoft.System.Collections.List;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiArray = Stimulsoft.System.StiArray;
            class StiBoxAndWhiskerSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        let brush = style.core.getColumnBrush(color);
                        this.series.brush = brush;
                    }
                }
                renderSeries(context, rect, geom, series) {
                    let boxAndWhiskerArea = geom.area.stimulsoft().as(Chart.IStiBoxAndWhiskerArea);
                    let singleX = boxAndWhiskerArea.xAxis.info.dpi;
                    let singleY = boxAndWhiskerArea.yAxis.info.dpi;
                    let posY = boxAndWhiskerArea.axisCore.getDividerY();
                    let indexSeries = 1;
                    for (let curSeries of series) {
                        let boxAnsWhiskerSeries = curSeries;
                        let pointLabelList = new List();
                        let seriesBrush = boxAnsWhiskerSeries.brush;
                        if (boxAnsWhiskerSeries.allowApplyBrush) {
                            seriesBrush = boxAnsWhiskerSeries.core.getSeriesBrush(indexSeries - 1, series.length);
                            seriesBrush = boxAnsWhiskerSeries.processSeriesBrushes(indexSeries - 1, seriesBrush);
                        }
                        if (boxAnsWhiskerSeries.values.length > 0) {
                            let minValue = boxAnsWhiskerSeries.values.stimulsoft().toList().min();
                            let maxValue = boxAnsWhiskerSeries.values.stimulsoft().toList().max();
                            let median = this.getMedian(boxAnsWhiskerSeries.values);
                            let firstQuartile = this.getFirstQuartile(boxAnsWhiskerSeries.values);
                            let thirdQuartile = this.getThirdQuartile(boxAnsWhiskerSeries.values);
                            let positionX = indexSeries * singleX;
                            let maxValuePosition = Math.abs(posY - maxValue * singleY);
                            let minValuePosition = Math.abs(posY - minValue * singleY);
                            let medianPosition = Math.abs(posY - median * singleY);
                            let firstQuartilePosition = Math.abs(posY - firstQuartile * singleY);
                            let thirdQuartilePosition = Math.abs(posY - thirdQuartile * singleY);
                            let clientRect = new Rectangle(positionX - singleX / 4, minValuePosition, singleX / 2, maxValuePosition - minValuePosition);
                            let borderColor = StiBrush.toColor(StiBrush.dark(seriesBrush, 30));
                            pointLabelList.add([minValue, new PointF(positionX, minValuePosition)]);
                            pointLabelList.add([maxValue, new PointF(positionX, maxValuePosition)]);
                            pointLabelList.add([median, new PointF(positionX, medianPosition)]);
                            pointLabelList.add([firstQuartile, new PointF(positionX, firstQuartilePosition)]);
                            pointLabelList.add([thirdQuartile, new PointF(positionX, thirdQuartilePosition)]);
                            let valueList = new List();
                            if (boxAnsWhiskerSeries.showInnerPoints) {
                                for (let value of boxAnsWhiskerSeries.values) {
                                    let currentValue = value;
                                    if (currentValue != minValue && currentValue != maxValue && !valueList.contains(currentValue)) {
                                        let point = Math.abs(posY - currentValue * singleY);
                                        valueList.add(point);
                                        pointLabelList.add([currentValue, new PointF(positionX, point)]);
                                    }
                                }
                            }
                            let meanValuePoint = null;
                            if (boxAnsWhiskerSeries.showMeanMarkers) {
                                let sum = boxAnsWhiskerSeries.values.stimulsoft().toList().sum();
                                let meanValue = sum / boxAnsWhiskerSeries.values.length;
                                meanValuePoint = Math.abs(posY - meanValue * singleY);
                                pointLabelList.add([meanValue, new PointF(positionX, meanValuePoint)]);
                            }
                            let boxAndWhiskerGeom = new Chart.StiBoxAndWhiskerSeriesElementGeom(geom, boxAnsWhiskerSeries, positionX, minValuePosition, maxValuePosition, firstQuartilePosition, thirdQuartilePosition, medianPosition, valueList.stimulsoft().toArray(), meanValuePoint, clientRect, seriesBrush, borderColor, new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / series.length * indexSeries));
                            geom.createChildGeoms();
                            geom.childGeoms.push(boxAndWhiskerGeom);
                            let labels = boxAnsWhiskerSeries.core.getSeriesLabels();
                            if (labels != null && labels.visible) {
                                for (let pointLabel of pointLabelList) {
                                    let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                    let seriesLabelsGeom = labels.core.renderLabel(boxAnsWhiskerSeries, context, pointLabel[1], pointLabel[1], indexSeries, pointLabel[0], pointLabel[0], pointLabel[0].toString(), null, 0, 1, rect, animation);
                                    if (seriesLabelsGeom != null) {
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(seriesLabelsGeom);
                                    }
                                }
                            }
                        }
                        indexSeries++;
                    }
                }
                getFirstValues(values) {
                    let medianIndices = this.getMedianIndices(values);
                    let firstValues = [];
                    let index = medianIndices.length == 1
                        ? medianIndices[0] + 1
                        : medianIndices[1];
                    StiArray.copy2(values, 0, firstValues, 0, index);
                    return firstValues;
                }
                getSecondValues(values) {
                    let medianIndices = this.getMedianIndices(values);
                    let secondValues = [];
                    let index = medianIndices.length == 1
                        ? medianIndices[0] + 1
                        : medianIndices[1];
                    StiArray.copy2(values, index - 1, secondValues, 0, index);
                    return secondValues;
                }
                getThirdQuartile(values) {
                    values.sort((a, b) => a - b);
                    let secondValues = this.getSecondValues(values);
                    return this.getMedian(secondValues);
                }
                getFirstQuartile(values) {
                    values.sort((a, b) => a - b);
                    let firstValues = this.getFirstValues(values);
                    return this.getMedian(firstValues);
                }
                getMedian(values) {
                    values.sort((a, b) => a - b);
                    let indices = this.getMedianIndices(values);
                    let median = 0;
                    for (let index of indices) {
                        median += values[index];
                    }
                    return median / indices.length;
                }
                getMedianIndices(values) {
                    let array = (values.length % 2) == 0
                        ? [0, 1]
                        : [0];
                    if (array.length == 1) {
                        let indexMedian = Math.ceil(values.length / 2) - 1;
                        array[0] = indexMedian;
                    }
                    else {
                        let indexMedianLeft = values.length / 2 - 1;
                        array[0] = indexMedianLeft;
                        array[1] = indexMedianLeft + 1;
                    }
                    return array;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "BoxAndWhisker");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiBoxAndWhiskerSeriesCoreXF = StiBoxAndWhiskerSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var List = Stimulsoft.System.Collections.List;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiLabelAnimation = Stimulsoft.Base.Context.Animation.StiLabelAnimation;
            var StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
            var StiString = Stimulsoft.System.StiString;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            class StiBaseLineSeriesCoreXF extends Chart.StiSeriesCoreXF {
                constructor(series) {
                    super(series);
                }
                implements() {
                    if (!StiBaseLineSeriesCoreXF.implementsStiBaseLineSeriesCoreXF)
                        StiBaseLineSeriesCoreXF.implementsStiBaseLineSeriesCoreXF = super.implements().concat([
                            Chart.IStiApplyStyleSeries
                        ]);
                    return StiBaseLineSeriesCoreXF.implementsStiBaseLineSeriesCoreXF;
                }
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let columnSeries = this.series;
                    if (columnSeries.allowApplyStyle) {
                        columnSeries.lineColor = color;
                        columnSeries.lighting = style.core.seriesLighting;
                        if (columnSeries.marker != null) {
                            let marker = columnSeries.marker.stimulsoft().as(Chart.StiMarker);
                            if (marker != null && marker.extendedVisible != Chart.StiExtendedStyleBool.FromStyle)
                                columnSeries.marker.visible = marker.extendedVisible == Chart.StiExtendedStyleBool.True;
                            else
                                columnSeries.marker.visible = style.core.markerVisible;
                            columnSeries.marker.brush = new StiSolidBrush(StiColorUtils.light(color, 100));
                            columnSeries.marker.borderColor = StiColorUtils.dark(color, 100);
                        }
                        if (columnSeries.lineMarker != null) {
                            columnSeries.lineMarker.brush = new StiSolidBrush(StiColorUtils.light(color, 50));
                            columnSeries.lineMarker.borderColor = StiColorUtils.dark(color, 150);
                        }
                    }
                }
                clipLinePoints(context, geom, points, REFstartIndex, REFendIndex) {
                    let startIndex = REFstartIndex.ref;
                    let endIndex = REFendIndex.ref;
                    if (this.series.chart.area.xAxis.range.auto) {
                        startIndex = 0;
                        endIndex = points.length;
                        REFstartIndex.ref = startIndex;
                        REFendIndex.ref = endIndex;
                        return points;
                    }
                    startIndex = -1;
                    endIndex = -1;
                    let clipRect = geom.view.clientRectangle.clone();
                    clipRect.x = 0;
                    clipRect.y = 0;
                    let pointIndex = 0;
                    for (let point of points) {
                        if (point != null) {
                            let valuePoint = point;
                            valuePoint.x += geom.clientRectangle.x;
                            valuePoint.y += geom.clientRectangle.y;
                            if (clipRect.x <= valuePoint.x && valuePoint.x < clipRect.right && startIndex == -1)
                                startIndex = pointIndex;
                            if ((!(clipRect.x <= valuePoint.x && valuePoint.x < clipRect.right)) && startIndex != -1) {
                                endIndex = pointIndex;
                                break;
                            }
                        }
                        pointIndex++;
                    }
                    if (endIndex == -1)
                        endIndex = points.length - 1;
                    startIndex--;
                    endIndex++;
                    if (startIndex < 0)
                        startIndex = 0;
                    if (endIndex >= points.length)
                        endIndex = points.length - 1;
                    let newCount = endIndex - startIndex + 1;
                    if (newCount == points.length) {
                        REFstartIndex.ref = startIndex;
                        REFendIndex.ref = endIndex;
                        return points;
                    }
                    let newPoints = StiArray.create(PointD, newCount, true);
                    StiArray.copy(points, startIndex, newPoints, newCount);
                    REFstartIndex.ref = startIndex;
                    REFendIndex.ref = endIndex;
                    return newPoints;
                }
                renderMarkers(context, geom, points) {
                    let axisArea = geom.area;
                    let lineSeries = this.series;
                    if (points.length == 0)
                        return;
                    let isTooltipMarkerMode = !lineSeries.marker.visible && lineSeries.toolTips.length > 0;
                    if (lineSeries.marker != null) {
                        let index = 0;
                        for (let point of points) {
                            if (point != null) {
                                let value = axisArea.reverseHor ?
                                    lineSeries.values[lineSeries.values.length - index - 1] :
                                    lineSeries.values[index];
                                if (value == null && lineSeries.showNulls)
                                    value = 0;
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                clipRect.inflate(10, 10);
                                let valuePoint = new PointD(point.x, point.y);
                                valuePoint.x += geom.clientRectangle.x;
                                valuePoint.y += geom.clientRectangle.y;
                                if (clipRect.contains(valuePoint.x, valuePoint.y)) {
                                    let markerGeom = new Chart.StiMarkerGeom(this.series, index, value, point, lineSeries.marker, lineSeries.showShadow, context.options.zoom, isTooltipMarkerMode);
                                    if (markerGeom != null) {
                                        if (lineSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, lineSeries, index);
                                            markerGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(markerGeom);
                                    }
                                }
                            }
                            index++;
                        }
                    }
                }
                getInteractions(context, geom, points) {
                    let interactions = [];
                    for (let index = 0; index < points.length; index++) {
                        let data = new StiSeriesInteractionData();
                        data.fill(geom.area, this.series, index);
                        data.point = points[index];
                        interactions.push(data);
                    }
                    return interactions;
                }
                renderLines(context, geom, pointsInfo) {
                }
                renderAreas(context, geom, pointsInfo) {
                }
                renderSeries(context, rect, geom, series) {
                    var _a;
                    let area = geom.area;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let axisArea = area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    rect.width += 0.001;
                    let posY = 0;
                    let pointLists = [];
                    let pointFromLists = [];
                    let pointsZeroConnectList = [];
                    let pointsNullConnectList = [];
                    let pointsIdsList = [];
                    for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                        let currentSeries = series[seriesIndex];
                        let pointsCount = currentSeries.values.length;
                        let points = StiArray.create(PointD, pointsCount, true);
                        let pointsStart = StiArray.create(PointD, pointsCount, true);
                        let pointsIds = StiArray.create(String, pointsCount, true);
                        let valuesStartApproximation = currentSeries.valuesStart;
                        for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                            let stripPoint = getStartFromZero ? pointIndex + 1 : pointIndex;
                            if (stripPoint >= axisArea.xAxis.info.stripPositions.length)
                                break;
                            let posX = axisArea.xAxis.info.stripPositions[stripPoint];
                            points[pointIndex] = this.getPointValue(pointIndex, currentSeries, currentSeries.values, axisArea, posX);
                            pointsStart[pointIndex] = this.getPointValue(pointIndex, currentSeries, valuesStartApproximation, axisArea, posX);
                            let argId = axisArea.xAxis.info.stripLines.getByIndex(stripPoint).valueObject;
                            pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                        }
                        let pointZeroConnectLists = this.getPointsZeroConnect(currentSeries, axisArea);
                        let pointNullConnectLists = this.getPointsNullConnect(currentSeries, axisArea);
                        pointsZeroConnectList.push(pointZeroConnectLists);
                        pointsNullConnectList.push(pointNullConnectLists);
                        pointsIdsList.push(pointsIds);
                        if (points.length > 0) {
                            points = Chart.StiPointHelper.optimizePoints(points);
                            let startIndex;
                            let endIndex;
                            let REFstartIndex = { ref: startIndex };
                            let REFendIndex = { ref: endIndex };
                            let newPointList = this.clipLinePoints(context, geom, points, REFstartIndex, REFendIndex);
                            let newPointFromList = this.clipLinePoints(context, geom, pointsStart, REFstartIndex, REFendIndex);
                            startIndex = REFstartIndex.ref;
                            endIndex = REFendIndex;
                            let pointsInfo = new Chart.StiSeriesPointsInfo();
                            pointsInfo.pointsFrom = newPointFromList;
                            pointsInfo.points = newPointList;
                            pointsInfo.pointsZeroConnect = pointZeroConnectLists;
                            pointsInfo.pointsNullConnect = pointNullConnectLists;
                            pointsInfo.pointsIds = pointsIds;
                            currentSeries.core.renderAreas(context, geom, pointsInfo);
                            if (!this.isTopmostLine(currentSeries)) {
                                currentSeries.core.renderLines(context, geom, pointsInfo);
                            }
                        }
                        pointLists.push(points);
                        pointFromLists.push(pointsStart);
                    }
                    let index = 0;
                    for (let pointList of pointLists) {
                        let startIndex;
                        let endIndex;
                        let REFstartIndex = { ref: startIndex };
                        let REFendIndex = { ref: endIndex };
                        let newPointList = this.clipLinePoints(context, geom, pointList, REFstartIndex, REFendIndex);
                        let newPointFromList = this.clipLinePoints(context, geom, pointFromLists[index], REFstartIndex, REFendIndex);
                        startIndex = REFstartIndex.ref;
                        endIndex = REFendIndex.ref;
                        let pointsIds = pointsIdsList[index];
                        let newPointZeroConnectList = this.clipLinePoints(context, geom, pointsZeroConnectList[index], REFstartIndex, REFendIndex);
                        let newPointNullConnectList = this.clipLinePoints(context, geom, pointsNullConnectList[index], REFstartIndex, REFendIndex);
                        let currentSeries = series[index];
                        if (this.isTopmostLine(series[index])) {
                            let pointsInfo = new Chart.StiSeriesPointsInfo();
                            pointsInfo.pointsFrom = newPointFromList;
                            pointsInfo.points = newPointList;
                            pointsInfo.pointsZeroConnect = newPointZeroConnectList;
                            pointsInfo.pointsNullConnect = newPointNullConnectList;
                            pointsInfo.pointsIds = pointsIds;
                            currentSeries.core.renderLines(context, geom, pointsInfo);
                        }
                        currentSeries.as(Chart.StiSeries).trendLines.list.forEach(trendLine => {
                            if (trendLine != null) {
                                trendLine.core.renderTrendLine(geom, newPointList, axisArea.axisCore.getDividerY());
                            }
                        });
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = startIndex; pointIndex <= endIndex; pointIndex++) {
                                if (currentSeries.values.length > pointIndex) {
                                    let value = axisArea.reverseHor ?
                                        currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                        currentSeries.values[pointIndex];
                                    if (value == null && currentSeries.showNulls)
                                        value = 0;
                                    let seriesValue = value;
                                    if (axisArea.reverseVert && value != null)
                                        seriesValue = -seriesValue;
                                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                        posY = axisArea.axisCore.getDividerY();
                                    else
                                        posY = axisArea.axisCore.getDividerRightY();
                                    let endPoint = pointList[pointIndex];
                                    if (endPoint != null) {
                                        let valueFrom = 0;
                                        if (currentSeries.valuesStart != null && currentSeries.valuesStart.length > pointIndex) {
                                            valueFrom = axisArea.reverseHor ?
                                                currentSeries.valuesStart[currentSeries.values.length - pointIndex - 1] :
                                                currentSeries.valuesStart[pointIndex];
                                        }
                                        let startPoint = new PointD(endPoint.x, posY);
                                        let animation = null;
                                        if (this.series.chart.isAnimationChangingValues && labels.valueType == Chart.StiSeriesLabelsValueType.Value) {
                                            if (labels.valueType == Chart.StiSeriesLabelsValueType.Value && StiString.isNullOrEmpty(labels.format) && ((_a = labels.formatService) === null || _a === void 0 ? void 0 : _a.is(StiGeneralFormatService))) {
                                                let endPointFrom = pointFromLists[index].length > pointIndex ? pointFromLists[index][pointIndex] : null;
                                                animation = new StiLabelAnimation(valueFrom, value, endPointFrom, endPoint, Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                            }
                                            else {
                                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                            }
                                        }
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let argumentIndex = axisArea.xAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, axisArea.axisCore.getArgumentLabel(axisArea.xAxis.info.stripLines.getByIndex(argumentIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect, animation);
                                            if (seriesLabelsGeom != null) {
                                                geom.createChildGeoms();
                                                geom.childGeoms.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        index++;
                    }
                    if (geom.area.chart.seriesLabels.preventIntersection) {
                        this.checkIntersectionLabels(geom);
                    }
                }
                getPointsZeroConnect(series, axisArea) {
                    let pointZeroConnectLists = new List();
                    if (series.showZerosAs == Chart.StiShowEmptyCellsAs.Gap)
                        return pointZeroConnectLists;
                    let pointConnectIndexGroupList = new List();
                    let indexGroup = new List();
                    for (let index = 0; index < series.values.length; index++) {
                        let value = series.values[index];
                        if (value == 0) {
                            indexGroup.add(index);
                            if (indexGroup.length == 1)
                                pointConnectIndexGroupList.add(indexGroup);
                        }
                        else {
                            indexGroup = new List();
                        }
                    }
                    pointZeroConnectLists = this.getPointConnect(series, axisArea, pointConnectIndexGroupList);
                    return pointZeroConnectLists;
                }
                getPointsNullConnect(series, axisArea) {
                    let pointNullConnectLists = new List();
                    if (series.showNullsAs == Chart.StiShowEmptyCellsAs.Gap)
                        return pointNullConnectLists;
                    let pointConnectIndexGroupList = new List();
                    let indexGroup = new List();
                    for (let index = 0; index < series.values.length; index++) {
                        let value = series.values[index];
                        if (value == null) {
                            indexGroup.add(index);
                            if (indexGroup.length == 1)
                                pointConnectIndexGroupList.add(indexGroup);
                        }
                        else {
                            indexGroup = new List();
                        }
                    }
                    pointNullConnectLists = this.getPointConnect(series, axisArea, pointConnectIndexGroupList);
                    return pointNullConnectLists;
                }
                getPointConnect(series, axisArea, pointConnectIndexGroupList) {
                    let pointConnectLists = new List();
                    for (let indexGroupCurrent of pointConnectIndexGroupList) {
                        let startIndexGroup = indexGroupCurrent[0] - 1;
                        let endIndexGroup = indexGroupCurrent[indexGroupCurrent.length - 1] + 1;
                        let startValueInterpolation = 0;
                        let endValueInterpolation = 0;
                        if (startIndexGroup >= 0 && startIndexGroup < series.values.length) {
                            startValueInterpolation = series.values[startIndexGroup];
                            let pointStart = this.getPointValue2(series, axisArea, startValueInterpolation, startIndexGroup);
                            pointConnectLists.add(pointStart);
                        }
                        if (endIndexGroup >= 0 && endIndexGroup < series.values.length) {
                            endValueInterpolation = series.values[endIndexGroup];
                        }
                        let deltaInterpolation = (endValueInterpolation - startValueInterpolation) / (indexGroupCurrent.length + 1);
                        for (let index = 0; index < indexGroupCurrent.length; index++) {
                            let value = startValueInterpolation + deltaInterpolation * (index + 1);
                            let point = this.getPointValue2(series, axisArea, value, indexGroupCurrent[index]);
                            pointConnectLists.add(point);
                        }
                        if (endIndexGroup >= 0 && endIndexGroup < series.values.length) {
                            let pointEnd = this.getPointValue2(series, axisArea, endValueInterpolation, endIndexGroup);
                            pointConnectLists.add(pointEnd);
                        }
                        pointConnectLists.add(null);
                    }
                    return pointConnectLists;
                }
                getPointValue2(series, axisArea, value, index) {
                    index = axisArea.xAxis.core.getStartFromZero() ? index + 1 : index;
                    if (index >= axisArea.xAxis.info.stripPositions.length)
                        return PointD.empty;
                    let posX = axisArea.xAxis.info.stripPositions[index];
                    let srY = 0;
                    if (series.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        srY = -value * axisArea.yAxis.info.dpi + axisArea.axisCore.getDividerY();
                    }
                    else {
                        srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                    }
                    return new PointD(posX, srY);
                }
                getPointValue(pointIndex, currentSeries, values, axisArea, posX) {
                    let value = 0;
                    if (values.length > pointIndex) {
                        value = axisArea.reverseHor ?
                            values[values.length - pointIndex - 1] :
                            values[pointIndex];
                    }
                    return this.getPointValue1(value, currentSeries, axisArea, posX);
                }
                getPointValue1(value, currentSeries, axisArea, posX) {
                    let isAreaSeries = currentSeries.is(Chart.StiAreaSeries) ||
                        currentSeries.is(Chart.StiSplineAreaSeries) ||
                        currentSeries.is(Chart.StiStackedAreaSeries) ||
                        currentSeries.is(Chart.StiStackedSplineAreaSeries) ||
                        currentSeries.is(Chart.StiSteppedAreaSeries);
                    if (value == 0 && !currentSeries.showZeros && !isAreaSeries)
                        return null;
                    if (value == null && !currentSeries.showNulls && !isAreaSeries)
                        return null;
                    if (value == null && currentSeries.showNulls)
                        value = 0;
                    if (axisArea.reverseVert && value != null)
                        value = -value;
                    let srY = 0;
                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        srY = -value * axisArea.yAxis.info.dpi + axisArea.axisCore.getDividerY();
                    }
                    else {
                        srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                    }
                    return new PointD(posX, srY);
                }
                isTopmostLine(series) {
                    if (series.is(Chart.IStiSplineAreaSeries))
                        return series.topmostLine;
                    if (series.is(Chart.IStiSteppedAreaSeries))
                        return series.topmostLine;
                    if (series.is(Chart.IStiAreaSeries))
                        return series.topmostLine;
                    return true;
                }
                correctPoint(point, rect, correctY) {
                    if (point.y + correctY < 0)
                        return new PointD(point.x, 0);
                    if (point.y + correctY > rect.height)
                        return new PointD(point.x, rect.height);
                    return new PointD(point.x, point.y + correctY);
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let lineSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return new StiSolidBrush(StiColorUtils.dark(lineSeries.lineColor, 20));
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let lineSeries = this.series;
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return lineSeries.lineColor;
                    return color;
                }
            }
            Chart.StiBaseLineSeriesCoreXF = StiBaseLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiConvert = Stimulsoft.Base.StiConvert;
            var StiArray = Stimulsoft.System.StiArray;
            var DateTime = Stimulsoft.System.DateTime;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiScatterSeriesCoreXF extends Chart.StiBaseLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let series = this.series.stimulsoft().as(Chart.IStiBaseLineSeries);
                    if (series.allowApplyStyle) {
                        if (!style.core.markerVisible) {
                            series.marker.visible = true;
                        }
                    }
                }
                renderLines(context, geom, pointsInfo) {
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                renderSeries(context, rect, geom, seriesArray) {
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null)
                        return;
                    let dotArea = geom.area;
                    let posY = 0;
                    let pointLists = [];
                    let pointsIdsList = [];
                    for (let seriesIndex = 0; seriesIndex < seriesArray.length; seriesIndex++) {
                        let currentSeries = seriesArray[seriesIndex];
                        let pointsCount = Math.min(currentSeries.values.length, currentSeries.arguments.length);
                        let points = StiArray.create(PointD, pointsCount, true);
                        let pointsIds = StiArray.create(String, pointsCount, true);
                        let currentSeriesArgumentsKeys = currentSeries.arguments.stimulsoft().getKeys();
                        for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                            let value = currentSeries.values[pointIndex];
                            if (value == null && this.series.showNulls)
                                value = 0;
                            if (value == 0 && !this.series.showZeros) {
                                points[pointIndex] = null;
                                pointsIds[pointIndex] = "_zero_";
                                continue;
                            }
                            if (value != null) {
                                if (dotArea.reverseVert && value != null && !(dotArea.yAxis.logarithmicScale))
                                    value = -value;
                                let srY = 0;
                                if (dotArea.yAxis.logarithmicScale) {
                                    let countStrip = dotArea.yAxis.info.stripLines.count;
                                    let startPoint = 0;
                                    let endPoint = countStrip - 1;
                                    let startValue = dotArea.yAxis.info.stripLines.getByIndex(startPoint).value;
                                    let endValue = dotArea.yAxis.info.stripLines.getByIndex(endPoint).value;
                                    let decadeY = Math.abs(rect.height / (Math.log10(endValue) - Math.log10(startValue)));
                                    srY = Math.abs(Math.log10(dotArea.yAxis.info.stripLines.getByIndex(startPoint).value) * decadeY - Math.log10(value) * decadeY);
                                }
                                else {
                                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                        srY = -value * dotArea.yAxis.info.dpi + dotArea.axisCore.getDividerY();
                                    }
                                    else {
                                        srY = -value * dotArea.yRightAxis.info.dpi + dotArea.axisCore.getDividerRightY();
                                    }
                                }
                                let argument = null;
                                if (currentSeries.arguments.stimulsoft().getByIndex(pointIndex, currentSeriesArgumentsKeys) instanceof DateTime) {
                                    let tempDateTime = currentSeries.arguments.stimulsoft().getByIndex(pointIndex, currentSeriesArgumentsKeys);
                                    argument = tempDateTime.toOADate().stimulsoft().toNumber();
                                }
                                else {
                                    try {
                                        if (currentSeries.arguments.stimulsoft().getByIndex(pointIndex, currentSeriesArgumentsKeys) == null) {
                                            argument = null;
                                        }
                                        else {
                                            let argValue = currentSeries.arguments.stimulsoft().getByIndex(pointIndex, currentSeriesArgumentsKeys);
                                            if (typeof argValue == "string") {
                                                let refRes = { ref: 0 };
                                                if (Chart.StiSeries.tryParseValue(argValue, currentSeries.chart.report.culture, refRes))
                                                    argument = refRes.ref;
                                                else
                                                    argument = null;
                                            }
                                            else {
                                                argument = StiConvert.changeType(argValue, Number);
                                            }
                                        }
                                    }
                                    catch (e) {
                                        argument = null;
                                    }
                                }
                                if (argument == null) {
                                    points[pointIndex] = null;
                                    pointsIds[pointIndex] = "_zero_";
                                }
                                else {
                                    let posX = 0;
                                    if (dotArea.xAxis.logarithmicScale && dotArea.xAxis.info.stripLines.count > 0) {
                                        let countStrip = dotArea.xAxis.info.stripLines.count;
                                        let startPoint = dotArea.reverseHor ? countStrip - 1 : 0;
                                        let endPoint = dotArea.reverseHor ? 0 : countStrip - 1;
                                        let startValue = dotArea.xAxis.info.stripLines.getByIndex(startPoint).value;
                                        let endValue = dotArea.xAxis.info.stripLines.getByIndex(endPoint).value;
                                        let decadeX = Math.abs(rect.width / (Math.log10(endValue) - Math.log10(startValue)));
                                        posX = Math.log10(argument) * decadeX - Math.log10(dotArea.xAxis.info.stripLines.getByIndex(startPoint).value) * decadeX;
                                    }
                                    else {
                                        posX = (argument - dotArea.xAxis.info.minimum) * dotArea.xAxis.info.dpi;
                                    }
                                    if (dotArea.reverseHor)
                                        posX = rect.width - posX;
                                    points[pointIndex] = new PointD(posX, srY);
                                    pointsIds[pointIndex] = argument.stimulsoft().toString();
                                }
                            }
                            else {
                                points[pointIndex] = null;
                                pointsIds[pointIndex] = "_zero_";
                            }
                        }
                        pointLists.push(points);
                        pointsIdsList.push(pointsIds);
                    }
                    let index = 0;
                    for (let pointList of pointLists) {
                        let currentSeries = seriesArray[index];
                        let currentSeriesArgumentsKeys = currentSeries.arguments.stimulsoft().getKeys();
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.points = pointList;
                        pointsInfo.pointsIds = pointsIdsList[index];
                        currentSeries.core.renderLines(context, geom, pointsInfo);
                        currentSeries.stimulsoft().as(Chart.StiSeries).trendLines.list.forEach(trendLine => {
                            if (trendLine != null) {
                                trendLine.core.renderTrendLine(geom, pointList, dotArea.axisCore.getDividerY());
                            }
                        });
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = 0; pointIndex < pointList.length; pointIndex++) {
                                let value = currentSeries.values[pointIndex];
                                let seriesValue = value;
                                if (dotArea.reverseVert && value != null)
                                    seriesValue = -seriesValue;
                                if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    posY = dotArea.axisCore.getDividerY();
                                else
                                    posY = dotArea.axisCore.getDividerRightY();
                                let endPoint = pointList[pointIndex];
                                if (endPoint != null) {
                                    let startPoint = new PointD(endPoint.x, posY);
                                    if (rect.contains(startPoint.x, startPoint.y) || startPoint.y == rect.bottom || rect.contains(endPoint.x, endPoint.y)) {
                                        if ((labels.step == 0 || (pointIndex % labels.step == 0))) {
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, currentSeries.arguments.stimulsoft().getByIndex(pointIndex, currentSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                            if (seriesLabelsGeom != null) {
                                                geom.createChildGeoms();
                                                geom.childGeoms.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        index++;
                    }
                    if (geom.area.chart.seriesLabels.preventIntersection) {
                        this.checkIntersectionLabels(geom);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Scatter");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiScatterSeriesCoreXF = StiScatterSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var DBNull = Stimulsoft.System.Data.DBNull;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var DateTime = Stimulsoft.System.DateTime;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiBubbleSeriesCoreXF extends Chart.StiScatterSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        this.series.brush = style.core.getColumnBrush(color);
                        this.series.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderLines(context, geom, pointsInfo) {
                }
                renderBubbles(context, geom, series, points, weights) {
                    let max = 0;
                    let index = 0;
                    for (let serie of series.chart.series.list) {
                        let bubbleSeries = serie;
                        if (bubbleSeries == null)
                            continue;
                        for (let weight of bubbleSeries.weights) {
                            if (index == 0)
                                max = weight;
                            else
                                max = Math.max(weight, max);
                            index++;
                        }
                    }
                    let axisArea = geom.area;
                    let step = Math.min(axisArea.xAxis.info.step, axisArea.yAxis.info.step) * 0.9;
                    let dpi = step / max;
                    let time = Chart.StiChartHelper.globalBeginTimeElement;
                    index = 0;
                    for (let weight of weights) {
                        let point = points[index];
                        if (point != null && weight > 0) {
                            let size = weight * dpi;
                            let rect = new RectangleD(point.x - size / 2, point.y - size / 2, size, size);
                            let seriesBrush = this.getSeriesBrush(index, points.length);
                            let seriesBorderColor = series.core.getSeriesBorderColor(index, points.length);
                            let seriesColumnGeom = new Chart.StiBubbleSeriesElementGeom(geom, weight, index, seriesBrush, seriesBorderColor, series, rect, new TimeSpan(time.ticks / axisArea.core.valuesCount * index));
                            if (series.core.interaction != null) {
                                let data = new StiSeriesInteractionData();
                                data.fill(axisArea, series, index);
                                seriesColumnGeom.interaction = data;
                            }
                            geom.createChildGeoms();
                            geom.childGeoms.push(seriesColumnGeom);
                        }
                        index++;
                    }
                }
                renderSeries(context, rect, geom, seriesArray) {
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null)
                        return;
                    let dotArea = geom.area;
                    let posY = 0;
                    let pointLists = [];
                    let weightLists = [];
                    for (let seriesIndex = 0; seriesIndex < seriesArray.length; seriesIndex++) {
                        let currentSeries = seriesArray[seriesIndex];
                        let pointsCount = Math.min(currentSeries.values.length, currentSeries.arguments.length);
                        let points = [];
                        let weights = [];
                        for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                            let value = currentSeries.values[pointIndex];
                            if (value == null && currentSeries.showNulls)
                                value = 0;
                            if (dotArea.reverseVert && value != null)
                                value = -value;
                            let srY = 0;
                            if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                                srY = -value * dotArea.yAxis.info.dpi + dotArea.axisCore.getDividerY();
                            }
                            else {
                                srY = -value * dotArea.yRightAxis.info.dpi + dotArea.axisCore.getDividerRightY();
                            }
                            let argument = null;
                            if (currentSeries.arguments[pointIndex] instanceof DateTime) {
                                let tempDateTime = currentSeries.arguments[pointIndex];
                                argument = tempDateTime.toOADate().stimulsoft().toNumber();
                            }
                            else {
                                try {
                                    if (currentSeries.arguments[pointIndex] != null && currentSeries.arguments[pointIndex] != DBNull.value)
                                        argument = currentSeries.arguments[pointIndex].stimulsoft().toNumber();
                                }
                                catch (e) {
                                    Stimulsoft.System.StiError.showError(e, false);
                                    argument = null;
                                }
                            }
                            if (argument == null && currentSeries.showNulls)
                                argument = 0;
                            if (value != null && argument != null) {
                                let posX = (argument - dotArea.xAxis.info.minimum) * dotArea.xAxis.info.dpi;
                                if (dotArea.reverseHor)
                                    posX = rect.width - posX;
                                points.push(new PointD(posX, srY));
                            }
                            else {
                                points.push(null);
                            }
                            weights.push(pointIndex < currentSeries.weights.length ? currentSeries.weights[pointIndex] : 0);
                        }
                        pointLists.push(points);
                        weightLists.push(weights);
                    }
                    for (let index = 0; index < pointLists.length; index++) {
                        let weightList = weightLists[index];
                        let pointList = pointLists[index];
                        let currentSeries = seriesArray[index];
                        currentSeries.core.renderBubbles(context, geom, currentSeries, pointList, weightList);
                        let trendLines = currentSeries.stimulsoft().as(Chart.StiSeries).trendLines;
                        let points = StiArray.create(PointD, pointList.length, true);
                        pointList.stimulsoft().copyTo(points);
                        for (let line of trendLines.list)
                            line.core.renderTrendLine(geom, points, dotArea.axisCore.getDividerY());
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = 0; pointIndex < pointList.length; pointIndex++) {
                                let value = currentSeries.values[pointIndex];
                                let seriesValue = value;
                                if (dotArea.reverseVert && seriesValue != null)
                                    seriesValue = -seriesValue;
                                if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    posY = dotArea.axisCore.getDividerY();
                                else
                                    posY = dotArea.axisCore.getDividerRightY();
                                let endPoint = pointList[pointIndex];
                                if (endPoint != null) {
                                    let startPoint = new PointD(endPoint.x, posY);
                                    if (rect.contains(startPoint.x, startPoint.y) || startPoint.y == rect.bottom || rect.contains(endPoint.x, endPoint.y)) {
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let seriesLabelsGeom = labels.core.renderLabel2(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, currentSeries.arguments[pointIndex].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currentSeries.core.getTag(pointIndex), currentSeries.weights[pointIndex], pointIndex, pointList.length, rect);
                                            if (seriesLabelsGeom != null) {
                                                geom.createChildGeoms();
                                                geom.childGeoms.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Bubble");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiBubbleSeriesCoreXF = StiBubbleSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            var StiString = Stimulsoft.System.StiString;
            var StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
            var StiLabelAnimation = Stimulsoft.Base.Context.Animation.StiLabelAnimation;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiClusteredColumnSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        this.series.brush = style.core.getColumnBrush(color);
                        this.series.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    var _a;
                    let seriesLabelsList = [];
                    let area = geom.area;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let axisArea = area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    let posY = axisArea.axisCore.getDividerY();
                    let colorIndex = 0;
                    let colorCount = axisArea.axisCore.valuesCount * series.length;
                    let pointsLists = [];
                    for (let index = 0; index < series.length; index++) {
                        pointsLists.push([]);
                    }
                    let sumSeriesWidth = 0;
                    for (let ser of series) {
                        sumSeriesWidth += axisArea.xAxis.info.step / series.length * ser.width;
                    }
                    for (let pointIndex = 0; pointIndex < axisArea.axisCore.valuesCount; pointIndex++) {
                        let seriesLeftPos = this.measureLeftPosition(axisArea, pointIndex, sumSeriesWidth, getStartFromZero);
                        let seriesIndex = 0;
                        if (axisArea.reverseHor)
                            seriesIndex = series.length - 1;
                        while ((seriesIndex < series.length && (!axisArea.reverseHor)) ||
                            (seriesIndex >= 0 && axisArea.reverseHor)) {
                            let currentSeries = series[seriesIndex];
                            let seriesWidth = axisArea.xAxis.info.step / series.length * currentSeries.width;
                            let valuesStartApproximation = currentSeries.valuesStart;
                            if (pointIndex < currentSeries.values.length) {
                                let value = this.getSeriesCurrentValue(axisArea, currentSeries, pointIndex);
                                let columnRect = this.getColumnRect(context, currentSeries, value, seriesLeftPos, seriesWidth);
                                let valueStart = this.getSeriesValueStart(axisArea, currentSeries.valuesStart, pointIndex);
                                let valueStartApproximation = this.getSeriesValueStart(axisArea, valuesStartApproximation, pointIndex);
                                let columnRectStart = this.getColumnRect(context, currentSeries, valueStartApproximation !== null && valueStartApproximation !== void 0 ? valueStartApproximation : 0, seriesLeftPos, seriesWidth);
                                for (let line of currentSeries.as(Chart.StiSeries).trendLines.list) {
                                    if (!line.is(Chart.IStiTrendLineNone)) {
                                        pointsLists[seriesIndex].push(new PointD(seriesLeftPos + seriesWidth / 2, columnRect.y));
                                        break;
                                    }
                                }
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                let columnRectCheck = columnRect.clone();
                                columnRectCheck.x += geom.clientRectangle.x;
                                columnRectCheck.y += geom.clientRectangle.y;
                                if ((columnRectCheck.right > clipRect.x && columnRectCheck.x < clipRect.right) || this.series.chart.area.xAxis.range.auto) {
                                    let seriesBrush = this.getSeriesBrush2(currentSeries, value, colorIndex, colorCount, pointIndex);
                                    let seriesBorderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                    if (this.series.chart != null && this.series.chart.style != null && columnRect.height > 0) {
                                        let seriesColumnGeom = new Chart.StiClusteredColumnSeriesElementGeom(geom, value, pointIndex, seriesBrush, seriesBorderColor, currentSeries, columnRect, columnRectStart);
                                        if (currentSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, currentSeries, pointIndex);
                                            seriesColumnGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(seriesColumnGeom);
                                    }
                                    let labels = currentSeries.core.getSeriesLabels();
                                    if (labels != null && labels.visible) {
                                        let endPoint = this.getPointEnd(currentSeries, value, seriesLeftPos, seriesWidth);
                                        let seriesValue = 0;
                                        if (value != null)
                                            seriesValue = axisArea.reverseVert ? -value : value;
                                        let animation = null;
                                        if (this.series.chart.isAnimationChangingValues) {
                                            if (labels.valueType == Chart.StiSeriesLabelsValueType.Value && StiString.isNullOrEmpty(labels.format) && ((_a = labels.formatService) === null || _a === void 0 ? void 0 : _a.is(StiGeneralFormatService))) {
                                                let endPointFrom = this.getPointEnd(currentSeries, valueStart, seriesLeftPos, seriesWidth);
                                                animation = new StiLabelAnimation(valueStart, value, new PointD(endPointFrom.x, endPointFrom.y), new PointD(endPoint.x, endPoint.y), Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                            }
                                            else {
                                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                            }
                                        }
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let argumentIndex = axisArea.xAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect), this.correctPoint(new PointD(endPoint.x, posY), rect), pointIndex, value, seriesValue, axisArea.axisCore.getArgumentLabel(axisArea.xAxis.info.stripLines.getByIndex(argumentIndex), currentSeries), currentSeries.core.getTag(pointIndex), colorIndex, colorCount, rect, animation);
                                            if (seriesLabelsGeom != null) {
                                                seriesLabelsList.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle);
                                            }
                                        }
                                    }
                                }
                            }
                            seriesLeftPos += seriesWidth;
                            colorIndex++;
                            if (axisArea.reverseHor)
                                seriesIndex--;
                            else
                                seriesIndex++;
                        }
                    }
                    for (let indexSeries = 0; indexSeries < series.length; indexSeries++) {
                        series[indexSeries].trendLines.list.forEach(trendLine => {
                            if (!trendLine.is2(Chart.IStiTrendLineNone)) {
                                let pointsList = pointsLists[indexSeries];
                                if (trendLine != null) {
                                    trendLine.core.renderTrendLine(geom, pointsList.stimulsoft().toArray(), axisArea.axisCore.getDividerY());
                                }
                            }
                        });
                    }
                    for (let seriesLabelsGeom of seriesLabelsList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                    }
                    if (geom.area.chart.seriesLabels.preventIntersection) {
                        this.checkIntersectionLabels(geom);
                    }
                }
                getPointEnd(currentSeries, value, seriesLeftPos, seriesWidth) {
                    let endPoint;
                    let axisArea = currentSeries.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    let posRightY = axisArea.axisCore.getDividerRightY();
                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        endPoint = new PointD(seriesLeftPos + seriesWidth / 2, -(value * axisArea.yAxis.info.dpi) + posY);
                    }
                    else {
                        endPoint = new PointD(seriesLeftPos + seriesWidth / 2, -(value * axisArea.yRightAxis.info.dpi) + posRightY);
                    }
                    return endPoint;
                }
                getColumnRect(context, currentSeries, value, seriesLeftPos, seriesWidth) {
                    let axisArea = currentSeries.chart.area;
                    let seriesHeight = 0;
                    let seriesTopPos = 0;
                    let posY = axisArea.axisCore.getDividerY();
                    let posRightY = axisArea.axisCore.getDividerRightY();
                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        if (!axisArea.reverseVert) {
                            seriesHeight = value * axisArea.yAxis.info.dpi;
                            seriesTopPos = -seriesHeight + posY;
                        }
                        else {
                            seriesHeight = value * axisArea.yAxis.info.dpi;
                            seriesTopPos = -seriesHeight + posY;
                        }
                    }
                    else {
                        seriesHeight = value * axisArea.yRightAxis.info.dpi;
                        seriesTopPos = -seriesHeight + posRightY;
                    }
                    if (currentSeries.showZeros && (value == 0 || value == null)) {
                        seriesHeight = Math.max(context.options.zoom, 2);
                        if (!axisArea.reverseVert)
                            seriesTopPos -= seriesHeight;
                    }
                    if (value < 0) {
                        if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                            seriesTopPos = posY;
                        else
                            seriesTopPos = posRightY;
                        seriesHeight = -seriesHeight;
                    }
                    return new RectangleD(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                }
                correctPoint(point, rect) {
                    if (point.y < 0)
                        return new PointD(point.x, 0);
                    if (point.y > rect.height)
                        return new PointD(point.x, rect.height);
                    return point;
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return this.series.brush;
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return this.series.borderColor;
                    return color;
                }
                measureLeftPosition(axisArea, pointIndex, sumSeriesWidth, startFromZero) {
                    let posX = startFromZero ?
                        axisArea.xAxis.info.stripPositions[pointIndex + 1] :
                        axisArea.xAxis.info.stripPositions[pointIndex];
                    posX -= axisArea.xAxis.info.step / 2;
                    let seriesLeftPos = posX + (axisArea.xAxis.info.step - sumSeriesWidth) / 2;
                    return seriesLeftPos;
                }
                getSeriesCurrentValue(axisArea, currentSeries, pointIndex) {
                    let value = axisArea.reverseHor ?
                        currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                        currentSeries.values[pointIndex];
                    if (axisArea.reverseVert && value != null)
                        value = -value;
                    return value;
                }
                getSeriesValueStart(axisArea, valuesStart, pointIndex) {
                    let valueStart = null;
                    if (this.series.chart.isAnimationChangingValues) {
                        if (valuesStart != null && valuesStart.length > pointIndex) {
                            valueStart = axisArea.reverseHor ?
                                valuesStart[valuesStart.length - pointIndex - 1] :
                                valuesStart[pointIndex];
                        }
                        if (axisArea.reverseVert && valueStart != null)
                            valueStart = -valueStart;
                    }
                    return valueStart;
                }
                getSeriesBrush2(currentSeries, value, colorIndex, colorCount, pointIndex) {
                    let seriesBrush = currentSeries.core.getSeriesBrush(colorIndex, colorCount);
                    if (currentSeries.allowApplyBrushNegative && (value < 0))
                        seriesBrush = currentSeries.brushNegative;
                    seriesBrush = currentSeries.processSeriesBrushes(pointIndex, seriesBrush);
                    return seriesBrush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ClusteredColumn");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiClusteredColumnSeriesCoreXF = StiClusteredColumnSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            var StiString = Stimulsoft.System.StiString;
            var StiGeneralFormatService = Stimulsoft.Report.Components.TextFormats.StiGeneralFormatService;
            var StiLabelAnimation = Stimulsoft.Base.Context.Animation.StiLabelAnimation;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiClusteredBarSeriesCoreXF extends Chart.StiClusteredColumnSeriesCoreXF {
                constructor(series) {
                    super(series);
                }
                implements() {
                    if (!StiClusteredBarSeriesCoreXF.implementsStiClusteredBarSeriesCoreXF)
                        StiClusteredBarSeriesCoreXF.implementsStiClusteredBarSeriesCoreXF = super.implements().concat([
                            Chart.IStiApplyStyleSeries
                        ]);
                    return StiClusteredBarSeriesCoreXF.implementsStiClusteredBarSeriesCoreXF;
                }
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let barSeries = this.series;
                    if (barSeries.allowApplyStyle) {
                        barSeries.brush = style.core.getColumnBrush(color);
                        if (barSeries.brush.is(StiGradientBrush))
                            barSeries.brush.angle += 90;
                        if (barSeries.brush.is(StiGlareBrush))
                            barSeries.brush.angle += 90;
                        barSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    var _a, _b;
                    let seriesLabelsList = [];
                    let area = geom.area;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let axisArea = area;
                    let getStartFromZero = axisArea.yAxis.core.getStartFromZero();
                    let posX = axisArea.axisCore.getDividerX();
                    let posTopX = axisArea.axisCore.getDividerTopX();
                    let colorCount = axisArea.axisCore.valuesCount * series.length;
                    let colorIndex = axisArea.reverseVert ? colorCount - 1 : 0;
                    let pointCount = axisArea.axisCore.valuesCount;
                    let pointsLists = [];
                    for (let index = 0; index < series.length; index++) {
                        pointsLists.push([]);
                    }
                    let seriesKeys = series.stimulsoft().getKeys();
                    for (let pointIndex = 0; pointIndex < pointCount; pointIndex++) {
                        let posY = getStartFromZero ?
                            axisArea.yAxis.info.stripPositions[pointIndex + 1] - axisArea.yAxis.info.step / 2 :
                            axisArea.yAxis.info.stripPositions[pointIndex] - axisArea.yAxis.info.step / 2;
                        let sumSeriesHeight = 0;
                        for (let ser of series) {
                            sumSeriesHeight += axisArea.yAxis.info.step / series.length * ser.width;
                        }
                        let seriesTopPos = posY + (axisArea.yAxis.info.step - sumSeriesHeight) / 2;
                        let seriesIndex = 0;
                        if (axisArea.reverseVert)
                            seriesIndex = series.length - 1;
                        let time = Chart.StiChartHelper.globalBeginTimeElement;
                        while ((seriesIndex < series.length && (!axisArea.reverseVert)) ||
                            (seriesIndex >= 0 && axisArea.reverseVert)) {
                            let currentSeries = series.stimulsoft().getByIndex(seriesIndex, seriesKeys);
                            let seriesHeight = axisArea.yAxis.info.step / series.length * currentSeries.width;
                            if (pointIndex < currentSeries.values.length) {
                                let value = -(!axisArea.reverseVert ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex]);
                                let seriesWidth = value * axisArea.xAxis.info.dpi;
                                let columnRect = this.getBarRect(context, currentSeries, value, seriesTopPos, seriesHeight);
                                let rectFrom = Rectangle.empty;
                                let valueFrom = null;
                                if (this.series.chart.isAnimationChangingValues) {
                                    if (((_a = currentSeries.valuesStart) === null || _a === void 0 ? void 0 : _a.length) > pointIndex) {
                                        valueFrom = -(!axisArea.reverseVert ?
                                            currentSeries.valuesStart[currentSeries.valuesStart.length - pointIndex - 1] :
                                            currentSeries.valuesStart[pointIndex]);
                                    }
                                    if (axisArea.reverseHor) {
                                        if (value < 0)
                                            rectFrom = Rectangle.fromLTRB(columnRect.right, columnRect.top, columnRect.right, columnRect.bottom);
                                        else
                                            rectFrom = Rectangle.fromLTRB(columnRect.left, columnRect.top, columnRect.left, columnRect.bottom);
                                    }
                                    else {
                                        if (value >= 0)
                                            rectFrom = Rectangle.fromLTRB(columnRect.right, columnRect.top, columnRect.right, columnRect.bottom);
                                        else
                                            rectFrom = Rectangle.fromLTRB(columnRect.left, columnRect.top, columnRect.left, columnRect.bottom);
                                    }
                                }
                                for (let line of currentSeries.as(Chart.StiSeries).trendLines.list) {
                                    if (!line.is(Chart.IStiTrendLineNone)) {
                                        pointsLists[seriesIndex].push(new PointD(seriesWidth, seriesTopPos + seriesHeight / 2));
                                        break;
                                    }
                                }
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                let columnRectCheck = columnRect.clone();
                                columnRectCheck.x += geom.clientRectangle.x;
                                columnRectCheck.y += geom.clientRectangle.y;
                                if ((columnRectCheck.bottom > clipRect.y && columnRectCheck.y < clipRect.bottom) || this.series.chart.area.yAxis.range.auto) {
                                    if (this.series.chart != null && this.series.chart.style != null && columnRect.width > 0) {
                                        let seriesBrush = currentSeries.core.getSeriesBrush(colorIndex, colorCount);
                                        if (currentSeries.allowApplyBrushNegative && (value > 0))
                                            seriesBrush = currentSeries.brushNegative;
                                        seriesBrush = currentSeries.processSeriesBrushes((pointCount - 1) - pointIndex, seriesBrush);
                                        let seriesBorderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                        let seriesColumnGeom = new Chart.StiClusteredBarSeriesElementGeom(geom, valueFrom, axisArea.reverseHor ? -value : value, pointIndex, seriesBrush, seriesBorderColor, currentSeries, rectFrom, columnRect);
                                        if (currentSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, currentSeries, pointIndex);
                                            seriesColumnGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(seriesColumnGeom);
                                    }
                                    let labels = currentSeries.core.getSeriesLabels();
                                    if (labels != null && labels.visible) {
                                        let seriesValue = value;
                                        if (value != null)
                                            seriesValue = axisArea.reverseHor ? value : -value;
                                        let currentPosX = currentSeries.yAxis == Chart.StiSeriesYAxis.RightYAxis ? posTopX : posX;
                                        let currentDpi = currentSeries.yAxis == Chart.StiSeriesYAxis.RightYAxis ? axisArea.xTopAxis.info.dpi : axisArea.xAxis.info.dpi;
                                        let endPoint = new PointD((seriesValue * currentDpi) + currentPosX, seriesTopPos + seriesHeight / 2);
                                        let animation = null;
                                        if (this.series.chart.isAnimationChangingValues) {
                                            if (labels.valueType == Chart.StiSeriesLabelsValueType.Value && StiString.isNullOrEmpty(labels.format) && ((_b = labels.formatService) === null || _b === void 0 ? void 0 : _b.is(StiGeneralFormatService))) {
                                                let endPointFrom = new PointD(-(valueFrom * currentDpi) + currentPosX, seriesTopPos + seriesHeight / 2);
                                                let animationValueFrom = null;
                                                let animationValue = null;
                                                if (valueFrom != null)
                                                    animationValueFrom = axisArea.reverseHor ? valueFrom : -valueFrom;
                                                if (value != null)
                                                    animationValue = axisArea.reverseHor ? value : -value;
                                                animation = new StiLabelAnimation(animationValueFrom, animationValue, new PointD(endPointFrom.x, endPointFrom.y), new PointD(endPoint.x, endPoint.y), time, TimeSpan.zero);
                                            }
                                            else {
                                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, TimeSpan.zero);
                                            }
                                        }
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let argumentIndex = axisArea.yAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect), this.correctPoint(new PointD(posX, endPoint.y), rect), pointIndex, value, axisArea.reverseHor ? -seriesValue : seriesValue, axisArea.axisCore.getArgumentLabel(axisArea.yAxis.info.stripLines.getByIndex(argumentIndex), currentSeries), currentSeries.core.getTag(pointIndex), colorIndex, colorCount, rect, animation);
                                            if (seriesLabelsGeom != null) {
                                                seriesLabelsList.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect2(labels, clipRect, seriesLabelsGeom.clientRectangle);
                                            }
                                        }
                                    }
                                }
                            }
                            seriesTopPos += seriesHeight;
                            colorIndex = axisArea.reverseVert ? colorIndex - 1 : colorIndex + 1;
                            if (axisArea.reverseVert)
                                seriesIndex--;
                            else
                                seriesIndex++;
                        }
                    }
                    for (let indexSeries = 0; indexSeries < series.length; indexSeries++) {
                        series.stimulsoft().getByIndex(indexSeries, seriesKeys).trendLines.list.forEach(trendLine => {
                            if (!trendLine.is2(Chart.IStiTrendLineNone)) {
                                let pointsList = pointsLists[indexSeries];
                                if (trendLine != null) {
                                    trendLine.core.renderTrendLine(geom, pointsList.stimulsoft().toArray(), axisArea.axisCore.getDividerY());
                                }
                            }
                        });
                    }
                    for (let seriesLabelsGeom of seriesLabelsList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                    }
                }
                getBarRect(context, currentSeries, value, seriesTopPos, seriesHeight) {
                    let axisArea = currentSeries.chart.area;
                    let posX = axisArea.axisCore.getDividerX();
                    let posTopX = axisArea.axisCore.getDividerTopX();
                    let posCurrentX = currentSeries.yAxis == Chart.StiSeriesYAxis.RightYAxis ? posTopX : posX;
                    let currentDpi = currentSeries.yAxis == Chart.StiSeriesYAxis.RightYAxis ? axisArea.xTopAxis.info.dpi : axisArea.xAxis.info.dpi;
                    let seriesWidth = value * currentDpi;
                    let seriesLeftPos = -seriesWidth + posCurrentX;
                    if (this.series.showZeros && (value == 0 || value == null)) {
                        seriesWidth = Math.max(context.options.zoom, 2);
                    }
                    if (value < 0) {
                        seriesLeftPos = posCurrentX;
                        seriesWidth = -seriesWidth;
                    }
                    return new Rectangle(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                }
                correctPoint(point, rect) {
                    if (point.x < 0)
                        return new PointD(0, point.y);
                    if (point.x > rect.width)
                        return new PointD(rect.width, point.y);
                    return point;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ClusteredBar");
                }
            }
            Chart.StiClusteredBarSeriesCoreXF = StiClusteredBarSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiLineSeriesCoreXF extends Chart.StiBaseLineSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points != null && pointsInfo.points.length > 1) {
                        let seriesGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, this.series);
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                        if (this.interaction != null) {
                            seriesGeom.interactions = this.getInteractions(context, geom, pointsInfo.points);
                        }
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Line");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiLineSeriesCoreXF = StiLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiAreaSeriesCoreXF extends Chart.StiLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderAreas(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiAreaSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let areaSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return areaSeries.brush;
                    return brush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Area");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiAreaSeriesCoreXF = StiAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiHistogramSeriesCoreXF extends Chart.StiClusteredColumnSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "Histogram");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiHistogramSeriesCoreXF = StiHistogramSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var List = Stimulsoft.System.Collections.List;
            class StiParetoSeriesCoreXF extends Chart.StiClusteredColumnSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let paretoSeries = this.series;
                    if (this.series.allowApplyStyle) {
                        paretoSeries.brush = style.core.getColumnBrush(color);
                        paretoSeries.borderColor = style.core.getColumnBorder(color);
                        paretoSeries.lighting = style.core.seriesLighting;
                        paretoSeries.marker.visible = style.core.markerVisible;
                        if (paretoSeries.marker != null) {
                            paretoSeries.marker.brush = new StiSolidBrush(StiColorUtils.light(color, 100));
                            paretoSeries.marker.borderColor = StiColorUtils.dark(color, 100);
                        }
                        if (paretoSeries.lineMarker != null) {
                            paretoSeries.lineMarker.brush = new StiSolidBrush(StiColorUtils.light(color, 50));
                            paretoSeries.lineMarker.borderColor = StiColorUtils.dark(color, 150);
                        }
                    }
                    if (!paretoSeries.allowApplyLineColor) {
                        paretoSeries.lineColor = StiColorUtils.light(color, 50);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    super.renderSeries(context, rect, geom, series);
                    this.renderLinePareto(context, rect, geom, series);
                }
                renderLinePareto(context, rect, geom, series) {
                    let area = geom.area;
                    let axisArea = area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    rect.width += 0.001;
                    let pointLists = [];
                    let pointFromLists = [];
                    let pointIdsLists = [];
                    for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                        let currentSeries = series[seriesIndex];
                        let paretoValues = this.getParetoValues(currentSeries.values);
                        let pointsCount = currentSeries.values.length;
                        let points = StiArray.create(PointD, pointsCount, true);
                        let pointsFrom = StiArray.create(PointD, pointsCount, true);
                        let pointsIds = StiArray.create(String, pointsCount, true);
                        for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                            let stripPoint = getStartFromZero ? pointIndex + 1 : pointIndex;
                            if (stripPoint >= axisArea.xAxis.info.stripPositions.length)
                                break;
                            let posX = axisArea.xAxis.info.stripPositions[stripPoint];
                            let value = axisArea.reverseHor ?
                                paretoValues[paretoValues.length - pointIndex - 1] :
                                paretoValues[pointIndex];
                            points[pointIndex] = this.getPointValue(value, currentSeries, axisArea, posX);
                            let paretoValuesStart = this.getParetoValues(currentSeries.valuesStart);
                            let valueFrom = 0;
                            if (paretoValuesStart.length > pointIndex) {
                                valueFrom = axisArea.reverseHor ?
                                    paretoValuesStart[paretoValuesStart.length - pointIndex - 1] :
                                    paretoValuesStart[pointIndex];
                            }
                            pointsFrom[pointIndex] = this.getPointValue(valueFrom, currentSeries, axisArea, posX);
                            let argId = axisArea.xAxis.info.stripLines.getByIndex(stripPoint).valueObject;
                            pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                        }
                        if (points.length > 0) {
                            points = Chart.StiPointHelper.optimizePoints(points);
                            let pointsInfo = new Chart.StiSeriesPointsInfo();
                            pointsInfo.pointsFrom = pointsFrom;
                            pointsInfo.points = points;
                            pointsInfo.pointsIds = pointsIds;
                            this.renderLines(geom, pointsInfo, currentSeries);
                        }
                        pointLists.push(points);
                        if (this.series.chart.isAnimationChangingValues) {
                            pointFromLists.push(pointsFrom);
                            pointIdsLists.push(pointsIds);
                        }
                    }
                }
                renderLines(geom, pointsInfo, series) {
                    if (pointsInfo.points != null && pointsInfo.points.length > 1) {
                        let seriesGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, series);
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getParetoValues(values) {
                    let paretoTempValues = new List();
                    let paretoValues = new List();
                    let sum = 0;
                    for (let value of values) {
                        sum += value;
                        paretoTempValues.push(sum);
                    }
                    for (let value of paretoTempValues) {
                        let percentValue = value / sum * 100;
                        paretoValues.push(percentValue);
                    }
                    return paretoValues;
                }
                getPointValue(value, currentSeries, axisArea, posX) {
                    if (axisArea.reverseVert && value != null)
                        value = -value;
                    let srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                    return new PointD(posX, srY);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ClusteredColumn");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiParetoSeriesCoreXF = StiParetoSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSplineSeriesCoreXF extends Chart.StiBaseLineSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiSplineSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    if (this.interaction != null) {
                        seriesGeom.interactions = this.getInteractions(context, geom, pointsInfo.points);
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Spline");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSplineSeriesCoreXF = StiSplineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSplineAreaSeriesCoreXF extends Chart.StiSplineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderAreas(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiSplineAreaSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let areaSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return areaSeries.brush;
                    return brush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "SplineArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSplineAreaSeriesCoreXF = StiSplineAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSteppedLineSeriesCoreXF extends Chart.StiBaseLineSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    let lineSeries = this.series;
                    if (pointsInfo.points.length > 1 || (lineSeries.pointAtCenter && pointsInfo.points.length > 0)) {
                        let seriesGeom = new Chart.StiSteppedLineSeriesGeom(geom, pointsInfo, this.series);
                        if (seriesGeom != null) {
                            geom.createChildGeoms();
                            geom.childGeoms.push(seriesGeom);
                        }
                        if (this.interaction != null) {
                            seriesGeom.interactions = this.getInteractions(context, geom, pointsInfo.points);
                        }
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedLine");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSteppedLineSeriesCoreXF = StiSteppedLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiSteppedAreaSeriesCoreXF extends Chart.StiSteppedLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderAreas(context, geom, pointsInfo) {
                    let lineSeries = this.series;
                    if (pointsInfo.points == null || pointsInfo.points.length == 0 ||
                        (pointsInfo.points.length == 1 && !lineSeries.pointAtCenter))
                        return;
                    let seriesGeom = new Chart.StiSteppedAreaSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let areaSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return areaSeries.brush;
                    return brush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSteppedAreaSeriesCoreXF = StiSteppedAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var List = Stimulsoft.System.Collections.List;
            var PointF = Stimulsoft.System.Drawing.Point;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiChart = Stimulsoft.Report.Components.StiChart;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            class StiWaterfallSeriesCoreXF extends Chart.StiClusteredColumnSeriesCoreXF {
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    this.renderColumns(context, rect, geom, series);
                }
                getSumSeriesWidth(axisArea, series) {
                    let sumSeriesWidth = 0;
                    for (let ser of series) {
                        sumSeriesWidth += axisArea.xAxis.info.step / series.length * ser.width;
                    }
                    return sumSeriesWidth;
                }
                getDividerYSeries(axisArea, series) {
                    let posY = axisArea.axisCore.getDividerY();
                    let array = [];
                    for (let index = 0; index < series.length; index++) {
                        array[index] = posY;
                    }
                    return array;
                }
                renderColumns(context, rect, geom, series) {
                    let area = geom.area;
                    let seriesLabelsList = new List();
                    let axisArea = area;
                    let posYSeries = this.getDividerYSeries(axisArea, series);
                    let colorIndex = 0;
                    let colorCount = axisArea.axisCore.valuesCount * series.length;
                    let sumSeriesWidth = this.getSumSeriesWidth(axisArea, series);
                    for (let pointIndex = 0; pointIndex < axisArea.axisCore.valuesCount; pointIndex++) {
                        let posX = axisArea.xAxis.core.getStartFromZero() ?
                            axisArea.xAxis.info.stripPositions[pointIndex + 1] :
                            axisArea.xAxis.info.stripPositions[pointIndex];
                        posX -= axisArea.xAxis.info.step / 2;
                        let seriesLeftPos = (posX + (axisArea.xAxis.info.step - sumSeriesWidth) / 2);
                        let seriesIndex = axisArea.reverseHor ? series.length - 1 : 0;
                        while ((seriesIndex < series.length && (!axisArea.reverseHor)) || (seriesIndex >= 0 && axisArea.reverseHor)) {
                            let currentSeries = series[seriesIndex];
                            let seriesWidth = axisArea.xAxis.info.step / series.length * currentSeries.width;
                            if (pointIndex < currentSeries.values.length) {
                                let value = axisArea.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                if (value == null)
                                    seriesWidth = 0;
                                if (axisArea.reverseVert && value != null)
                                    value = -value;
                                let isLastValue = pointIndex == currentSeries.values.length - 1;
                                let posY = isLastValue && currentSeries.total.visible ? axisArea.axisCore.getDividerY() : posYSeries[seriesIndex];
                                let REFposY = { ref: posY };
                                let REFposYSeries = { ref: posYSeries[seriesIndex] };
                                let columnRect = isLastValue && currentSeries.total.visible ?
                                    this.getColumnRect(context, currentSeries, value, seriesLeftPos, seriesWidth, REFposY) :
                                    this.getColumnRect(context, currentSeries, value, seriesLeftPos, seriesWidth, REFposYSeries);
                                posY = REFposY.ref;
                                posYSeries[seriesIndex] = REFposYSeries.ref;
                                let rectFrom;
                                if (value < 0)
                                    rectFrom = Rectangle.fromLTRB(columnRect.left, columnRect.top, columnRect.right, columnRect.top);
                                else
                                    rectFrom = Rectangle.fromLTRB(columnRect.left, columnRect.bottom, columnRect.right, columnRect.bottom);
                                let clipRect = geom.as(Chart.StiAxisAreaGeom).view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                let columnRectCheck = columnRect;
                                columnRectCheck.x += geom.clientRectangle.x;
                                columnRectCheck.y += geom.clientRectangle.y;
                                if ((columnRectCheck.right > clipRect.x && columnRectCheck.x < clipRect.right) || this.series.chart.area.stimulsoft().as(Chart.IStiAxisArea).xAxis.range.auto) {
                                    let seriesBrush;
                                    let seriesBorderColor;
                                    if (area.colorEach) {
                                        seriesBrush = currentSeries.core.getSeriesBrush(colorIndex, colorCount);
                                        if (currentSeries.allowApplyBrushNegative && (value < 0))
                                            seriesBrush = currentSeries.brushNegative;
                                        seriesBrush = currentSeries.processSeriesBrushes(pointIndex, seriesBrush);
                                        seriesBorderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                    }
                                    else {
                                        seriesBrush = currentSeries.connectorLine.visible && !(isLastValue && currentSeries.total.visible)
                                            ? currentSeries.core.getSeriesBrush(0, 3)
                                            : currentSeries.core.getSeriesBrush(2, 3);
                                        if (value < 0)
                                            seriesBrush = currentSeries.allowApplyBrushNegative ? currentSeries.brushNegative : currentSeries.core.getSeriesBrush(1, 3);
                                        seriesBrush = currentSeries.processSeriesBrushes(pointIndex, seriesBrush);
                                        seriesBrush = StiBrush.light(seriesBrush, seriesIndex * 10);
                                        seriesBorderColor = currentSeries.core.getSeriesBorderColor(0, 3);
                                    }
                                    if (this.series.chart != null && this.series.chart.style != null && columnRect.height > 0) {
                                        let seriesColumnGeom = null;
                                        if (columnRect.height > 0) {
                                            seriesColumnGeom = new Chart.StiClusteredColumnSeriesElementGeom(geom, value, pointIndex, seriesBrush, seriesBorderColor, currentSeries, columnRect, rectFrom);
                                        }
                                        if (currentSeries.connectorLine.visible && !isLastValue) {
                                            let pen = new StiPenGeom(currentSeries.connectorLine.lineColor, currentSeries.connectorLine.lineWidth);
                                            pen.penStyle = currentSeries.connectorLine.lineStyle;
                                            let y = value > 0 ? columnRect.top : columnRect.bottom;
                                            let width = columnRect.right + axisArea.xAxis.info.step - seriesWidth;
                                            let lineGeom = new Chart.StiWaterfallLineGeom(new PointF(columnRect.right, y), new PointF(width, y), pen, new Rectangle(columnRect.right, y, width - columnRect.right, y), currentSeries.chart.stimulsoft().as(StiChart).isAnimation);
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(lineGeom);
                                        }
                                        if (seriesColumnGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesColumnGeom);
                                        }
                                    }
                                    let labels = currentSeries.core.getSeriesLabels();
                                    if (labels != null && labels.visible && value != null) {
                                        let posYLabel = isLastValue && currentSeries.total.visible ? axisArea.axisCore.getDividerY() : posY;
                                        let endPoint = this.getPointEnd(currentSeries, value, seriesLeftPos, seriesWidth, posYLabel);
                                        let seriesValue = axisArea.reverseVert ? -value : value;
                                        let animation = null;
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let argumentIndex = axisArea.xAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let seriesLabelsGeom = labels.core.stimulsoft().as(Chart.StiAxisSeriesLabelsCoreXF).renderLabel(currentSeries, context, this.correctPoint(endPoint, rect), this.correctPoint(new PointF(endPoint.x, posYLabel), rect), pointIndex, value, seriesValue, axisArea.axisCore.getArgumentLabel(axisArea.xAxis.info.stripLines.getByIndex(argumentIndex), currentSeries), currentSeries.core.getTag(pointIndex), colorIndex, colorCount, rect, animation);
                                            if (seriesLabelsGeom != null) {
                                                seriesLabelsList.push(seriesLabelsGeom);
                                                seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle);
                                            }
                                        }
                                    }
                                }
                            }
                            seriesLeftPos += seriesWidth;
                            colorIndex++;
                            if (axisArea.reverseHor)
                                seriesIndex--;
                            else
                                seriesIndex++;
                        }
                    }
                    for (let seriesLabelsGeom of seriesLabelsList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                    }
                    if (geom.area.chart.seriesLabels.preventIntersection) {
                        this.checkIntersectionLabels(geom);
                    }
                }
                getPointEnd(currentSeries, value, seriesLeftPos, seriesWidth, posY = null) {
                    let endPoint;
                    let axisArea = currentSeries.chart.area.stimulsoft().as(Chart.IStiAxisArea);
                    let posRightY = axisArea.axisCore.getDividerRightY();
                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        endPoint = new PointF(seriesLeftPos + seriesWidth / 2, -(value * axisArea.yAxis.info.dpi) + posY);
                    }
                    else {
                        endPoint = new PointF(seriesLeftPos + seriesWidth / 2, -(value * axisArea.yRightAxis.info.dpi) + posRightY);
                    }
                    return endPoint;
                }
                getColumnRect(context, currentSeries, value, seriesLeftPos, seriesWidth, REFposY = null) {
                    let axisArea = currentSeries.chart.area.stimulsoft().as(Chart.IStiAxisArea);
                    let seriesHeight = 0;
                    let seriesTopPos = 0;
                    let posRightY = axisArea.axisCore.getDividerRightY();
                    if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                        if (!axisArea.reverseVert) {
                            seriesHeight = value * axisArea.yAxis.info.dpi;
                            seriesTopPos = -seriesHeight + REFposY.ref;
                        }
                        else {
                            seriesHeight = value * axisArea.yAxis.info.dpi;
                            seriesTopPos = -seriesHeight + REFposY.ref;
                        }
                    }
                    else {
                        seriesHeight = value * axisArea.yRightAxis.info.dpi;
                        seriesTopPos = -seriesHeight + posRightY;
                    }
                    if (currentSeries.showZeros && (value == 0 || value == null)) {
                        seriesHeight = Math.max(context.options.zoom, 2);
                        if (!axisArea.reverseVert)
                            seriesTopPos -= seriesHeight;
                    }
                    if (value < 0) {
                        if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                            seriesTopPos = REFposY.ref;
                        else
                            seriesTopPos = posRightY;
                        seriesHeight = -seriesHeight;
                    }
                    REFposY.ref = value > 0 ? seriesTopPos : seriesTopPos + seriesHeight;
                    return new Rectangle(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Waterfall");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiWaterfallSeriesCoreXF = StiWaterfallSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiPieSegmentGeom = Stimulsoft.Base.Context.StiPieSegmentGeom;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiPieSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let pieSeries = this.series;
                    if (pieSeries.allowApplyStyle) {
                        pieSeries.lighting = style.core.seriesLighting;
                        if (pieSeries.allowApplyBrush) {
                            pieSeries.brush = style.core.getColumnBrush(color);
                        }
                        if (pieSeries.allowApplyBorderColor) {
                            pieSeries.borderColor = style.core.getColumnBorder(color);
                        }
                    }
                }
                correctBrush(brush) {
                    if (brush.is(StiGradientBrush)) {
                        brush = brush.clone();
                        brush.angle = -45;
                    }
                    if (brush.is(StiGlareBrush)) {
                        brush = brush.clone();
                        brush.angle = -45;
                    }
                    return brush;
                }
                renderPieElement(context, center, radius, borderColor, brush, start, angle, value, index, currentSeries, distance, geom, beginTime) {
                    let path;
                    let pathLight;
                    let rectPie = RectangleD.empty;
                    brush = this.correctBrush(brush);
                    let REFpath = { ref: path };
                    let REFpathLight = { ref: pathLight };
                    let REFrectPie = { ref: rectPie };
                    let clientRectangle = this.measurePieElementCore(context, center, radius, start, angle, currentSeries, distance, REFpath, REFpathLight, REFrectPie);
                    path = REFpath.ref;
                    pathLight = REFpathLight.ref;
                    rectPie = REFrectPie.ref;
                    if (clientRectangle.isEmpty)
                        return null;
                    return new Chart.StiPieSeriesElementGeom(geom, value, index, currentSeries, rectPie, path, pathLight, borderColor, brush, start, start + angle, radius);
                }
                renderPieElementShadow(context, center, radius, brush, start, angle, currentSeries, distance) {
                    if (this.series.chart.isAnimation)
                        return;
                    let path;
                    let pathLight;
                    let rectPie = RectangleD.empty;
                    brush = this.correctBrush(brush);
                    let REFpath = { ref: path };
                    let REFpathLight = { ref: pathLight };
                    let REFrectPie = { ref: rectPie };
                    let clientRectangle = this.measurePieElementCore(context, center, radius, start, angle, currentSeries, distance, REFpath, REFpathLight, REFrectPie);
                    path = REFpath.ref;
                    pathLight = REFpathLight.ref;
                    rectPie = REFrectPie.ref;
                    if (clientRectangle.isEmpty)
                        return;
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(brush, path, rectPie, null);
                    if (pathLight != null) {
                        let brLight = new StiGradientBrush(Color.fromArgb(100, Color.white), Color.fromArgb(50, Color.black), 45);
                        context.fillPath(brLight, pathLight, rectPie, null);
                    }
                    context.popSmoothingMode();
                }
                measurePieElement(context, center, radius, start, angle, currentSeries, distance) {
                    let path;
                    let pathLight;
                    let rectPie = RectangleD.empty;
                    let REFpath = { ref: path };
                    let REFpathLight = { ref: pathLight };
                    let REFrectPie = { ref: rectPie };
                    let returnRect = this.measurePieElementCore(context, center, radius, start, angle, currentSeries, distance, REFpath, REFpathLight, REFrectPie);
                    path = REFpath.ref;
                    pathLight = REFpathLight.ref;
                    rectPie = REFrectPie.ref;
                    return returnRect;
                }
                measurePieElementCore(context, center, radius, start, angle, currentSeries, distance, REFpath, REFpathLight, REFrectPie) {
                    let path = [];
                    let pathLight = null;
                    let rectPie = RectangleD.empty;
                    if (angle == 0 || isNaN(angle))
                        return RectangleD.empty;
                    if (distance > 0)
                        center = this.getPoint(center, distance * context.options.zoom, start + angle / 2);
                    rectPie = new RectangleD(center.x - radius, center.y - radius, radius * 2, radius * 2);
                    if (rectPie.width <= 0 && rectPie.height <= 0)
                        return RectangleD.empty;
                    path.push(new StiPieSegmentGeom(new RectangleD(rectPie.x, rectPie.y, rectPie.width, rectPie.height), start, angle, null));
                    if (currentSeries.lighting && !Color.transparent.equals(currentSeries.borderColor)) {
                        let lightWidth = 0;
                        pathLight = [];
                        lightWidth = radius * 0.02;
                        pathLight.push(new StiArcSegmentGeom(rectPie, start, angle));
                        pathLight.push(new StiLineSegmentGeom(this.getPoint(center, radius - lightWidth, start + angle), this.getPoint(center, radius - lightWidth, start + angle)));
                        pathLight.push(new StiArcSegmentGeom(new RectangleD(rectPie.x + lightWidth, rectPie.y + lightWidth, rectPie.width - lightWidth * 2, rectPie.height - lightWidth * 2), start + angle, -angle));
                        pathLight.push(new StiLineSegmentGeom(this.getPoint(center, radius - lightWidth, start), this.getPoint(center, radius - lightWidth, start)));
                    }
                    REFpath.ref = path;
                    REFpathLight.ref = pathLight;
                    REFrectPie.ref = rectPie;
                    return context.getPathBounds(path);
                }
                checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries, isForValueFrom = false) {
                    let nonZeroValuesCountTemp = 0;
                    let firstNonZeroValueIndexTemp = 0;
                    let firstNonZeroValueIndexTemp1 = 0;
                    let firstNonZeroValue = 0;
                    let firstNonZeroSeriesTemp = null;
                    for (let ser of seriesArray) {
                        let values = isForValueFrom ? ser.valuesStart : ser.values;
                        for (let value of values) {
                            if (!(value == 0 || value == null || isNaN(value))) {
                                nonZeroValuesCountTemp++;
                                firstNonZeroValue = value;
                                firstNonZeroSeriesTemp = ser;
                                if (nonZeroValuesCountTemp == 1)
                                    firstNonZeroValueIndexTemp1 = firstNonZeroValueIndexTemp;
                            }
                            firstNonZeroValueIndexTemp++;
                        }
                    }
                    REFfirstNonZeroValueIndex.ref = firstNonZeroValueIndexTemp1;
                    REFnonZeroValuesCount.ref = nonZeroValuesCountTemp;
                    REFfirstNonZeroSeries.ref = firstNonZeroSeriesTemp;
                    return firstNonZeroValue;
                }
                isNotNullValues(seriesArray) {
                    for (let series of seriesArray) {
                        for (let value of series.values) {
                            if (value != null)
                                return true;
                        }
                    }
                    return false;
                }
                renderSeries(context, rect, geom, seriesArray) {
                    let radius = this.getRadius(context, rect);
                    let pointCenter = this.getPointCenter(rect);
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null || (seriesArray != null && !this.isNotNullValues(seriesArray))) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(new Chart.StiPieEmptySeriesElementGeom(new Rectangle(pointCenter.x - radius, pointCenter.y - radius, 2 * radius, 2 * radius)));
                        return;
                    }
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    let chart = this.series.chart;
                    let colorCount = this.getColorCount(seriesArray);
                    let REFnonZeroValuesCount = { ref: 0 };
                    this.checkNonZerovalue(seriesArray, REFnonZeroValuesCount, { ref: -1 }, { ref: null });
                    let nonZeroValuesCount = REFnonZeroValuesCount.ref;
                    let gradPerValue = this.getGradPerValue(seriesArray);
                    let percentPerValue = this.getPercentPerValue(seriesArray);
                    let currentSeries = seriesArray[0];
                    let seriesLabels = currentSeries.core.getPieSeriesLabels();
                    let angle = currentSeries.startAngle;
                    let bounds = new RectangleD(0, 0, rect.width, rect.height);
                    for (let ser of seriesArray) {
                        if (nonZeroValuesCount > 1) {
                            let pieSeries = ser;
                            let index = 0;
                            for (let value of ser.values) {
                                let arcWidth = (gradPerValue * Math.abs(value));
                                let measureRect = this.measurePieElement(context, pointCenter, radius, angle, arcWidth, pieSeries, this.getPieDistance(index));
                                if (value != 0)
                                    bounds = RectangleD.union(bounds, measureRect);
                                angle += arcWidth;
                                index++;
                            }
                        }
                    }
                    let maximumDeltaX = Math.max(-bounds.left, bounds.right - rect.width);
                    let maximumDeltaY = Math.max(-bounds.top, bounds.bottom - rect.height);
                    let maximumDelta = Math.max(maximumDeltaX, maximumDeltaY);
                    radius -= maximumDelta * 1.2;
                    let labelsRect = StiArray.create(RectangleD, colorCount);
                    let deltaY = StiArray.create(Number, colorCount);
                    let quarterCounts = StiArray.create(Number, 4);
                    StiArray.clear(quarterCounts, 0, quarterCounts.length);
                    angle = currentSeries.startAngle;
                    bounds = new RectangleD(10 * context.options.zoom, 10 * context.options.zoom, rect.width - 20 * context.options.zoom, rect.height - 20 * context.options.zoom);
                    let rectPie2 = bounds.clone();
                    let labelIndex = 0;
                    for (let ser of seriesArray) {
                        let pieSer = ser;
                        let index = 0;
                        for (let value of ser.values) {
                            let arcWidth = (gradPerValue * Math.abs(value));
                            let labels = pieSer.core.getPieSeriesLabels();
                            if (labels != null && labels.visible) {
                                let labelRadius = radius;
                                if (this.getPieDistance(index) > 0)
                                    labelRadius += pieSer.distance * context.options.zoom;
                                let currAngle = angle + arcWidth / 2;
                                let REFmeasureRect = { ref: null };
                                labels.core.renderLabel(pieSer, context, pointCenter, labelRadius, 0, currAngle, index, Math.abs(value), value, this.getArgumentText(ser, index), pieSer.core.getTag(index), true, index, colorCount, percentPerValue, REFmeasureRect, false, 0);
                                let measureRect = REFmeasureRect.ref;
                                if (!measureRect.isEmpty)
                                    bounds = RectangleD.union(bounds, measureRect);
                                if (value != 0 || labels.showZeros) {
                                    labelsRect[labelIndex] = measureRect;
                                    deltaY[labelIndex] = measureRect.y;
                                    if (currAngle >= 0 && currAngle <= 90)
                                        quarterCounts[0]++;
                                    if (currAngle > 90 && currAngle <= 180)
                                        quarterCounts[1]++;
                                    if (currAngle > 180 && currAngle <= 270)
                                        quarterCounts[2]++;
                                    if (currAngle > 270 && currAngle <= 360)
                                        quarterCounts[3]++;
                                }
                            }
                            angle += arcWidth;
                            index++;
                            if (value != 0 || this.series.chart.seriesLabels.showZeros)
                                labelIndex++;
                        }
                    }
                    if (currentSeries.diameter == 0) {
                        let dist = 0;
                        dist = Math.min(dist, bounds.left - rectPie2.left);
                        dist = Math.min(dist, rectPie2.right - bounds.right);
                        dist = Math.min(dist, bounds.top - rectPie2.top);
                        dist = Math.min(dist, rectPie2.bottom - bounds.bottom);
                        radius += dist;
                    }
                    labelIndex = 0;
                    for (let ser of seriesArray) {
                        let pieSer = ser;
                        let index = 0;
                        for (let value of ser.values) {
                            let arcWidth = (gradPerValue * value);
                            let labels = pieSer.core.getPieSeriesLabels();
                            if (labels != null && labels.visible) {
                                let labelRadius = radius;
                                if (this.getPieDistance(index) > 0)
                                    labelRadius += pieSer.distance * context.options.zoom;
                                let currAngle = angle + arcWidth / 2;
                                let REFmeasureRect = { ref: null };
                                labels.core.renderLabel(this.series, context, pointCenter, labelRadius, 0, currAngle, index, value, value, this.getArgumentText(ser, index), pieSer.core.getTag(index), true, index, colorCount, percentPerValue, REFmeasureRect, false, 0);
                                let measureRect = REFmeasureRect.ref;
                                if (value != 0 || labels.showZeros) {
                                    labelsRect[labelIndex] = measureRect;
                                    deltaY[labelIndex] = measureRect.y;
                                }
                            }
                            angle += arcWidth;
                            index++;
                            if (value != 0 || this.series.chart.seriesLabels.showZeros)
                                labelIndex++;
                        }
                    }
                    if (this.series.chart != null && this.series.chart.seriesLabels != null) {
                        let twoColumnsLabels = this.series.chart.seriesLabels.as(Chart.IStiTwoColumnsPieLabels);
                        if (twoColumnsLabels != null && twoColumnsLabels.preventIntersection) {
                            let calcedHeight = 0;
                            if (quarterCounts[0] > 0) {
                                let destinationArray = StiArray.create(RectangleD, quarterCounts[0], true);
                                StiArray.copy(labelsRect, 0, destinationArray, quarterCounts[0]);
                                if (this.isIntersectionLabels(destinationArray)) {
                                    calcedHeight = bounds.height / 2 / quarterCounts[0];
                                    labelsRect[0].y = bounds.y + bounds.height / 2 + calcedHeight / 2 - labelsRect[0].height / 2;
                                    for (let i = 1; i < quarterCounts[0]; i++) {
                                        labelsRect[i].y = labelsRect[i - 1].y + calcedHeight;
                                    }
                                }
                            }
                            let startIndex = quarterCounts[0];
                            if (quarterCounts[1] > 0) {
                                let destinationArray = StiArray.create(RectangleD, quarterCounts[1], true);
                                StiArray.copy(labelsRect, 0, destinationArray, quarterCounts[1]);
                                if (this.isIntersectionLabels(destinationArray)) {
                                    calcedHeight = bounds.height / 2 / quarterCounts[1];
                                    labelsRect[startIndex].y = bounds.y + bounds.height - calcedHeight / 2 - labelsRect[startIndex].height / 2;
                                    for (let i = startIndex + 1; i < startIndex + quarterCounts[1]; i++) {
                                        labelsRect[i].y = labelsRect[i - 1].y - calcedHeight;
                                    }
                                }
                            }
                            startIndex += quarterCounts[1];
                            if (quarterCounts[2] > 0) {
                                let destinationArray = StiArray.create(RectangleD, quarterCounts[2], true);
                                StiArray.copy(labelsRect, 0, destinationArray, quarterCounts[2]);
                                if (this.isIntersectionLabels(destinationArray)) {
                                    calcedHeight = bounds.height / 2 / quarterCounts[2];
                                    labelsRect[startIndex].y = bounds.y + bounds.height / 2 - calcedHeight / 2 - labelsRect[startIndex].height / 2;
                                    for (let i = startIndex + 1; i < startIndex + quarterCounts[2]; i++) {
                                        labelsRect[i].y = labelsRect[i - 1].y - calcedHeight;
                                    }
                                }
                            }
                            startIndex += quarterCounts[2];
                            if (quarterCounts[3] > 0) {
                                let destinationArray = StiArray.create(RectangleD, quarterCounts[3], true);
                                StiArray.copy(labelsRect, 0, destinationArray, quarterCounts[3]);
                                if (this.isIntersectionLabels(destinationArray)) {
                                    calcedHeight = bounds.height / 2 / quarterCounts[3];
                                    labelsRect[startIndex].y = bounds.y + calcedHeight / 2 - labelsRect[startIndex].height / 2;
                                    for (let i = startIndex + 1; i < startIndex + quarterCounts[3]; i++) {
                                        labelsRect[i].y = labelsRect[i - 1].y + calcedHeight;
                                    }
                                }
                            }
                            for (let i = 0; i < labelIndex; i++) {
                                deltaY[i] = labelsRect[i].y - deltaY[i];
                            }
                        }
                    }
                    if (radius <= 5)
                        return;
                    if (currentSeries.showShadow) {
                        angle = currentSeries.startAngle;
                        for (let ser of seriesArray) {
                            if (nonZeroValuesCount == 1) {
                                let rectPie = new RectangleD(pointCenter.x - radius, pointCenter.y - radius, radius * 2, radius * 2);
                                let shadowRect = new RectangleD(0, 0, radius * 2, radius * 2);
                                let shadowContext = context.createShadowGraphics();
                                if (shadowContext != null)
                                    shadowContext.fillEllipse2(Color.fromArgb(100, Color.black), shadowRect, null);
                                let shadowGeom = new Chart.StiPieSeriesShadowElementGeom(currentSeries, rectPie, radius * 0.01 + 2 * context.options.zoom, shadowContext, duration, beginTime);
                                geom.createChildGeoms();
                                geom.childGeoms.push(shadowGeom);
                                break;
                            }
                            else {
                                let pieSeries = ser;
                                let index = 0;
                                for (let value of ser.values) {
                                    let arcWidth = (gradPerValue * Math.abs(value));
                                    let shadowPointCenter = pointCenter;
                                    let shadowBrush = new StiSolidBrush(Color.fromArgb(100, Color.black));
                                    let shadowContext = context.createShadowGraphics();
                                    let shadowRect = rect.clone();
                                    shadowRect.x = 0;
                                    shadowRect.y = 0;
                                    if (chart.isAnimation) {
                                        shadowRect.x = pointCenter.x - radius;
                                        shadowRect.y = pointCenter.y - radius;
                                        shadowRect.height = radius * 2;
                                        shadowRect.width = radius * 2;
                                    }
                                    this.renderPieElementShadow(shadowContext, shadowPointCenter, radius, shadowBrush, angle, arcWidth, pieSeries, this.getPieDistance(index));
                                    let shadowGeom = new Chart.StiPieSeriesShadowElementGeom(currentSeries, shadowRect, radius * 0.01 + 2 * context.options.zoom, shadowContext, duration, beginTime);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                    angle += arcWidth;
                                    index++;
                                }
                            }
                        }
                    }
                    let listPieElementsGeom = this.getPieElementGeoms(context, geom, radius, rect, seriesArray);
                    if (listPieElementsGeom.length < 1) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(new Chart.StiPieEmptySeriesElementGeom(new RectangleD(pointCenter.x - radius, pointCenter.y - radius, 2 * radius, 2 * radius)));
                        return;
                    }
                    for (let indexGeom = 0; indexGeom < listPieElementsGeom.length; indexGeom++) {
                        let elementGeom = listPieElementsGeom[indexGeom];
                        if (elementGeom.is(Chart.StiPieSeriesFullElementGeom)) {
                            if (elementGeom.series.core.interaction != null)
                                elementGeom.interaction = new StiSeriesInteractionData(geom.area, elementGeom.series, elementGeom.index);
                            geom.createChildGeoms();
                            geom.childGeoms.push(elementGeom);
                        }
                        else if (elementGeom.is(Chart.StiPieSeriesElementGeom)) {
                            elementGeom.count = listPieElementsGeom.length;
                            if (elementGeom.series.core.interaction != null)
                                elementGeom.interaction = new StiSeriesInteractionData(geom.area, elementGeom.series, elementGeom.index);
                            geom.createChildGeoms();
                            geom.childGeoms.push(elementGeom);
                        }
                    }
                    angle = currentSeries.startAngle;
                    let listPieLabelsGeom = this.getPieLabelGeoms(context, radius, rect, seriesArray, deltaY);
                    if (this.series.chart.isAnimationChangingValues && seriesLabels != null && seriesLabels.valueType == Chart.StiSeriesLabelsValueType.Value) {
                        let labelRadius = radius / 1.75;
                        let labelClientRect = new RectangleD();
                        labelClientRect.x = pointCenter.x - labelRadius;
                        labelClientRect.y = pointCenter.y - labelRadius;
                        labelClientRect.width = 2 * labelRadius;
                        labelClientRect.height = 2 * labelRadius;
                        for (let indexGeom = 0; indexGeom < listPieElementsGeom.length; indexGeom++) {
                            let cellGeom = listPieLabelsGeom.length > indexGeom
                                ? listPieLabelsGeom[indexGeom]
                                : null;
                            if (cellGeom != null) {
                                geom.createChildGeoms();
                                geom.childGeoms.push(cellGeom);
                            }
                        }
                    }
                    else {
                        for (let labelGeom of listPieLabelsGeom) {
                            if (this.series.chart.isAnimationChangingValues && labelGeom.is(Chart.StiCenterPieLabelsGeom))
                                labelGeom.animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalBeginTimeElement);
                            geom.createChildGeoms();
                            geom.childGeoms.push(labelGeom);
                        }
                    }
                    let seriesLabel = this.getPieSeriesLabels();
                    if (seriesLabel != null && seriesLabel.preventIntersection) {
                        if (seriesLabel.is(Chart.IStiTwoColumnsPieLabels))
                            this.checkIntersectionTwoColumnsLabels(geom, rectPie2);
                        else if (seriesLabel.is(Chart.IStiOutsidePieLabels))
                            this.checkIntersectionOutLabels(geom);
                        else
                            this.checkIntersectionLabels(geom);
                    }
                }
                getColorCount(seriesArray, isForValueFrom = false) {
                    let colorCount = 0;
                    for (let ser of seriesArray) {
                        if (isForValueFrom && ser.valuesStart != null)
                            colorCount += ser.valuesStart.length;
                        if (!isForValueFrom && ser.values != null)
                            colorCount += ser.values.length;
                    }
                    return colorCount;
                }
                isIntersectionLabels(labels) {
                    for (let index = 0; index < labels.length; index++) {
                        for (let indexSecond = 0; indexSecond < labels.length; indexSecond++) {
                            if (index == indexSecond)
                                continue;
                            if (labels[index].intersectsWith(labels[indexSecond])) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                getPieLabelGeoms(context, radius, rect, seriesArray, deltaY, isForValueFrom = false) {
                    let resault = [];
                    let colorIndex = 0;
                    let labelIndex = 0;
                    let currentSeries = seriesArray[0];
                    let gradPerValue = this.getGradPerValue(seriesArray, isForValueFrom);
                    let percentPerValue = this.getPercentPerValue(seriesArray, isForValueFrom);
                    let pointCenter = this.getPointCenter(rect);
                    let angle = currentSeries.startAngle;
                    let colorCount = this.getColorCount(seriesArray, isForValueFrom);
                    for (let ser of seriesArray) {
                        let pieSeries = ser;
                        let index = 0;
                        let values = isForValueFrom ? ser.valuesStart : ser.values;
                        for (let value of values) {
                            let arcWidth = gradPerValue * Math.abs(value);
                            let seriesLabels = pieSeries.core.getPieSeriesLabels();
                            if (seriesLabels != null && seriesLabels.visible) {
                                let labels = seriesLabels;
                                let twoColumnsLabels = seriesLabels;
                                if (labels != null) {
                                    let labelRadius = radius;
                                    if (this.getPieDistance2(pieSeries, index) > 0)
                                        labelRadius += pieSeries.distance * context.options.zoom;
                                    let currAngle = angle + arcWidth / 2;
                                    let currDeltaY = 0;
                                    if (twoColumnsLabels != null && twoColumnsLabels.preventIntersection)
                                        currDeltaY += deltaY[labelIndex];
                                    if (labels.step == 0 || (index % labels.step == 0)) {
                                        let REFmeasureRect = { ref: null };
                                        let seriesLabelsGeom = labels.core.renderLabel(pieSeries, context, pointCenter, labelRadius, 0, currAngle, index, Math.abs(value), value, this.getArgumentText(ser, index), pieSeries.core.getTag(index), false, colorIndex, colorCount, percentPerValue, REFmeasureRect, false, currDeltaY);
                                        if (seriesLabelsGeom != null) {
                                            resault.push(seriesLabelsGeom);
                                        }
                                        if (labels.is(Chart.IStiOutsidePieLabels) && labels.showValue) {
                                            seriesLabelsGeom =
                                                labels.core.renderLabel(pieSeries, context, pointCenter, labelRadius, 0, currAngle, index, Math.abs(value), value, this.getArgumentText(ser, index), pieSeries.core.getTag(index), false, colorIndex, colorCount, percentPerValue, REFmeasureRect, true, 0);
                                            if (seriesLabelsGeom != null) {
                                                resault.push(seriesLabelsGeom);
                                            }
                                        }
                                    }
                                }
                            }
                            colorIndex++;
                            angle += arcWidth;
                            index++;
                            if (value != 0 || (seriesLabels != null && seriesLabels.showZeros))
                                labelIndex++;
                        }
                    }
                    return resault;
                }
                getPieSeriesLabels() {
                    var _a, _b;
                    if (this.series.showSeriesLabels == Chart.StiShowSeriesLabels.FromChart)
                        return (_a = this.series.chart.seriesLabels) === null || _a === void 0 ? void 0 : _a.as(Chart.IStiPieSeriesLabels);
                    if (this.series.showSeriesLabels == Chart.StiShowSeriesLabels.FromSeries)
                        return (_b = this.series.seriesLabels) === null || _b === void 0 ? void 0 : _b.as(Chart.IStiPieSeriesLabels);
                    return null;
                }
                getPieElementGeoms(context, geom, radius, rect, seriesArray, isForValueFrom = false) {
                    let resaultList = [];
                    let currentSeries = seriesArray[0];
                    let gradPerValue = this.getGradPerValue(seriesArray, isForValueFrom);
                    let pointCenter = this.getPointCenter(rect);
                    let angle = currentSeries.startAngle;
                    let colorCount = this.getColorCount(seriesArray, isForValueFrom);
                    let REFnonZeroValuesCount = { ref: 0 };
                    let REFfirstNonZeroValueIndex = { ref: -1 };
                    let REFfirstNonZeroSeries = { ref: Chart.IStiSeries = null };
                    this.checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries, isForValueFrom);
                    let nonZeroValuesCount = REFnonZeroValuesCount.ref;
                    let colorIndex = 0;
                    for (let ser of seriesArray) {
                        if (nonZeroValuesCount == 0) {
                            break;
                        }
                        else {
                            let values = isForValueFrom ? ser.valuesStart : ser.values;
                            for (let index = 0; index < values.length; index++) {
                                let value = values[index];
                                if (value != 0) {
                                    let arcWidth = gradPerValue * Math.abs(value);
                                    let seriesBrush = ser.brush;
                                    if (ser.allowApplyBrush) {
                                        seriesBrush = ser.core.getSeriesBrush(colorIndex, colorCount);
                                        seriesBrush = ser.processSeriesBrushes(index, seriesBrush);
                                    }
                                    let borderColor = ser.borderColor;
                                    if (ser.allowApplyBorderColor)
                                        borderColor = ser.core.getSeriesBorderColor(colorIndex, colorCount);
                                    let ticks = ser.values.length == 0 ? 0 : Chart.StiChartHelper.globalBeginTimeElement.ticks / ser.values.length * index;
                                    let beginTime = new TimeSpan(ticks);
                                    let pieElementGeom = this.renderPieElement(context, pointCenter, radius, borderColor, seriesBrush, angle, arcWidth, Math.abs(value), index, ser, this.getPieDistance2(ser, index), geom, beginTime);
                                    if (pieElementGeom != null) {
                                        resaultList.push(pieElementGeom);
                                    }
                                    angle += arcWidth;
                                }
                                colorIndex++;
                            }
                        }
                    }
                    return resaultList;
                }
                checkIntersectionOutLabels(geom) {
                    let childGeoms = geom.childGeoms;
                    let labelGeoms = [];
                    if (childGeoms != null) {
                        for (let cellGeom of childGeoms) {
                            if (cellGeom.is(Chart.StiOutsidePieLabelsGeom))
                                labelGeoms.push(cellGeom);
                        }
                    }
                    let count = labelGeoms.length;
                    let intersection = true;
                    let indexCheck = 0;
                    while (intersection && indexCheck < 29) {
                        indexCheck++;
                        for (let index1 = 0; index1 < count; index1++) {
                            for (let index2 = 0; index2 < count; index2++) {
                                if (index2 == index1)
                                    continue;
                                if (labelGeoms[index1].labelRect.intersectsWith(labelGeoms[index2].labelRect)) {
                                    let rect1 = labelGeoms[index1].labelRect;
                                    let rect2 = labelGeoms[index2].labelRect;
                                    if (rect1.intersectsWith(rect2)) {
                                        let overlay = rect1.height - Math.abs(labelGeoms[index2].labelRect.y - labelGeoms[index1].labelRect.y) + 2;
                                        if (rect1.y > rect2.y) {
                                            rect1.y += overlay / 2;
                                            rect2.y -= overlay / 2;
                                        }
                                        else {
                                            rect1.y -= overlay / 2;
                                            rect2.y += overlay / 2;
                                        }
                                        if (rect1.y < 0)
                                            rect1.y = 0;
                                        if (rect2.y < 0)
                                            rect2.y = 0;
                                        if ((rect1.y + rect1.height) > geom.clientRectangle.height)
                                            rect1.y = geom.clientRectangle.height - rect1.height;
                                        if ((rect2.y + overlay / 2 + rect2.height) > geom.clientRectangle.height)
                                            rect2.y = geom.clientRectangle.height - rect2.height;
                                        labelGeoms[index1].labelRect = rect1;
                                        labelGeoms[index2].labelRect = rect2;
                                    }
                                }
                            }
                        }
                    }
                }
                checkIntersectionTwoColumnsLabels(geom, rect) {
                    let childGeoms = geom.childGeoms;
                    if (childGeoms == null)
                        return;
                    let centerPoint = this.getPointCenter(rect);
                    let labelLeftGeoms = [];
                    let labelRightGeoms = [];
                    for (let cellGeom of childGeoms) {
                        if (cellGeom.is(Chart.StiTwoColumnsPieLabelsGeom)) {
                            if (cellGeom.clientRectangle.x < centerPoint.x) {
                                labelLeftGeoms.push(cellGeom);
                            }
                            else {
                                labelRightGeoms.push(cellGeom);
                            }
                        }
                    }
                    if (this.isIntersectionLabels(labelLeftGeoms.map(x => x.clientRectangle)))
                        this.checkLabelPosition(labelLeftGeoms, rect);
                    if (this.isIntersectionLabels(labelRightGeoms.map(x => x.clientRectangle)))
                        this.checkLabelPosition(labelRightGeoms, rect);
                }
                checkIntersectionLabels(geom) {
                    let childGeoms = geom.childGeoms;
                    let labelGeoms = [];
                    if (childGeoms != null) {
                        for (let cellGeom of childGeoms) {
                            if (cellGeom.is(Chart.StiCenterPieLabelsGeom))
                                labelGeoms.push(cellGeom);
                        }
                    }
                    let count = labelGeoms.length;
                    let intersection = true;
                    let indexCheck = 0;
                    while (intersection && indexCheck < 29) {
                        indexCheck++;
                        for (let index1 = 0; index1 < count; index1++) {
                            for (let index2 = 0; index2 < count; index2++) {
                                if (index2 == index1)
                                    continue;
                                if (labelGeoms[index1].clientRectangle.intersectsWith(labelGeoms[index2].clientRectangle)) {
                                    let rect1 = labelGeoms[index1].labelRect;
                                    let rect2 = labelGeoms[index2].labelRect;
                                    if (rect1.intersectsWith(rect2)) {
                                        let overlay = rect1.height - Math.abs(labelGeoms[index2].clientRectangle.y - labelGeoms[index1].clientRectangle.y) + 2;
                                        if (rect1.y > rect2.y) {
                                            rect1.y += overlay / 2;
                                            rect2.y -= overlay / 2;
                                        }
                                        else {
                                            rect1.y -= overlay / 2;
                                            rect2.y += overlay / 2;
                                        }
                                        if (rect1.y < 0)
                                            rect1.y = 0;
                                        if (rect2.y < 0)
                                            rect2.y = 0;
                                        if ((rect1.y + rect1.height) > geom.clientRectangle.height)
                                            rect1.y = geom.clientRectangle.height - rect1.height;
                                        if ((rect2.y + overlay / 2 + rect2.height) > geom.clientRectangle.height)
                                            rect2.y = geom.clientRectangle.height - rect2.height;
                                        labelGeoms[index1].labelRect = rect1;
                                        labelGeoms[index2].labelRect = rect2;
                                    }
                                }
                            }
                        }
                    }
                }
                checkLabelPosition(labels, rect) {
                    let freeHeight = rect.height;
                    labels = labels.stimulsoft().toList().orderBy(x => x.clientRectangle.y);
                    for (let label of labels) {
                        freeHeight -= label.clientRectangle.height;
                    }
                    let stepFreeHeight = freeHeight / (labels.length + 1);
                    let y0 = rect.y;
                    for (let label of labels) {
                        label.clientRectangle = new RectangleD(label.clientRectangle.x, y0 + stepFreeHeight, label.clientRectangle.width, label.clientRectangle.height);
                        label.endPoint = new PointD(label.endPoint.x, label.clientRectangle.y + label.clientRectangle.height / 2);
                        y0 = label.clientRectangle.y + label.clientRectangle.height;
                    }
                }
                getGradPerValue(series, isForValueFrom = false) {
                    let totals = 0;
                    let count = 0;
                    for (let sr of series) {
                        let values = isForValueFrom ? sr.valuesStart : sr.values;
                        for (let value of values) {
                            totals += Math.abs(value);
                            count++;
                        }
                    }
                    if (count == 0)
                        count = 1;
                    if (totals > 0)
                        return (360 / totals);
                    else
                        return 360 / count;
                }
                getPercentPerValue(series, isForValueFrom = false) {
                    let totals = 0;
                    for (let sr of series) {
                        let values = isForValueFrom ? sr.valuesStart : sr.values;
                        for (let value of values) {
                            totals += Math.abs(value);
                        }
                    }
                    return (1 / totals * 100);
                }
                getPointCenter(rect) {
                    return new PointD(rect.width / 2, rect.height / 2);
                }
                getRadius(context, rect) {
                    let pieSeries = this.series;
                    if (pieSeries.diameter > 0)
                        return pieSeries.diameter / 2 * context.options.zoom;
                    return Math.min(rect.width / 2, rect.height / 2) * 0.95;
                }
                getPoint(centerPie, radius, angle) {
                    let angleRad = (Math.PI * angle / 180);
                    return new PointD(centerPie.x + Math.cos(angleRad) * radius, centerPie.y + Math.sin(angleRad) * radius);
                }
                getArgumentText(series, index) {
                    let seriesArgumentsKeys = series.arguments.stimulsoft().getKeys();
                    if (series.arguments.length > index && series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys) != null) {
                        return series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                getPieDistance(pieIndex) {
                    return this.getPieDistance2(this.series, pieIndex);
                }
                getPieDistance2(series, pieIndex) {
                    if (series.distance == 0)
                        return 0;
                    if (series.cutPieListValues.length == 0)
                        return series.distance;
                    for (let index of series.cutPieListValues) {
                        if (index == pieIndex + 1)
                            return series.distance;
                    }
                    return 0;
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return this.series.brush;
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return this.series.borderColor;
                    return color;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Pie");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiPieSeriesCoreXF = StiPieSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiDoughnutSeriesCoreXF extends Chart.StiPieSeriesCoreXF {
                renderDoughnutElement(context, center, radius, radiusDt, borderColor, brush, start, angle, value, index, currentSeries, shadow, areaGeom, beginTime) {
                    if (radiusDt < 0)
                        radiusDt = 1;
                    if (angle == 0 || isNaN(angle))
                        return null;
                    let rectPie = new RectangleD(center.x - radius, center.y - radius, radius * 2, radius * 2);
                    let rectPieDt = new RectangleD(center.x - radiusDt, center.y - radiusDt, radiusDt * 2, radiusDt * 2);
                    if (rectPie.width <= 0 && rectPie.height <= 0)
                        return null;
                    if (!shadow) {
                        if (brush.is(StiGradientBrush)) {
                            brush = brush.clone();
                            brush.angle = -45;
                        }
                        if (brush.is(StiGlareBrush)) {
                            brush = brush.clone();
                            brush.angle = -45;
                        }
                    }
                    let path = [];
                    let brLight = null;
                    let brDark = null;
                    let pathLight = null;
                    let pathDark = null;
                    let lightWidth = 0;
                    if (currentSeries.lighting && (!shadow)) {
                        pathLight = [];
                        pathDark = [];
                        lightWidth = radius * 0.02;
                        brLight = new StiGradientBrush(Color.fromArgb(100, Color.white), Color.fromArgb(50, Color.black), 45);
                        brDark = new StiGradientBrush(Color.fromArgb(50, Color.black), Color.fromArgb(100, Color.white), 45);
                    }
                    let chart = this.series.chart;
                    path.push(new StiArcSegmentGeom(rectPie, start, angle));
                    if (angle - start != 360)
                        path.push(new StiLineSegmentGeom(this.getPoint(center, radius, start + angle), this.getPoint(center, radiusDt, start + angle)));
                    path.push(new StiArcSegmentGeom(rectPieDt, start + angle, -angle));
                    if (angle - start != 360)
                        path.push(new StiLineSegmentGeom(this.getPoint(center, radiusDt, start), this.getPoint(center, radius, start)));
                    if (shadow) {
                        if (chart.isAnimation) {
                            let animation = new StiOpacityAnimation(TimeSpan.fromSeconds(1), beginTime);
                            context.fillDrawAnimationPath(brush, null, path, rectPie, null, animation, null);
                        }
                        else
                            context.fillPath(brush, path, rectPie, null);
                    }
                    if (brLight != null && (!shadow)) {
                        pathLight.push(new StiLineSegmentGeom(this.getPoint(center, radius - lightWidth, start), this.getPoint(center, radius, start)));
                        pathLight.push(new StiArcSegmentGeom(rectPie, start, angle));
                        pathLight.push(new StiLineSegmentGeom(this.getPoint(center, radius, start + angle), this.getPoint(center, radius - lightWidth, start + angle)));
                        pathLight.push(new StiArcSegmentGeom(new RectangleD(rectPie.x + lightWidth, rectPie.y + lightWidth, rectPie.width - lightWidth * 2, rectPie.height - lightWidth * 2), start + angle, -angle));
                        pathDark.push(new StiLineSegmentGeom(this.getPoint(center, radiusDt + lightWidth, start), this.getPoint(center, radiusDt, start)));
                        pathDark.push(new StiArcSegmentGeom(rectPieDt, start, angle));
                        pathDark.push(new StiLineSegmentGeom(this.getPoint(center, radiusDt, start + angle), this.getPoint(center, radiusDt + lightWidth, start + angle)));
                        pathDark.push(new StiArcSegmentGeom(new RectangleD(rectPieDt.x - lightWidth, rectPieDt.y - lightWidth, rectPieDt.width + lightWidth * 2, rectPieDt.height + lightWidth * 2), start + angle, -angle));
                    }
                    if (!shadow) {
                        let seriesGeom = new Chart.StiDoughnutSeriesElementGeom(areaGeom, value, index, currentSeries, rectPie, rectPieDt, path, pathLight, pathDark, borderColor, brush, brLight, brDark, start, start + angle, radius, radiusDt, beginTime);
                        return seriesGeom;
                    }
                    return null;
                }
                isNotNullValues(seriesArray) {
                    for (let series of seriesArray) {
                        for (let value of series.values) {
                            if (value != null)
                                return true;
                        }
                    }
                    return false;
                }
                renderSeries(context, rect, geom, seriesArray) {
                    let radius = this.getRadius(context, rect);
                    let pointCenter = this.getPointCenter(rect);
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null || (seriesArray != null && !this.isNotNullValues(seriesArray))) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(new Chart.StiDoughnutEmptySeriesElementGeom(new Rectangle(pointCenter.x - radius, pointCenter.y - radius, 2 * radius, 2 * radius)));
                        return;
                    }
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    let step = radius / (seriesArray.length + 1);
                    let sumStep = step;
                    let colorCount = 0;
                    for (let ser of seriesArray) {
                        if (ser.values != null)
                            colorCount += ser.values.length;
                        sumStep += ser.width != 0 ? ser.width : step;
                    }
                    if (sumStep < radius)
                        radius = sumStep;
                    if (colorCount == 0)
                        return;
                    let currentSeries = seriesArray[0];
                    let colorIndex = 0;
                    let bounds = new RectangleD(10 * context.options.zoom, 10 * context.options.zoom, rect.width - 20 * context.options.zoom, rect.height - 20 * context.options.zoom);
                    let rectPie2 = bounds.clone();
                    let angle = 0;
                    let radiusDt = radius;
                    for (let ser of seriesArray) {
                        let index = 0;
                        angle = ser.startAngle;
                        let gradPerValue = this.getGradPerValue([ser]);
                        for (let value of ser.values) {
                            let percentPerValue = this.getPercentPerValue([ser]);
                            let arcWidth = (gradPerValue * Math.abs(value));
                            let seriesLabels = null;
                            if (ser.showSeriesLabels == Chart.StiShowSeriesLabels.FromChart)
                                seriesLabels = this.series.chart.seriesLabels;
                            if (ser.showSeriesLabels == Chart.StiShowSeriesLabels.FromSeries)
                                seriesLabels = currentSeries.seriesLabels;
                            if (this.series.chart != null && seriesLabels != null && seriesLabels.visible) {
                                let labels = seriesLabels.stimulsoft().as(Chart.IStiPieSeriesLabels);
                                if (labels != null && labels.visible) {
                                    let radiusDt2 = ser.width != 0 ? radiusDt - ser.width : radiusDt - step;
                                    let measureRect;
                                    let REFmeasureRect = { ref: measureRect };
                                    labels.core.renderLabel(ser, context, pointCenter, radiusDt, radiusDt2, angle + arcWidth / 2, index, Math.abs(value), value, this.getArgumentText(ser, index), currentSeries.core.getTag(index), true, colorIndex, colorCount, percentPerValue, REFmeasureRect, false, 0);
                                    measureRect = REFmeasureRect.ref;
                                    if (!measureRect.isEmpty)
                                        bounds = RectangleD.union(bounds, measureRect);
                                }
                            }
                            colorIndex++;
                            angle += arcWidth;
                            index++;
                        }
                        radiusDt -= ser.width != 0 ? ser.width + step * 0.2 : step * 1.2;
                    }
                    let dist = 0;
                    dist = Math.min(dist, bounds.left - rectPie2.left);
                    dist = Math.min(dist, rectPie2.right - bounds.right);
                    dist = Math.min(dist, bounds.top - rectPie2.top);
                    dist = Math.min(dist, rectPie2.bottom - bounds.bottom);
                    radius += dist;
                    let chart = this.series.chart;
                    if (currentSeries.showShadow && !chart.isAnimation) {
                        let rectPie = new RectangleD(pointCenter.x - radius, pointCenter.y - radius, radius * 2, radius * 2);
                        let shadowContext = context.createShadowGraphics();
                        let shadowBrush = new StiSolidBrush(Color.fromArgb(100, Color.black));
                        step = radius / (seriesArray.length + 1);
                        radiusDt = radius;
                        for (let ser of seriesArray) {
                            angle = ser.startAngle;
                            let gradPerValue = this.getGradPerValue([ser]);
                            let index = 0;
                            for (let value of ser.values) {
                                let arcWidth = (gradPerValue * Math.abs(value));
                                let radiusDt2 = ser.width != 0 ? radiusDt - ser.width : radiusDt - step;
                                this.renderDoughnutElement(shadowContext, new PointD(rectPie.width / 2, rectPie.height / 2), radiusDt, radiusDt2, Color.black, shadowBrush, angle, arcWidth, Math.abs(value), index, ser, true, geom, new TimeSpan(beginTime.ticks));
                                angle += arcWidth;
                                index++;
                            }
                            radiusDt -= ser.width != 0 ? ser.width + step * 0.2 : step * 1.2;
                        }
                        let shadowGeom = new Chart.StiPieSeriesShadowElementGeom(currentSeries, rectPie, (radius * 0.01 + 2 * context.options.zoom), shadowContext, duration, beginTime);
                        geom.createChildGeoms();
                        geom.childGeoms.push(shadowGeom);
                    }
                    step = radius / (seriesArray.length + 1);
                    colorIndex = 0;
                    radiusDt = radius;
                    for (let ser of seriesArray) {
                        let colorIndexCondition = 0;
                        if (!ser.chart.area.colorEach)
                            colorIndex = 0;
                        angle = ser.startAngle;
                        let gradPerValue = this.getGradPerValue([ser]);
                        let REFnonZeroValuesCount = { ref: null };
                        let REFfirstNonZeroValueIndex = { ref: null };
                        let REFfirstNonZeroSeries = { ref: null };
                        this.checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries);
                        let nonZeroValuesCount = REFnonZeroValuesCount.ref;
                        let firstNonZeroValueIndex = REFfirstNonZeroValueIndex.ref;
                        if (nonZeroValuesCount == 0) {
                        }
                        else if (nonZeroValuesCount == 1) {
                            let seriesBrush = ser.brush;
                            if (ser.allowApplyStyle) {
                                seriesBrush = ser.core.getSeriesBrush(firstNonZeroValueIndex, colorCount);
                                seriesBrush = ser.processSeriesBrushes(firstNonZeroValueIndex, seriesBrush);
                            }
                            let borderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                            if (firstNonZeroValueIndex >= ser.values.length)
                                continue;
                            let radiusDt2 = ser.width != 0 ? radiusDt - ser.width : radiusDt - step;
                            let doughnutElementGeom = this.renderDoughnutElement(context, pointCenter, radiusDt, radiusDt2, borderColor, seriesBrush, 0, 360, ser.values[firstNonZeroValueIndex], firstNonZeroValueIndex, ser, false, geom, new TimeSpan(beginTime.ticks));
                            if (doughnutElementGeom != null) {
                                if (ser.core.interaction != null) {
                                    doughnutElementGeom.interaction = new StiSeriesInteractionData();
                                    doughnutElementGeom.interaction.fill(geom.area, ser, 0);
                                }
                                geom.createChildGeoms();
                                geom.childGeoms.push(doughnutElementGeom);
                            }
                            radiusDt -= step * 1.2;
                            colorIndexCondition++;
                            colorIndex++;
                            continue;
                        }
                        else {
                            let currentIndex = 0;
                            for (let value of ser.values) {
                                let arcWidth = (gradPerValue * Math.abs(value));
                                if (value != 0) {
                                    let seriesBrush = ser.brush;
                                    if (ser.allowApplyStyle) {
                                        seriesBrush = ser.core.getSeriesBrush(colorIndex, colorCount);
                                        seriesBrush = ser.processSeriesBrushes(colorIndexCondition, seriesBrush);
                                    }
                                    let borderColor = ser.borderColor;
                                    if (ser.allowApplyBorderColor) {
                                        borderColor = ser.core.getSeriesBorderColor(colorIndex, colorCount);
                                    }
                                    let radiusDt2 = ser.width != 0 ? radiusDt - ser.width : radiusDt - step;
                                    let doughnutElementGeom = this.renderDoughnutElement(context, pointCenter, radiusDt, radiusDt2, borderColor, seriesBrush, angle, arcWidth, Math.abs(value), currentIndex, ser, false, geom, new TimeSpan(beginTime.ticks / ser.values.length * colorIndex));
                                    if (doughnutElementGeom != null) {
                                        if (ser.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(geom.area, ser, currentIndex);
                                            doughnutElementGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(doughnutElementGeom);
                                    }
                                    angle += arcWidth;
                                }
                                colorIndexCondition++;
                                colorIndex++;
                                currentIndex++;
                            }
                        }
                        radiusDt -= ser.width != 0 ? ser.width + step * 0.2 : step * 1.2;
                    }
                    colorIndex = 0;
                    radiusDt = radius;
                    for (let ser of seriesArray) {
                        let index = 0;
                        angle = ser.startAngle;
                        let gradPerValue = this.getGradPerValue([ser]);
                        for (let value of ser.values) {
                            let percentPerValue = this.getPercentPerValue([ser]);
                            let arcWidth = (gradPerValue * Math.abs(value));
                            let seriesLabels = null;
                            if (ser.showSeriesLabels == Chart.StiShowSeriesLabels.FromChart)
                                seriesLabels = this.series.chart.seriesLabels;
                            if (ser.showSeriesLabels == Chart.StiShowSeriesLabels.FromSeries)
                                seriesLabels = currentSeries.seriesLabels;
                            if (this.series.chart != null && seriesLabels != null && seriesLabels.visible) {
                                let labels = seriesLabels.stimulsoft().as(Chart.IStiPieSeriesLabels);
                                if (labels != null && labels.visible && (labels.step == 0 || (index % labels.step == 0))) {
                                    let measureRect;
                                    let radiusDt2 = ser.width != 0 ? radiusDt - ser.width : radiusDt - step;
                                    let REFmeasureRect = { ref: measureRect };
                                    let seriesLabelsGeom = labels.core.renderLabel(ser, context, pointCenter, radiusDt, radiusDt2, angle + arcWidth / 2, index, Math.abs(value), value, this.getArgumentText(ser, index), this.getTag(index), false, colorIndex, colorCount, percentPerValue, REFmeasureRect, false, 0);
                                    measureRect = REFmeasureRect.ref;
                                    if (seriesLabelsGeom != null) {
                                        seriesLabelsGeom.duration = duration;
                                        seriesLabelsGeom.beginTime = new TimeSpan(beginTime.ticks / ser.values.length * colorIndex);
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(seriesLabelsGeom);
                                    }
                                }
                            }
                            colorIndex++;
                            angle += arcWidth;
                            index++;
                        }
                        radiusDt -= ser.width != 0 ? ser.width + step * 0.2 : step * 1.2;
                    }
                }
                checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries, isForValueFrom = false) {
                    let nonZeroValuesCountTemp = 0;
                    let firstNonZeroValueIndexTemp = 0;
                    let firstNonZeroValueIndexTemp1 = 0;
                    let firstNonZeroValue = 0;
                    let firstNonZeroSeriesTemp = null;
                    for (let ser of seriesArray) {
                        let values = isForValueFrom ? ser.valuesStart : ser.values;
                        for (let value of values) {
                            if (!(value == 0 || value == null || isNaN(value))) {
                                nonZeroValuesCountTemp++;
                                firstNonZeroValue = value;
                                firstNonZeroSeriesTemp = ser;
                                if (nonZeroValuesCountTemp == 1)
                                    firstNonZeroValueIndexTemp1 = firstNonZeroValueIndexTemp;
                            }
                            firstNonZeroValueIndexTemp++;
                        }
                    }
                    REFnonZeroValuesCount.ref = nonZeroValuesCountTemp;
                    REFfirstNonZeroValueIndex.ref = firstNonZeroValueIndexTemp1;
                    REFfirstNonZeroSeries.ref = firstNonZeroSeriesTemp;
                    return firstNonZeroValue;
                }
                getGradPerValue(series) {
                    let totals = 0;
                    for (let value of series[0].values) {
                        totals += Math.abs(value);
                    }
                    return (360 / totals);
                }
                getPercentPerValue(series) {
                    let totals = 0;
                    for (let value of series[0].values) {
                        totals += Math.abs(value);
                    }
                    return (1 / totals * 100);
                }
                getArgumentText(series, index) {
                    if (series.arguments.length > index) {
                        return series.arguments[index].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Doughnut");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiDoughnutSeriesCoreXF = StiDoughnutSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiCandlestickSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        let brush = style.core.getColumnBrush(color);
                        this.series.brush = brush;
                        let borderColor = style.core.getColumnBorder(color);
                        if (Color.transparent.equals(borderColor)) {
                            borderColor = StiBrush.toColor(brush);
                        }
                        this.series.borderColor = borderColor;
                    }
                }
                renderSeries(context, rect, geom, series) {
                    var _a, _b;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let candlestickArea = geom.area;
                    let posY = candlestickArea.axisCore.getDividerY();
                    let time = Chart.StiChartHelper.globalBeginTimeElement;
                    for (let currentSeries of series) {
                        let values = currentSeries.valuesOpen;
                        let valuesEnd = currentSeries.valuesClose;
                        let valuesHigh = currentSeries.valuesHigh;
                        let valuesLow = currentSeries.valuesLow;
                        let valueCount = Math.min(Math.min(values.length, valuesEnd.length), Math.min(valuesHigh.length, valuesLow.length));
                        let argumentCount = currentSeries.arguments.length;
                        let count = Math.min(valueCount, argumentCount);
                        let currentSeriesArgumentsKeys = currentSeries.arguments.stimulsoft().getKeys();
                        for (let index = 0; index < count; index++) {
                            let value = values[index];
                            let valueEnd = valuesEnd[index];
                            let valueHigh = valuesHigh[index];
                            let valueLow = valuesLow[index];
                            if (value == null || valueEnd == null || valueHigh == null || valueLow == null)
                                continue;
                            let argumentIndex = 0;
                            for (let line of candlestickArea.xAxis.info.stripLines.list) {
                                if (((_a = currentSeries.arguments.stimulsoft().getByIndex(index, currentSeriesArgumentsKeys)) === null || _a === void 0 ? void 0 : _a.toString()) == ((_b = line.valueObject) === null || _b === void 0 ? void 0 : _b.toString()))
                                    break;
                                argumentIndex++;
                            }
                            let singleX = candlestickArea.xAxis.info.dpi;
                            let candlestickBrush = new StiSolidBrush();
                            let candlestickBorderColor;
                            if (value > valueEnd) {
                                candlestickBrush = currentSeries.brush;
                                candlestickBorderColor = currentSeries.borderColor;
                                if (valueHigh < value)
                                    valueHigh = value;
                                if (valueEnd < valueLow)
                                    valueLow = valueEnd;
                            }
                            else {
                                candlestickBrush = currentSeries.brushNegative;
                                candlestickBorderColor = currentSeries.borderColorNegative;
                                if (valueLow > value)
                                    valueLow = value;
                                if (valueEnd > valueHigh)
                                    valueHigh = valueEnd;
                                value = valuesEnd[index];
                                valueEnd = values[index];
                            }
                            if (candlestickArea.reverseVert && value > valueEnd) {
                                let temp = value;
                                value = valueEnd;
                                valueEnd = temp;
                                temp = valueLow;
                                valueLow = valueHigh;
                                valueHigh = temp;
                            }
                            let singleY = candlestickArea.yAxis.info.dpi;
                            let bodyStart = Math.abs(posY - value * singleY);
                            let bodyEnd = Math.abs(posY - valueEnd * singleY);
                            let highCandle = Math.abs(posY - valueHigh * singleY);
                            let lowCandle = Math.abs(posY - valueLow * singleY);
                            let positionX = argumentIndex * singleX;
                            let clientRect = new RectangleD(positionX - singleX / 4, bodyStart, singleX / 2, bodyEnd - bodyStart);
                            candlestickBrush = currentSeries.processSeriesBrushes(index, candlestickBrush);
                            let candlestickGeom = new Chart.StiCandlestickSeriesElementGeom(geom, currentSeries, clientRect, bodyStart, bodyEnd, highCandle, lowCandle, positionX, argumentIndex - 1, candlestickBrush, candlestickBorderColor, new TimeSpan(time.ticks / valueCount * index));
                            if (candlestickGeom != null) {
                                if (currentSeries.core.interaction != null) {
                                    let data = new StiSeriesInteractionData();
                                    data.fill(geom.area, currentSeries, index);
                                    candlestickGeom.interaction = data;
                                }
                            }
                            geom.createChildGeoms();
                            geom.childGeoms.push(candlestickGeom);
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Candlestick");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiCandlestickSeriesCoreXF = StiCandlestickSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiStockSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        this.series.lineColor = color;
                    }
                }
                renderSeries(context, rect, geom, series) {
                    var _a, _b;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let stockArea = geom.area;
                    let posY = stockArea.axisCore.getDividerY();
                    let time = Chart.StiChartHelper.globalBeginTimeElement;
                    for (let currentSeries of series) {
                        let valuesOpen = currentSeries.valuesOpen;
                        let valuesClose = currentSeries.valuesClose;
                        let valuesHigh = currentSeries.valuesHigh;
                        let valuesLow = currentSeries.valuesLow;
                        let valueCount = Math.min(Math.min(valuesOpen.length, valuesClose.length), Math.min(valuesHigh.length, valuesLow.length));
                        let argumentCount = currentSeries.arguments.length;
                        let count = Math.min(valueCount, argumentCount);
                        for (let index = 0; index < count; index++) {
                            let valueOpen = valuesOpen[index];
                            let valueClose = valuesClose[index];
                            let valueHigh = valuesHigh[index];
                            let valueLow = valuesLow[index];
                            let argumentIndex = 0;
                            let currentSeriesArgumentsKeys = currentSeries.arguments.stimulsoft().getKeys();
                            for (let line of stockArea.xAxis.info.stripLines.list) {
                                if (((_a = currentSeries.arguments.stimulsoft().getByIndex(index, currentSeriesArgumentsKeys)) === null || _a === void 0 ? void 0 : _a.toString()) == ((_b = line.valueObject) === null || _b === void 0 ? void 0 : _b.toString()))
                                    break;
                                argumentIndex++;
                            }
                            let singleX = stockArea.xAxis.info.dpi;
                            let color = currentSeries.lineColor;
                            if (!currentSeries.allowApplyColorNegative && valueOpen < valueClose) {
                                color = currentSeries.lineColorNegative;
                            }
                            if (valueOpen == null || valueClose == null || valueHigh == null || valueLow == null)
                                continue;
                            let singleY = stockArea.yAxis.info.dpi;
                            let open = Math.abs(posY - valueOpen * singleY);
                            let close = Math.abs(posY - valueClose * singleY);
                            let high = Math.abs(posY - valueHigh * singleY);
                            let low = Math.abs(posY - valueLow * singleY);
                            let positionX = argumentIndex * singleX;
                            if (stockArea.reverseHor) {
                                let temp = open;
                                open = close;
                                close = temp;
                            }
                            let clientRect = new RectangleD(positionX - singleX / 3, Math.min(high, low), singleX * 2 / 3, Math.abs(low - high));
                            color = currentSeries.processSeriesColors(index, color);
                            let stockGeom = new Chart.StiStockSeriesElementGeom(geom, currentSeries, clientRect, open, close, high, low, positionX, argumentIndex - 1, color, new TimeSpan(time.ticks / valueCount * index));
                            if (stockGeom != null) {
                                if (currentSeries.core.interaction != null) {
                                    let data = new StiSeriesInteractionData();
                                    data.fill(geom.area, currentSeries, index);
                                    stockGeom.interaction = data;
                                }
                            }
                            geom.createChildGeoms();
                            geom.childGeoms.push(stockGeom);
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Stock");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStockSeriesCoreXF = StiStockSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiStackedBarSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let barSeries = this.series;
                    if (barSeries.allowApplyStyle) {
                        barSeries.brush = style.core.getColumnBrush(color);
                        if (barSeries.brush.is(StiGradientBrush))
                            barSeries.brush.angle += 90;
                        if (barSeries.brush.is(StiGlareBrush))
                            barSeries.brush.angle += 90;
                        barSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let labelList = [];
                    let seriesList = [];
                    let area = geom.area;
                    let axisArea = area;
                    let barSeries = this.series;
                    let posX = axisArea.axisCore.getDividerX();
                    let dpiX = axisArea.xAxis.info.dpi;
                    let pointCount = axisArea.axisCore.valuesCount;
                    let colorArea = [];
                    let colorAreaIndex = 0;
                    for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                        let arr = [];
                        for (let valueIndex = 0; valueIndex < series[seriesIndex].values.length; valueIndex++) {
                            arr.push(colorAreaIndex);
                            colorAreaIndex++;
                        }
                        colorArea.push(arr);
                    }
                    let colorCount = colorAreaIndex;
                    for (let pointIndex = 0; pointIndex < pointCount; pointIndex++) {
                        let totalPositiveWidth = 0;
                        let totalNegativeWidth = 0;
                        let REFtotalPositiveWidth = { ref: totalPositiveWidth };
                        let REFtotalNegativeWidth = { ref: totalNegativeWidth };
                        this.calculateTotalWidth(series, pointIndex, REFtotalPositiveWidth, REFtotalNegativeWidth);
                        totalPositiveWidth = REFtotalPositiveWidth.ref;
                        totalNegativeWidth = REFtotalNegativeWidth.ref;
                        let posY = axisArea.yAxis.info.stripPositions[axisArea.yAxis.startFromZero ? pointIndex + 1 : pointIndex] - axisArea.yAxis.info.step / 2;
                        let seriesHeight = axisArea.yAxis.info.step - axisArea.yAxis.info.step * (1 - barSeries.width);
                        let seriesTopPos = posY + (axisArea.yAxis.info.step - seriesHeight) / 2;
                        let posXMax = 0;
                        let posXMin = 0;
                        if (series.length == 0)
                            return;
                        let showShadow = series[0].showShadow;
                        if (showShadow) {
                            for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                                if (pointIndex < series[seriesIndex].values.length) {
                                    let currentSeries = series[seriesIndex];
                                    let value = (axisArea.reverseVert ?
                                        currentSeries.values[pointIndex] :
                                        currentSeries.values[currentSeries.values.length - pointIndex - 1]);
                                    if (axisArea.reverseHor && value != null)
                                        value = -value;
                                    if (value > 0)
                                        posXMax += value;
                                    else
                                        posXMin += value;
                                }
                            }
                            if (this.series.is(Chart.IStiFullStackedBarSeries)) {
                                let totalPositiveWidth2 = axisArea.reverseHor ? totalNegativeWidth : totalPositiveWidth;
                                let totalNegativeWidth2 = axisArea.reverseHor ? totalPositiveWidth : totalNegativeWidth;
                                if (totalPositiveWidth2 > 0 && totalNegativeWidth2 > 0) {
                                    let shadowRect = new RectangleD(-8, seriesTopPos, rect.width + 8, seriesHeight);
                                    let shadowGeom = new Chart.StiStackedBarSeriesShadowElementGeom(series[0], shadowRect, false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                else if (totalPositiveWidth2 > 0) {
                                    let shadowRect = new RectangleD(axisArea.axisCore.getDividerX() - 8, seriesTopPos, rect.width - axisArea.axisCore.getDividerX() + 8, seriesHeight);
                                    let shadowGeom = new Chart.StiStackedBarSeriesShadowElementGeom(series[0], shadowRect.clone(), false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                else if (totalNegativeWidth2 > 0) {
                                    let shadowRect = new RectangleD(-8, seriesTopPos, axisArea.axisCore.getDividerX() + 8, seriesHeight);
                                    let shadowGeom = new Chart.StiStackedBarSeriesShadowElementGeom(series[0], shadowRect.clone(), false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                            }
                            else {
                                if (posXMax > 0) {
                                    let shadowRect = new RectangleD(posX, seriesTopPos, (posXMax * dpiX), seriesHeight);
                                    shadowRect.x -= 7;
                                    shadowRect.width += 7;
                                    let shadowGeom = new Chart.StiStackedBarSeriesShadowElementGeom(series[0], shadowRect, false, true);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                if (posXMin < 0) {
                                    let shadowRect = new RectangleD(posX + posXMin * dpiX, seriesTopPos, (-posXMin * dpiX), seriesHeight);
                                    let shadowGeom = new Chart.StiStackedBarSeriesShadowElementGeom(series[0], shadowRect, true, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                            }
                        }
                        posXMax = 0;
                        posXMin = 0;
                        for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                            let currentSeries = series[seriesIndex];
                            if (pointIndex < currentSeries.values.length) {
                                let colorIndex = colorArea[seriesIndex][pointIndex];
                                let originalValue = (axisArea.reverseVert ?
                                    currentSeries.values[pointIndex] :
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1]);
                                let value = originalValue != null ? -originalValue : originalValue;
                                let totalValue = axisArea.reverseHor
                                    ? series.stimulsoft().toList().cast().sum(s => s.values[pointIndex])
                                    : series.stimulsoft().toList().cast().sum(s => s.values[currentSeries.values.length - pointIndex - 1]);
                                if (this.series.is(Chart.IStiFullStackedBarSeries)) {
                                    if (!(totalPositiveWidth == 0 && totalNegativeWidth == 0) && value != null) {
                                        if (value > 0)
                                            dpiX = axisArea.axisCore.getDividerX() / (totalNegativeWidth);
                                        else
                                            dpiX = (rect.width - axisArea.axisCore.getDividerX()) / (totalPositiveWidth);
                                    }
                                }
                                if (axisArea.reverseHor && value != null)
                                    value = -value;
                                let seriesWidth = (value * dpiX);
                                let seriesLeftPos = -seriesWidth + posX;
                                if (value > 0)
                                    seriesLeftPos -= posXMax;
                                else {
                                    seriesLeftPos = posXMin + posX;
                                    seriesWidth = -seriesWidth;
                                }
                                if (currentSeries.showZeros && (value == 0 || value == null)) {
                                    seriesWidth = Math.max(context.options.zoom, 1);
                                    if (!axisArea.reverseHor)
                                        seriesLeftPos -= seriesWidth;
                                }
                                let columnRect = new RectangleD(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                                columnRect = this.correctRect(columnRect, rect.clone());
                                let columnRectStart;
                                if (value < 0)
                                    columnRectStart = RectangleD.fromLTRB(columnRect.left, columnRect.top, columnRect.left, columnRect.bottom);
                                else
                                    columnRectStart = RectangleD.fromLTRB(columnRect.right, columnRect.top, columnRect.right, columnRect.bottom);
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                let columnRectCheck = columnRect.clone();
                                columnRectCheck.x += geom.clientRectangle.x;
                                columnRectCheck.y += geom.clientRectangle.y;
                                if ((columnRectCheck.bottom > clipRect.y && columnRectCheck.y < clipRect.bottom) || this.series.chart.area.yAxis.range.auto) {
                                    let seriesBrush = currentSeries.core.getSeriesBrush(colorIndex, colorCount);
                                    if (currentSeries.allowApplyBrushNegative && (value > 0))
                                        seriesBrush = currentSeries.brushNegative;
                                    seriesBrush = currentSeries.processSeriesBrushes((pointCount - 1) - pointIndex, seriesBrush);
                                    if (columnRect.height != 0 && Math.round2(columnRect.width, 2) > 0 && seriesBrush != null) {
                                        let seriesBorderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                        let seriesColumnGeom = new Chart.StiStackedBarSeriesElementGeom(geom, value, pointIndex, seriesBrush, seriesBorderColor, currentSeries, columnRect, columnRectStart);
                                        if (currentSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, currentSeries, (pointCount - 1) - pointIndex);
                                            seriesColumnGeom.interaction = data;
                                        }
                                        seriesList.push(seriesColumnGeom);
                                    }
                                    let labels = currentSeries.core.getSeriesLabels();
                                    if (labels != null &&
                                        labels.visible &&
                                        Math.round2(columnRect.width, 2) > 0) {
                                        let endPoint = new PointD(columnRect.x, columnRect.y + columnRect.height / 2);
                                        let startPoint = new PointD(columnRect.right, columnRect.y + columnRect.height / 2);
                                        if (value < 0) {
                                            startPoint.x = columnRect.x;
                                            endPoint.x = columnRect.right;
                                        }
                                        if (value < 0) {
                                            startPoint.x = columnRect.x;
                                            endPoint.x = columnRect.right;
                                        }
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let labelValue = value;
                                            if ((currentSeries.stimulsoft().as(Chart.StiSeries)).isTotalLabel)
                                                labelValue = originalValue = totalValue;
                                            let argumentIndex = axisArea.yAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let stripLine = axisArea.yAxis.info.stripLines.count > pointIndex ?
                                                axisArea.yAxis.info.stripLines.getByIndex(argumentIndex) : null;
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, endPoint, startPoint, pointIndex, labelValue, originalValue, axisArea.axisCore.getArgumentLabel(stripLine, currentSeries), currentSeries.core.getTag(pointIndex), colorIndex, colorCount, rect);
                                            if (seriesLabelsGeom != null) {
                                                labelList.push(seriesLabelsGeom);
                                            }
                                        }
                                    }
                                }
                                if (value > 0)
                                    posXMax += seriesWidth;
                                else
                                    posXMin += seriesWidth;
                                colorIndex++;
                            }
                        }
                    }
                    for (let index = seriesList.length - 1; index >= 0; index--) {
                        let seriesGeom = seriesList[index];
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    for (let seriesLabelsGeom of labelList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                        seriesLabelsGeom.clientRectangle = this.checkLabelsRect(seriesLabelsGeom.seriesLabels, geom, seriesLabelsGeom.clientRectangle.clone());
                    }
                }
                calculateTotalWidth(series, pointIndex, REFtotalPositiveWidth, REFtotalNegativeWidth) {
                    let totalPositiveWidth = 0;
                    let totalNegativeWidth = 0;
                    if (this.series.is(Chart.IStiFullStackedBarSeries)) {
                        for (let currentSeries of series) {
                            if (pointIndex < currentSeries.values.length) {
                                let value = this.series.chart.area.reverseVert ?
                                    currentSeries.values[pointIndex] :
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1];
                                if (value > 0)
                                    totalPositiveWidth += value;
                                else
                                    totalNegativeWidth += Math.abs(value);
                            }
                        }
                    }
                    REFtotalPositiveWidth.ref = totalPositiveWidth;
                    REFtotalNegativeWidth.ref = totalNegativeWidth;
                }
                correctRect(columnRect, rect) {
                    if (columnRect.x > rect.width || columnRect.right < 0) {
                        columnRect.width = 0;
                        return columnRect;
                    }
                    if (columnRect.x < 0) {
                        let dist = -columnRect.x;
                        columnRect.x += dist;
                        columnRect.width -= dist;
                    }
                    if (columnRect.right > rect.width) {
                        let dist = columnRect.right - rect.width;
                        columnRect.width -= dist;
                    }
                    return columnRect;
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let barSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return barSeries.brush;
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let barSeries = this.series;
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return barSeries.borderColor;
                    return color;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedBar");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedBarSeriesCoreXF = StiStackedBarSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedBarSeriesCoreXF extends Chart.StiStackedBarSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedBar");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedBarSeriesCoreXF = StiFullStackedBarSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var Hashtable = Stimulsoft.System.Collections.Hashtable;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiStackedBaseLineSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let lineSeries = this.series;
                    if (lineSeries.allowApplyStyle) {
                        lineSeries.lineColor = color;
                        lineSeries.lighting = style.core.seriesLighting;
                        lineSeries.marker.visible = style.core.markerVisible;
                        if (lineSeries.marker != null) {
                            lineSeries.marker.brush = new StiSolidBrush(StiColorUtils.light(color, 100));
                            lineSeries.marker.borderColor = StiColorUtils.dark(color, 100);
                        }
                        if (lineSeries.lineMarker != null) {
                            lineSeries.lineMarker.brush = new StiSolidBrush(StiColorUtils.light(color, 50));
                            lineSeries.lineMarker.borderColor = StiColorUtils.dark(color, 150);
                        }
                    }
                }
                clipLinePoints(context, geom, startPoints, endPoints, REFnewStartPoints, REFnewEndPoints, REFstartIndex, REFendIndex) {
                    let newStartPoints = REFnewStartPoints.ref;
                    let newEndPoints = REFnewEndPoints.ref;
                    let startIndex = REFstartIndex.ref;
                    let endIndex = REFendIndex.ref;
                    if (this.series.chart.area.xAxis.range.auto) {
                        startIndex = 0;
                        endIndex = startPoints.length;
                        newStartPoints = startPoints;
                        newEndPoints = endPoints;
                        REFnewStartPoints.ref = newStartPoints;
                        REFnewEndPoints.ref = newEndPoints;
                        REFstartIndex.ref = startIndex;
                        REFendIndex.ref = endIndex;
                        return;
                    }
                    startIndex = -1;
                    endIndex = -1;
                    let clipRect = geom.view.clientRectangle.clone();
                    clipRect.x = 0;
                    clipRect.y = 0;
                    let pointIndex = 0;
                    for (let point of startPoints) {
                        let valuePoint = new PointD(point.x, point.y);
                        valuePoint.x += geom.clientRectangle.x;
                        valuePoint.y += geom.clientRectangle.y;
                        if (clipRect.x <= valuePoint.x && valuePoint.x < clipRect.right && startIndex == -1)
                            startIndex = pointIndex;
                        if ((!(clipRect.x <= valuePoint.x && valuePoint.x < clipRect.right)) && startIndex != -1) {
                            endIndex = pointIndex;
                            break;
                        }
                        pointIndex++;
                    }
                    if (endIndex == -1)
                        endIndex = startPoints.length - 1;
                    startIndex--;
                    endIndex++;
                    if (startIndex < 0)
                        startIndex = 0;
                    if (endIndex >= startPoints.length)
                        endIndex = startPoints.length - 1;
                    let newCount = endIndex - startIndex + 1;
                    if (newCount == startPoints.length) {
                        newStartPoints = startPoints;
                        newEndPoints = endPoints;
                        REFnewStartPoints.ref = newStartPoints;
                        REFnewEndPoints.ref = newEndPoints;
                        REFstartIndex.ref = startIndex;
                        REFendIndex.ref = endIndex;
                        return;
                    }
                    newStartPoints = StiArray.create(PointD, newCount, true);
                    StiArray.copy(startPoints, startIndex, newStartPoints, newCount);
                    if (endPoints != null) {
                        newEndPoints = StiArray.create(PointD, newCount, true);
                        StiArray.copy(endPoints, startIndex, newEndPoints, newCount);
                    }
                    else
                        newEndPoints = null;
                    REFnewStartPoints.ref = newStartPoints;
                    REFnewEndPoints.ref = newEndPoints;
                    REFstartIndex.ref = startIndex;
                    REFendIndex.ref = endIndex;
                }
                renderMarkers(context, geom, points) {
                    let axisArea = geom.area;
                    let lineSeries = this.series;
                    if (points.length == 0)
                        return;
                    let isTooltipMarkerMode = !lineSeries.marker.visible && lineSeries.toolTips.length > 0;
                    if (lineSeries.marker != null && (lineSeries.marker.visible || isTooltipMarkerMode)) {
                        let index = 0;
                        for (let point of points) {
                            if (point != null) {
                                let value = axisArea.reverseHor ?
                                    this.series.values[this.series.values.length - index - 1] :
                                    this.series.values[index];
                                if (value == null && lineSeries.showNulls)
                                    value = 0;
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                clipRect.inflate(10, 10);
                                let valuePoint = new PointD(point.x, point.y);
                                valuePoint.x += geom.clientRectangle.x;
                                valuePoint.y += geom.clientRectangle.y;
                                if (clipRect.contains(valuePoint.x, valuePoint.y)) {
                                    let markerGeom = new Chart.StiMarkerGeom(this.series, index, value, point, lineSeries.marker, this.series.showShadow, context.options.zoom, isTooltipMarkerMode);
                                    if (markerGeom != null) {
                                        if (lineSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, lineSeries, index);
                                            markerGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(markerGeom);
                                    }
                                }
                            }
                            index++;
                        }
                    }
                }
                renderLines(context, geom, pointsInfo) {
                }
                renderAreas(context, geom, pointsInfo) {
                }
                renderSeries(context, rect, geom, series) {
                    let lineSeries = this.series;
                    let labelList = [];
                    let area = geom.area;
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let axisArea = area;
                    let posY = this.series.yAxis == Chart.StiSeriesYAxis.LeftYAxis
                        ? axisArea.axisCore.getDividerY()
                        : axisArea.axisCore.getDividerRightY();
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    let pointMaxStack = new Hashtable();
                    let pointMinStack = new Hashtable();
                    let pointLists = [];
                    let pointFromLists = [];
                    let pointIdsLists = [];
                    let dpiY = axisArea.yAxis.info.dpi;
                    if (this.series.yAxis == Chart.StiSeriesYAxis.RightYAxis)
                        dpiY = axisArea.yRightAxis.info.dpi;
                    for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                        let currentSeries = series[seriesIndex];
                        let pointsCount = currentSeries.values.length;
                        let endPoints = StiArray.create(PointD, pointsCount, true);
                        let startPoints = StiArray.create(PointD, pointsCount, true);
                        let pointsIds = StiArray.create(String, pointsCount, true);
                        for (let pointIndex = 0; pointIndex < pointsCount; pointIndex++) {
                            let posX = getStartFromZero ?
                                axisArea.xAxis.info.stripPositions[pointIndex + 1] :
                                axisArea.xAxis.info.stripPositions[pointIndex];
                            let value = axisArea.reverseHor ?
                                currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                currentSeries.values[pointIndex];
                            if (value == null && !currentSeries.showNulls) {
                                startPoints[pointIndex] = null;
                                endPoints[pointIndex] = null;
                                pointsIds[pointIndex] = null;
                            }
                            else {
                                if (value == null && currentSeries.showNulls)
                                    value = 0;
                                let totalPositiveHeight = 0;
                                let totalNegativeHeight = 0;
                                let REFtotalPositiveHeight = { ref: totalPositiveHeight };
                                let REFtotalNegativeHeight = { ref: totalNegativeHeight };
                                this.calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight);
                                totalPositiveHeight = REFtotalPositiveHeight.ref;
                                totalNegativeHeight = REFtotalNegativeHeight.ref;
                                if (lineSeries.core.isFullStacked) {
                                    if (!(totalPositiveHeight == 0 && totalNegativeHeight == 0) && value != null) {
                                        if (value >= 0)
                                            dpiY = posY / (totalPositiveHeight);
                                        else
                                            dpiY = (rect.height - posY) / (totalNegativeHeight);
                                    }
                                }
                                if (axisArea.reverseVert && value != null)
                                    value = -value;
                                let srY = -value * dpiY;
                                let srYStack = 0;
                                if (value >= 0) {
                                    if (pointMaxStack.get(pointIndex) != null)
                                        srYStack = pointMaxStack.get(pointIndex);
                                }
                                else {
                                    if (pointMinStack.get(pointIndex) != null)
                                        srYStack = pointMinStack.get(pointIndex);
                                }
                                srY += srYStack;
                                if (value >= 0)
                                    pointMaxStack.set(pointIndex, srY);
                                else
                                    pointMinStack.set(pointIndex, srY);
                                startPoints[pointIndex] = new PointD(posX, srYStack + posY);
                                endPoints[pointIndex] = new PointD(posX, srY + posY);
                                let argId = getStartFromZero ?
                                    axisArea.xAxis.info.stripLines.getByIndex(pointIndex + 1).valueObject :
                                    axisArea.xAxis.info.stripLines.getByIndex(pointIndex).valueObject;
                                pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                            }
                        }
                        if (endPoints.length > 0 && startPoints.length > 0) {
                            let startIndex;
                            let endIndex;
                            let newStartPoints = null;
                            let newEndPoints = null;
                            let REFnewStartPoints = { ref: newStartPoints };
                            let REFnewEndPoints = { ref: newEndPoints };
                            let REFstartIndex = { ref: startIndex };
                            let REFendIndex = { ref: endIndex };
                            this.clipLinePoints(context, geom, startPoints, endPoints, REFnewStartPoints, REFnewEndPoints, REFstartIndex, REFendIndex);
                            newStartPoints = REFnewStartPoints.ref;
                            newEndPoints = REFnewEndPoints.ref;
                            startIndex = REFstartIndex.ref;
                            endIndex = REFendIndex.ref;
                            let pointsInfo = new Chart.StiSeriesPointsInfo();
                            pointsInfo.pointsStart = newStartPoints;
                            pointsInfo.pointsEnd = newEndPoints;
                            pointsInfo.pointsIds = pointsIds;
                            currentSeries.core.renderAreas(context, geom, pointsInfo);
                        }
                        pointLists.push(endPoints);
                        pointFromLists.push(startPoints);
                        pointIdsLists.push(pointsIds);
                    }
                    let index = 0;
                    let prevMaxHeights = StiArray.create(Number, axisArea.axisCore.valuesCount);
                    let prevMinHeights = StiArray.create(Number, axisArea.axisCore.valuesCount);
                    for (let pointIndex = 0; pointIndex < axisArea.axisCore.valuesCount; pointIndex++) {
                        prevMaxHeights[pointIndex] = posY;
                        prevMinHeights[pointIndex] = posY;
                    }
                    for (let pointList of pointLists) {
                        let startIndex;
                        let endIndex;
                        let newPoints = null;
                        let newEndPoints = null;
                        let REFnewPoints = { ref: newPoints };
                        let REFnewEndPoints = { ref: newEndPoints };
                        let REFstartIndex = { ref: startIndex };
                        let REFendIndex = { ref: endIndex };
                        this.clipLinePoints(context, geom, pointList, null, REFnewPoints, REFnewEndPoints, REFstartIndex, REFendIndex);
                        newPoints = REFnewPoints.ref;
                        newEndPoints = REFnewEndPoints.ref;
                        startIndex = REFstartIndex.ref;
                        endIndex = REFendIndex.ref;
                        let currentSeries = series[index];
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.points = newPoints;
                        pointsInfo.pointsFrom = pointFromLists[index];
                        pointsInfo.pointsIds = pointIdsLists[index];
                        currentSeries.core.renderLines(context, geom, pointsInfo);
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = startIndex; pointIndex <= endIndex; pointIndex++) {
                                if (pointIndex < currentSeries.values.length) {
                                    let value = currentSeries.values[pointIndex];
                                    if (value == null && lineSeries.showNulls)
                                        value = 0;
                                    let y = posY;
                                    if (value > 0) {
                                        y = prevMaxHeights[pointIndex];
                                        if (pointList[pointIndex] != null)
                                            prevMaxHeights[pointIndex] = pointList[pointIndex].y;
                                    }
                                    else {
                                        y = prevMinHeights[pointIndex];
                                        if (pointList[pointIndex] != null)
                                            prevMinHeights[pointIndex] = pointList[pointIndex].y;
                                    }
                                    let seriesValue = value;
                                    if (axisArea.reverseVert && value != null)
                                        seriesValue = -seriesValue;
                                    let endPoint = pointList[pointIndex];
                                    if (endPoint != null) {
                                        let startPoint = new PointD(endPoint.x, y);
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, endPoint, startPoint, pointIndex, seriesValue, value, axisArea.axisCore.getArgumentLabel(axisArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                            if (seriesLabelsGeom != null) {
                                                labelList.push(seriesLabelsGeom);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        index++;
                    }
                    for (let seriesLabelsGeom of labelList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                        seriesLabelsGeom.clientRectangle = this.checkLabelsRect(seriesLabelsGeom.seriesLabels, geom, seriesLabelsGeom.clientRectangle.clone());
                    }
                }
                calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight) {
                    let lineSeries = this.series;
                    let totalPositiveHeight = 0;
                    let totalNegativeHeight = 0;
                    if (lineSeries.core.isFullStacked) {
                        for (let currentSeries of series) {
                            if (pointIndex < currentSeries.values.length) {
                                let value = this.series.chart.area.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                if (value == null && lineSeries.showNulls)
                                    value = 0;
                                if (value > 0)
                                    totalPositiveHeight += value;
                                else
                                    totalNegativeHeight += Math.abs(value);
                            }
                        }
                    }
                    REFtotalPositiveHeight.ref = totalPositiveHeight;
                    REFtotalNegativeHeight.ref = totalNegativeHeight;
                }
                correctPoint(point, rect) {
                    if (point.y < 0)
                        return new PointD(point.x, 0);
                    if (point.y > rect.height)
                        return new PointD(point.x, rect.height);
                    return point;
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let lineSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return new StiSolidBrush(StiColorUtils.dark(lineSeries.lineColor, 20));
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let lineSeries = this.series;
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return lineSeries.lineColor;
                    return color;
                }
                get isFullStacked() {
                    return this.is2(Chart.StiFullStackedAreaSeriesCoreXF) ||
                        this.is2(Chart.StiFullStackedLineSeriesCoreXF) ||
                        this.is2(Chart.StiFullStackedSplineSeriesCoreXF) ||
                        this.is2(Chart.StiFullStackedSplineAreaSeriesCoreXF);
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedBaseLineSeriesCoreXF = StiStackedBaseLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedLineSeriesCoreXF extends Chart.StiStackedBaseLineSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiStackedLineSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedLine");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedLineSeriesCoreXF = StiStackedLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedAreaSeriesCoreXF extends Chart.StiStackedLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderAreas(context, geom, pointsInfo) {
                    if (pointsInfo.pointsStart == null || pointsInfo.pointsStart.length <= 1)
                        return;
                    if (pointsInfo.pointsEnd == null || pointsInfo.pointsEnd.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiStackedAreaSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let areaSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return areaSeries.brush;
                    return brush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedAreaSeriesCoreXF = StiStackedAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedAreaSeriesCoreXF extends Chart.StiStackedAreaSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedAreaSeriesCoreXF = StiFullStackedAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiStackedColumnSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let columnSeries = this.series;
                    if (columnSeries.allowApplyStyle) {
                        columnSeries.brush = style.core.getColumnBrush(color);
                        columnSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let labelList = [];
                    let seriesList = [];
                    let area = geom.area;
                    let axisArea = area;
                    let columnSeries = this.series;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    let posY = axisArea.axisCore.getDividerY();
                    let dpiY = axisArea.yAxis.info.dpi;
                    if (this.series.yAxis == Chart.StiSeriesYAxis.RightYAxis)
                        dpiY = axisArea.yRightAxis.info.dpi;
                    let colorArea = [];
                    let colorAreaIndex = 0;
                    for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                        let arr = [];
                        for (let valueIndex = 0; valueIndex < series[seriesIndex].values.length; valueIndex++) {
                            arr.push(colorAreaIndex);
                            colorAreaIndex++;
                        }
                        colorArea.push(arr);
                    }
                    let colorCount = colorAreaIndex;
                    for (let pointIndex = 0; pointIndex < axisArea.axisCore.valuesCount; pointIndex++) {
                        let totalPositiveHeight = 0;
                        let totalNegativeHeight = 0;
                        let REFtotalPositiveHeight = { ref: totalPositiveHeight };
                        let REFtotalNegativeHeight = { ref: totalNegativeHeight };
                        this.calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight);
                        totalPositiveHeight = REFtotalPositiveHeight.ref;
                        totalNegativeHeight = REFtotalNegativeHeight.ref;
                        let posX = getStartFromZero ?
                            axisArea.xAxis.info.stripPositions[pointIndex + 1] :
                            axisArea.xAxis.info.stripPositions[pointIndex];
                        posX -= axisArea.xAxis.info.step / 2;
                        let seriesWidth = axisArea.xAxis.info.step - axisArea.xAxis.info.step * (1 - columnSeries.width);
                        let seriesLeftPos = posX + (axisArea.xAxis.info.step - seriesWidth) / 2;
                        let posYMax = 0;
                        let posYMin = 0;
                        if (series.length == 0)
                            return;
                        let showShadow = series[0].showShadow;
                        if (showShadow) {
                            for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                                if (pointIndex < series[seriesIndex].values.length) {
                                    let currentSeries = series[seriesIndex];
                                    let value = (axisArea.reverseHor ?
                                        currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                        currentSeries.values[pointIndex]);
                                    if (value != null) {
                                        if (axisArea.reverseVert)
                                            value = -value;
                                        if (value > 0)
                                            posYMax += value;
                                        else
                                            posYMin += value;
                                    }
                                }
                            }
                            if (this.is(Chart.StiFullStackedColumnSeriesCoreXF)) {
                                let totalPositiveHeight2 = axisArea.reverseVert ? totalNegativeHeight : totalPositiveHeight;
                                let totalNegativeHeight2 = axisArea.reverseVert ? totalPositiveHeight : totalNegativeHeight;
                                if (totalPositiveHeight2 > 0 && totalNegativeHeight2 > 0) {
                                    let shadowRect = new RectangleD(seriesLeftPos, -8, seriesWidth, rect.height + 8);
                                    let shadowGeom = new Chart.StiStackedColumnSeriesShadowElementGeom(series[0], shadowRect, false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                else if (totalPositiveHeight2 > 0) {
                                    let shadowRect = new RectangleD(seriesLeftPos, -8, seriesWidth, axisArea.axisCore.getDividerY() + 8);
                                    let shadowGeom = new Chart.StiStackedColumnSeriesShadowElementGeom(series[0], shadowRect, false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                else if (totalNegativeHeight2 > 0) {
                                    let shadowRect = new RectangleD(seriesLeftPos, axisArea.axisCore.getDividerY() - 8, seriesWidth, rect.height - axisArea.axisCore.getDividerY() + 8);
                                    let shadowGeom = new Chart.StiStackedColumnSeriesShadowElementGeom(series[0], shadowRect, false, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                            }
                            else {
                                if (posYMax > 0) {
                                    let shadowRect = new RectangleD(seriesLeftPos, (-posYMax * dpiY + posY), seriesWidth, (posYMax * dpiY));
                                    let shadowGeom = new Chart.StiStackedColumnSeriesShadowElementGeom(series[0], shadowRect, true, false);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                                if (posYMin < 0) {
                                    let shadowRect = new RectangleD(seriesLeftPos, posY, seriesWidth, (-posYMin * dpiY));
                                    shadowRect.y -= 7;
                                    shadowRect.height += 7;
                                    let shadowGeom = new Chart.StiStackedColumnSeriesShadowElementGeom(series[0], shadowRect, false, true);
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(shadowGeom);
                                }
                            }
                        }
                        posYMax = 0;
                        posYMin = 0;
                        for (let seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
                            let currentSeries = series[seriesIndex];
                            if (pointIndex < currentSeries.values.length) {
                                let colorIndex = colorArea[seriesIndex][pointIndex];
                                let value = (axisArea.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex]);
                                let totalValue = axisArea.reverseHor
                                    ? series.stimulsoft().toList().cast().sum(s => s.values[currentSeries.values.length - pointIndex - 1])
                                    : series.stimulsoft().toList().cast().sum(s => s.values[pointIndex]);
                                if (this.series.is(Chart.IStiFullStackedColumnSeries)) {
                                    if (!(totalPositiveHeight == 0 && totalNegativeHeight == 0) && value != null) {
                                        if (value >= 0)
                                            dpiY = axisArea.axisCore.getDividerY() / (totalPositiveHeight);
                                        else
                                            dpiY = (rect.height - axisArea.axisCore.getDividerY()) / (totalNegativeHeight);
                                    }
                                }
                                if (axisArea.reverseVert && value != null)
                                    value = -value;
                                let seriesHeight = value * dpiY;
                                let seriesTop = -seriesHeight + posY;
                                if (value > 0)
                                    seriesTop -= posYMax;
                                else {
                                    seriesTop = posYMin + posY;
                                    seriesHeight = -seriesHeight;
                                }
                                if (columnSeries.showZeros && (value == 0 || value == null)) {
                                    seriesHeight = Math.max(context.options.zoom, 1);
                                    if (!axisArea.reverseVert)
                                        seriesTop -= seriesHeight;
                                }
                                let columnRect = new RectangleD(seriesLeftPos, seriesTop, seriesWidth, seriesHeight);
                                columnRect = this.correctRect(columnRect, rect);
                                let columnRectStart;
                                if (value < 0)
                                    columnRectStart = RectangleD.fromLTRB(columnRect.left, columnRect.top, columnRect.right, columnRect.top);
                                else
                                    columnRectStart = RectangleD.fromLTRB(columnRect.left, columnRect.bottom, columnRect.right, columnRect.bottom);
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                let columnRectCheck = columnRect.clone();
                                columnRectCheck.x += geom.clientRectangle.x;
                                columnRectCheck.y += geom.clientRectangle.y;
                                if ((columnRectCheck.right > clipRect.x && columnRectCheck.x < clipRect.right) || this.series.chart.area.xAxis.range.auto) {
                                    let seriesBrush = currentSeries.core.getSeriesBrush(colorIndex, colorCount);
                                    if (currentSeries.allowApplyBrushNegative && (value < 0))
                                        seriesBrush = currentSeries.brushNegative;
                                    seriesBrush = currentSeries.processSeriesBrushes(pointIndex, seriesBrush);
                                    if (columnRect.width != 0 && Math.round2(columnRect.height, 2) > 0 && seriesBrush != null) {
                                        let seriesBorderColor = currentSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                        let seriesColumnGeom = new Chart.StiStackedColumnSeriesElementGeom(geom, value, pointIndex, seriesBrush, seriesBorderColor, currentSeries, columnRect, columnRectStart);
                                        if (currentSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, currentSeries, pointIndex);
                                            seriesColumnGeom.interaction = data;
                                        }
                                        seriesList.push(seriesColumnGeom);
                                    }
                                    let labels = currentSeries.core.getSeriesLabels();
                                    if (labels != null &&
                                        labels.visible &&
                                        Math.round2(columnRect.height, 2) > 0) {
                                        let endPoint = new PointD(columnRect.x + columnRect.width / 2, columnRect.y);
                                        let startPoint = new PointD(columnRect.x + columnRect.width / 2, columnRect.bottom);
                                        let seriesValue = currentSeries.values[pointIndex];
                                        if (axisArea.reverseVert && seriesValue != null)
                                            seriesValue = -value;
                                        if (value < 0) {
                                            startPoint.y = columnRect.y;
                                            endPoint.y = columnRect.bottom;
                                        }
                                        if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                            let labelValue = value;
                                            if ((currentSeries.stimulsoft().as(Chart.StiSeries)).isTotalLabel)
                                                labelValue = seriesValue = totalValue;
                                            let argumentIndex = axisArea.xAxis.startFromZero ? pointIndex + 1 : pointIndex;
                                            let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, endPoint, startPoint, pointIndex, labelValue, seriesValue, axisArea.axisCore.getArgumentLabel(axisArea.xAxis.info.stripLines.getByIndex(argumentIndex), currentSeries), currentSeries.core.getTag(pointIndex), colorIndex, colorCount, rect);
                                            if (seriesLabelsGeom != null) {
                                                labelList.push(seriesLabelsGeom);
                                            }
                                        }
                                    }
                                }
                                if (value > 0)
                                    posYMax += seriesHeight;
                                else
                                    posYMin += seriesHeight;
                                colorIndex++;
                            }
                        }
                    }
                    for (let index = seriesList.length - 1; index >= 0; index--) {
                        let seriesGeom = seriesList[index];
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    for (let seriesLabelsGeom of labelList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                        seriesLabelsGeom.clientRectangle = this.checkLabelsRect(seriesLabelsGeom.seriesLabels, geom, seriesLabelsGeom.clientRectangle.clone());
                    }
                }
                calculateTotalHeight(series, pointIndex, REFtotalPositiveHeight, REFtotalNegativeHeight) {
                    let totalPositiveHeight = 0;
                    let totalNegativeHeight = 0;
                    if (this.series.is(Chart.IStiFullStackedColumnSeries)) {
                        for (let currentSeries of series) {
                            if (pointIndex < currentSeries.values.length) {
                                let value = this.series.chart.area.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                if (value > 0)
                                    totalPositiveHeight += value;
                                else
                                    totalNegativeHeight += Math.abs(value);
                            }
                        }
                    }
                    REFtotalPositiveHeight.ref = totalPositiveHeight;
                    REFtotalNegativeHeight.ref = totalNegativeHeight;
                }
                correctRect(columnRect, rect) {
                    if (columnRect.y > rect.height || columnRect.bottom < 0) {
                        columnRect.height = 0;
                        return columnRect;
                    }
                    if (columnRect.top < 0) {
                        let dist = -columnRect.top;
                        columnRect.y += dist;
                        columnRect.height -= dist;
                    }
                    if (columnRect.bottom > rect.height) {
                        let dist = columnRect.bottom - rect.height;
                        columnRect.height -= dist;
                    }
                    return columnRect;
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let columnSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return columnSeries.brush;
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let columnSeries = this.series;
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return columnSeries.borderColor;
                    return color;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedColumn");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedColumnSeriesCoreXF = StiStackedColumnSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedColumnSeriesCoreXF extends Chart.StiStackedColumnSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedColumn");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedColumnSeriesCoreXF = StiFullStackedColumnSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedLineSeriesCoreXF extends Chart.StiStackedLineSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedLine");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedLineSeriesCoreXF = StiFullStackedLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedSplineSeriesCoreXF extends Chart.StiStackedBaseLineSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiStackedSplineSeriesGeom(geom, pointsInfo, this.series);
                    geom.createChildGeoms();
                    geom.childGeoms.push(seriesGeom);
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedSpline");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedSplineSeriesCoreXF = StiStackedSplineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiStackedSplineAreaSeriesCoreXF extends Chart.StiStackedSplineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderAreas(context, geom, pointsInfo) {
                    if (pointsInfo.pointsStart == null || pointsInfo.pointsStart.length <= 1)
                        return;
                    if (pointsInfo.pointsEnd == null || pointsInfo.pointsEnd.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiStackedSplineAreaSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let areaSeries = this.series;
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return areaSeries.brush;
                    return brush;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "StackedSplineArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiStackedSplineAreaSeriesCoreXF = StiStackedSplineAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedSplineAreaSeriesCoreXF extends Chart.StiStackedSplineAreaSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedSplineArea");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedSplineAreaSeriesCoreXF = StiFullStackedSplineAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiFullStackedSplineSeriesCoreXF extends Chart.StiStackedSplineSeriesCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "FullStackedSpline");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiFullStackedSplineSeriesCoreXF = StiFullStackedSplineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiCloseFigureSegmentGeom = Stimulsoft.Base.Context.StiCloseFigureSegmentGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var List = Stimulsoft.System.Collections.List;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiFunnelSeriesCoreXF extends Chart.StiSeriesCoreXF {
                constructor(series) {
                    super(series);
                }
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let funnelSeries = this.series;
                    if (funnelSeries.allowApplyStyle) {
                        funnelSeries.brush = style.core.getColumnBrush(color);
                        funnelSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                isNotNullValues(seriesArray) {
                    for (let series of seriesArray) {
                        for (let value of series.values) {
                            if (value != null)
                                return true;
                        }
                    }
                    return false;
                }
                renderSeries(context, rect, geom, seriesArray) {
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null || (seriesArray != null && !this.isNotNullValues(seriesArray))) {
                        this.renderFunnelEmpty(geom, rect);
                        return;
                    }
                    let funnelSeriesArray = seriesArray.stimulsoft().toList().cast().stimulsoft().toArray();
                    let allValues = this.getAllValues(funnelSeriesArray);
                    let allTrueValues = this.getAllTrueValues(funnelSeriesArray);
                    let colorCount = 0;
                    for (let ser of seriesArray) {
                        if (ser.values != null) {
                            colorCount += ser.values.length;
                        }
                    }
                    if (colorCount == 0) {
                        this.renderFunnelEmpty(geom, rect);
                        return;
                    }
                    let singleValueHeight = this.getSingleValueHeight(colorCount, rect);
                    let singleValueWidth = this.getSingleValueWidth(allValues, rect);
                    this.labels = this.series.chart.seriesLabels.stimulsoft().as(Chart.IStiFunnelSeriesLabels);
                    let measureRect = rect.clone();
                    let measureRectTemp = rect.clone();
                    for (let ser of seriesArray) {
                        let funnelSeries = ser;
                        if (this.labels != null && this.labels.visible) {
                            for (let pointIndex = 0; pointIndex < funnelSeries.values.length; pointIndex++) {
                                if (ser.values.length > pointIndex) {
                                    let value = funnelSeries.values[pointIndex];
                                    let valueNext = (pointIndex == funnelSeries.values.length - 1) ? value : funnelSeries.values[pointIndex + 1];
                                    if (this.labels.step == 0 || (pointIndex % this.labels.step == 0)) {
                                        let REFmeasureRect = { ref: measureRect };
                                        this.labels.core.renderLabel(ser, context, pointIndex, value, valueNext, this.getArgumentText(ser, pointIndex), ser.core.getTag(pointIndex), 0, colorCount, rect, singleValueHeight, singleValueWidth, 1, REFmeasureRect);
                                        measureRect = REFmeasureRect.ref;
                                        measureRectTemp = measureRect.width < measureRectTemp.width ? measureRect : measureRectTemp;
                                    }
                                }
                            }
                            measureRect = measureRectTemp.clone();
                        }
                        singleValueHeight = this.getSingleValueHeight(colorCount, measureRect);
                        singleValueWidth = this.getSingleValueWidth(allValues, measureRect);
                        let globalIndex = 0;
                        let colorIndex = 0;
                        let centerAxis;
                        if (this.labels != null && this.labels.is(Chart.StiOutsideLeftFunnelLabels))
                            centerAxis = measureRect.width / 2 + measureRect.x;
                        else
                            centerAxis = measureRect.width / 2;
                        let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                        for (let funnelSeries of funnelSeriesArray) {
                            let REFnonZeroValuesCount = { ref: null };
                            let REFfirstNonZeroValueIndex = { ref: null };
                            let REFfirstNonZeroSeries = { ref: null };
                            this.checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries);
                            let nonZeroValuesCount = REFnonZeroValuesCount.ref;
                            let firstNonZeroValueIndex = REFfirstNonZeroValueIndex.ref;
                            if (nonZeroValuesCount == 0) {
                            }
                            else if (nonZeroValuesCount == 1) {
                                let seriesBrush = funnelSeries.brush;
                                if (funnelSeries.allowApplyBrush) {
                                    seriesBrush = funnelSeries.core.getSeriesBrush(firstNonZeroValueIndex, funnelSeries.values.length);
                                    seriesBrush = funnelSeries.processSeriesBrushes(firstNonZeroValueIndex, seriesBrush);
                                }
                                let borderColor = funnelSeries.borderColor;
                                if (funnelSeries.allowApplyBorderColor) {
                                    borderColor = funnelSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                }
                                let funnelElementGeom = this.renderFunnelElement(borderColor, seriesBrush, funnelSeries.values[firstNonZeroValueIndex], 0, colorIndex, firstNonZeroValueIndex, funnelSeries, geom, measureRect, singleValueHeight, singleValueWidth, new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks));
                                if (funnelElementGeom != null) {
                                    if (funnelSeries.core.interaction != null) {
                                        let interaction = new StiSeriesInteractionData();
                                        interaction.fill(geom.area, funnelSeries, firstNonZeroValueIndex);
                                        funnelElementGeom.interaction = interaction;
                                    }
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(funnelElementGeom);
                                }
                            }
                            else {
                                for (let index = 0; index < funnelSeries.values.length; index++) {
                                    let value = this.getCurrentValue(funnelSeries, globalIndex, allTrueValues);
                                    if (value == 0 && !funnelSeries.showZeros) {
                                        globalIndex++;
                                        continue;
                                    }
                                    let valueNext = this.getNextCurrentValue(funnelSeries, globalIndex, allTrueValues);
                                    let seriesBrush = funnelSeries.brush;
                                    if (funnelSeries.allowApplyBrush) {
                                        seriesBrush = funnelSeries.core.getSeriesBrush(globalIndex, colorCount);
                                        seriesBrush = funnelSeries.processSeriesBrushes(globalIndex, seriesBrush);
                                    }
                                    let borderColor = funnelSeries.borderColor;
                                    if (funnelSeries.allowApplyBorderColor) {
                                        borderColor = funnelSeries.core.getSeriesBorderColor(colorIndex, colorCount);
                                    }
                                    let funnelElementGeom = this.renderFunnelElement(borderColor, seriesBrush, value, valueNext, colorIndex, index, funnelSeries, geom, measureRect, singleValueHeight, singleValueWidth, new TimeSpan(beginTime.ticks / allValues.length * index));
                                    if (funnelElementGeom != null) {
                                        if (ser.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(geom.area, ser, index);
                                            funnelElementGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(funnelElementGeom);
                                    }
                                    if (this.labels != null && this.labels.visible && (this.labels.step == 0 || (index % this.labels.step == 0))) {
                                        let REFmeasureRect = { ref: measureRect };
                                        let seriesLabelsGeom = this.labels.core.renderLabel(funnelSeries, context, colorIndex, value, valueNext, this.getArgumentText(funnelSeries, index), funnelSeries.core.getTag(index), colorIndex, colorCount, rect, singleValueHeight, singleValueWidth, centerAxis, REFmeasureRect);
                                        measureRect = REFmeasureRect.ref;
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(this.labels, geom, seriesLabelsGeom.clientRectangle);
                                        }
                                    }
                                    colorIndex++;
                                    globalIndex++;
                                }
                            }
                        }
                    }
                }
                checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries, isForValueFrom = false) {
                    let nonZeroValuesCountTemp = 0;
                    let firstNonZeroValueIndexTemp = 0;
                    let firstNonZeroValueIndexTemp1 = 0;
                    let firstNonZeroValue = 0;
                    let firstNonZeroSeriesTemp = null;
                    for (let ser of seriesArray) {
                        let values = isForValueFrom ? ser.valuesStart : ser.values;
                        for (let value of values) {
                            if (!(value == 0 || value == null || isNaN(value))) {
                                nonZeroValuesCountTemp++;
                                firstNonZeroValue = value;
                                firstNonZeroSeriesTemp = ser;
                                if (nonZeroValuesCountTemp == 1)
                                    firstNonZeroValueIndexTemp1 = firstNonZeroValueIndexTemp;
                            }
                            firstNonZeroValueIndexTemp++;
                        }
                    }
                    REFnonZeroValuesCount.ref = nonZeroValuesCountTemp;
                    REFfirstNonZeroValueIndex.ref = firstNonZeroValueIndexTemp1;
                    REFfirstNonZeroSeries.ref = firstNonZeroSeriesTemp;
                    return firstNonZeroValue;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                    let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                    return styleCore.getColumnBorder(color);
                }
                getSeriesBrush(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                    let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                    let seriesBrush = styleCore.getColumnBrush(color);
                    return seriesBrush;
                }
                getCurrentValue(funnelSeries, index, values) {
                    return values[index];
                }
                getNextCurrentValue(funnelSeries, index, values) {
                    if (index != values.length - 1) {
                        let value = values[index + 1];
                        if (value == 0 && !funnelSeries.showZeros) {
                            while (value == 0 && index < values.length - 2) {
                                index++;
                                value = values[index + 1];
                            }
                        }
                        return value;
                    }
                    return values[index];
                }
                getAllValues(funnelSeries) {
                    let values = new List();
                    for (let series of funnelSeries) {
                        for (let value of series.values) {
                            if (value == 0 && !series.showZeros)
                                continue;
                            values.push(value);
                        }
                    }
                    return values.stimulsoft().toArray();
                }
                getAllTrueValues(funnelSeries) {
                    let values = new List();
                    for (let series of funnelSeries) {
                        for (let value of series.values) {
                            {
                                values.push(value);
                            }
                        }
                    }
                    return values.stimulsoft().toArray();
                }
                getValues(funnelSeries) {
                    let values = [];
                    for (let value of funnelSeries.values) {
                        if (!funnelSeries.showZeros && value == 0)
                            continue;
                        values.push(value);
                    }
                    return values.stimulsoft().toArray();
                }
                getArgumentText(series, index) {
                    let seriesArgumentsKeys = series.arguments.stimulsoft().getKeys();
                    if (series.arguments.length > index && series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys) != null) {
                        return series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                renderFunnelEmpty(geom, rect) {
                    let values = [3, 2, 1];
                    let singleValueHeight = rect.height * 0.9 / values.length;
                    let singleValueWidth = rect.width * 0.9 / values.length;
                    for (let index = 0; index < values.length; index++) {
                        let value = values[index];
                        let valueNext = index != values.length - 1 ? values[index + 1] : values[index];
                        let path = this.measureFunnelElementCore(value, valueNext, index, rect, singleValueHeight, singleValueWidth);
                        geom.createChildGeoms();
                        geom.childGeoms.push(new Chart.StiFunnelEmptySeriesElementGeom(rect, path));
                    }
                }
                renderFunnelElement(borderColor, brush, value, valueNext, globalIndex, index, currentSeries, geom, rect, singleValueHeight, singleValueWidth, beginTime) {
                    let path = this.measureFunnelElementCore(value, valueNext, globalIndex, rect, singleValueHeight, singleValueWidth);
                    return new Chart.StiFunnelSeriesElementGeom(geom, value, index, currentSeries, rect, brush, borderColor, path, beginTime);
                }
                getSingleValueHeight(values, rect) {
                    return rect.height * 0.9 / values;
                }
                getSingleValueWidth(values, rect) {
                    let maxValue = Number.MIN_VALUE;
                    for (let value of values) {
                        maxValue = maxValue > value ? maxValue : value;
                    }
                    return rect.width * 0.9 / maxValue;
                }
                measureFunnelElementCore(value, valueNext, index, rect, singleValueHeight, singleValueWidth) {
                    let path = new List();
                    let indent = rect.height * 0.05;
                    let center;
                    if (this.labels != null && this.labels.is(Chart.StiOutsideLeftFunnelLabels))
                        center = rect.width / 2 + rect.x;
                    else
                        center = rect.width / 2;
                    let pointLeftTop = new PointD(center - value / 2 * singleValueWidth, singleValueHeight * index + indent);
                    let pointRightTop = new PointD(center + value / 2 * singleValueWidth, singleValueHeight * index + indent);
                    let pointRightBottom = new PointD(center + valueNext / 2 * singleValueWidth, singleValueHeight * (index + 1) + indent);
                    let pointLeftBottom = new PointD(center - valueNext / 2 * singleValueWidth, singleValueHeight * (index + 1) + indent);
                    let points = [pointLeftTop, pointRightTop, pointRightBottom, pointLeftBottom, pointLeftTop];
                    path.push(new StiLinesSegmentGeom(points));
                    path.push(new StiCloseFigureSegmentGeom());
                    return path;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Funnel");
                }
            }
            Chart.StiFunnelSeriesCoreXF = StiFunnelSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiCloseFigureSegmentGeom = Stimulsoft.Base.Context.StiCloseFigureSegmentGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var List = Stimulsoft.System.Collections.List;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiFunnelWeightedSlicesSeriesCoreXF extends Chart.StiSeriesCoreXF {
                constructor(series) {
                    super(series);
                }
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let funnelSeries = this.series;
                    if (funnelSeries.allowApplyStyle) {
                        funnelSeries.brush = style.core.getColumnBrush(color);
                        funnelSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                isNotNullValues(seriesArray) {
                    for (let series of seriesArray) {
                        for (let value of series.values) {
                            if (value != null)
                                return true;
                        }
                    }
                    return false;
                }
                renderSeries(context, rect, geom, seriesArray) {
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null || (seriesArray != null && !this.isNotNullValues(seriesArray))) {
                        this.renderFunnelEmpty(geom, rect);
                        return;
                    }
                    let funnelSeriesArray = seriesArray.stimulsoft().toList().cast().stimulsoft().toArray();
                    let colorCount = 0;
                    for (let ser of seriesArray) {
                        if (ser.values != null) {
                            colorCount += ser.values.length;
                        }
                    }
                    if (colorCount == 0) {
                        this.renderFunnelEmpty(geom, rect);
                        return;
                    }
                    let listLabelsGeom = new List();
                    let allValues = this.getAllValues(funnelSeriesArray);
                    let allTrueValues = this.getAllTrueValues(funnelSeriesArray);
                    let singleValueHeight = rect.height * 0.9 / this.getSumValues(allTrueValues);
                    let globalIndex = 0;
                    let colorIndex = 0;
                    let centerAxis;
                    if (this.labels != null && this.labels.is(Chart.StiOutsideLeftFunnelLabels))
                        centerAxis = rect.width / 2 + rect.x;
                    else
                        centerAxis = rect.width / 2;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    for (let ser of seriesArray) {
                        let funnelSeries = ser;
                        let values = this.getValues(funnelSeries);
                        this.labels = this.series.chart.seriesLabels.stimulsoft().as(Chart.StiFunnelSeriesLabels);
                        let REFnonZeroValuesCount = { ref: null };
                        let REFfirstNonZeroValueIndex = { ref: null };
                        let REFfirstNonZeroSeries = { ref: null };
                        this.checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries);
                        let nonZeroValuesCount = REFnonZeroValuesCount.ref;
                        let firstNonZeroValueIndex = REFfirstNonZeroValueIndex.ref;
                        if (nonZeroValuesCount == 0) {
                        }
                        else if (nonZeroValuesCount == 1) {
                            let seriesBrush = funnelSeries.brush;
                            if (funnelSeries.allowApplyBrush) {
                                seriesBrush = funnelSeries.core.getSeriesBrush(firstNonZeroValueIndex, funnelSeries.values.length);
                                seriesBrush = funnelSeries.processSeriesBrushes(firstNonZeroValueIndex, seriesBrush);
                            }
                            let borderColor = funnelSeries.borderColor;
                            if (funnelSeries.allowApplyBorderColor) {
                                borderColor = funnelSeries.core.getSeriesBorderColor(globalIndex, colorCount);
                            }
                            let funnelElementGeom = this.renderFunnelElement(borderColor, seriesBrush, funnelSeries.values[firstNonZeroValueIndex], allValues, globalIndex, firstNonZeroValueIndex, funnelSeries, geom, rect, singleValueHeight, new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks));
                            if (funnelElementGeom != null) {
                                if (funnelSeries.core.interaction != null) {
                                    let interaction = new StiSeriesInteractionData();
                                    interaction.fill(geom.area, funnelSeries, firstNonZeroValueIndex);
                                    funnelElementGeom.interaction = interaction;
                                }
                                geom.createChildGeoms();
                                geom.childGeoms.push(funnelElementGeom);
                            }
                        }
                        else {
                            for (let index = 0; index < values.length; index++) {
                                let value = values[index];
                                if (!funnelSeries.showZeros && value == 0) {
                                    globalIndex++;
                                    continue;
                                }
                                let seriesBrush = funnelSeries.brush;
                                if (funnelSeries.allowApplyBrush) {
                                    seriesBrush = funnelSeries.core.getSeriesBrush(globalIndex, colorCount);
                                    seriesBrush = funnelSeries.processSeriesBrushes(globalIndex, seriesBrush);
                                }
                                let borderColor = funnelSeries.borderColor;
                                if (funnelSeries.allowApplyBorderColor) {
                                    borderColor = funnelSeries.core.getSeriesBorderColor(globalIndex, colorCount);
                                }
                                let funnelElementGeom = this.renderFunnelElement(borderColor, seriesBrush, value, allValues, colorIndex, index, ser, geom, rect, singleValueHeight, new TimeSpan(beginTime.ticks / ser.values.length * index));
                                if (funnelElementGeom != null) {
                                    if (ser.core.interaction != null) {
                                        let data = new StiSeriesInteractionData();
                                        data.fill(geom.area, ser, index);
                                        funnelElementGeom.interaction = data;
                                    }
                                    geom.createChildGeoms();
                                    geom.childGeoms.push(funnelElementGeom);
                                }
                                if (this.labels != null && this.labels.visible) {
                                    let valueNext = (globalIndex == allTrueValues.length - 1) ? value : allTrueValues[index + 1];
                                    if (this.labels.step == 0 || index % this.labels.step == 0) {
                                        let REFmeasureRect = { ref: rect };
                                        let seriesLabelsGeom = this.labels.core.renderLabel(funnelSeries, context, globalIndex, value, valueNext, this.getArgumentText(funnelSeries, index), funnelSeries.core.getTag(index), globalIndex, colorCount, rect, singleValueHeight, 0, centerAxis, REFmeasureRect);
                                        rect = REFmeasureRect.ref;
                                        if (seriesLabelsGeom != null) {
                                            listLabelsGeom.push(seriesLabelsGeom);
                                        }
                                    }
                                }
                                colorIndex++;
                                globalIndex++;
                            }
                        }
                    }
                    for (let label of listLabelsGeom) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(label);
                        label.clientRectangle = this.checkLabelsRect(this.labels, geom, label.clientRectangle);
                    }
                }
                checkNonZerovalue(seriesArray, REFnonZeroValuesCount, REFfirstNonZeroValueIndex, REFfirstNonZeroSeries, isForValueFrom = false) {
                    let nonZeroValuesCountTemp = 0;
                    let firstNonZeroValueIndexTemp = 0;
                    let firstNonZeroValueIndexTemp1 = 0;
                    let firstNonZeroValue = 0;
                    let firstNonZeroSeriesTemp = null;
                    for (let ser of seriesArray) {
                        let values = isForValueFrom ? ser.valuesStart : ser.values;
                        for (let value of values) {
                            if (!(value == 0 || value == null || isNaN(value))) {
                                nonZeroValuesCountTemp++;
                                firstNonZeroValue = value;
                                firstNonZeroSeriesTemp = ser;
                                if (nonZeroValuesCountTemp == 1)
                                    firstNonZeroValueIndexTemp1 = firstNonZeroValueIndexTemp;
                            }
                            firstNonZeroValueIndexTemp++;
                        }
                    }
                    REFnonZeroValuesCount.ref = nonZeroValuesCountTemp;
                    REFfirstNonZeroValueIndex.ref = firstNonZeroValueIndexTemp1;
                    REFfirstNonZeroSeries.ref = firstNonZeroSeriesTemp;
                    return firstNonZeroValue;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                    let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                    return styleCore.getColumnBorder(color);
                }
                getSeriesBrush(colorIndex, colorCount) {
                    if (this.series.chart == null || this.series.chart.area == null)
                        return null;
                    let styleCore = this.series.chart.style != null ? this.series.chart.style.core : new Chart.StiStyleCoreXF29();
                    let color = styleCore.getColorByIndex(colorIndex, colorCount, this.seriesColors);
                    let seriesBrush = styleCore.getColumnBrush(color);
                    return seriesBrush;
                }
                getAllValues(funnelSeries) {
                    let values = new List();
                    for (let series of funnelSeries) {
                        for (let value of series.values) {
                            if (value == 0 && !series.showZeros)
                                continue;
                            values.push(value);
                        }
                    }
                    return values.stimulsoft().toArray();
                }
                getAllTrueValues(funnelSeries) {
                    let values = new List();
                    for (let series of funnelSeries) {
                        for (let value of series.values) {
                            {
                                values.push(value);
                            }
                        }
                    }
                    return values.stimulsoft().toArray();
                }
                getValues(funnelSeries) {
                    let values = [];
                    for (let value of funnelSeries.values) {
                        if (!funnelSeries.showZeros && value == 0)
                            continue;
                        values.push(value);
                    }
                    return values.stimulsoft().toArray();
                }
                getArgumentText(series, index) {
                    let seriesArgumentsKeys = series.arguments.stimulsoft().getKeys();
                    if (series.arguments.length > index && series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys) != null) {
                        return series.arguments.stimulsoft().getByIndex(index, seriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                renderFunnelEmpty(geom, rect) {
                    let values = [3, 2, 1];
                    let singleValueHeight = rect.height * 0.9 / this.getSumValues(values);
                    for (let index = 0; index < values.length; index++) {
                        let path = this.measureFunnelElementCore(index, rect, singleValueHeight, values);
                        geom.createChildGeoms();
                        geom.childGeoms.push(new Chart.StiFunnelEmptySeriesElementGeom(rect, path.stimulsoft().toList()));
                    }
                }
                getPathFunnelEmpty(rect) {
                    let path = new List();
                    let indent = rect.height * 0.05;
                    let center = rect.width / 2;
                    let pointLeftTop = new PointD(center - rect.width * 0.9 / 2, indent);
                    let pointRightTop = new PointD(center + rect.width * 0.9 / 2, indent);
                    let pointLeftInflection = new PointD(center - rect.width * 0.1 / 2, rect.height + indent - rect.height / 5);
                    let pointRightInflection = new PointD(center + rect.width * 0.1 / 2, rect.height + indent - rect.height / 5);
                    let pointRightBottom = new PointD(center + rect.width * 0.1 / 2, rect.height + indent);
                    let pointLeftBottom = new PointD(center - rect.width * 0.1 / 2, rect.height + indent);
                    let points = [pointLeftTop, pointRightTop, pointRightInflection, pointRightBottom, pointLeftBottom, pointLeftInflection];
                    path.push(new StiLinesSegmentGeom(points));
                    path.push(new StiCloseFigureSegmentGeom());
                    return path;
                }
                renderFunnelElement(borderColor, brush, value, values, globalIndex, index, currentSeries, geom, rect, singleValueHeight, beginTime) {
                    let path = this.measureFunnelElementCore(globalIndex, rect, singleValueHeight, values);
                    return new Chart.StiFunnelSeriesElementGeom(geom, value, index, currentSeries, rect, brush, borderColor, path, beginTime);
                }
                getSumValues(values) {
                    let sumValues = 0;
                    for (let value of values) {
                        sumValues += Math.abs(value);
                    }
                    return sumValues;
                }
                getSumLastValues(indexCurrent, values) {
                    let sumLastValues = 0;
                    for (let index = 0; index < indexCurrent; index++) {
                        if (index >= values.length)
                            break;
                        sumLastValues += Math.abs(values[index]);
                    }
                    return sumLastValues;
                }
                measureFunnelElementCore(index, rect, singleValueHeight, values) {
                    let path = [];
                    let indent = rect.height * 0.05;
                    let center;
                    if (this.labels != null && this.labels.is(Chart.StiOutsideLeftFunnelLabels))
                        center = rect.width / 2 + rect.x;
                    else
                        center = rect.width / 2;
                    let pointLeftTop;
                    let pointRightTop;
                    let pointLeftInflection = new PointD();
                    let pointRightInflection = new PointD();
                    let pointRightBottom;
                    let pointLeftBottom;
                    let isInflection = false;
                    let sumLastValues = this.getSumLastValues(index, values);
                    let isInflectionValue = false;
                    let valueHeight = rect.height - singleValueHeight * sumLastValues;
                    if (valueHeight < rect.height / 5) {
                        valueHeight = rect.height / 5;
                        isInflectionValue = true;
                    }
                    let valueWidth = rect.width * 0.9 * valueHeight / rect.height;
                    pointLeftTop = new PointD(center - valueWidth / 2, singleValueHeight * sumLastValues + indent);
                    pointRightTop = new PointD(center + valueWidth / 2, singleValueHeight * sumLastValues + indent);
                    sumLastValues = this.getSumLastValues(index + 1, values);
                    valueHeight = rect.height - singleValueHeight * sumLastValues;
                    if (valueHeight < rect.height / 5) {
                        valueHeight = rect.height / 5;
                        if (!isInflectionValue) {
                            valueWidth = rect.width * 0.9 * valueHeight / rect.height;
                            pointLeftInflection = new PointD(center - valueWidth / 2, rect.height + indent - valueHeight);
                            pointRightInflection = new PointD(center + valueWidth / 2, rect.height + indent - valueHeight);
                            isInflection = true;
                        }
                    }
                    valueWidth = rect.width * 0.9 * valueHeight / rect.height;
                    pointRightBottom = new PointD(center + valueWidth / 2, singleValueHeight * sumLastValues + indent);
                    pointLeftBottom = new PointD(center - valueWidth / 2, singleValueHeight * sumLastValues + indent);
                    let points;
                    if (isInflection)
                        points = [pointLeftTop, pointRightTop, pointRightInflection, pointRightBottom, pointLeftBottom, pointLeftInflection, pointLeftTop];
                    else
                        points = [pointLeftTop, pointRightTop, pointRightBottom, pointLeftBottom, pointLeftTop];
                    path.push(new StiLinesSegmentGeom(points));
                    path.push(new StiCloseFigureSegmentGeom());
                    return path;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "FunnelWeightedSlices");
                }
            }
            Chart.StiFunnelWeightedSlicesSeriesCoreXF = StiFunnelWeightedSlicesSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiGanttSeriesCoreXF extends Chart.StiClusteredBarSeriesCoreXF {
                renderSeries(context, rect, geom, series) {
                    let seriesLabelsList = [];
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let ganttArea = geom.area;
                    let posX = ganttArea.axisCore.getDividerX();
                    let posY = ganttArea.axisCore.getDividerY();
                    for (let currSeries of series) {
                        let valuesCount = currSeries.values.length;
                        if (currSeries.valuesEnd.length < valuesCount)
                            valuesCount = currSeries.valuesEnd.length;
                        let argumentsCount = currSeries.arguments.length;
                        let count = Math.min(valuesCount, argumentsCount);
                        let colorIndex = argumentsCount - 1;
                        let index = 0;
                        let currSeriesArgumentsKeys = currSeries.arguments.stimulsoft().getKeys();
                        while (index < count) {
                            let nullableValue = currSeries.values[index];
                            let nullableValueEnd = currSeries.valuesEnd[index];
                            if (nullableValue == null)
                                nullableValue = 0;
                            if (nullableValueEnd == null)
                                nullableValueEnd = 0;
                            let seriesWidth = Math.abs(nullableValue - nullableValueEnd) * ganttArea.xAxis.info.dpi;
                            let seriesLeftPos = posX;
                            let value = Math.min(nullableValue, nullableValueEnd);
                            if (ganttArea.reverseHor)
                                seriesLeftPos -= value * ganttArea.xAxis.info.dpi + seriesWidth;
                            else
                                seriesLeftPos += value * ganttArea.xAxis.info.dpi;
                            let argumentIndex = ganttArea.yAxis.info.stripLines.count - 1;
                            for (let line of ganttArea.yAxis.info.stripLines.list) {
                                let currValue = currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys);
                                if (currValue == null && line.valueObject == null || currValue != null && line.valueObject != null && currValue.toString() == line.valueObject.toString())
                                    break;
                                argumentIndex--;
                            }
                            if (ganttArea.reverseVert)
                                argumentIndex = ganttArea.yAxis.info.stripLines.count - 1 - argumentIndex;
                            let seriesHeight = ganttArea.yAxis.info.step / 2;
                            let seriesTopPos = posY - seriesHeight / 2;
                            if (ganttArea.reverseVert)
                                seriesTopPos += ganttArea.yAxis.info.step * argumentIndex;
                            else
                                seriesTopPos -= ganttArea.yAxis.info.step * argumentIndex;
                            let seriesRect = new RectangleD(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                            let seriesRectFrom = RectangleD.fromLTRB(seriesRect.left, seriesRect.top, seriesRect.left, seriesRect.bottom);
                            let seriesBrush = currSeries.core.getSeriesBrush(colorIndex, count);
                            let brush = currSeries.processSeriesBrushes(colorIndex, seriesBrush);
                            let seriesGeom = new Chart.StiGanttSeriesElementGeom(geom, value, index, currSeries, seriesRect, seriesRectFrom, brush);
                            if (currSeries.core.interaction != null) {
                                let data = new StiSeriesInteractionData();
                                data.fill(ganttArea, currSeries, index);
                                seriesGeom.interaction = data;
                            }
                            geom.createChildGeoms();
                            geom.childGeoms.push(seriesGeom);
                            let labels = currSeries.core.getSeriesLabels();
                            if (labels != null && labels.visible) {
                                if (labels.is(Chart.StiValueAxisLabels)) {
                                    let pointValueEndLabels = new PointD(seriesLeftPos, seriesTopPos + seriesHeight / 2);
                                    let pointValueLabels = new PointD(seriesLeftPos + seriesWidth, seriesTopPos + seriesHeight / 2);
                                    if (labels.step == 0 || (index % labels.step == 0)) {
                                        if (nullableValueEnd < nullableValue) {
                                            let temp = nullableValue;
                                            nullableValue = nullableValueEnd;
                                            nullableValueEnd = temp;
                                        }
                                        let seriesValueLabelsGeom = labels.core.renderLabel(currSeries, context, pointValueLabels, pointValueLabels, index, nullableValueEnd, nullableValueEnd, currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currSeries.core.getTag(index), 0, 1, rect);
                                        let seriesValueEndLabelsGeom = labels.core.renderLabel(currSeries, context, pointValueEndLabels, pointValueEndLabels, index, nullableValue, nullableValue, currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currSeries.core.getTag(index), 0, 1, rect);
                                        if (seriesValueEndLabelsGeom != null) {
                                            seriesLabelsList.push(seriesValueEndLabelsGeom);
                                            seriesValueEndLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesValueEndLabelsGeom.clientRectangle.clone());
                                        }
                                        if (seriesValueLabelsGeom != null) {
                                            seriesLabelsList.push(seriesValueLabelsGeom);
                                            seriesValueLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesValueLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                                else if (!(labels.is(Chart.StiNoneLabels))) {
                                    let pointValueEndLabels;
                                    let pointValueLabels;
                                    if (labels.is(Chart.StiCenterAxisLabels)) {
                                        pointValueEndLabels = new PointD(seriesLeftPos, seriesTopPos + seriesHeight / 2);
                                        pointValueLabels = new PointD(seriesLeftPos + seriesWidth, seriesTopPos + seriesHeight / 2);
                                    }
                                    else {
                                        pointValueEndLabels = new PointD(seriesLeftPos + seriesWidth / 2, seriesTopPos);
                                        pointValueLabels = new PointD(seriesLeftPos + seriesWidth / 2, seriesTopPos);
                                    }
                                    let seriesValue = value;
                                    if (labels.step == 0 || (index % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currSeries, context, pointValueLabels, pointValueEndLabels, index, value, seriesValue, currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currSeries.core.getTag(index), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            seriesLabelsList.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                            }
                            colorIndex = colorIndex - 1;
                            index++;
                        }
                    }
                    for (let seriesLabelsGeom of seriesLabelsList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Gantt");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiGanttSeriesCoreXF = StiGanttSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            var SizeD = Stimulsoft.System.Drawing.Size;
            class DataPictorial {
                constructor(value, series, index) {
                    this.value = value;
                    this.series = series;
                    this.index = index;
                }
            }
            Chart.DataPictorial = DataPictorial;
            class StiPictorialSeriesCoreXF extends Chart.StiSeriesCoreXF {
                constructor(series) {
                    super(series);
                    this.singleSizeConst = new SizeD(25, 25);
                }
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    if (this.series.allowApplyStyle) {
                        this.series.brush = style.core.getColumnBrush(color);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Pictorial");
                }
                getSingleSize(context) {
                    return new SizeD(this.singleSizeConst.width * context.options.zoom, this.singleSizeConst.height * context.options.zoom);
                }
                renderSeries(context, rect, geom, seriesArray) {
                    let singleSize = this.getSingleSize(context);
                    let countElementsWidth = Math.floor(rect.width / singleSize.width);
                    let countElementsHeight = Math.floor(rect.height / singleSize.height);
                    let rectWidth = countElementsWidth * singleSize.width;
                    let rectHeight = countElementsHeight * singleSize.height;
                    let rectX = rect.x + (rect.width - rectWidth) / 2;
                    let rectY = rect.y + (rect.height - rectHeight) / 2;
                    let rectSeries = new RectangleD(rectX, rectY, rectWidth, rectHeight);
                    let countElemets = countElementsWidth * countElementsHeight;
                    let area = this.series.chart.area;
                    let datas = [];
                    for (let series of seriesArray) {
                        let ser = series.stimulsoft().as(Chart.StiPictorialSeries);
                        let indexSer = 0;
                        for (let value of series.values) {
                            let val = value == null ? 0 : area.roundValues ? Math.round(value) : value;
                            datas.push(new DataPictorial(Math.abs(val), ser, indexSer));
                            indexSer++;
                        }
                    }
                    let sumValues = 0;
                    for (let x of datas) {
                        sumValues += x.value;
                    }
                    let factor = countElemets / sumValues;
                    if (factor > 1 && area.actual)
                        factor = 1;
                    let startPointValueRect = new PointD(rectSeries.x, rectSeries.y);
                    let deltaValue = 0;
                    for (let index = 0; index < datas.length; index++) {
                        let value = Math.abs(datas[index].value);
                        if (value == 0)
                            continue;
                        let currentFactorValue = factor * value;
                        let elementValue = area.roundValues ? this.roundPictirialValue(currentFactorValue, deltaValue) : currentFactorValue;
                        deltaValue += currentFactorValue - elementValue;
                        let squareElement = elementValue * singleSize.width * singleSize.height;
                        let sumWidthSquareElement = squareElement / singleSize.height;
                        let restWidthSquareElement = sumWidthSquareElement;
                        let drawRectangles = [];
                        let clipRectangles = [];
                        do {
                            let curWidth = 0;
                            let curStartPoint = startPointValueRect;
                            let currentRowWidth = rectSeries.right - startPointValueRect.x;
                            if (currentRowWidth > restWidthSquareElement) {
                                curWidth = restWidthSquareElement;
                                startPointValueRect = new PointD(startPointValueRect.x + restWidthSquareElement, startPointValueRect.y);
                            }
                            else {
                                curWidth = currentRowWidth;
                                startPointValueRect = new PointD(rectSeries.x, startPointValueRect.y + singleSize.height);
                            }
                            restWidthSquareElement -= curWidth;
                            let mod = (curStartPoint.x - rectSeries.x) / singleSize.width;
                            let delta = (mod - Math.floor(mod)) * singleSize.width;
                            let curRect = new RectangleD(curStartPoint.x - delta, curStartPoint.y, curWidth + delta, singleSize.height);
                            let clipRect = new RectangleD(curStartPoint.x, curStartPoint.y, curWidth, singleSize.height);
                            drawRectangles.push(curRect);
                            clipRectangles.push(clipRect);
                        } while (restWidthSquareElement > 0 && startPointValueRect.y < rectSeries.bottom);
                        let seriesPictorialElementGeom = new Chart.StiPictorialSeriesElementGeom(geom, value, datas[index].index, this.getSeriesBrush(index, datas.length), datas[index].series, datas[index].series.icon, drawRectangles, clipRectangles, rect, null);
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesPictorialElementGeom);
                    }
                }
                roundPictirialValue(currentFactorValue, deltaValue) {
                    if (deltaValue > 0)
                        return Math.ceil(currentFactorValue);
                    else if (deltaValue < 0)
                        return Math.floor(currentFactorValue);
                    else
                        return Math.round(currentFactorValue);
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return this.series.brush;
                    return brush;
                }
            }
            Chart.StiPictorialSeriesCoreXF = StiPictorialSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiRadarSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let radarSeries = this.series;
                    if (radarSeries.allowApplyStyle) {
                        if (radarSeries.marker != null) {
                            radarSeries.marker.brush = new StiSolidBrush(StiColorUtils.light(color, 100));
                            radarSeries.marker.borderColor = StiColorUtils.dark(color, 100);
                        }
                    }
                }
                getPointsList(values, geom, seriesArray) {
                    let pointsList = [];
                    let area = geom.area;
                    let core = area.core;
                    for (let series of seriesArray) {
                        let points = [];
                        pointsList.push(points);
                        let pointIndex = 0;
                        for (let curPoint of core.points) {
                            let value = pointIndex < series.values.length ? series.values[pointIndex] : null;
                            if (value == null && series.showNulls)
                                value = 0;
                            if (value == null) {
                                points.push(null);
                            }
                            else {
                                if (value != null)
                                    value = (value - area.yAxis.info.minimum) * area.yAxis.info.dpi;
                                let point = new PointD(core.centerPoint.x + value * curPoint.x, core.centerPoint.y + value * curPoint.y);
                                point.x -= geom.clientRectangle.x;
                                point.y -= geom.clientRectangle.y;
                                points.push(point);
                            }
                            pointIndex++;
                        }
                    }
                    return pointsList;
                }
                renderSeries(context, rect, geom, seriesArray) {
                    if (seriesArray == null || seriesArray.length == 0 || this.series.chart == null)
                        return;
                    let pointsList = this.getPointsList(this.series.values, geom, seriesArray);
                    let pointsListFrom = this.getPointsList(this.series.valuesStart, geom, seriesArray);
                    let seriesIndex = 0;
                    for (let series of seriesArray) {
                        let points = pointsList[seriesIndex];
                        points.push(points[0]);
                        let pointsIds = series.arguments.map(a => a);
                        if (pointsIds.length < points.length - 1)
                            pointsIds = points.map((p, i) => i.toString());
                        pointsIds.push(pointsIds[0] + "_e");
                        let pointsFrom = pointsListFrom[seriesIndex];
                        pointsFrom.push(pointsFrom[0]);
                        let centerPoint = new PointD(geom.clientRectangle.width / 2, geom.clientRectangle.height / 2);
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.pointsFrom = pointsFrom.map(p => p != null ? p : centerPoint);
                        pointsInfo.points = points.map(p => p != null ? p : centerPoint);
                        pointsInfo.pointsIds = pointsIds.map(p => p);
                        this.renderAreas(context, series, pointsInfo, geom);
                        this.renderLines(context, series, pointsInfo, geom);
                        points.splice(points.length - 1, 1);
                        this.renderPoints(context, series, points, geom);
                        points.splice(points.length - 1, 1);
                        seriesIndex++;
                    }
                }
                renderAreas(context, series, pointsInfo, geom) {
                }
                renderLines(context, series, pointsInfo, geom) {
                }
                renderPoints(context, series, points, geom) {
                    let pointIndex = 0;
                    for (let point of points) {
                        if (point != null) {
                            let value = pointIndex < series.values.length ? series.values[pointIndex] : null;
                            let radarGeom = new Chart.StiRadarPointSeriesElementGeom(geom, value, pointIndex, series.marker.brush, series, point, context.options.zoom);
                            if (geom != null) {
                                geom.createChildGeoms();
                                geom.childGeoms.push(radarGeom);
                            }
                            let labels = series.core.getSeriesLabels();
                            if (labels != null && labels.visible && value != null) {
                                let startPoint = point;
                                if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                    let seriesLabelsGeom = labels.core.renderLabel(series, context, startPoint, startPoint, pointIndex, value, value, this.getArgument(series, pointIndex), series.core.getTag(pointIndex), 0, 1, geom.clientRectangle);
                                    if (seriesLabelsGeom != null) {
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(seriesLabelsGeom);
                                        seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                    }
                                }
                            }
                        }
                        pointIndex++;
                    }
                }
                getArgument(series, pointIndex) {
                    let seriesArgumentsKeys = series.arguments.stimulsoft().getKeys();
                    if (series.arguments.length > pointIndex)
                        return series.arguments.stimulsoft().getByIndex(pointIndex, seriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    else
                        return "";
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return new StiSolidBrush(StiColorUtils.dark(Color.white, 20));
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return Color.black;
                    return color;
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRadarSeriesCoreXF = StiRadarSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarAreaSeriesCoreXF extends Chart.StiRadarSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let radarSeries = this.series;
                    if (radarSeries.allowApplyStyle) {
                        radarSeries.brush = style.core.getAreaBrush(color);
                        radarSeries.lineColor = color;
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarArea");
                }
                renderLines(context, series, pointsInfo, geom) {
                    let radarGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, series);
                    if (geom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(radarGeom);
                    }
                }
                renderAreas(context, series, pointsInfo, geom) {
                    let radarGeom = new Chart.StiRadarAreaSeriesGeom(series, pointsInfo);
                    if (geom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(radarGeom);
                    }
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRadarAreaSeriesCoreXF = StiRadarAreaSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarLineSeriesCoreXF extends Chart.StiRadarSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let radarSeries = this.series;
                    if (radarSeries.allowApplyStyle) {
                        radarSeries.lineColor = color;
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarLine");
                }
                renderLines(context, series, pointsInfo, geom) {
                    let radarGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, series);
                    if (geom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(radarGeom);
                    }
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRadarLineSeriesCoreXF = StiRadarLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiRadarPointSeriesCoreXF extends Chart.StiRadarSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let series = this.series.stimulsoft().as(Chart.StiRadarPointSeries);
                    if (series.allowApplyStyle) {
                        if (!style.core.markerVisible) {
                            series.marker.visible = true;
                        }
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "RadarPoint");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRadarPointSeriesCoreXF = StiRadarPointSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiRangeBarSeriesCoreXF extends Chart.StiClusteredColumnSeriesCoreXF {
                renderSeries(context, rect, geom, series) {
                    var _a, _b;
                    let seriesLabelsList = [];
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let rangeArea = geom.area;
                    let posX = rangeArea.axisCore.getDividerX();
                    let posY = rangeArea.axisCore.getDividerY();
                    for (let currSeries of series) {
                        let valuesCount = currSeries.values.length;
                        if (currSeries.valuesEnd.length < valuesCount)
                            valuesCount = currSeries.valuesEnd.length;
                        let argumentsCount = currSeries.arguments.length;
                        let count = Math.min(valuesCount, argumentsCount);
                        let colorIndex = rangeArea.reverseHor ? count - 1 : 0;
                        let index = 0;
                        let currSeriesArgumentsKeys = currSeries.arguments.stimulsoft().getKeys();
                        while (index < count) {
                            let nullableValue = currSeries.values[index];
                            let nullableValueEnd = currSeries.valuesEnd[index];
                            if (nullableValue == null)
                                nullableValue = 0;
                            if (nullableValueEnd == null)
                                nullableValueEnd = 0;
                            let seriesHeight = Math.abs(nullableValue - nullableValueEnd) * rangeArea.yAxis.info.dpi;
                            let seriesTopPos = posY;
                            let value = Math.max(nullableValue, nullableValueEnd);
                            if (rangeArea.reverseVert)
                                seriesTopPos += Math.min(nullableValue, nullableValueEnd) * rangeArea.yAxis.info.dpi;
                            else
                                seriesTopPos -= value * rangeArea.yAxis.info.dpi;
                            let argumentIndex = rangeArea.xAxis.info.stripLines.count - 1;
                            for (let line of rangeArea.xAxis.info.stripLines.list) {
                                if (((_a = currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys)) === null || _a === void 0 ? void 0 : _a.toString()) == ((_b = line.valueObject) === null || _b === void 0 ? void 0 : _b.toString()))
                                    break;
                                argumentIndex--;
                            }
                            argumentIndex = rangeArea.xAxis.info.stripLines.count - 1 - argumentIndex;
                            let seriesWidth = ((rangeArea.xAxis.info.step - rangeArea.xAxis.info.step * (1 - currSeries.width)) / series.length);
                            let seriesLeftPos = posX - seriesWidth / 2;
                            seriesLeftPos += rangeArea.xAxis.info.step * argumentIndex;
                            let seriesRect = new RectangleD(seriesLeftPos, seriesTopPos, seriesWidth, seriesHeight);
                            let seriesRectFrom = RectangleD.fromLTRB(seriesRect.left, seriesRect.bottom, seriesRect.right, seriesRect.bottom);
                            let seriesBrush = currSeries.core.getSeriesBrush(colorIndex, count);
                            let brush = currSeries.processSeriesBrushes(colorIndex, seriesBrush);
                            let seriesGeom = new Chart.StiRangeBarElementGeom(geom, value, index, currSeries, brush, seriesRect, seriesRectFrom);
                            if (currSeries.core.interaction != null) {
                                let data = new StiSeriesInteractionData();
                                data.fill(rangeArea, currSeries, index);
                                seriesGeom.interaction = data;
                            }
                            geom.createChildGeoms();
                            geom.childGeoms.push(seriesGeom);
                            let labels = currSeries.core.getSeriesLabels();
                            if (labels != null && labels.visible) {
                                let pointValueEndLabels = new PointD(seriesLeftPos + seriesWidth / 2, seriesTopPos);
                                let pointValueLabels = new PointD(seriesLeftPos + seriesWidth / 2, seriesTopPos + seriesHeight);
                                if (labels.step == 0 || (index % labels.step == 0)) {
                                    if (nullableValueEnd < nullableValue) {
                                        let temp = nullableValue;
                                        nullableValue = nullableValueEnd;
                                        nullableValueEnd = temp;
                                    }
                                    let seriesValueLabelsGeom = labels.core.renderLabel(currSeries, context, pointValueLabels, pointValueLabels, index, nullableValue, nullableValue, currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currSeries.core.getTag(index), 0, 1, rect);
                                    let seriesValueEndLabelsGeom = labels.core.renderLabel(currSeries, context, pointValueEndLabels, pointValueEndLabels, index, nullableValueEnd, nullableValueEnd, currSeries.arguments.stimulsoft().getByIndex(index, currSeriesArgumentsKeys).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator), currSeries.core.getTag(index), 0, 1, rect);
                                    if (seriesValueEndLabelsGeom != null) {
                                        seriesLabelsList.push(seriesValueEndLabelsGeom);
                                        seriesValueEndLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesValueEndLabelsGeom.clientRectangle.clone());
                                    }
                                    if (seriesValueLabelsGeom != null) {
                                        seriesLabelsList.push(seriesValueLabelsGeom);
                                        seriesValueLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesValueLabelsGeom.clientRectangle.clone());
                                    }
                                }
                            }
                            colorIndex = rangeArea.reverseHor ? colorIndex - 1 : colorIndex + 1;
                            index++;
                        }
                    }
                    for (let seriesLabelsGeom of seriesLabelsList) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesLabelsGeom);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "RangeBar");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRangeBarSeriesCoreXF = StiRangeBarSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiRangeSeriesCoreXF extends Chart.StiLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let rangeArea = geom.area;
                    let axisArea = geom.area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    for (let currentSeries of series) {
                        let valuesCount = Math.min(currentSeries.values.length, currentSeries.valuesEnd.length);
                        let points = StiArray.create(PointD, valuesCount, true);
                        let pointsEnd = StiArray.create(PointD, valuesCount, true);
                        let pointsIds = StiArray.create(String, valuesCount, true);
                        if (currentSeries.valuesEnd.length < valuesCount)
                            valuesCount = currentSeries.valuesEnd.length;
                        for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                            let value = rangeArea.reverseHor ?
                                currentSeries.values[valuesCount - pointIndex - 1] :
                                currentSeries.values[pointIndex];
                            let valueEnd = rangeArea.reverseHor ?
                                currentSeries.valuesEnd[valuesCount - pointIndex - 1] :
                                currentSeries.valuesEnd[pointIndex];
                            if (value == valueEnd) {
                                points[pointIndex] = pointsEnd[pointIndex] = this.getYPoint(value, currentSeries, rangeArea, pointIndex);
                            }
                            else {
                                points[pointIndex] = this.getYPoint(value, currentSeries, rangeArea, pointIndex);
                                pointsEnd[pointIndex] = this.getYPoint(valueEnd, currentSeries, rangeArea, pointIndex);
                            }
                            let argId = getStartFromZero ?
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex + 1).valueObject :
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex).valueObject;
                            pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                        }
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.points = points;
                        pointsInfo.pointsEnd = pointsEnd;
                        pointsInfo.pointsIds = pointsIds;
                        let pointsInfoEnd = new Chart.StiSeriesPointsInfo();
                        pointsInfoEnd.points = pointsEnd;
                        pointsInfoEnd.pointsIds = pointsIds;
                        pointsInfoEnd.additionalSeriesId = "_e";
                        this.renderAreas2(geom, pointsInfo, currentSeries);
                        this.renderLines2(context, geom, pointsInfo, currentSeries.values, currentSeries);
                        this.renderLines2(context, geom, pointsInfoEnd, currentSeries.valuesEnd, currentSeries);
                        let posY = 0;
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                                let value = axisArea.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                let valueEnd = axisArea.reverseHor ?
                                    currentSeries.valuesEnd[currentSeries.valuesEnd.length - pointIndex - 1] :
                                    currentSeries.valuesEnd[pointIndex];
                                if (value == null && currentSeries.showNulls)
                                    value = 0;
                                if (valueEnd == null && currentSeries.showNulls)
                                    value = 0;
                                let seriesValue = value;
                                if (rangeArea.reverseVert && value != null)
                                    seriesValue = -seriesValue;
                                let seriesValueEnd = valueEnd;
                                if (rangeArea.reverseVert && valueEnd != null)
                                    seriesValueEnd = -seriesValueEnd;
                                if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    posY = rangeArea.axisCore.getDividerY();
                                else
                                    posY = rangeArea.axisCore.getDividerRightY();
                                let endPoint = points[pointIndex];
                                let endPointEnd = pointsEnd[pointIndex];
                                if (endPoint != null) {
                                    let startPoint = new PointD(endPoint.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                                if (endPointEnd != null) {
                                    let startPoint = new PointD(endPointEnd.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPointEnd, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValueEnd, valueEnd, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                renderLines2(context, geom, pointsInfo, values, series) {
                    if (pointsInfo.points != null && pointsInfo.points.length > 1) {
                        let seriesGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, series);
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                        if (this.interaction != null) {
                            seriesGeom.interactions = this.getInteractions(context, geom, pointsInfo.points);
                        }
                    }
                    this.renderMarkers2(context, geom, pointsInfo.points, values, series);
                }
                renderMarkers2(context, geom, points, values, series) {
                    let axisArea = geom.area;
                    let lineSeries = series;
                    if (points.length == 0)
                        return;
                    let isTooltipMarkerMode = !lineSeries.marker.visible && lineSeries.toolTips.length > 0;
                    if (lineSeries.marker != null && (lineSeries.marker.visible || isTooltipMarkerMode)) {
                        let index = 0;
                        let valuesCount = Math.min(lineSeries.values.length, lineSeries.valuesEnd.length);
                        for (let point of points) {
                            if (point != null) {
                                let value = axisArea.reverseHor ?
                                    values[valuesCount - index - 1] :
                                    values[index];
                                if (value == null && lineSeries.showNulls)
                                    value = 0;
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                clipRect.inflate(10, 10);
                                let valuePoint = point;
                                valuePoint.x += geom.clientRectangle.x;
                                valuePoint.y += geom.clientRectangle.y;
                                if (clipRect.contains(valuePoint.x, valuePoint.y)) {
                                    let markerGeom = new Chart.StiMarkerGeom(series, index, value, point, lineSeries.marker, lineSeries.showShadow, context.options.zoom, isTooltipMarkerMode);
                                    if (markerGeom != null) {
                                        if (lineSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, lineSeries, index);
                                            markerGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(markerGeom);
                                    }
                                }
                            }
                            index++;
                        }
                    }
                }
                getYPoint(value, currentSeries, axisArea, index) {
                    let point;
                    let posX = axisArea.xAxis.core.getStartFromZero() ?
                        axisArea.xAxis.info.stripPositions[index + 1] :
                        axisArea.xAxis.info.stripPositions[index];
                    if (value == null && !currentSeries.showNulls) {
                        point = null;
                    }
                    else {
                        if (value == null && currentSeries.showNulls)
                            value = 0;
                        if (axisArea.reverseVert && value != null)
                            value = -value;
                        let srY = 0;
                        if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                            srY = -value * axisArea.yAxis.info.dpi + axisArea.axisCore.getDividerY();
                        }
                        else {
                            srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                        }
                        point = new PointD(posX, srY);
                    }
                    return point;
                }
                renderAreas2(geom, pointsInfo, series) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiRangeSeriesGeom(geom, pointsInfo, series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Range");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiRangeSeriesCoreXF = StiRangeSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiSplineRangeSeriesCoreXF extends Chart.StiSplineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let rangeArea = geom.area;
                    let axisArea = geom.area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    for (let currentSeries of series) {
                        let valuesCount = currentSeries.values.length;
                        if (currentSeries.valuesEnd.length < valuesCount)
                            valuesCount = currentSeries.valuesEnd.length;
                        let points = StiArray.create(PointD, valuesCount, true);
                        let pointsEnd = StiArray.create(PointD, valuesCount, true);
                        let pointsIds = StiArray.create(String, valuesCount, true);
                        for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                            let value = rangeArea.reverseHor ?
                                currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                currentSeries.values[pointIndex];
                            let valueEnd = rangeArea.reverseHor ?
                                currentSeries.valuesEnd[currentSeries.values.length - pointIndex - 1] :
                                currentSeries.valuesEnd[pointIndex];
                            points[pointIndex] = this.getYPoint(value, currentSeries, rangeArea, pointIndex);
                            pointsEnd[pointIndex] = this.getYPoint(valueEnd, currentSeries, rangeArea, pointIndex);
                            let argId = getStartFromZero ?
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex + 1).valueObject :
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex).valueObject;
                            pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                        }
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.points = points;
                        pointsInfo.pointsEnd = pointsEnd;
                        pointsInfo.pointsIds = pointsIds;
                        let pointsInfoEnd = new Chart.StiSeriesPointsInfo();
                        pointsInfoEnd.points = pointsEnd;
                        pointsInfoEnd.pointsIds = pointsIds;
                        pointsInfoEnd.additionalSeriesId = "_e";
                        this.renderAreas2(context, geom, pointsInfo, currentSeries);
                        this.renderLines(context, geom, pointsInfo);
                        this.renderLines(context, geom, pointsInfoEnd);
                        let posY = 0;
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                                let value = axisArea.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                let valueEnd = axisArea.reverseHor ?
                                    currentSeries.valuesEnd[currentSeries.valuesEnd.length - pointIndex - 1] :
                                    currentSeries.valuesEnd[pointIndex];
                                if (value == null && currentSeries.showNulls)
                                    value = 0;
                                if (valueEnd == null && currentSeries.showNulls)
                                    value = 0;
                                let seriesValue = value;
                                if (rangeArea.reverseVert && value != null)
                                    seriesValue = -seriesValue;
                                let seriesValueEnd = valueEnd;
                                if (rangeArea.reverseVert && valueEnd != null)
                                    seriesValueEnd = -seriesValueEnd;
                                if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    posY = rangeArea.axisCore.getDividerY();
                                else
                                    posY = rangeArea.axisCore.getDividerRightY();
                                let endPoint = points[pointIndex];
                                let endPointEnd = pointsEnd[pointIndex];
                                if (endPoint != null) {
                                    let startPoint = new PointD(endPoint.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                                if (endPointEnd != null) {
                                    let startPoint = new PointD(endPointEnd.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPointEnd, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValueEnd, valueEnd, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), currentSeries.core.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                getYPoint(value, currentSeries, axisArea, index) {
                    let point;
                    let posX = axisArea.xAxis.core.getStartFromZero() ?
                        axisArea.xAxis.info.stripPositions[index + 1] :
                        axisArea.xAxis.info.stripPositions[index];
                    if (value == null && !currentSeries.showNulls) {
                        point = null;
                    }
                    else {
                        if (value == null && currentSeries.showNulls)
                            value = 0;
                        if (axisArea.reverseVert && value != null)
                            value = -value;
                        let srY = 0;
                        if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                            srY = -value * axisArea.yAxis.info.dpi + axisArea.axisCore.getDividerY();
                        }
                        else {
                            srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                        }
                        point = new PointD(posX, srY);
                    }
                    return point;
                }
                renderAreas2(context, geom, pointsInfo, series) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiSplineRangeSeriesGeom(geom, pointsInfo, series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "SplineRange");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSplineRangeSeriesCoreXF = StiSplineRangeSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiSteppedRangeSeriesCoreXF extends Chart.StiSteppedLineSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let areaSeries = this.series;
                    if (areaSeries.allowApplyStyle) {
                        areaSeries.brush = style.core.getAreaBrush(color);
                    }
                }
                renderSeries(context, rect, geom, series) {
                    if (series == null || series.length == 0 || this.series.chart == null)
                        return;
                    let rangeArea = geom.area;
                    let axisArea = geom.area;
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    for (let currentSeries of series) {
                        let valuesCount = Math.min(currentSeries.values.length, currentSeries.valuesEnd.length);
                        let points = StiArray.create(PointD, valuesCount, true);
                        let pointsEnd = StiArray.create(PointD, valuesCount, true);
                        let pointsIds = StiArray.create(String, valuesCount, true);
                        if (currentSeries.valuesEnd.length < valuesCount)
                            valuesCount = currentSeries.valuesEnd.length;
                        for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                            let value = rangeArea.reverseHor ?
                                currentSeries.values[valuesCount - pointIndex - 1] :
                                currentSeries.values[pointIndex];
                            let valueEnd = rangeArea.reverseHor ?
                                currentSeries.valuesEnd[valuesCount - pointIndex - 1] :
                                currentSeries.valuesEnd[pointIndex];
                            points[pointIndex] = this.getYPoint(value, currentSeries, rangeArea, pointIndex);
                            pointsEnd[pointIndex] = this.getYPoint(valueEnd, currentSeries, rangeArea, pointIndex);
                            let argId = getStartFromZero ?
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex + 1).valueObject :
                                axisArea.xAxis.info.stripLines.getByIndex(pointIndex).valueObject;
                            pointsIds[pointIndex] = argId == null ? "" : argId.stimulsoft().toString();
                        }
                        let pointsInfo = new Chart.StiSeriesPointsInfo();
                        pointsInfo.points = points;
                        pointsInfo.pointsIds = pointsIds;
                        pointsInfo.pointsEnd = pointsEnd;
                        let pointsInfoEnd = new Chart.StiSeriesPointsInfo();
                        pointsInfoEnd.points = pointsEnd;
                        pointsInfoEnd.pointsIds = pointsIds;
                        pointsInfoEnd.additionalSeriesId = "_e";
                        this.renderAreas2(context, geom, pointsInfo, currentSeries);
                        this.renderLines2(context, geom, pointsInfo, currentSeries.values, currentSeries);
                        this.renderLines2(context, geom, pointsInfoEnd, currentSeries.valuesEnd, currentSeries);
                        let posY = 0;
                        let labels = currentSeries.core.getSeriesLabels();
                        if (labels != null && labels.visible) {
                            for (let pointIndex = 0; pointIndex < valuesCount; pointIndex++) {
                                let value = axisArea.reverseHor ?
                                    currentSeries.values[currentSeries.values.length - pointIndex - 1] :
                                    currentSeries.values[pointIndex];
                                let valueEnd = axisArea.reverseHor ?
                                    currentSeries.valuesEnd[currentSeries.valuesEnd.length - pointIndex - 1] :
                                    currentSeries.valuesEnd[pointIndex];
                                if (value == null && currentSeries.showNulls)
                                    value = 0;
                                if (valueEnd == null && currentSeries.showNulls)
                                    value = 0;
                                let seriesValue = value;
                                if (rangeArea.reverseVert && value != null)
                                    seriesValue = -seriesValue;
                                let seriesValueEnd = valueEnd;
                                if (rangeArea.reverseVert && valueEnd != null)
                                    seriesValueEnd = -seriesValueEnd;
                                if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                                    posY = rangeArea.axisCore.getDividerY();
                                else
                                    posY = rangeArea.axisCore.getDividerRightY();
                                let endPoint = points[pointIndex];
                                let endPointEnd = pointsEnd[pointIndex];
                                if (endPoint != null) {
                                    let startPoint = new PointD(endPoint.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPoint, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValue, value, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), this.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                                if (endPointEnd != null) {
                                    let startPoint = new PointD(endPointEnd.x, posY);
                                    if (labels.step == 0 || (pointIndex % labels.step == 0)) {
                                        let seriesLabelsGeom = labels.core.renderLabel(currentSeries, context, this.correctPoint(endPointEnd, rect, currentSeries.labelsOffset * context.options.zoom), this.correctPoint(startPoint, rect, currentSeries.labelsOffset * context.options.zoom), pointIndex, seriesValueEnd, valueEnd, rangeArea.axisCore.getArgumentLabel(rangeArea.xAxis.info.stripLines.getByIndex(pointIndex), currentSeries), this.getTag(pointIndex), 0, 1, rect);
                                        if (seriesLabelsGeom != null) {
                                            geom.createChildGeoms();
                                            geom.childGeoms.push(seriesLabelsGeom);
                                            seriesLabelsGeom.clientRectangle = this.checkLabelsRect(labels, geom, seriesLabelsGeom.clientRectangle.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                renderAreas2(context, geom, pointsInfo, series) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    if (pointsInfo.pointsEnd == null || pointsInfo.pointsEnd.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiSteppedRangeSeriesGeom(geom, pointsInfo, series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                }
                renderLines2(context, geom, pointsInfo, values, series) {
                    let lineSeries = series;
                    if (pointsInfo.points.length > 1 || (lineSeries.pointAtCenter && pointsInfo.points.length > 0)) {
                        let seriesGeom = new Chart.StiSteppedLineSeriesGeom(geom, pointsInfo, series);
                        if (seriesGeom != null) {
                            geom.createChildGeoms();
                            geom.childGeoms.push(seriesGeom);
                        }
                        if (this.interaction != null) {
                            seriesGeom.interactions = this.getInteractions(context, geom, pointsInfo.points);
                        }
                    }
                    this.renderMarkers2(context, geom, pointsInfo.points, values, series);
                }
                renderMarkers2(context, geom, points, values, series) {
                    let axisArea = geom.area;
                    let lineSeries = series;
                    if (points.length == 0)
                        return;
                    let isTooltipMarkerMode = !lineSeries.marker.visible && lineSeries.toolTips.length > 0;
                    if (lineSeries.marker != null && (lineSeries.marker.visible || isTooltipMarkerMode)) {
                        let index = 0;
                        for (let point of points) {
                            if (point != null) {
                                let value = axisArea.reverseHor ?
                                    values[lineSeries.values.length - index - 1] :
                                    values[index];
                                if (value == null && lineSeries.showNulls)
                                    value = 0;
                                let clipRect = geom.view.clientRectangle.clone();
                                clipRect.x = 0;
                                clipRect.y = 0;
                                clipRect.inflate(10, 10);
                                let valuePoint = new PointD(point.x, point.y);
                                valuePoint.x += geom.clientRectangle.x;
                                valuePoint.y += geom.clientRectangle.y;
                                if (clipRect.contains(valuePoint.x, valuePoint.y)) {
                                    let markerGeom = new Chart.StiMarkerGeom(series, index, value, point, lineSeries.marker, lineSeries.showShadow, context.options.zoom, isTooltipMarkerMode);
                                    if (markerGeom != null) {
                                        if (lineSeries.core.interaction != null) {
                                            let data = new StiSeriesInteractionData();
                                            data.fill(axisArea, lineSeries, index);
                                            markerGeom.interaction = data;
                                        }
                                        geom.createChildGeoms();
                                        geom.childGeoms.push(markerGeom);
                                    }
                                }
                            }
                            index++;
                        }
                    }
                }
                getYPoint(value, currentSeries, axisArea, index) {
                    let point;
                    let stripPositionsKeys = axisArea.xAxis.info.stripPositions.stimulsoft().getKeys();
                    let posX = axisArea.xAxis.core.getStartFromZero() ?
                        axisArea.xAxis.info.stripPositions.stimulsoft().getByIndex(index + 1, stripPositionsKeys) :
                        axisArea.xAxis.info.stripPositions.stimulsoft().getByIndex(index, stripPositionsKeys);
                    if (value == null && !currentSeries.showNulls) {
                        point = null;
                    }
                    else {
                        if (value == null && currentSeries.showNulls)
                            value = 0;
                        if (axisArea.reverseVert && value != null)
                            value = -value;
                        let srY = 0;
                        if (currentSeries.yAxis == Chart.StiSeriesYAxis.LeftYAxis) {
                            srY = -value * axisArea.yAxis.info.dpi + axisArea.axisCore.getDividerY();
                        }
                        else {
                            srY = -value * axisArea.yRightAxis.info.dpi + axisArea.axisCore.getDividerRightY();
                        }
                        point = new PointD(posX, srY);
                    }
                    return point;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "SteppedRange");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSteppedRangeSeriesCoreXF = StiSteppedRangeSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiScatterLineSeriesCoreXF extends Chart.StiScatterSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiLineSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ScatterLine");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiScatterLineSeriesCoreXF = StiScatterLineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiScatterSplineSeriesCoreXF extends Chart.StiScatterSeriesCoreXF {
                renderLines(context, geom, pointsInfo) {
                    if (pointsInfo.points == null || pointsInfo.points.length <= 1)
                        return;
                    let seriesGeom = new Chart.StiScatterSplineSeriesGeom(geom, pointsInfo, this.series);
                    if (seriesGeom != null) {
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesGeom);
                    }
                    this.renderMarkers(context, geom, pointsInfo.points);
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "ScatterSpline");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiScatterSplineSeriesCoreXF = StiScatterSplineSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Dictionary = Stimulsoft.System.Collections.Dictionary;
            var DataTable = Stimulsoft.System.Data.DataTable;
            var List = Stimulsoft.System.Collections.List;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointF = Stimulsoft.System.Drawing.Point;
            var StiString = Stimulsoft.System.StiString;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var DataColumn = Stimulsoft.System.Data.DataColumn;
            var StiValueHelper = Stimulsoft.Base.Helpers.StiValueHelper;
            class StiSunburstSeriesCoreXF extends Chart.StiSeriesCoreXF {
                renderSeries(context, rect, geom, seriesCollection) {
                    let dataTable = this.getDataTable(seriesCollection);
                    if (dataTable.rows.count < 1)
                        return;
                    let indexValueColumn = dataTable.columns.count - 1;
                    for (let indexRow = 0; indexRow < dataTable.rows.count; indexRow++) {
                        for (let indexSeries = 0; indexSeries < seriesCollection.length; indexSeries++) {
                            if (seriesCollection.length > 0 && seriesCollection[indexSeries].arguments.length > indexRow)
                                dataTable.rows.getByIndex(indexRow).setValue(indexSeries + 1, seriesCollection[indexSeries].arguments[indexRow]);
                            else
                                dataTable.rows.getByIndex(indexRow).setValue(indexSeries + 1, null);
                        }
                        if (seriesCollection.length > 0 && seriesCollection[0].values.length > indexRow)
                            dataTable.rows.getByIndex(indexRow).setValue(indexValueColumn, seriesCollection[0].values[indexRow]);
                        else
                            dataTable.rows.getByIndex(indexRow).setValue(indexValueColumn, null);
                    }
                    let hashTables = new Dictionary();
                    for (let row of dataTable.rows.list) {
                        let argumentKey = row.gett(1);
                        if (argumentKey == null)
                            continue;
                        if (hashTables.contains(argumentKey)) {
                            let tableSeries = hashTables.get(argumentKey);
                            tableSeries.loadDataRow(row.itemArray);
                        }
                        else {
                            let table = dataTable.clone();
                            table.loadDataRow(row.itemArray);
                            hashTables.add(argumentKey, table);
                        }
                    }
                    let radius = this.getRadius(context, rect);
                    let pointCenter = this.getPointCenter(rect);
                    let gradPerValue = this.getGradPerValue(dataTable);
                    if (Number.POSITIVE_INFINITY == gradPerValue || Number.NEGATIVE_INFINITY == gradPerValue)
                        return;
                    let starAngle = 0;
                    let colorIndex = 0;
                    let labelList = new List();
                    for (let seriesTable of hashTables.values) {
                        let sumCurrentSeriesTable = this.getSumColumn(seriesTable, "Value");
                        let arcWidth = gradPerValue * sumCurrentSeriesTable;
                        let REFLabelGeoms = { ref: labelList };
                        this.renderComputeSeries(context, geom, seriesTable, pointCenter, radius, starAngle, gradPerValue, colorIndex, hashTables.values.length, REFLabelGeoms);
                        labelList = REFLabelGeoms.ref;
                        starAngle += arcWidth;
                        colorIndex++;
                    }
                    for (let label of labelList) {
                        if (label != null) {
                            geom.createChildGeoms();
                            geom.childGeoms.push(label);
                        }
                    }
                }
                renderComputeSeries(context, geom, seriesTable, center, radius, startAngle, gradPerValue, colorIndex, colorCount, REFLabelGeoms) {
                    let level = 1;
                    let stepRadius = radius / (seriesTable.columns.count - 1);
                    for (let indexArgumentColumn = 1; indexArgumentColumn < seriesTable.columns.count - 1; indexArgumentColumn++) {
                        let argumentValueHash = new Dictionary();
                        for (let row of seriesTable.rows.list) {
                            let argument = row.gett(indexArgumentColumn);
                            if (argument == null)
                                continue;
                            let value = StiValueHelper.tryToNullableNumber(row.gett(seriesTable.columns.count - 1));
                            if (argumentValueHash.contains(argument) && value != null) {
                                let valueOld = StiValueHelper.tryToNullableNumber(argumentValueHash.get(argument));
                                argumentValueHash.set(argument, Math.abs(valueOld) + Math.abs(value));
                            }
                            else {
                                argumentValueHash.set(argument, value);
                            }
                        }
                        let _arguments = StiArray.create(Object, argumentValueHash.keys.length);
                        argumentValueHash.keys.copyTo(_arguments);
                        let values = StiArray.create(Number, argumentValueHash.values.length);
                        argumentValueHash.values.copyTo(values, 0);
                        this.renderLevelSeries(context, geom, _arguments, values, center, stepRadius * level, stepRadius * (level + 1), startAngle, gradPerValue, colorIndex, colorCount, level);
                        let labels = this.renderLevelSeriesLebels(context, _arguments, values, center, stepRadius * level, stepRadius * (level + 1), startAngle, gradPerValue);
                        REFLabelGeoms.ref.addRange(labels);
                        level++;
                    }
                }
                renderLevelSeries(context, geom, _arguments, values, center, radius, radiusDt, startAngle, gradPerValue, colorIndex, colorCount, level) {
                    let borderColor = this.series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = this.series.core.getSeriesBrush(colorIndex, colorCount);
                    let numberValues = values;
                    if (borderColor.a == 0) {
                        borderColor = Color.white;
                    }
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    for (let index = 0; index < numberValues.length; index++) {
                        let value = numberValues[index];
                        let argument = _arguments[index];
                        let arcWidth = gradPerValue * Math.abs(value);
                        if (!StiString.isNullOrEmpty(argument.toString())) {
                            let doughnutElementGeom = this.renderSunburstElement(center, radius, radiusDt, borderColor, seriesBrush, startAngle, arcWidth, value, level, colorIndex, index, geom, new TimeSpan(beginTime.ticks / (colorCount + numberValues.length) * (index + colorIndex)));
                            if (doughnutElementGeom != null) {
                                geom.createChildGeoms();
                                geom.childGeoms.push(doughnutElementGeom);
                            }
                        }
                        startAngle += arcWidth;
                    }
                }
                renderLevelSeriesLebels(context, _arguments, values, center, radius, radiusDt, startAngle, gradPerValue) {
                    let resultList = new List();
                    for (let index = 0; index < values.length; index++) {
                        let value = values[index];
                        let argument = _arguments[index];
                        let arcWidth = gradPerValue * Math.abs(value);
                        if (!StiString.isNullOrEmpty(argument.toString())) {
                            let seriesLabels = this.series.chart.seriesLabels;
                            if (this.series.chart != null && seriesLabels != null && seriesLabels.visible) {
                                let labels = seriesLabels.as(Chart.IStiPieSeriesLabels);
                                if (labels != null && labels.visible && (labels.step == 0 || (index % labels.step == 0))) {
                                    let measureRect;
                                    let REFmeasureRect = { ref: measureRect };
                                    let seriesLabelsGeom = labels.core.renderLabel(this.series, context, center, radius, radiusDt, startAngle + arcWidth / 2, index, Math.abs(value), value, argument, this.getTag(index), false, 0, 1, gradPerValue, REFmeasureRect, false, 0);
                                    measureRect = REFmeasureRect.ref;
                                    resultList.push(seriesLabelsGeom);
                                }
                            }
                        }
                        startAngle += arcWidth;
                    }
                    return resultList;
                }
                renderSunburstElement(center, radius, radiusDt, borderColor, brush, start, angle, value, index1, index2, index3, areaGeom, beginTime) {
                    if (angle == 0 || angle == null)
                        return null;
                    let rectSunburst = new Rectangle(center.x - radius, center.y - radius, radius * 2, radius * 2);
                    let rectSunburstDt = new Rectangle(center.x - radiusDt, center.y - radiusDt, radiusDt * 2, radiusDt * 2);
                    if (rectSunburst.width <= 0 && rectSunburst.height <= 0)
                        return null;
                    let path = new List();
                    path.push(new StiArcSegmentGeom(rectSunburst, start, angle));
                    path.push(new StiLineSegmentGeom(this.getPoint(center, radius, start + angle), this.getPoint(center, radiusDt, start + angle)));
                    path.push(new StiArcSegmentGeom(rectSunburstDt, start + angle, -angle));
                    path.push(new StiLineSegmentGeom(this.getPoint(center, radiusDt, start), this.getPoint(center, radius, start)));
                    let seriesGeom = new Chart.StiSunburstSeriesElementGeom(areaGeom, value, index1, index2, index3, this.series, rectSunburst, rectSunburstDt, path, borderColor, brush, start, start + angle, radius, radiusDt, beginTime);
                    return seriesGeom;
                }
                getPoint(centerPie, radius, angle) {
                    let angleRad = Math.PI * angle / 180;
                    return new PointF(centerPie.x + Math.cos(angleRad) * radius, centerPie.y + Math.sin(angleRad) * radius);
                }
                getDataTable(seriesCollection) {
                    let table = new DataTable();
                    let idColumn = new DataColumn("Id", Number);
                    table.columns.add(idColumn);
                    for (let index = 0; index < seriesCollection.length; index++) {
                        let argumentColumn = new DataColumn("Argument-" + index.toString(), String);
                        table.columns.add(argumentColumn);
                    }
                    let valueColumn = new DataColumn("Value", Number);
                    table.columns.add(valueColumn);
                    let rowCount = this.getCountRow(seriesCollection);
                    for (let index = 0; index < rowCount; index++) {
                        let dataRow = table.newRow();
                        table.rows.add(dataRow);
                    }
                    return table;
                }
                getCountRow(seriesCollection) {
                    let count = 0;
                    for (let series of seriesCollection) {
                        count = Math.max(count, series.arguments.length);
                    }
                    return count;
                }
                getGradPerValue(dataTable) {
                    let totals = this.getSumColumn(dataTable, "Value");
                    return 360 / totals;
                }
                getRadius(context, rect) {
                    return Math.min(rect.width / 2, rect.height / 2) * 0.95;
                }
                getPointCenter(rect) {
                    return new PointF(rect.width / 2, rect.height / 2);
                }
                getSumColumn(dataTable, columnName) {
                    let sum = 0;
                    for (let row of dataTable.rows.toList()) {
                        let value = row.gett(columnName);
                        sum += Math.abs(value);
                    }
                    return sum;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Sunburst");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiSunburstSeriesCoreXF = StiSunburstSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiValueHelper = Stimulsoft.Base.Helpers.StiValueHelper;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiTreemapSeriesCoreXF extends Chart.StiSeriesCoreXF {
                applyStyle(style, color) {
                    super.applyStyle(style, color);
                    let treemapSeries = this.series;
                    if (treemapSeries.allowApplyStyle) {
                        treemapSeries.brush = style.core.getColumnBrush(color);
                        treemapSeries.borderColor = style.core.getColumnBorder(color);
                    }
                }
                renderSeries(context, rect, geom, seriesArray) {
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    let listValues = [];
                    for (let value of this.series.values)
                        listValues.push(StiValueHelper.tryToNumber(value));
                    let normalizeData = this.series.chart.area.core.normalizeDataForArea(listValues, rect.width * rect.height);
                    let rects = this.series.chart.area.core.squarify(normalizeData, [], rect, []);
                    let indexColor = 0;
                    for (let ser of seriesArray) {
                        if (ser == this.series)
                            break;
                        indexColor += ser.values.length;
                    }
                    let indexColorCount = 0;
                    for (let ser of seriesArray) {
                        indexColorCount += ser.values.length;
                    }
                    for (let index = 0; index < rects.length; index++) {
                        if (listValues[index] == 0 || listValues[index] == null)
                            continue;
                        let seriesBrush = this.series.core.getSeriesBrush(indexColor, indexColorCount);
                        seriesBrush = this.series.processSeriesBrushes(indexColor, seriesBrush);
                        let seriesBorderColor = this.series.core.getSeriesBorderColor(indexColor, indexColorCount);
                        if (seriesBorderColor.a == 0 && !this.series.chart.area.colorEach) {
                            seriesBorderColor = Color.white;
                        }
                        let beginTimeAnimationOpacity = new TimeSpan(beginTime.ticks / rects.length * (index + 2));
                        let animation = new StiOpacityAnimation(duration, beginTimeAnimationOpacity);
                        let seriesTreemapElementGeom = new Chart.StiTreemapSeriesElementGeom(geom, StiValueHelper.tryToNumber(this.series.values[index]), index, seriesBrush, seriesBorderColor, this.series, rects[index], animation);
                        if (this.series.core.interaction != null) {
                            let data = new StiSeriesInteractionData();
                            data.fill(geom.area, this.series, index);
                            seriesTreemapElementGeom.interaction = data;
                        }
                        geom.createChildGeoms();
                        geom.childGeoms.push(seriesTreemapElementGeom);
                        let labels = this.series.chart.seriesLabels.stimulsoft().as(Chart.StiCenterTreemapLabels);
                        if (labels != null && labels.visible) {
                            let seriesLabelsGeom = labels.core.renderLabel(this.series, context, index, StiValueHelper.tryToNumber(this.series.values[index]), this.getArgumentText(this.series, index), this.series.core.getTag(index), indexColor, indexColorCount, rects[index], null);
                            if (seriesLabelsGeom != null) {
                                geom.createChildGeoms();
                                geom.childGeoms.push(seriesLabelsGeom);
                            }
                        }
                        indexColor++;
                    }
                }
                getArgumentText(series, index) {
                    if (series.arguments.length > index && series.arguments[index] != null) {
                        return series.arguments[index].toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                    }
                    return "";
                }
                getSeriesBrush(colorIndex, colorCount) {
                    let brush = super.getSeriesBrush(colorIndex, colorCount);
                    if (brush == null)
                        return this.series.brush;
                    return brush;
                }
                getSeriesBorderColor(colorIndex, colorCount) {
                    let color = super.getSeriesBorderColor(colorIndex, colorCount);
                    if (color == null)
                        return this.series.borderColor;
                    return color;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Treemap");
                }
                constructor(series) {
                    super(series);
                }
            }
            Chart.StiTreemapSeriesCoreXF = StiTreemapSeriesCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var DateTime = Stimulsoft.System.DateTime;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSeriesLabelsCoreXF {
                constructor(seriesLabels) {
                    this._seriesLabels = seriesLabels;
                }
                implements() {
                    if (!StiSeriesLabelsCoreXF.implementsStiSeriesLabelsCoreXF)
                        StiSeriesLabelsCoreXF.implementsStiSeriesLabelsCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiSeriesLabelsCoreXF
                        ];
                    return StiSeriesLabelsCoreXF.implementsStiSeriesLabelsCoreXF;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.seriesLabels.allowApplyStyle) {
                        this.seriesLabels.labelColor = style.core.seriesLabelsColor;
                        this.seriesLabels.borderColor = style.core.seriesLabelsBorderColor;
                        this.seriesLabels.brush = style.core.seriesLabelsBrush;
                        this.seriesLabels.font = style.core.seriesLabelsFont;
                    }
                }
                get position() {
                    return null;
                }
                get seriesLabelsType() {
                    return null;
                }
                get seriesLabels() {
                    return this._seriesLabels;
                }
                set seriesLabels(value) {
                    this._seriesLabels = value;
                }
                get localizedName() {
                    return null;
                }
                processSeriesColors(pointIndex, brush, series) {
                    let seriesBrush = brush;
                    if (this.seriesLabels == null)
                        return seriesBrush;
                    for (let condition of this.seriesLabels.chart.seriesLabelsConditions.list) {
                        if (series.values == null || series.values.length <= pointIndex)
                            continue;
                        let itemValue = series.values[pointIndex];
                        let itemValueEnd = null;
                        if (series.is(Chart.IStiRangeSeries) && pointIndex < series.valuesEnd.length)
                            itemValueEnd = series.valuesEnd[pointIndex];
                        let itemArgument = null;
                        if (series.arguments != null &&
                            pointIndex < series.arguments.length)
                            itemArgument = series.arguments[pointIndex];
                        let itemValueOpen = null;
                        let itemValueClose = null;
                        let itemValueLow = null;
                        let itemValueHigh = null;
                        if (series.is(Chart.IStiFinancialSeries)) {
                            if (pointIndex < series.valuesOpen.length)
                                itemValueOpen = series.valuesOpen[pointIndex];
                            if (pointIndex < series.valuesClose.length)
                                itemValueClose = series.valuesClose[pointIndex];
                            if (pointIndex < series.valuesLow.length)
                                itemValueLow = series.valuesLow[pointIndex];
                            if (pointIndex < series.valuesHigh.length)
                                itemValueHigh = series.valuesHigh[pointIndex];
                        }
                        let data = Chart.StiChartHelper.getFilterData(null, condition, null);
                        if (Chart.StiChartHelper.getFilterResult(condition, itemArgument, itemValue, itemValueEnd, itemValueOpen, itemValueClose, itemValueLow, itemValueHigh, data)) {
                            seriesBrush = this.seriesLabels.chart.style.core.getColumnBrush(condition.color);
                            if (this.seriesLabels.chart.area.is(Chart.IStiClusteredBarArea)) {
                                if (seriesBrush.is(StiGradientBrush))
                                    seriesBrush.angle += 90;
                                if (seriesBrush.is(StiGlareBrush))
                                    seriesBrush.angle += 90;
                            }
                            return seriesBrush;
                        }
                    }
                    return seriesBrush;
                }
                getSeriesLabelColor(series, colorIndex, colorCount) {
                    return StiColorUtils.light(series.core.getSeriesBorderColor(colorIndex, colorCount), 100);
                }
                getBorderColor(series, colorIndex, colorCount) {
                    if (this.seriesLabels.useSeriesColor)
                        return this.getSeriesLabelColor(series, colorIndex, colorCount);
                    return this.seriesLabels.borderColor;
                }
                getLabelColor(series, colorIndex, colorCount) {
                    if (this.seriesLabels.useSeriesColor)
                        return this.getSeriesLabelColor(series, colorIndex, colorCount);
                    return this.seriesLabels.labelColor;
                }
                recalcValue(value, signs) {
                    return value;
                }
                getLabelText(series, value, argument, tag, seriesName, useLegendValueType = false) {
                    return this.getLabelText2(series, value, argument, tag, seriesName, 0, useLegendValueType);
                }
                getLabelText2(series, value, argument, tag, seriesName, weight, useLegendValueType) {
                    let text = "";
                    let type = this.seriesLabels.valueType;
                    if (useLegendValueType)
                        type = this.seriesLabels.legendValueType;
                    switch (type) {
                        case Chart.StiSeriesLabelsValueType.Argument:
                            text = this.getArgument(series, argument);
                            break;
                        case Chart.StiSeriesLabelsValueType.Value:
                            text = this.getFormattedValue(series, value);
                            break;
                        case Chart.StiSeriesLabelsValueType.SeriesTitle:
                            text = seriesName;
                            break;
                        case Chart.StiSeriesLabelsValueType.Tag:
                            text = tag;
                            break;
                        case Chart.StiSeriesLabelsValueType.Weight:
                            text = weight.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                            break;
                        case Chart.StiSeriesLabelsValueType.ValueArgument: {
                            let arg3 = this.getArgument(series, argument);
                            text = StiString.isNullOrEmpty(arg3) ?
                                this.getFormattedValue(series, value) :
                                StiString.format("{0} {1} {2}", this.getFormattedValue(series, value), this.seriesLabels.valueTypeSeparator, arg3);
                            break;
                        }
                        case Chart.StiSeriesLabelsValueType.ArgumentValue: {
                            let arg4 = this.getFormattedValue(series, value);
                            text = StiString.isNullOrEmpty(arg4) ?
                                this.getArgument(series, argument) :
                                StiString.format("{0} {1} {2}", this.getArgument(series, argument), this.seriesLabels.valueTypeSeparator, arg4);
                            break;
                        }
                        case Chart.StiSeriesLabelsValueType.SeriesTitleArgument: {
                            let arg5 = this.getArgument(series, argument);
                            text = StiString.isNullOrEmpty(arg5)
                                ? seriesName
                                : StiString.format("{0} {1} {2}", seriesName, this.seriesLabels.valueTypeSeparator, arg5);
                            break;
                        }
                        case Chart.StiSeriesLabelsValueType.SeriesTitleValue: {
                            let arg6 = this.getFormattedValue(series, value);
                            text = StiString.isNullOrEmpty(arg6)
                                ? seriesName
                                : StiString.format("{0} {1} {2}", seriesName, this.seriesLabels.valueTypeSeparator, arg6);
                            break;
                        }
                    }
                    if (useLegendValueType)
                        return text;
                    return StiString.format("{0}{1}{2}", this.seriesLabels.textBefore, text, this.seriesLabels.textAfter);
                }
                getArgument(series, argument) {
                    let text = argument;
                    if (series.core.isDateTimeArguments) {
                        let dateArgument = DateTime.fromString(argument, false);
                        if (dateArgument != null) {
                            text = this.getFormatted(series, dateArgument.toOADate(), true);
                        }
                    }
                    return text;
                }
                getFormatted(series, value, isDateTime) {
                    var _a, _b, _c, _d;
                    try {
                        this.storedCulture = CultureInfo.currentCulture;
                        let culture = (_b = (_a = this.seriesLabels.chart) === null || _a === void 0 ? void 0 : _a.report) === null || _b === void 0 ? void 0 : _b.culture;
                        if (!StiString.isNullOrEmpty((_d = (_c = this.seriesLabels.chart) === null || _c === void 0 ? void 0 : _c.report) === null || _d === void 0 ? void 0 : _d.culture)) {
                            CultureInfo.currentCulture = new CultureInfo(culture);
                        }
                        let objectValue = value;
                        if (isDateTime)
                            objectValue = DateTime.fromOADate(value);
                        let pieLabels = this.seriesLabels.stimulsoft().as(Chart.StiPieSeriesLabels);
                        let axisLabels = this.seriesLabels.stimulsoft().as(Chart.StiAxisSeriesLabels);
                        if (this.seriesLabels.formatService != null &&
                            !(pieLabels != null && pieLabels.showInPercent) &&
                            !(axisLabels != null && axisLabels.showInPercent)) {
                            return this.seriesLabels.formatService.format(objectValue);
                        }
                        let format = null;
                        if (series != null)
                            format = series.format;
                        if (format == null || format.trim().length == 0)
                            format = this.seriesLabels.format;
                        if (format != null && format.trim().length != 0) {
                            if (format.stimulsoft().startsWith("P") && this.seriesLabels.chart != null &&
                                !Chart.StiChartOptions.oldChartPercentMode) {
                                let decimals = 0;
                                let percentValue;
                                try {
                                    if (format.length > 1)
                                        decimals = format.stimulsoft().remove(0, 1).stimulsoft().toNumber();
                                    percentValue = this.recalcValue(value, decimals);
                                }
                                catch (e) {
                                    Stimulsoft.System.StiError.showError(e, false);
                                    percentValue = this.recalcValue(value, 2);
                                }
                                return StiString.format("{0:N" + decimals.toString() + "}{1}", percentValue, "%");
                            }
                            else {
                                let returnText = StiString.format("{0:" + format + "}", objectValue);
                                if (!isDateTime && returnText == format)
                                    return objectValue.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                                return returnText;
                            }
                        }
                        if (!StiString.isNullOrEmpty(culture)) {
                            CultureInfo.currentCulture = this.storedCulture;
                        }
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    return this.recalcValue(value, 2).toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                getFormattedValue(series, value) {
                    if (value == null)
                        return "";
                    return this.getFormatted(series, value, series.core.isDateTimeValues);
                }
                getStringFormatGeom(context) {
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    if (!this.seriesLabels.wordWrap)
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    return sf;
                }
            }
            Chart.StiSeriesLabelsCoreXF = StiSeriesLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiNoneLabelsCoreXF extends Chart.StiSeriesLabelsCoreXF {
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.All;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.None;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsNone");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiNoneLabelsCoreXF = StiNoneLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiAxisSeriesLabelsCoreXF extends Chart.StiSeriesLabelsCoreXF {
                constructor(seriesLabels) {
                    super(seriesLabels);
                    this.currentIndex = null;
                }
                renderLabel(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, colorIndex, colorCount, rect, animation = null) {
                    return null;
                }
                renderLabel2(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, weight, colorIndex, colorCount, rect, animation = null) {
                    return null;
                }
                recalcValue(value, signs) {
                    if (this.seriesLabels.showInPercent && (this.seriesLabels.chart.area.is(Chart.StiFullStackedColumnArea)) && (this.currentIndex != null)) {
                        let seriesCollection = this.seriesLabels.chart.area.core.getSeries();
                        let sumIndexValue = 0;
                        for (let series of seriesCollection) {
                            if (this.currentIndex < series.values.length)
                                sumIndexValue += series.values[this.currentIndex];
                        }
                        if (sumIndexValue != 0)
                            return Math.round2(100 * value / sumIndexValue, signs);
                    }
                    return value;
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Axis;
                }
            }
            Chart.StiAxisSeriesLabelsCoreXF = StiAxisSeriesLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLabelAnimation = Stimulsoft.Base.Context.Animation.StiLabelAnimation;
            class StiCenterAxisLabelsCoreXF extends Chart.StiAxisSeriesLabelsCoreXF {
                renderLabel(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, colorIndex, colorCount, rect, animation = null) {
                    this.currentIndex = pointIndex;
                    return this.renderLabel2(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, 0, colorIndex, colorCount, rect, animation);
                }
                renderLabel2(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, weight, colorIndex, colorCount, rect, animation = null) {
                    if (value == null && (!this.seriesLabels.showNulls))
                        return null;
                    if (value == 0 && (!this.seriesLabels.showZeros))
                        return null;
                    if (value == null)
                        value = 0;
                    if (labelValue == null)
                        labelValue = 0;
                    let labelText = this.getLabelText2(series, labelValue, argumentText, tag, series.coreTitle, weight, false);
                    let labelColor = this.getLabelColor(series, colorIndex, colorCount);
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let sf = this.getStringFormatGeom(context);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let seriesLabelsBrush = this.processSeriesColors(pointIndex, this.seriesLabels.brush, series);
                    let labelRect = this.getLabelRect(context, endPoint, startPoint, value, labelText, true, font, sf);
                    let animationLabel = animation != null ? animation.stimulsoft().as(StiLabelAnimation) : null;
                    if (animationLabel != null) {
                        animationLabel.labelRect = this.getLabelRect(context, animationLabel.pointFrom, startPoint, animationLabel.valueFrom, animationLabel.valueFrom.toString(), true, font, sf);
                    }
                    return new Chart.StiCenterAxisLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRect, labelText, labelColor, labelBorderColor, seriesBrush, seriesLabelsBrush, seriesBorderColor, font, animation);
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    if (this.seriesLabels.chart.area.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, (endPoint.y + startPoint.y) / 2), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                    else {
                        return context.measureRotatedString3(labelText, font, new PointD((endPoint.x + startPoint.x) / 2, endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.CenterAxis;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsCenter");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiCenterAxisLabelsCoreXF = StiCenterAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiInsideBaseAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsInsideBase");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.InsideBaseAxis;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    let deltaWidth = 2;
                    if (this.seriesLabels.chart.area.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, startPoint.y - (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, startPoint.y + (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                    else {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(startPoint.x - (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(startPoint.x + (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiInsideBaseAxisLabelsCoreXF = StiInsideBaseAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiInsideEndAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get position() {
                    return Chart.StiSeriesLabelsPosition.InsideEndAxis;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsInsideEnd");
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    let deltaWidth = 2;
                    if (this.seriesLabels.chart.area.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, endPoint.y + (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, endPoint.y - (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                    else {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x + (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x - (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiInsideEndAxisLabelsCoreXF = StiInsideEndAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiLeftAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Left");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.Left;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    if (this.seriesLabels.width > 0) {
                        size.width = this.seriesLabels.width * context.options.zoom;
                    }
                    else {
                        size.width += context.options.zoom * 2;
                    }
                    if (!this.seriesLabels.chart.area.reverseHor) {
                        return context.measureRotatedString3(labelText, font, new PointD(endPoint.x - size.width, endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                    else {
                        return context.measureRotatedString3(labelText, font, new PointD(endPoint.x + size.width, endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiLeftAxisLabelsCoreXF = StiLeftAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiOutsideAxisLabelsCoreXF extends Chart.StiAxisSeriesLabelsCoreXF {
                renderLabel(series, context, endPoint, startPoint, pointIndex, value, labelValue, argumentText, tag, colorIndex, colorCount, rect) {
                    let labels = this.seriesLabels;
                    if (value == null && (!labels.showNulls))
                        return null;
                    if (value == 0 && (!labels.showZeros))
                        return null;
                    if (value == null)
                        value = 0;
                    if (labelValue == null)
                        labelValue = 0;
                    let labelText = this.getLabelText(series, labelValue, argumentText, tag, series.coreTitle);
                    let infoAngle = 90;
                    if (this.seriesLabels.chart.area.is(Chart.IStiStackedBarArea)) {
                        if (value <= 0)
                            infoAngle = -infoAngle;
                        infoAngle += 90;
                    }
                    else {
                        if (value < 0)
                            infoAngle = -infoAngle;
                    }
                    infoAngle *= Math.PI / 180;
                    let newPoint = new PointD((endPoint.x + labels.lineLength * Math.cos(infoAngle) * context.options.zoom), (endPoint.y - labels.lineLength * Math.sin(infoAngle) * context.options.zoom));
                    let font = StiFontGeom.changeFontSize(labels.font, labels.font.size * context.options.zoom);
                    let sf = this.getStringFormatGeom(context);
                    let labelSize = (context.measureString2(labelText, font, (this.seriesLabels.width * context.options.zoom), sf));
                    let labelRect = new RectangleD(newPoint.x - labelSize.width / 2, newPoint.y - labelSize.height / 2, labelSize.width + 1, labelSize.height + 1);
                    let labelColor = this.getLabelColor(series, colorIndex, colorCount);
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    seriesBrush = this.processSeriesColors(pointIndex, seriesBrush, series);
                    return new Chart.StiOutsideAxisLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRect, labelText, labelColor, labelBorderColor, seriesBrush, seriesBorderColor, font, newPoint, endPoint, null);
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsideAxis;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsOutside");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsideAxisLabelsCoreXF = StiOutsideAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiOutsideBaseAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsOutsideBase");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsideBaseAxis;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    let deltaWidth = 2;
                    if (this.seriesLabels.chart.area.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, startPoint.y + (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, startPoint.y - (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                    else {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(startPoint.x + (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(startPoint.x - (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsideBaseAxisLabelsCoreXF = StiOutsideBaseAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiOutsideEndAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsOutsideEnd");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsideEndAxis;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    let deltaWidth = 2;
                    if (this.seriesLabels.chart.area.core.seriesOrientation == Chart.StiChartSeriesOrientation.Vertical) {
                        if (value >= 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, endPoint.y - (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x, endPoint.y + (Math.abs(size.height * Math.cos(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.sin(this.seriesLabels.angle * Math.PI / 180)))), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                    else {
                        if (value > 0) {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x - (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                        else {
                            return context.measureRotatedString3(labelText, font, new PointD(endPoint.x + (Math.abs(size.height * Math.sin(this.seriesLabels.angle * Math.PI / 180)) + Math.abs((size.width / 2 + deltaWidth) * Math.cos(this.seriesLabels.angle * Math.PI / 180))), endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                        }
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsideEndAxisLabelsCoreXF = StiOutsideEndAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiRightAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Right");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.Right;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let size = context.measureString(labelText, font);
                    if (this.seriesLabels.width > 0) {
                        size.width = this.seriesLabels.width * context.options.zoom;
                    }
                    else {
                        size.width += context.options.zoom * 2;
                    }
                    if (!this.seriesLabels.chart.area.reverseHor) {
                        return context.measureRotatedString3(labelText, font, new PointD(endPoint.x + size.width, endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                    else {
                        return context.measureRotatedString3(labelText, font, new PointD(endPoint.x - size.width, endPoint.y), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    }
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiRightAxisLabelsCoreXF = StiRightAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiValueAxisLabelsCoreXF extends Chart.StiCenterAxisLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Value");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.Value;
                }
                getLabelRect(context, endPoint, startPoint, value, labelText, checkHeight, font, sf) {
                    let labelRect = context.measureRotatedString3(labelText, font, new PointD(0, 0), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    return new RectangleD(endPoint.x - labelRect.width / 2, endPoint.y - labelRect.height / 2, labelRect.width, labelRect.height);
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiValueAxisLabelsCoreXF = StiValueAxisLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiFunnelSeriesLabelsCoreXF extends Chart.StiSeriesLabelsCoreXF {
                renderLabel(series, context, pointIndex, value, valueNext, argumentText, tag, colorIndex, colorCount, rect, singleValueHeight, singleValueWidth, centerAxis, REFmeasureRect) {
                    return null;
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Funnel;
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiFunnelSeriesLabelsCoreXF = StiFunnelSeriesLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var List = Stimulsoft.System.Collections.List;
            class StiCenterFunnelLabelsCoreXF extends Chart.StiFunnelSeriesLabelsCoreXF {
                renderLabel(series, context, pointIndex, value, valueNext, argumentText, tag, colorIndex, colorCount, rect, singleValueHeight, singleValueWidth, centerAxis, REFmeasureRect) {
                    let measureRect = rect.clone();
                    let labelText = this.getLabelText(series, value, argumentText, tag, series.coreTitle);
                    let labelBrush = new StiSolidBrush(this.getLabelColor(series, colorIndex, colorCount));
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let sf = this.getStringFormatGeom(context);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let point;
                    if (series.is(Chart.StiFunnelWeightedSlicesSeries))
                        point = new PointD(rect.width / 2, rect.height * 0.05 + singleValueHeight * this.getSumLastValues(series, pointIndex) + singleValueHeight * value / 2);
                    else
                        point = new PointD(rect.width / 2, singleValueHeight * pointIndex + singleValueHeight / 2 + rect.height * 0.05);
                    let labelRect = context.measureRotatedString3(labelText, font, point, sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    REFmeasureRect.ref = measureRect;
                    return new Chart.StiCenterFunnelLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRect, labelText, seriesBrush, labelBrush, labelBorderColor, seriesBorderColor, labelRect, null);
                }
                getSumLastValues(series, indexCurrent) {
                    let values = new List();
                    for (let ser of series.chart.series.list) {
                        let funnelSeries = ser.stimulsoft().as(Chart.IStiFunnelSeries);
                        for (let value of funnelSeries.values) {
                            if (!funnelSeries.showZeros && value == 0)
                                continue;
                            values.push(value);
                        }
                    }
                    let sumLastValues = 0;
                    for (let index = 0; index < indexCurrent; index++) {
                        if (index >= values.length)
                            break;
                        sumLastValues += Math.abs(values[index]);
                    }
                    return sumLastValues;
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Funnel;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.CenterFunnel;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsCenter");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiCenterFunnelLabelsCoreXF = StiCenterFunnelLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiOutsideLeftFunnelLabelsCoreXF extends Chart.StiFunnelSeriesLabelsCoreXF {
                renderLabel(series, context, pointIndex, value, valueNext, argumentText, tag, colorIndex, colorCount, rect, singleValueHeight, singleValueWidth, centerAxis, REFmeasureRect) {
                    let measureRect = rect.clone();
                    let labelText = this.getLabelText(series, value, argumentText, tag, series.coreTitle);
                    let labelBrush = new StiSolidBrush(this.getLabelColor(series, colorIndex, colorCount));
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let sf = this.getStringFormatGeom(context);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let labelRect = context.measureRotatedString3(labelText, font, new PointD(0, 0), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    measureRect.width -= labelRect.width;
                    measureRect.x += labelRect.width;
                    let startPoint = new PointD(centerAxis - (value + valueNext) * singleValueWidth / 4, singleValueHeight * pointIndex + singleValueHeight / 2 + rect.height * 0.05);
                    let endPoint = new PointD(rect.width * 0.05 + labelRect.width, singleValueHeight * pointIndex + singleValueHeight / 2 + rect.height * 0.05);
                    let labelRectPosition = context.measureRotatedString3(labelText, font, endPoint, sf, StiRotationMode.RightCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    REFmeasureRect.ref = measureRect;
                    return new Chart.StiOutsideFunnelLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRectPosition, labelText, seriesBrush, labelBrush, labelBorderColor, seriesBorderColor, labelRectPosition, startPoint, endPoint);
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Funnel;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsideLeftFunnel;
                }
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Left");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsideLeftFunnelLabelsCoreXF = StiOutsideLeftFunnelLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiOutsideRightFunnelLabelsCoreXF extends Chart.StiFunnelSeriesLabelsCoreXF {
                renderLabel(series, context, pointIndex, value, valueNext, argumentText, tag, colorIndex, colorCount, rect, singleValueHeight, singleValueWidth, centerAxis, REFmeasureRect) {
                    let measureRect = rect.clone();
                    let labelText = this.getLabelText(series, value, argumentText, tag, series.coreTitle);
                    let labelBrush = new StiSolidBrush(this.getLabelColor(series, colorIndex, colorCount));
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let sf = this.getStringFormatGeom(context);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let labelRect = context.measureRotatedString3(labelText, font, new PointD(0, 0), sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    measureRect.width -= labelRect.width + 5;
                    let startPoint = new PointD(centerAxis + (value + valueNext) * singleValueWidth / 4, singleValueHeight * pointIndex + singleValueHeight / 2 + rect.height * 0.05);
                    let endPoint = new PointD(rect.width * 0.95 - labelRect.width, singleValueHeight * pointIndex + singleValueHeight / 2 + rect.height * 0.05);
                    let labelRectPosition = context.measureRotatedString3(labelText, font, endPoint, sf, StiRotationMode.LeftCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                    REFmeasureRect.ref = measureRect;
                    return new Chart.StiOutsideFunnelLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRectPosition, labelText, seriesBrush, labelBrush, labelBorderColor, seriesBorderColor, labelRectPosition, startPoint, endPoint);
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Funnel;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsideRightFunnel;
                }
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Right");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsideRightFunnelLabelsCoreXF = StiOutsideRightFunnelLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiPieSeriesLabelsCoreXF extends Chart.StiSeriesLabelsCoreXF {
                constructor(seriesLabels) {
                    super(seriesLabels);
                    this.percentPerValue = 0.0;
                }
                renderLabel(series, context, centerPie, radius, radius2, pieAngle, pointIndex, value, labelValue, argumentText, tag, measure, colorIndex, colorCount, percentPerValue, REFmeasureRect, drawValue, deltaY) {
                    return null;
                }
                recalcValue(value, signs) {
                    if (this.seriesLabels.showInPercent) {
                        let seriesCollection = this.seriesLabels.chart.area.core.getSeries();
                        if (seriesCollection.length > 0) {
                            let seriesArray = [];
                            seriesCollection.stimulsoft().copyTo(seriesArray);
                            if (seriesArray.length > 0 && seriesArray[0].is(Chart.StiPieSeries))
                                this.percentPerValue = seriesArray[0].core.getPercentPerValue(seriesArray);
                        }
                        return Math.round2(value * this.percentPerValue, signs);
                    }
                    return value;
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Pie;
                }
            }
            Chart.StiPieSeriesLabelsCoreXF = StiPieSeriesLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiCenterPieLabelsCoreXF extends Chart.StiPieSeriesLabelsCoreXF {
                renderLabel(series, context, centerPie, radius, radius2, pieAngle, pointIndex, value, labelValue, argumentText, tag, measure, colorIndex, colorCount, percentPerValue, REFmeasureRect, drawValue, deltaY) {
                    let measureRect = RectangleD.empty;
                    REFmeasureRect.ref = measureRect;
                    this.percentPerValue = percentPerValue;
                    if (labelValue == null && (!this.seriesLabels.showNulls))
                        return null;
                    if (labelValue == 0 && (!this.seriesLabels.showZeros))
                        return null;
                    if (value == null)
                        value = 0;
                    if (labelValue == null)
                        labelValue = 0;
                    if (isNaN(radius) || isNaN(radius2))
                        return null;
                    let labelText = "";
                    if (drawValue)
                        labelText = this.getFormattedValue(series, labelValue);
                    else
                        labelText = this.getLabelText(series, labelValue, argumentText, tag, series.coreTitle);
                    let angleRad = (Math.PI * pieAngle / 180);
                    let labelPoint = this.getLabelPoint(centerPie, (radius - radius2) / 1.75 + radius2, angleRad);
                    if (!drawValue) {
                        if (this.is(Chart.StiOutsidePieLabelsCoreXF)) {
                            labelPoint = this.getLabelPoint(centerPie, radius + (this.seriesLabels.lineLength * context.options.zoom), angleRad);
                        }
                        if (this.is(Chart.StiInsideEndPieLabelsCoreXF)) {
                            labelPoint = this.getLabelPoint(centerPie, (radius - radius2) / 1.2 + radius2, angleRad);
                        }
                    }
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let sf = this.getStringFormatGeom(context);
                    let labelRect = this.getLabelRect(context, labelPoint, labelText, font, sf);
                    let angleToUse = this.seriesLabels.angle;
                    let mode = StiRotationMode.CenterCenter;
                    let rect = labelRect.clone();
                    rect.x = -rect.width / 2;
                    rect.y = -rect.height / 2;
                    if (this.seriesLabels.autoRotate) {
                        angleToUse = pieAngle;
                        if ((angleToUse > 0 && angleToUse < 90) || (angleToUse > 270)) {
                            if (this.seriesLabels.is(Chart.IStiOutsidePieLabels))
                                mode = StiRotationMode.LeftCenter;
                            rect.x = 0;
                        }
                        else {
                            if (this.seriesLabels.is(Chart.IStiOutsidePieLabels))
                                mode = StiRotationMode.RightCenter;
                            angleToUse += 180;
                            rect.x = -rect.width;
                        }
                    }
                    if (this.is(Chart.StiOutsidePieLabelsCoreXF)) {
                        if (!this.seriesLabels.autoRotate) {
                            if (pieAngle > 337.5 || pieAngle < 22.5) {
                                rect.x = 0;
                                rect.y = -rect.height / 2;
                                mode = StiRotationMode.LeftCenter;
                            }
                            else if (pieAngle >= 22.5 && pieAngle < 67.5) {
                                rect.x = 0;
                                rect.y = 0;
                                mode = StiRotationMode.LeftTop;
                            }
                            else if (pieAngle >= 67.5 && pieAngle < 112.5) {
                                rect.x = -rect.width / 2;
                                rect.y = 0;
                                mode = StiRotationMode.CenterTop;
                            }
                            else if (pieAngle >= 112.5 && pieAngle < 157.5) {
                                rect.x = -rect.width;
                                rect.y = 0;
                                mode = StiRotationMode.RightTop;
                            }
                            else if (pieAngle >= 157.5 && pieAngle < 202.5) {
                                rect.x = -rect.width;
                                rect.y = -rect.height / 2;
                                mode = StiRotationMode.RightCenter;
                            }
                            else if (pieAngle >= 202.5 && pieAngle < 247.5) {
                                rect.x = -rect.width;
                                rect.y = -rect.height;
                                mode = StiRotationMode.RightBottom;
                            }
                            else if (pieAngle >= 247.5 && pieAngle < 292.5) {
                                rect.x = -rect.width / 2;
                                rect.y = -rect.height;
                                mode = StiRotationMode.CenterBottom;
                            }
                            else if (pieAngle >= 292.5) {
                                rect.x = 0;
                                rect.y = -rect.height;
                                mode = StiRotationMode.LeftBottom;
                            }
                        }
                    }
                    else {
                        rect.x = -rect.width / 2;
                        rect.y = -rect.height / 2;
                    }
                    if (measure) {
                        measureRect = context.measureRotatedString2(labelText, font, labelRect, sf, mode, angleToUse);
                        REFmeasureRect.ref = measureRect;
                        return null;
                    }
                    let borderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let labelBrush = new StiSolidBrush(this.getLabelColor(series, colorIndex, colorCount));
                    seriesBrush = this.processSeriesColors(pointIndex, seriesBrush, series);
                    let seriesLabelsBrush = this.processSeriesColors(pointIndex, this.seriesLabels.brush, series);
                    measureRect = RectangleD.empty;
                    if (this.seriesLabels.is(Chart.IStiOutsidePieLabels)) {
                        let outsidePieLabels = this.as(Chart.StiOutsidePieLabelsCoreXF);
                        let lineColor = outsidePieLabels.getLineColor(series, colorIndex, colorCount);
                        labelPoint = this.getLabelPoint(centerPie, radius + (outsidePieLabels.seriesLabels.lineLength * context.options.zoom), angleRad);
                        let startPoint = this.getLabelPoint(centerPie, radius, angleRad);
                        REFmeasureRect.ref = measureRect;
                        return new Chart.StiOutsidePieLabelsGeom(this.seriesLabels, series, pointIndex, value, rect, labelText, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, mode, labelRect, angleToUse, lineColor, labelPoint, startPoint);
                    }
                    else {
                        REFmeasureRect.ref = measureRect;
                        return new Chart.StiCenterPieLabelsGeom(this.seriesLabels, series, pointIndex, value, rect, labelText, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, mode, labelRect, angleToUse, null);
                    }
                }
                getLabelPoint(centerPie, radius, angleRad) {
                    return new PointD(centerPie.x + Math.cos(angleRad) * radius, centerPie.y + Math.sin(angleRad) * radius);
                }
                getLabelRect(context, labelPoint, labelText, font, sf) {
                    return context.measureRotatedString3(labelText, font, labelPoint, sf, StiRotationMode.CenterCenter, 0, Math.trunc(this.seriesLabels.width * context.options.zoom));
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Pie;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.CenterPie;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsCenter");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiCenterPieLabelsCoreXF = StiCenterPieLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiInsideEndPieLabelsCoreXF extends Chart.StiCenterPieLabelsCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsInsideEnd");
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.InsideEndPie;
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiInsideEndPieLabelsCoreXF = StiInsideEndPieLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiOutsidePieLabelsCoreXF extends Chart.StiCenterPieLabelsCoreXF {
                applyStyle(style) {
                    super.applyStyle(style);
                    if (this.seriesLabels.allowApplyStyle) {
                        this.seriesLabels.lineColor = style.core.seriesLabelsBorderColor;
                    }
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.OutsidePie;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsOutside");
                }
                getLineColor(series, colorIndex, colorCount) {
                    if (this.seriesLabels.useSeriesColor)
                        return this.getSeriesLabelColor(series, colorIndex, colorCount);
                    return this.seriesLabels.lineColor;
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiOutsidePieLabelsCoreXF = StiOutsidePieLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiTwoColumnsPieLabelsCoreXF extends Chart.StiOutsidePieLabelsCoreXF {
                renderLabel(series, context, centerPie, radius, radius2, pieAngle, pointIndex, value, labelValue, argumentText, tag, measure, colorIndex, colorCount, percentPerValue, REFmeasureRect, drawValue, deltaY) {
                    this.percentPerValue = percentPerValue;
                    let measureRect = RectangleD.empty;
                    if (labelValue == null && (!this.seriesLabels.showNulls))
                        return null;
                    if (labelValue == 0 && (!this.seriesLabels.showZeros))
                        return null;
                    if (value == null)
                        value = 0;
                    if (labelValue == null)
                        labelValue = 0;
                    if (isNaN(radius) || isNaN(radius2))
                        return null;
                    if (drawValue) {
                        REFmeasureRect.ref = measureRect;
                        return super.renderLabel(series, context, centerPie, radius, radius2, pieAngle, pointIndex, value, labelValue, this.getFormattedValue(series, labelValue), tag, measure, colorIndex, colorCount, percentPerValue, REFmeasureRect, drawValue, deltaY);
                    }
                    let labelText = this.getLabelText(series, labelValue, argumentText, tag, series.coreTitle);
                    let angleRad = (Math.PI * pieAngle / 180);
                    let arcPoint = this.getLabelPoint(centerPie, radius, angleRad);
                    let startPoint = this.getLabelPoint(centerPie, radius + (this.seriesLabels.lineLength * context.options.zoom), angleRad);
                    let dist = 0;
                    if (arcPoint.x > startPoint.x)
                        dist = -1;
                    else
                        dist = 1;
                    let endPoint = new PointD(centerPie.x + radius * dist + this.seriesLabels.lineLength * dist + 10 * dist, startPoint.y);
                    if (this.seriesLabels.preventIntersection)
                        endPoint.y = arcPoint.y;
                    endPoint.y += deltaY * Math.min(context.options.zoom, 1);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    let labelRect = this.getLabelRect(context, endPoint, labelText, font, sf);
                    let labelRectPosition = RectangleD.empty;
                    if (dist < 0) {
                        labelRectPosition = new RectangleD(endPoint.x - labelRect.width, endPoint.y - labelRect.height / 2, labelRect.width, labelRect.height);
                    }
                    else {
                        labelRectPosition = new RectangleD(endPoint.x, endPoint.y - labelRect.height / 2, labelRect.width, labelRect.height);
                    }
                    if (measure) {
                        measureRect = labelRectPosition;
                        REFmeasureRect.ref = measureRect;
                        return null;
                    }
                    else {
                        measureRect = RectangleD.empty;
                        let borderColor = this.getBorderColor(series, colorIndex, colorCount);
                        let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                        let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                        seriesBrush = this.processSeriesColors(pointIndex, seriesBrush, series);
                        let labelBrush = new StiSolidBrush(this.getLabelColor(series, colorIndex, colorCount));
                        let lineColor = this.getLineColor(series, colorIndex, colorCount);
                        let seriesLabelsBrush = this.processSeriesColors(pointIndex, this.seriesLabels.brush, series);
                        REFmeasureRect.ref = measureRect;
                        return new Chart.StiTwoColumnsPieLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRectPosition, labelText, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, labelRectPosition, lineColor, startPoint, endPoint, arcPoint, centerPie, null);
                    }
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Pie | Chart.StiSeriesLabelsType.Doughnut;
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.TwoColumnsPie;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsTwoColumns");
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiTwoColumnsPieLabelsCoreXF = StiTwoColumnsPieLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            class StiCenterTreemapLabelsCoreXF extends Chart.StiSeriesLabelsCoreXF {
                renderLabel(series, context, pointIndex, value, argumentText, tag, colorIndex, colorCount, rect, animation = null) {
                    let labelText = this.getLabelText(series, value, argumentText, tag, series.coreTitle);
                    let labelColor = this.getLabelColor(series, colorIndex, colorCount);
                    let labelBorderColor = this.getBorderColor(series, colorIndex, colorCount);
                    let sf = this.getStringFormatGeom(context);
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size * context.options.zoom);
                    let seriesBorderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    let seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                    let seriesLabelsBrush = this.processSeriesColors(pointIndex, this.seriesLabels.brush, series);
                    let labelRect = this.getLabelRect(context, rect, value, labelText, true, font, sf);
                    return new Chart.StiCenterTreemapLabelsGeom(this.seriesLabels, series, pointIndex, value, labelRect, labelText, labelColor, labelBorderColor, seriesBrush, seriesLabelsBrush, seriesBorderColor, font, animation);
                }
                getLabelRect(context, rect, value, labelText, checkHeight, font, sf) {
                    return context.measureRotatedString3(labelText, font, new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2), sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.width * context.options.zoom);
                }
                get position() {
                    return Chart.StiSeriesLabelsPosition.CenterTreemap;
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsCenter");
                }
                get seriesLabelsType() {
                    return Chart.StiSeriesLabelsType.Treemap;
                }
                constructor(seriesLabels) {
                    super(seriesLabels);
                }
            }
            Chart.StiCenterTreemapLabelsCoreXF = StiCenterTreemapLabelsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStripsCoreXF {
                constructor(strips) {
                    this._strips = strips;
                }
                implements() {
                    if (!StiStripsCoreXF.implementsStiStripsCoreXF)
                        StiStripsCoreXF.implementsStiStripsCoreXF = [
                            Chart.IStiApplyStyle,
                            ICloneable,
                            Chart.IStiStripsCoreXF
                        ];
                    return StiStripsCoreXF.implementsStiStripsCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                applyStyle(style) {
                    if (this.strips.allowApplyStyle) {
                        this.strips.titleColor = style.core.styleColors[style.core.styleColors.length - 1];
                        this.strips.stripBrush = new StiSolidBrush(Color.fromArgb(150, style.core.styleColors[style.core.styleColors.length - 1]));
                    }
                }
                renderXStrips(context, geom, rect) {
                    let area = this.strips.chart.area;
                    if (area == null)
                        return;
                    let minLeft = this.calculateXValue(this.strips.minValue, area, rect);
                    let maxLeft = this.calculateXValue(this.strips.maxValue, area, rect);
                    if (minLeft > maxLeft) {
                        let tmpTop = minLeft;
                        minLeft = maxLeft;
                        maxLeft = tmpTop;
                    }
                    let stripRect = new RectangleD(minLeft, 0, maxLeft - minLeft, rect.height);
                    let stripGeom = new Chart.StiStripsXGeom(this.strips, stripRect);
                    geom.createChildGeoms();
                    geom.childGeoms.push(stripGeom);
                }
                calculateXValue(xValue, area, rect) {
                    let value;
                    try {
                        value = xValue.stimulsoft().toNumber();
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                        value = 0;
                    }
                    let left = 0;
                    if (area.xAxis.logarithmicScale && area.xAxis.info.stripLines.count > 0) {
                        let countStrip = area.xAxis.info.stripLines.count;
                        let startPoint = area.reverseHor ? countStrip - 1 : 0;
                        let endPoint = area.reverseHor ? 0 : countStrip - 1;
                        let startValue = area.xAxis.info.stripLines.getByIndex(startPoint).value;
                        let endValue = area.xAxis.info.stripLines.getByIndex(endPoint).value;
                        let decadeX = Math.abs(rect.width / (Math.log10(endValue) - Math.log10(startValue)));
                        left = Math.abs(Math.log10(value) * decadeX - Math.log10(area.xAxis.info.stripLines.getByIndex(startPoint).value) * decadeX);
                    }
                    else {
                        left = area.axisCore.getDividerX() + value * area.xAxis.info.dpi;
                    }
                    return left;
                }
                renderYStrips(context, geom, rect) {
                    let area = this.strips.chart.area;
                    if (area == null)
                        return;
                    let minTop = this.calculateYValue(this.strips.minValue, area, rect);
                    let maxTop = this.calculateYValue(this.strips.maxValue, area, rect);
                    if (minTop > maxTop) {
                        let tmpTop = minTop;
                        minTop = maxTop;
                        maxTop = tmpTop;
                    }
                    let stripRect = new RectangleD(0, minTop, rect.width, maxTop - minTop);
                    let stripGeom = new Chart.StiStripsYGeom(this.strips, stripRect);
                    geom.createChildGeoms();
                    geom.childGeoms.push(stripGeom);
                }
                calculateYValue(yValue, area, rect) {
                    let value;
                    try {
                        value = yValue.stimulsoft().toNumber();
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                        value = 0;
                    }
                    let top = 0;
                    if (area.yAxis.logarithmicScale) {
                        let countStrip = area.yAxis.info.stripLines.count;
                        let startPoint = 0;
                        let endPoint = countStrip - 1;
                        let startValue = area.yAxis.info.stripLines.getByIndex(startPoint).value;
                        let endValue = area.yAxis.info.stripLines.getByIndex(endPoint).value;
                        let decadeY = Math.abs(rect.height / (Math.log10(endValue) - Math.log10(startValue)));
                        top = Math.abs(Math.log10(area.yAxis.info.stripLines.getByIndex(startPoint).value) * decadeY - Math.log10(value) * decadeY);
                    }
                    else {
                        if (this.strips.orientation == Chart.StiStrips_StiOrientation.Horizontal)
                            top = area.axisCore.getDividerY() - value * area.yAxis.info.dpi;
                        else
                            top = area.axisCore.getDividerRightY() - value * area.yRightAxis.info.dpi;
                    }
                    return top;
                }
                render(context, geom, rect) {
                    if (!this.strips.visible)
                        return;
                    if (this.strips.orientation == Chart.StiStrips_StiOrientation.Vertical)
                        this.renderXStrips(context, geom, rect);
                    if (this.strips.orientation == Chart.StiStrips_StiOrientation.Horizontal ||
                        this.strips.orientation == Chart.StiStrips_StiOrientation.HorizontalRight)
                        this.renderYStrips(context, geom, rect);
                }
                get strips() {
                    return this._strips;
                }
                set strips(value) {
                    this._strips = value;
                }
            }
            Chart.StiStripsCoreXF = StiStripsCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var Font = Stimulsoft.System.Drawing.Font;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF {
                constructor() {
                    this._chart = null;
                    this._markerVisible = true;
                }
                implements() {
                    if (!StiStyleCoreXF.implementsStiStyleCoreXF)
                        StiStyleCoreXF.implementsStiStyleCoreXF = [
                            Chart.IStiStyleCoreXF
                        ];
                    return StiStyleCoreXF.implementsStiStyleCoreXF;
                }
                get localizedName() {
                    return null;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle01;
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get chartAreaBrush() {
                    return new StiGradientBrush(StiColorUtils.light(this.basicStyleColor, 80), StiColorUtils.light(this.basicStyleColor, 40), 90);
                }
                get chartAreaBorderColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                get chartAreaShowShadow() {
                    return false;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(this.basicStyleColor);
                }
                get seriesLabelsColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get seriesLabelsBorderColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get seriesLabelsLineColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 7);
                }
                get trendLineColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get trendLineShowShadow() {
                    return false;
                }
                get legendBrush() {
                    return new StiGradientBrush(StiColorUtils.light(this.basicStyleColor, 80), StiColorUtils.light(this.basicStyleColor, 20), 90);
                }
                get legendLabelsColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get legendBorderColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get legendTitleColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 8);
                }
                get axisTitleColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get axisLineColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get axisLabelsColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 150);
                }
                get interlacingHorBrush() {
                    return new StiSolidBrush(Color.fromArgb(10, StiColorUtils.dark(this.basicStyleColor, 100)));
                }
                get interlacingVertBrush() {
                    return new StiSolidBrush(Color.fromArgb(10, StiColorUtils.dark(this.basicStyleColor, 100)));
                }
                get gridLinesHorColor() {
                    return Color.fromArgb(100, StiColorUtils.dark(this.basicStyleColor, 150));
                }
                get gridLinesVertColor() {
                    return Color.fromArgb(100, StiColorUtils.dark(this.basicStyleColor, 150));
                }
                get seriesLighting() {
                    return true;
                }
                get seriesShowShadow() {
                    return false;
                }
                get seriesShowBorder() {
                    return true;
                }
                get markerVisible() {
                    return this._markerVisible;
                }
                set markerVisible(value) {
                    this._markerVisible = value;
                }
                get firstStyleColor() {
                    return this.styleColors[0];
                }
                get lastStyleColor() {
                    return this.styleColors[this.styleColors.length - 1];
                }
                get styleColors() {
                    return null;
                }
                get basicStyleColor() {
                    return null;
                }
                fillColumn(context, rect, brush, interaction) {
                    context.fillRectangle2(brush, rect.x, rect.y, rect.width, rect.height, interaction);
                }
                getAreaBrush(color) {
                    return new StiSolidBrush(Color.fromArgb(200, color));
                }
                getColumnBrush(color) {
                    return new StiGradientBrush(color, StiColorUtils.dark(color, 50), 0);
                }
                getColumnBorder(color) {
                    if (!this.seriesShowBorder)
                        return Color.transparent;
                    return StiColorUtils.dark(color, 100);
                }
                getColors(seriesCount, seriesColors) {
                    let colors = StiArray.create(Color, seriesCount);
                    let styleColors = seriesColors != null ? seriesColors : this.styleColors;
                    let styleColorIndex = 0;
                    let dist = 0;
                    for (let colorIndex = 0; colorIndex < seriesCount; colorIndex++) {
                        if (styleColors.length == 0 || styleColors.length < styleColorIndex) {
                            colors[colorIndex] = Color.fromArgb(255, 112, 173, 71);
                        }
                        else {
                            if (dist != 0) {
                                let color = styleColors[styleColorIndex];
                                let a = Math.min(color.a + dist, 255);
                                let r = Math.min(color.r + dist, 255);
                                let g = Math.min(color.g + dist, 255);
                                let b = Math.min(color.b + dist, 255);
                                colors[colorIndex] = Color.fromArgb(a, r, g, b);
                            }
                            else {
                                colors[colorIndex] = styleColors[styleColorIndex];
                            }
                        }
                        styleColorIndex++;
                        if (styleColorIndex == styleColors.length) {
                            styleColorIndex = 0;
                            dist = 50;
                        }
                    }
                    return colors;
                }
                getColorByIndex(index, count, seriesColors) {
                    return this.getColors(count, seriesColors)[index];
                }
                getColorBySeries(series, seriesColors) {
                    return this.getColors(series.chart.series.count, seriesColors)[series.chart.series.indexOf(series)];
                }
            }
            Chart.StiStyleCoreXF = StiStyleCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF01 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0xC2, 0x75, 0x35),
                        Color.fromArgb(0xFF, 0xE7, 0x8C, 0x41),
                        Color.fromArgb(0xFF, 0xF8, 0xAA, 0x79),
                        Color.fromArgb(0xFF, 0xFA, 0xCB, 0xB4),
                        Color.fromArgb(0xFF, 0xFD, 0xE6, 0xDC)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "01";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.wheat;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle01;
                }
                getColumnBrush(color) {
                    return new StiGlareBrush(StiColorUtils.dark(color, 50), color, 0);
                }
            }
            Chart.StiStyleCoreXF01 = StiStyleCoreXF01;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiCustomStyleCoreXF extends Chart.StiStyleCoreXF01 {
                constructor(customStyle) {
                    super();
                    this._base = new Chart.StiStyleCoreXF01();
                    this.reportChartStyle = null;
                    this._reportStyleName = null;
                    this._customStyle = customStyle;
                }
                get localizedName() {
                    return "CustomStyle";
                }
                get chartBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.brush;
                    return this._base.chartBrush;
                }
                get chartAreaBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.chartAreaBrush;
                    return this._base.chartAreaBrush;
                }
                get chartAreaBorderColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.chartAreaBorderColor;
                    return this._base.chartAreaBorderColor;
                }
                get chartAreaShowShadow() {
                    if (this.reportStyle != null)
                        return this.reportStyle.chartAreaShowShadow;
                    return this._base.chartAreaShowShadow;
                }
                get seriesLighting() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesLighting;
                    return this._base.seriesLighting;
                }
                get seriesShowShadow() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesShowShadow;
                    return this._base.seriesShowShadow;
                }
                get seriesShowBorder() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesShowBorder;
                    return this._base.seriesShowBorder;
                }
                get seriesLabelsBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesLabelsBrush;
                    return this._base.seriesLabelsBrush;
                }
                get seriesLabelsColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesLabelsColor;
                    return this._base.seriesLabelsColor;
                }
                get seriesLabelsBorderColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesLabelsBorderColor;
                    return this._base.seriesLabelsBorderColor;
                }
                get seriesLabelsLineColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.seriesLabelsLineColor;
                    return this._base.seriesLabelsLineColor;
                }
                get trendLineColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.trendLineColor;
                    return this._base.trendLineColor;
                }
                get trendLineShowShadow() {
                    if (this.reportStyle != null)
                        return this.reportStyle.trendLineShowShadow;
                    return this._base.trendLineShowShadow;
                }
                get legendBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.legendBrush;
                    return this._base.legendBrush;
                }
                get legendLabelsColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.legendLabelsColor;
                    return this._base.legendLabelsColor;
                }
                get legendBorderColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.legendBorderColor;
                    return this._base.legendBorderColor;
                }
                get legendTitleColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.legendTitleColor;
                    return this._base.legendTitleColor;
                }
                get markerVisible() {
                    if (this.reportStyle != null)
                        return this.reportStyle.markerVisible;
                    return this._base.markerVisible;
                }
                set markerVisible(value) {
                }
                get axisTitleColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.axisTitleColor;
                    return this._base.axisTitleColor;
                }
                get axisLineColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.axisLineColor;
                    return this._base.axisLineColor;
                }
                get axisLabelsColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.axisLabelsColor;
                    return this._base.axisLabelsColor;
                }
                get interlacingHorBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.interlacingHorBrush;
                    return this._base.interlacingHorBrush;
                }
                get interlacingVertBrush() {
                    if (this.reportStyle != null)
                        return this.reportStyle.interlacingVertBrush;
                    return this._base.interlacingVertBrush;
                }
                get gridLinesHorColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.gridLinesHorColor;
                    return this._base.gridLinesHorColor;
                }
                get gridLinesVertColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.gridLinesVertColor;
                    return this._base.gridLinesVertColor;
                }
                get styleColors() {
                    if (this.reportStyle != null)
                        return this.reportStyle.styleColors;
                    return this._base.styleColors;
                }
                get basicStyleColor() {
                    if (this.reportStyle != null)
                        return this.reportStyle.basicStyleColor;
                    return this._base.basicStyleColor;
                }
                get reportStyleName() {
                    return this._reportStyleName;
                }
                set reportStyleName(value) {
                    this._reportStyleName = value;
                }
                get reportStyle() {
                    let styleName = this.reportStyleName == null ? this.chart.customStyleName : this.reportStyleName;
                    if (this.chart == null || this.chart.report == null || styleName == null || styleName.length == 0)
                        return null;
                    let style = (this.chart.report.styles.getByName(styleName));
                    return style;
                }
                get customStyle() {
                    return this._customStyle;
                }
                getColumnBrush(color) {
                    if (this.reportStyle != null) {
                        switch (this.reportStyle.brushType) {
                            case Report.StiBrushType.Glare:
                                return new StiGlareBrush(StiColorUtils.dark(color, 50), color, 0);
                            case Report.StiBrushType.Gradient0:
                                return new StiGradientBrush(StiColorUtils.dark(color, 50), color, 0);
                            case Report.StiBrushType.Gradient90:
                                return new StiGradientBrush(StiColorUtils.dark(color, 50), color, 90);
                            case Report.StiBrushType.Gradient180:
                                return new StiGradientBrush(StiColorUtils.dark(color, 50), color, 180);
                            case Report.StiBrushType.Gradient270:
                                return new StiGradientBrush(StiColorUtils.dark(color, 50), color, 270);
                            case Report.StiBrushType.Gradient45:
                                return new StiGradientBrush(StiColorUtils.dark(color, 50), color, 45);
                            case Report.StiBrushType.Solid:
                                return new StiSolidBrush(color);
                        }
                    }
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiCustomStyleCoreXF = StiCustomStyleCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiGlareBrush = Stimulsoft.Base.Drawing.StiGlareBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF02 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0x80, 0x91, 0xA5),
                        Color.fromArgb(0xFF, 0xaB, 0x7B, 0x7A),
                        Color.fromArgb(0xFF, 0x9B, 0xA7, 0x81),
                        Color.fromArgb(0xFF, 0x90, 0x85, 0x9D),
                        Color.fromArgb(0xFF, 0x79, 0xA1, 0xAD),
                        Color.fromArgb(0xFF, 0xBD, 0x98, 0x7A),
                        Color.fromArgb(0xFF, 0x8B, 0xA4, 0xC2),
                        Color.fromArgb(0xFF, 0xCA, 0x84, 0x82),
                        Color.fromArgb(0xFF, 0xB3, 0xC6, 0x8D),
                        Color.fromArgb(0xFF, 0xA2, 0x92, 0xB6)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "02";
                }
                get basicStyleColor() {
                    return Color.whiteSmoke;
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle02;
                }
                getColumnBrush(color) {
                    return new StiGlareBrush(color, StiColorUtils.light(color, 50), 0);
                }
            }
            Chart.StiStyleCoreXF02 = StiStyleCoreXF02;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF03 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0x96, 0x3D, 0x3B),
                        Color.fromArgb(0xFF, 0xB3, 0x4A, 0x47),
                        Color.fromArgb(0xFF, 0xC9, 0x7E, 0x7D),
                        Color.fromArgb(0xFF, 0xDD, 0xB6, 0xB5),
                        Color.fromArgb(0xFF, 0xEE, 0xDD, 0xDD)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "03";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.whiteSmoke;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle03;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF03 = StiStyleCoreXF03;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF04 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0x48, 0x39, 0x5A),
                        Color.fromArgb(0xFF, 0x6D, 0x57, 0x89),
                        Color.fromArgb(0xFF, 0x92, 0x7B, 0xAD),
                        Color.fromArgb(0xFF, 0xB5, 0xA6, 0xC8)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "04";
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xFF, 0xB5, 0xA6, 0xC8);
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle04;
                }
            }
            Chart.StiStyleCoreXF04 = StiStyleCoreXF04;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF05 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0xE0, 0xA9, 0x3D),
                        Color.fromArgb(0xFF, 0xB4, 0xB5, 0x00),
                        Color.fromArgb(0xFF, 0x0E, 0x98, 0x0D),
                        Color.fromArgb(0xFF, 0xAA, 0x48, 0x24),
                        Color.fromArgb(0xFF, 0x85, 0xDD, 0x4D),
                        Color.fromArgb(0xFF, 0xE6, 0xC7, 0x45),
                        Color.fromArgb(0xFF, 0xDB, 0x64, 0x34),
                        Color.fromArgb(0xFF, 0x83, 0xBE, 0x2F)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "05";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.lemonChiffon;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle05;
                }
            }
            Chart.StiStyleCoreXF05 = StiStyleCoreXF05;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF06 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0xCE, 0xB9, 0x66),
                        Color.fromArgb(0xff, 0x9C, 0xB0, 0x84),
                        Color.fromArgb(0xff, 0x6B, 0xB1, 0xC9),
                        Color.fromArgb(0xff, 0x65, 0x85, 0xCF),
                        Color.fromArgb(0xff, 0x7E, 0x6B, 0xC9),
                        Color.fromArgb(0xff, 0xA3, 0x79, 0xBB)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "06";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xCA, 0xC6, 0xCE);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle06;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF06 = StiStyleCoreXF06;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiGradientBrush = Stimulsoft.Base.Drawing.StiGradientBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF07 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0xD9, 0xFB, 0xA8),
                        Color.fromArgb(0xFF, 0xC8, 0xB5, 0xE7),
                        Color.fromArgb(0xFF, 0x9E, 0xE8, 0xFF),
                        Color.fromArgb(0xFF, 0xFF, 0xBD, 0x86),
                        Color.fromArgb(0xFF, 0xA3, 0xC3, 0xFE)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "07";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.white;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle07;
                }
                getColumnBrush(color) {
                    return new StiGradientBrush(StiColorUtils.dark(color, 50), StiColorUtils.light(color, 50), -90);
                }
            }
            Chart.StiStyleCoreXF07 = StiStyleCoreXF07;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF08 extends Chart.StiStyleCoreXF03 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0x3C, 0x64, 0x94),
                        Color.fromArgb(0xFF, 0x49, 0x78, 0xB1),
                        Color.fromArgb(0xFF, 0x7E, 0x9B, 0xC8),
                        Color.fromArgb(0xFF, 0xB6, 0xC3, 0xDC),
                        Color.fromArgb(0xFF, 0xDD, 0xE3, 0xEE)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "08";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xEE, 0xB6, 0xC3, 0xDC);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle08;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF08 = StiStyleCoreXF08;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF09 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0x4F, 0x81, 0xBD),
                        Color.fromArgb(0xFF, 0xC0, 0x50, 0x4D),
                        Color.fromArgb(0xFF, 0x9B, 0xBB, 0x59),
                        Color.fromArgb(0xFF, 0x80, 0x64, 0xA2),
                        Color.fromArgb(0xFF, 0x4B, 0xAC, 0xC6),
                        Color.fromArgb(0xFF, 0xF7, 0x96, 0x46)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "09";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xEE, 0xEE, 0xEC, 0xE1);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle09;
                }
            }
            Chart.StiStyleCoreXF09 = StiStyleCoreXF09;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF10 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0x79, 0xB5, 0xB0),
                        Color.fromArgb(0xff, 0xB4, 0xBC, 0x4C),
                        Color.fromArgb(0xff, 0xB7, 0x78, 0x51),
                        Color.fromArgb(0xff, 0x77, 0x6A, 0x5B),
                        Color.fromArgb(0xff, 0xB6, 0xAD, 0x76),
                        Color.fromArgb(0xff, 0x95, 0xAE, 0xB1)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "10";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xD1, 0xE1, 0xE3);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle10;
                }
            }
            Chart.StiStyleCoreXF10 = StiStyleCoreXF10;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF11 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0xCC, 0x4D, 0x5C),
                        Color.fromArgb(0xff, 0xFF, 0x6F, 0x61),
                        Color.fromArgb(0xff, 0xFF, 0x95, 0x3E),
                        Color.fromArgb(0xff, 0xF8, 0xBD, 0x52)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "11";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return StiColorUtils.dark(Color.navajoWhite, 30);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle11;
                }
            }
            Chart.StiStyleCoreXF11 = StiStyleCoreXF11;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF12 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.goldenrod,
                        Color.khaki
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "12";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.moccasin;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle12;
                }
            }
            Chart.StiStyleCoreXF12 = StiStyleCoreXF12;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF13 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0x97, 0x9E, 0xA8),
                        Color.fromArgb(0xff, 0xBD, 0xAE, 0x89),
                        Color.fromArgb(0xff, 0xCD, 0xB0, 0x05),
                        Color.fromArgb(0xff, 0xAA, 0xA6, 0xC2),
                        Color.fromArgb(0xff, 0x84, 0xBF, 0xD2),
                        Color.fromArgb(0xff, 0x8B, 0x9F, 0x73)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "13";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xD4, 0xD2, 0xD0);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle13;
                }
            }
            Chart.StiStyleCoreXF13 = StiStyleCoreXF13;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF14 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0xF0, 0xA2, 0x2E),
                        Color.fromArgb(0xff, 0xA5, 0x64, 0x4E),
                        Color.fromArgb(0xff, 0xB5, 0x8B, 0x80),
                        Color.fromArgb(0xff, 0xC3, 0x98, 0x6D),
                        Color.fromArgb(0xff, 0xA1, 0x95, 0x74),
                        Color.fromArgb(0xff, 0xC1, 0x75, 0x29)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "14";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xFB, 0xEE, 0xC9);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle14;
                }
            }
            Chart.StiStyleCoreXF14 = StiStyleCoreXF14;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF15 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 0x0F, 0x6F, 0xC6),
                        Color.fromArgb(0xff, 0x00, 0x9D, 0xD9),
                        Color.fromArgb(0xff, 0x0B, 0xD0, 0xD9),
                        Color.fromArgb(0xff, 0x10, 0xCF, 0x9B),
                        Color.fromArgb(0xff, 0x7C, 0xCA, 0x62),
                        Color.fromArgb(0xff, 0xA5, 0xC2, 0x49)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "15";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xDB, 0xF5, 0xF9);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle15;
                }
            }
            Chart.StiStyleCoreXF15 = StiStyleCoreXF15;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF16 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xff, 255, 128, 0),
                        Color.black,
                        Color.silver,
                        Color.red
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "16";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.white;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle16;
                }
            }
            Chart.StiStyleCoreXF16 = StiStyleCoreXF16;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF17 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.white,
                        Color.black
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "17";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.white;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle17;
                }
            }
            Chart.StiStyleCoreXF17 = StiStyleCoreXF17;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiHatchBrush = Stimulsoft.Base.Drawing.StiHatchBrush;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var HatchStyle = Stimulsoft.System.Drawing.Drawing2D.HatchStyle;
            class StiStyleCoreXF18 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.white,
                        Color.black,
                        Color.silver,
                        Color.red,
                        Color.green,
                        Color.blue
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "18";
                }
                fillColumn(context, rect, brush, interaction) {
                    let style = HatchStyle.Cross;
                    let solidBrush = brush;
                    if (Color.white.equals(solidBrush.color)) {
                        style = HatchStyle.BackwardDiagonal;
                    }
                    else if (Color.black.equals(solidBrush.color)) {
                        style = HatchStyle.DottedGrid;
                    }
                    else if (Color.silver.equals(solidBrush.color)) {
                        style = HatchStyle.Horizontal;
                    }
                    else if (Color.red.equals(solidBrush.color)) {
                        style = HatchStyle.Percent25;
                    }
                    else if (Color.green.equals(solidBrush.color)) {
                        style = HatchStyle.OutlinedDiamond;
                    }
                    else if (Color.blue.equals(solidBrush.color)) {
                        style = HatchStyle.ForwardDiagonal;
                    }
                    let br = new StiHatchBrush(style, Color.black, Color.white);
                    context.fillRectangle2(br, rect.x, rect.y, rect.width, rect.height, interaction);
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.white;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle18;
                }
            }
            Chart.StiStyleCoreXF18 = StiStyleCoreXF18;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF19 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0xF2, 0xEA, 0xDD),
                        Color.fromArgb(0xFF, 0xF0, 0xED, 0xE8),
                        Color.fromArgb(0xFF, 0xE8, 0xDD, 0xCB),
                        Color.fromArgb(0xFF, 0xE1, 0xC9, 0xAD),
                        Color.fromArgb(0xFF, 0xD8, 0xB4, 0x8C)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "19";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(0xff, 0xF2, 0xEA, 0xDD);
                }
                get interlacingHorBrush() {
                    return new StiSolidBrush(Color.fromArgb(128, 0xF0, 0xED, 0xE8));
                }
                get interlacingVertBrush() {
                    return new StiSolidBrush(Color.fromArgb(128, 0xF0, 0xED, 0xE8));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(Color.fromArgb(128, 0xF0, 0xED, 0xE8));
                }
                get chartBrush() {
                    return new StiSolidBrush(Color.white);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle19;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF19 = StiStyleCoreXF19;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF20 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(0xFF, 0xD9, 0xBB, 0x94),
                        Color.fromArgb(0xFF, 0xF5, 0xBE, 0x77),
                        Color.fromArgb(0xFF, 0xE6, 0xBD, 0x7F),
                        Color.fromArgb(0xFF, 0xDC, 0xD9, 0xD4),
                        Color.fromArgb(0xFF, 0xED, 0xE5, 0xD8),
                        Color.fromArgb(0xFF, 0xF6, 0xE9, 0xD4)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "20";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.bisque;
                }
                get axisLineColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 50);
                }
                get chartAreaBorderColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 50);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle20;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF20 = StiStyleCoreXF20;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF21 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(35, 159, 217),
                        Color.fromArgb(178, 178, 178),
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "21";
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(this.basicStyleColor);
                }
                get chartAreaBorderColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get seriesLabelsColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get seriesLabelsBorderColor() {
                    return Color.fromArgb(255, 255, 255);
                }
                get legendBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get legendLabelsColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get axisTitleColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get axisLineColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get axisLabelsColor() {
                    return Color.fromArgb(106, 106, 106);
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(102, 102, 102);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle21;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
                getColumnBorder(color) {
                    return StiColorUtils.light(color, 255);
                }
            }
            Chart.StiStyleCoreXF21 = StiStyleCoreXF21;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF22 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(91, 155, 213),
                        Color.fromArgb(237, 125, 49),
                        Color.fromArgb(159, 159, 159),
                        Color.fromArgb(255, 192, 0),
                        Color.fromArgb(68, 114, 196),
                        Color.fromArgb(112, 173, 71)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "22";
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(this.basicStyleColor);
                }
                get chartAreaBorderColor() {
                    return Color.fromArgb(171, 172, 173);
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get seriesLabelsColor() {
                    return Color.fromArgb(90, 90, 90);
                }
                get seriesLabelsBorderColor() {
                    return Color.fromArgb(140, 140, 140);
                }
                get legendBrush() {
                    return new StiSolidBrush(StiColorUtils.light(this.basicStyleColor, 100));
                }
                get legendLabelsColor() {
                    return Color.fromArgb(140, 140, 140);
                }
                get axisTitleColor() {
                    return Color.fromArgb(140, 140, 140);
                }
                get axisLineColor() {
                    return Color.fromArgb(140, 140, 140);
                }
                get axisLabelsColor() {
                    return Color.fromArgb(140, 140, 140);
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return Color.fromArgb(255, 255, 255);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle22;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
                getColumnBorder(color) {
                    return StiColorUtils.light(color, 255);
                }
            }
            Chart.StiStyleCoreXF22 = StiStyleCoreXF22;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStyleCoreXF23 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(91, 155, 213),
                        Color.fromArgb(159, 159, 159),
                        Color.fromArgb(68, 114, 196),
                        Color.fromArgb(37, 94, 145),
                        Color.fromArgb(99, 99, 99),
                        Color.fromArgb(38, 68, 120)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "23";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle23;
                }
            }
            Chart.StiStyleCoreXF23 = StiStyleCoreXF23;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStyleCoreXF24 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        Color.fromArgb(237, 125, 49),
                        Color.fromArgb(255, 192, 0),
                        Color.fromArgb(112, 173, 71),
                        Color.fromArgb(158, 72, 14),
                        Color.fromArgb(153, 115, 0),
                        Color.fromArgb(67, 104, 43)
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "24";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle24;
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
            }
            Chart.StiStyleCoreXF24 = StiStyleCoreXF24;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var Font = Stimulsoft.System.Drawing.Font;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStyleCoreXF25 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#70ad47"),
                        ColorTranslator.fromHtml("#4472c4"),
                        ColorTranslator.fromHtml("#ffc000"),
                        ColorTranslator.fromHtml("#43682b"),
                        ColorTranslator.fromHtml("#fd6a37"),
                        ColorTranslator.fromHtml("#997300")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "25";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle25;
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return ColorTranslator.fromHtml("#33475b");
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get seriesLighting() {
                    return false;
                }
                get seriesShowShadow() {
                    return false;
                }
            }
            Chart.StiStyleCoreXF25 = StiStyleCoreXF25;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Font = Stimulsoft.System.Drawing.Font;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStyleCoreXF26 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#2ec6c8"),
                        ColorTranslator.fromHtml("#b5a1dd"),
                        ColorTranslator.fromHtml("#5ab0ee"),
                        ColorTranslator.fromHtml("#f4984e"),
                        ColorTranslator.fromHtml("#d77a80"),
                        ColorTranslator.fromHtml("#d04456"),
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "26";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#ffffff"));
                }
                get legendShowShadow() {
                    return false;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsColor() {
                    return ColorTranslator.fromHtml("#33475B");
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get seriesLighting() {
                    return false;
                }
                get seriesShowShadow() {
                    return false;
                }
                get markerVisible() {
                    return false;
                }
                set markerVisible(value) {
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle26;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
            }
            Chart.StiStyleCoreXF26 = StiStyleCoreXF26;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Font = Stimulsoft.System.Drawing.Font;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStyleCoreXF27 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#0bac45"),
                        ColorTranslator.fromHtml("#585257"),
                        ColorTranslator.fromHtml("#ec334d"),
                        ColorTranslator.fromHtml("#a1ae94"),
                        ColorTranslator.fromHtml("#ed7d31"),
                        ColorTranslator.fromHtml("#5ab0ee"),
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "27";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get chartBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#33475b"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#33475b"));
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return Color.white;
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return Color.white;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendTitleColor() {
                    return Color.white;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get seriesLighting() {
                    return false;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle27;
                }
            }
            Chart.StiStyleCoreXF27 = StiStyleCoreXF27;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Font = Stimulsoft.System.Drawing.Font;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Color = Stimulsoft.System.Drawing.Color;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            class StiStyleCoreXF28 extends Chart.StiStyleCoreXF26 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#165d9e"),
                        ColorTranslator.fromHtml("#577eb6"),
                        ColorTranslator.fromHtml("#569436"),
                        ColorTranslator.fromHtml("#225056"),
                        ColorTranslator.fromHtml("#d4dae0")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "28";
                }
                get chartBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#0a325a"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#0a325a"));
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get axisTitleColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 50);
                }
                get axisLineColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 50);
                }
                get axisLabelsColor() {
                    return StiColorUtils.dark(this.basicStyleColor, 50);
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendTitleColor() {
                    return Color.white;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle28;
                }
            }
            Chart.StiStyleCoreXF28 = StiStyleCoreXF28;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStyleCoreXF29 extends Chart.StiStyleCoreXF26 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#3498db"),
                        ColorTranslator.fromHtml("#ef717a"),
                        ColorTranslator.fromHtml("#6dcbb3"),
                        ColorTranslator.fromHtml("#f28161"),
                        ColorTranslator.fromHtml("#fccd1b")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "29";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle29;
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsColor() {
                    return ColorTranslator.fromHtml("#323a45");
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
            }
            Chart.StiStyleCoreXF29 = StiStyleCoreXF29;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStyleCoreXF30 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#db7b46"),
                        ColorTranslator.fromHtml("#d3d3d5"),
                        ColorTranslator.fromHtml("#6b6e75"),
                        ColorTranslator.fromHtml("#4a4c55"),
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "30";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get chartBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#595b65"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#595b65"));
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return Color.white;
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return Color.white;
                }
                get legendTitleColor() {
                    return Color.white;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendFont() {
                    return new Font("Arial", 8);
                }
                get seriesLighting() {
                    return false;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle30;
                }
            }
            Chart.StiStyleCoreXF30 = StiStyleCoreXF30;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var ColorTranslator = Stimulsoft.System.Drawing.ColorTranslator;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStyleCoreXF31 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        ColorTranslator.fromHtml("#fefef9"),
                        ColorTranslator.fromHtml("#a8d7e2"),
                        ColorTranslator.fromHtml("#5ea8bf"),
                        ColorTranslator.fromHtml("#2b7f9e"),
                        ColorTranslator.fromHtml("#1c4458")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "31";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get chartBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#235e6d"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(ColorTranslator.fromHtml("#235e6d"));
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return Color.white;
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return Color.white;
                }
                get legendTitleColor() {
                    return Color.white;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get seriesLighting() {
                    return false;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle31;
                }
            }
            Chart.StiStyleCoreXF31 = StiStyleCoreXF31;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiColor = Stimulsoft.Base.Drawing.StiColor;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStyleCoreXF32 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        StiColor.get("3a5263"),
                        StiColor.get("90a1ab"),
                        StiColor.get("c9d5dc")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "32";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return StiColor.get("e9f4fc");
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColor.get("6d7e8b"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(StiColor.get("6d7e8b"));
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendTitleColor() {
                    return StiColor.get("e9f4fc");
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLabelsLineColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get axisTitleColor() {
                    return StiColor.get("e9f4fc");
                }
                get axisLineColor() {
                    return StiColor.get("e9f4fc");
                }
                get axisLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get gridLinesHorColor() {
                    return StiColor.get("e9f4fc");
                }
                get gridLinesVertColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLighting() {
                    return false;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle32;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF32 = StiStyleCoreXF32;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiColor = Stimulsoft.Base.Drawing.StiColor;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStyleCoreXF33 extends Chart.StiStyleCoreXF {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        StiColor.get("40568d"),
                        StiColor.get("4569bb"),
                        StiColor.get("e47334"),
                        StiColor.get("9d9c9c"),
                        StiColor.get("f8b92d"),
                        StiColor.get("5e93cc"),
                        StiColor.get("6ea548")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "33";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get basicStyleColor() {
                    return StiColor.get("e9f4fc");
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColor.get("f2f5fc"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(StiColor.get("f2f5fc"));
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendTitleColor() {
                    return StiColor.get("e9f4fc");
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLabelsLineColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get axisTitleColor() {
                    return StiColor.get("e9f4fc");
                }
                get axisLineColor() {
                    return StiColor.get("e9f4fc");
                }
                get axisLabelsColor() {
                    return StiColor.get("e9f4fc");
                }
                get gridLinesHorColor() {
                    return StiColor.get("e9f4fc");
                }
                get gridLinesVertColor() {
                    return StiColor.get("e9f4fc");
                }
                get seriesLighting() {
                    return false;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle33;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
                getColumnBrush(color) {
                    return new StiSolidBrush(color);
                }
            }
            Chart.StiStyleCoreXF33 = StiStyleCoreXF33;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiColor = Stimulsoft.Base.Drawing.StiColor;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStyleCoreXF34 extends Chart.StiStyleCoreXF22 {
                constructor() {
                    super(...arguments);
                    this._styleColor = [
                        StiColor.get("144b45"),
                        StiColor.get("ecb92f"),
                        StiColor.get("d66153"),
                        StiColor.get("25775b"),
                        StiColor.get("319491"),
                        StiColor.get("f7f7f7"),
                        StiColor.get("dd7c21")
                    ];
                }
                get localizedName() {
                    return StiLocalization.get("Chart", "Style") + "34";
                }
                get styleColors() {
                    return this._styleColor;
                }
                get chartBrush() {
                    return new StiSolidBrush(StiColor.get("3f745e"));
                }
                get chartAreaBrush() {
                    return new StiSolidBrush(StiColor.get("3f745e"));
                }
                get chartAreaBorderColor() {
                    return Color.transparent;
                }
                get legendBrush() {
                    return new StiSolidBrush(Color.transparent);
                }
                get legendLabelsColor() {
                    return Color.white;
                }
                get legendBorderColor() {
                    return Color.transparent;
                }
                get legendTitleColor() {
                    return Color.white;
                }
                get legendShowShadow() {
                    return false;
                }
                get legendFont() {
                    return new Font("Arial", 9);
                }
                get seriesLabelsBorderColor() {
                    return Color.transparent;
                }
                get seriesLabelsBrush() {
                    return new StiSolidBrush(Color.fromArgb(0x77, 0xff, 0xff, 0xff));
                }
                get seriesLabelsColor() {
                    return Color.white;
                }
                get seriesLabelsFont() {
                    return new Font("Arial", 10);
                }
                get seriesLighting() {
                    return false;
                }
                get styleId() {
                    return Chart.StiChartStyleId.StiStyle34;
                }
                getColumnBorder(color) {
                    return Color.transparent;
                }
            }
            Chart.StiStyleCoreXF34 = StiStyleCoreXF34;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var DateTime = Stimulsoft.System.DateTime;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var ICloneable = Stimulsoft.System.ICloneable;
            var CultureInfo = Stimulsoft.System.Globalization.CultureInfo;
            class StiChartTableCoreXF {
                constructor(table) {
                    this._chartTable = table;
                }
                implements() {
                    if (!StiChartTableCoreXF.implementsStiChartTableCoreXF)
                        StiChartTableCoreXF.implementsStiChartTableCoreXF = [
                            ICloneable,
                            Chart.IStiApplyStyle,
                            Chart.IStiChartTableCoreXF
                        ];
                    return StiChartTableCoreXF.implementsStiChartTableCoreXF;
                }
                applyStyle(style) {
                    if (this.chartTable.allowApplyStyle) {
                        this.chartTable.gridLineColor = style.core.legendBorderColor;
                        this.chartTable.textColor = style.core.legendLabelsColor;
                    }
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get chartTable() {
                    return this._chartTable;
                }
                set chartTable(value) {
                    this._chartTable = value;
                }
                showTable() {
                    if ((this._chartTable.chart.area.is2(Chart.IStiClusteredColumnArea) || this._chartTable.chart.area.is2(Chart.IStiStackedColumnArea)) &&
                        !(this._chartTable.chart.area.is2(Chart.IStiCandlestickArea)) &&
                        !(this._chartTable.chart.area.is2(Chart.IStiRangeArea)) &&
                        !(this._chartTable.chart.area.is2(Chart.IStiScatterArea)) &&
                        !(this._chartTable.chart.area.is2(Chart.IStiStockArea)) &&
                        this._chartTable.visible) {
                        return true;
                    }
                    return false;
                }
                getHeightTable(context, widthTable) {
                    let font = StiFontGeom.changeFontSize(this._chartTable.dataCells.font, this._chartTable.dataCells.font.size * context.options.zoom);
                    let size = context.measureString("HeightText", font);
                    return size.height * (this._chartTable.chart.series.count) + this.getHeightHeaderTable(context, widthTable);
                }
                getHeightHeaderTable(context, widthTable) {
                    let height = 0;
                    let area = this._chartTable.chart.area;
                    let startFromZero = area.xAxis.startFromZero;
                    let listArgument = this.getArguments();
                    let font = StiFontGeom.changeFontSize(this._chartTable.header.font, this._chartTable.header.font.size * context.options.zoom);
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    if (!this.chartTable.header.wordWrap)
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    let count = area.xAxis.startFromZero ? listArgument.length + 1 : listArgument.length - 1;
                    let cellWidth = (widthTable - this.getWidthCellLegend(context)) / count;
                    for (let indexColumn = 0; indexColumn < listArgument.length; indexColumn++) {
                        let deltaWidth = 0;
                        if (indexColumn == 0 || indexColumn == listArgument.length - 1) {
                            deltaWidth = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                        }
                        let widthMax = this.chartTable.header.wordWrap ? Math.trunc(cellWidth + deltaWidth) : 0;
                        let measureHeight = context.measureRotatedString3(listArgument[indexColumn], font, new PointD(0, 0), sf, StiRotationMode.CenterCenter, 0, widthMax).height;
                        height = Math.max(height, measureHeight);
                    }
                    return height;
                }
                getWidthCellLegend(context) {
                    let font = StiFontGeom.changeFontSize(this._chartTable.dataCells.font, this._chartTable.dataCells.font.size * context.options.zoom);
                    let sf = context.getGenericStringFormat();
                    sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    let widthCell = 0;
                    let rect = new RectangleD();
                    for (let series of this._chartTable.chart.series.list) {
                        rect = context.measureRotatedString4(series.coreTitle, font, new PointD(0, 0), sf, StiRotationMode.CenterCenter, 0);
                        widthCell = Math.max(rect.width, widthCell);
                    }
                    if (this._chartTable.markerVisible)
                        widthCell += rect.height;
                    return Math.ceil(widthCell);
                }
                render(context, rect) {
                    return new Chart.StiChartTableGeom(rect, this.getTableValues(), this.getWidthCellLegend(context), this.getHeightHeaderTable(context, rect.width), this._chartTable);
                }
                getMaxCountValues(series) {
                    let result = 0;
                    for (let stiSeries of series.list) {
                        result = Math.max(result, stiSeries.values.length);
                    }
                    return result;
                }
                getArguments() {
                    let series = this.chartTable.chart.series;
                    let result = [];
                    let countValues = this.getMaxCountValues(series);
                    for (let index = 0; index < countValues; index++) {
                        let value = series.getByIndex(0).arguments.length > index
                            ? series.getByIndex(0).arguments[index]
                            : (index + 1).toString();
                        let valueText = this.getLabelText(value, series.getByIndex(0));
                        result.push(valueText);
                    }
                    return result;
                }
                getLabelText(objectValue, series) {
                    if (objectValue == null)
                        objectValue = "";
                    this.storedCulture = CultureInfo.currentCulture;
                    let culture = this.chartTable.chart.report.culture;
                    try {
                        if (!StiString.isNullOrEmpty(this.chartTable.chart.report.culture)) {
                            CultureInfo.currentCulture = CultureInfo.cultures[culture];
                        }
                        let format = "";
                        if (series != null)
                            format = series.format;
                        if (format == null || format.trim().length == 0)
                            format = this.chartTable.header.format;
                        if (format != null && format.trim().length != 0) {
                            if (typeof objectValue == "string") {
                                let strValue = objectValue.toString();
                                let result = strValue.stimulsoft().toNumber();
                                if (strValue.length > 0 && !isNaN(result)) {
                                    objectValue = result;
                                }
                                else {
                                    let resultDateTime = DateTime.fromString(objectValue.toString(), false);
                                    if (resultDateTime != null) {
                                        objectValue = resultDateTime;
                                    }
                                }
                            }
                            else if (objectValue == null)
                                return "";
                            if (!Chart.StiChartOptions.oldChartPercentMode && format.stimulsoft().startsWith("P")) {
                                let signs = 0;
                                if (format.length > 1) {
                                    signs = format.stimulsoft().remove(0, 1).stimulsoft().toNumber();
                                }
                                return StiString.format("{0:N" + signs.toString() + "}{1}{2}", objectValue, "%", this.chartTable.header.textAfter);
                            }
                            else
                                return StiString.format("{0:" + format + "}{1}", objectValue, this.chartTable.header.textAfter);
                        }
                        return StiString.format("{0}{1}", objectValue, this.chartTable.header.textAfter);
                    }
                    catch (e) {
                        Stimulsoft.System.StiError.showError(e, false);
                    }
                    finally {
                        if (!StiString.isNullOrEmpty(culture)) {
                            CultureInfo.currentCulture = this.storedCulture;
                        }
                    }
                    return objectValue.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                }
                getTableValues() {
                    let series = this.chartTable.chart.series;
                    let list = this.getArguments();
                    let table = StiArray.create2(String, series.count + 1, list.length + 1);
                    for (let index = 0; index < list.length; index++) {
                        table[0][index + 1] = list[index];
                    }
                    let area = this.chartTable.chart.area;
                    let indexRow = 1;
                    for (let serie of series.list) {
                        table[indexRow][0] = serie.coreTitle;
                        let indexColumn = 1;
                        for (let index = 0; index < serie.values.length; index++) {
                            let val = area.reverseHor ? serie.values[serie.values.length - index - 1] : serie.values[index];
                            let format = this.chartTable.chart.table.format;
                            if ((format != null || format.trim().length != 0) && val != null) {
                                if (format.stimulsoft().startsWith("P") && !Chart.StiChartOptions.oldChartPercentMode) {
                                    let decimals = 0;
                                    let percentValue;
                                    try {
                                        if (format.length > 1)
                                            decimals = format.stimulsoft().remove(0, 1).stimulsoft().toNumber();
                                        percentValue = serie.seriesLabels.core.recalcValue(val, decimals);
                                    }
                                    catch (e) {
                                        Stimulsoft.System.StiError.showError(e, false);
                                        percentValue = serie.seriesLabels.core.recalcValue(val, 2);
                                    }
                                    table[indexRow][indexColumn] = StiString.format("{0:N" + decimals.toString() + "}{1}", percentValue, "%");
                                }
                                else {
                                    let objectValue = val;
                                    if (serie.core.isDateTimeValues)
                                        objectValue = DateTime.fromOADate(val);
                                    table[indexRow][indexColumn] = StiString.format("{0:" + format + "}", objectValue);
                                }
                            }
                            else {
                                table[indexRow][indexColumn] = val.toString().replace(".", ",").replace(",", Stimulsoft.System.Globalization.CultureInfo.currentCulture.numberFormat.numberDecimalSeparator);
                            }
                            indexColumn++;
                        }
                        indexRow++;
                    }
                    return table;
                }
            }
            Chart.StiChartTableCoreXF = StiChartTableCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLineCoreXF {
                constructor(trendLine) {
                    this._trendLine = trendLine;
                }
                implements() {
                    if (!StiTrendLineCoreXF.implementsStiTrendLineCoreXF)
                        StiTrendLineCoreXF.implementsStiTrendLineCoreXF = [
                            ICloneable,
                            Chart.IStiTrendLineCoreXF
                        ];
                    return StiTrendLineCoreXF.implementsStiTrendLineCoreXF;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                get localizedName() {
                    return null;
                }
                get trendLine() {
                    return this._trendLine;
                }
                set trendLine(value) {
                    this._trendLine = value;
                }
                renderTrendLine(geom, points, posY) {
                }
                sum(values) {
                    let sum = 0;
                    for (let value of values) {
                        sum += value;
                    }
                    return sum;
                }
                sumSqr(values) {
                    let sum = 0;
                    for (let value of values) {
                        sum += value * value;
                    }
                    return sum;
                }
                sumProductions(valuesX, valuesY) {
                    let sum = 0;
                    for (let index = 0; index < valuesX.length; index++) {
                        sum += valuesX[index] * valuesY[index];
                    }
                    return sum;
                }
                sumProductionsXLogY(valuesX, valuesY) {
                    let sum = 0;
                    for (let index = 0; index < valuesX.length; index++) {
                        sum += valuesX[index] * Math.log(valuesY[index]);
                    }
                    return sum;
                }
                sumLn(values) {
                    let sum = 0;
                    for (let value of values) {
                        sum += Math.log(value);
                    }
                    return sum;
                }
            }
            Chart.StiTrendLineCoreXF = StiTrendLineCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiTrendLineExponentialCoreXF extends Chart.StiTrendLineCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Exponential");
                }
                renderTrendLine(geom, points, posY) {
                    if (points.length > 0) {
                        let valuesX = StiArray.create(Number, points.length);
                        let valuesY = StiArray.create(Number, points.length);
                        let maxValue = points[0].x;
                        let minValue = points[0].x;
                        for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
                            valuesX[pointIndex] = points[pointIndex].x;
                            valuesY[pointIndex] = posY - points[pointIndex].y;
                            if (maxValue < points[pointIndex].x)
                                maxValue = points[pointIndex].x;
                            if (minValue > points[pointIndex].x)
                                minValue = points[pointIndex].x;
                        }
                        let countPoints = points.length;
                        let sumX = this.sum(valuesX);
                        let sumX2 = this.sumSqr(valuesX);
                        let sumXLnY = this.sumProductionsXLogY(valuesX, valuesY);
                        let sumLnY = this.sumLn(valuesY);
                        let a2 = (countPoints * sumXLnY - sumX * sumLnY) / (countPoints * sumX2 - sumX * sumX);
                        let c = (sumX2 * sumLnY - sumX * sumXLnY) / (countPoints * sumX2 - sumX * sumX);
                        let a1 = Math.exp(c);
                        let pointTemp = StiArray.create(PointD, 31, true);
                        for (let index = 0; index < 31; index++) {
                            let x = minValue + (maxValue - minValue) / 30 * index;
                            let y = a1 * Math.exp(a2 * x);
                            pointTemp[index] = new PointD(x, posY - y);
                        }
                        let curve = new Chart.StiTrendCurveGeom(pointTemp, this.trendLine);
                        geom.createChildGeoms();
                        geom.childGeoms.push(curve);
                    }
                }
                constructor(trendLine) {
                    super(trendLine);
                }
            }
            Chart.StiTrendLineExponentialCoreXF = StiTrendLineExponentialCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiTrendLineLinearCoreXF extends Chart.StiTrendLineCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Linear");
                }
                renderTrendLine(geom, points, posY) {
                    if (points.length > 0) {
                        let valuesX = StiArray.create(Number, points.length);
                        let valuesY = StiArray.create(Number, points.length);
                        let maxValue = points[0].x;
                        let minValue = points[0].x;
                        for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
                            valuesX[pointIndex] = points[pointIndex].x;
                            valuesY[pointIndex] = points[pointIndex].y;
                            if (maxValue < valuesX[pointIndex])
                                maxValue = valuesX[pointIndex];
                            if (minValue > valuesX[pointIndex])
                                minValue = valuesX[pointIndex];
                        }
                        let countPoints = points.length;
                        let sumX = this.sum(valuesX);
                        let sumY = this.sum(valuesY);
                        let sumX2 = this.sumSqr(valuesX);
                        let sumProductionsXY = this.sumProductions(valuesX, valuesY);
                        let c = (sumX * sumX - sumX2 * countPoints);
                        let a = (sumY * sumX - sumProductionsXY * countPoints) / c;
                        let b = (sumX * sumProductionsXY - sumX2 * sumY) / c;
                        let line = new Chart.StiTrendLineGeom(new PointD(minValue, a * minValue + b), new PointD(maxValue, a * maxValue + b), this.trendLine);
                        geom.createChildGeoms();
                        geom.childGeoms.push(line);
                    }
                }
                constructor(trendLine) {
                    super(trendLine);
                }
            }
            Chart.StiTrendLineLinearCoreXF = StiTrendLineLinearCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiTrendLineLogarithmicCoreXF extends Chart.StiTrendLineCoreXF {
                get localizedName() {
                    return StiLocalization.get("PropertyMain", "Logarithmic");
                }
                renderTrendLine(geom, points, posY) {
                    if (points.length > 0) {
                        let valuesX = StiArray.create(Number, points.length);
                        let valuesY = StiArray.create(Number, points.length);
                        let maxValue = points[0].x;
                        let minValue = points[0].x;
                        for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
                            valuesX[pointIndex] = Math.log(points[pointIndex].x);
                            valuesY[pointIndex] = points[pointIndex].y;
                            if (maxValue < points[pointIndex].x)
                                maxValue = points[pointIndex].x;
                            if (minValue > points[pointIndex].x)
                                minValue = points[pointIndex].x;
                        }
                        let countPoints = points.length;
                        let sumX = this.sum(valuesX);
                        let sumY = this.sum(valuesY);
                        let sumX2 = this.sumSqr(valuesX);
                        let sumProductionsXY = this.sumProductions(valuesX, valuesY);
                        let c = (sumX * sumX - sumX2 * countPoints);
                        let a = (sumY * sumX - sumProductionsXY * countPoints) / c;
                        let b = (sumX * sumProductionsXY - sumX2 * sumY) / c;
                        let pointTemp = StiArray.create(PointD, 31, true);
                        for (let index = 0; index < 31; index++) {
                            let x = minValue + (maxValue - minValue) / 30 * index;
                            let y = a * Math.log(x) + b;
                            pointTemp[index] = new PointD(x, y);
                        }
                        let curve = new Chart.StiTrendCurveGeom(pointTemp, this.trendLine);
                        geom.createChildGeoms();
                        geom.childGeoms.push(curve);
                    }
                }
                constructor(trendLine) {
                    super(trendLine);
                }
            }
            Chart.StiTrendLineLogarithmicCoreXF = StiTrendLineLogarithmicCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            class StiTrendLineNoneCoreXF extends Chart.StiTrendLineCoreXF {
                get localizedName() {
                    return StiLocalization.get("Chart", "LabelsNone");
                }
                constructor(trendLine) {
                    super(trendLine);
                }
            }
            Chart.StiTrendLineNoneCoreXF = StiTrendLineNoneCoreXF;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiGeom = Stimulsoft.Base.Context.StiGeom;
            var StiGeomType = Stimulsoft.Base.Context.StiGeomType;
            var IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
            class StiCellGeom extends StiGeom {
                constructor(clientRectangle) {
                    super();
                    this._childGeoms = null;
                    this._clientRectangle = RectangleD.empty;
                    this._clientRectangle = clientRectangle.clone();
                }
                implements() {
                    if (!StiCellGeom.implementsStiCellGeom)
                        StiCellGeom.implementsStiCellGeom = super.implements().concat([
                            Chart.IStiGeomInteraction,
                            Chart.IStiCellGeom
                        ]);
                    return StiCellGeom.implementsStiCellGeom;
                }
                invokeClick(options) {
                }
                invokeMouseEnter(options) {
                }
                invokeMouseLeave(options) {
                }
                invokeMouseDown(options) {
                }
                invokeMouseUp(options) {
                }
                invokeDrag(options) {
                }
                get invisible() {
                    return false;
                }
                get type() {
                    return StiGeomType.None;
                }
                get childGeoms() {
                    return this._childGeoms;
                }
                get clientRectangle() {
                    return this._clientRectangle;
                }
                set clientRectangle(value) {
                    this._clientRectangle = value;
                }
                dispose() {
                    if (this._childGeoms != null) {
                        this._childGeoms.stimulsoft().clear();
                        this._childGeoms = null;
                    }
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    return this.clientRectangle.contains(x, y);
                }
                getGeomAt(parent, x, y) {
                    let xx = x - parent.clientRectangle.x;
                    let yy = y - parent.clientRectangle.y;
                    if (parent.childGeoms != null) {
                        let axisAreaGeom = parent;
                        let selectedGeom = null;
                        for (let childGeom of parent.childGeoms) {
                            if ((axisAreaGeom != null && axisAreaGeom.isChildVisibleInView(childGeom)) ||
                                axisAreaGeom == null) {
                                if (childGeom.is(Chart.StiAxisAreaGeom)) {
                                    if (!childGeom.view.contains(x, y))
                                        continue;
                                    let geom = this.getGeomAt(childGeom, xx, yy);
                                    if (geom != null)
                                        selectedGeom = geom;
                                }
                                else {
                                    let geom = this.getGeomAt(childGeom, xx, yy);
                                    if (geom != null) {
                                        selectedGeom = geom;
                                        if (selectedGeom.is(Chart.StiMarkerGeom))
                                            return selectedGeom;
                                    }
                                }
                            }
                        }
                        if (selectedGeom != null)
                            return selectedGeom;
                    }
                    if (parent.contains(x, y))
                        return parent;
                    return null;
                }
                getSeriesGeoms() {
                    let geoms = [];
                    if (this._childGeoms == null)
                        return geoms;
                    for (let childGeom of this.childGeoms) {
                        if (childGeom.is(Chart.StiSeriesGeom) || childGeom.is(Chart.StiSeriesElementGeom))
                            geoms.push(childGeom);
                        let geoms2 = childGeom.getSeriesGeoms();
                        for (let childGeom2 of geoms2) {
                            geoms.push(childGeom2);
                        }
                    }
                    return geoms;
                }
                getSeriesElementGeoms() {
                    let geoms = [];
                    if (this.childGeoms == null)
                        return geoms;
                    for (let childGeom of this.childGeoms) {
                        if (childGeom.is(IStiSeriesElement))
                            geoms.push(childGeom);
                        let geoms2 = childGeom.getSeriesElementGeoms();
                        for (let childGeom2 of geoms2) {
                            geoms.push(childGeom2);
                        }
                    }
                    return geoms;
                }
                getRect(geom) {
                    let rect = RectangleD.empty;
                    if (this._childGeoms == null)
                        return rect;
                    for (let childGeom of this.childGeoms) {
                        if (childGeom == geom) {
                            rect.x += childGeom.clientRectangle.x;
                            rect.y += childGeom.clientRectangle.y;
                            rect.size = childGeom.clientRectangle.size;
                            return rect;
                        }
                        let clientRect = childGeom.getRect(geom);
                        if (!clientRect.isEmpty) {
                            rect.x += childGeom.clientRectangle.x;
                            rect.y += childGeom.clientRectangle.y;
                            rect.x += clientRect.x;
                            rect.y += clientRect.y;
                            rect.size = clientRect.size;
                            return rect;
                        }
                    }
                    return rect;
                }
                createChildGeoms() {
                    if (this._childGeoms == null)
                        this._childGeoms = [];
                }
                draw(context) {
                }
                drawGeom(context) {
                    this.draw(context);
                    this.drawChildGeoms(context);
                }
                drawChildGeoms(context) {
                    if (this.childGeoms != null) {
                        context.pushTranslateTransform(this.clientRectangle.x, this.clientRectangle.y);
                        for (let childGeom of this.childGeoms) {
                            if (this.allowChildDrawing(childGeom))
                                childGeom.drawGeom(context);
                        }
                        context.popTransform();
                    }
                }
                allowChildDrawing(cellGeom) {
                    return cellGeom != null;
                }
            }
            Chart.StiCellGeom = StiCellGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiChartGeom extends Chart.StiCellGeom {
                draw(context) {
                }
                constructor(clientRectangle) {
                    super(clientRectangle);
                }
            }
            Chart.StiChartGeom = StiChartGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiNullableDrawing {
                static drawLines(context, penGeom, points, animation = null) {
                    this.drawLines2(context, penGeom, null, points, animation);
                }
                static drawLines2(context, penGeom, pointsStart, points, animation = null) {
                    let newPoints = [];
                    for (let point of points) {
                        if (point != null)
                            newPoints.push(point);
                        else {
                            if (newPoints.length > 1) {
                                if (animation != null)
                                    context.drawAnimationLines(penGeom, newPoints.stimulsoft().toArray(), animation);
                                else
                                    context.drawLines(penGeom, newPoints.stimulsoft().toArray());
                            }
                            newPoints.stimulsoft().clear();
                        }
                    }
                    if (newPoints.length > 1) {
                        if (animation != null)
                            context.drawAnimationLines(penGeom, newPoints.stimulsoft().toArray(), animation);
                        else
                            context.drawLines(penGeom, newPoints.stimulsoft().toArray());
                    }
                }
                static drawCurve(context, penGeom, points, tension, animation = null) {
                    let newPoints = [];
                    for (let point of points) {
                        if (point != null)
                            newPoints.push(point);
                        else {
                            if (newPoints.length > 1) {
                                if (animation != null)
                                    context.drawAnimationCurve(penGeom, newPoints.stimulsoft().toArray(), tension, animation);
                                else
                                    context.drawCurve(penGeom, newPoints.stimulsoft().toArray(), tension);
                            }
                            newPoints.stimulsoft().clear();
                        }
                    }
                    if (newPoints.length > 1) {
                        if (animation != null)
                            context.drawAnimationCurve(penGeom, newPoints.stimulsoft().toArray(), tension, animation);
                        else
                            context.drawCurve(penGeom, newPoints.stimulsoft().toArray(), tension);
                    }
                }
                static getPointsList(points) {
                    let list = [];
                    let newPoints = [];
                    for (let point of points) {
                        if (point != null)
                            newPoints.push(point);
                        else {
                            if (newPoints.length > 1)
                                list.push(newPoints.stimulsoft().toArray());
                            newPoints.stimulsoft().clear();
                        }
                    }
                    if (newPoints.length > 1)
                        list.push(newPoints.stimulsoft().toArray());
                    return list;
                }
                static getNullablePointsList(points) {
                    let list = [];
                    let newPoints = [];
                    for (let point of points) {
                        if (point != null)
                            newPoints.push(point);
                        else {
                            if (newPoints.length > 1)
                                list.push(newPoints.stimulsoft().toArray());
                            newPoints.stimulsoft().clear();
                        }
                    }
                    if (newPoints.length >= 1)
                        list.push(newPoints.stimulsoft().toArray());
                    return list;
                }
                static getPointsList2(points1, points2, REFlist1, REFlist2) {
                    let list1 = [];
                    let list2 = [];
                    let newPoints1 = [];
                    let newPoints2 = [];
                    let index = 0;
                    for (let point1 of points1) {
                        let point2 = points2[index];
                        if (point1 != null && point2 != null) {
                            newPoints1.push(point1);
                            newPoints2.push(point2);
                        }
                        else {
                            if (newPoints1.length > 1) {
                                list1.push(newPoints1.stimulsoft().toArray());
                                list2.push(newPoints2.stimulsoft().toArray());
                            }
                            newPoints1.stimulsoft().clear();
                            newPoints2.stimulsoft().clear();
                        }
                        index++;
                    }
                    if (newPoints1.length > 1) {
                        list1.push(newPoints1.stimulsoft().toArray());
                        list2.push(newPoints2.stimulsoft().toArray());
                    }
                    REFlist1.ref = list1;
                    REFlist2.ref = list2;
                }
            }
            Chart.StiNullableDrawing = StiNullableDrawing;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiAreaGeom extends Chart.StiCellGeom {
                constructor(area, clientRectangle) {
                    super(clientRectangle);
                    this._area = area;
                }
                get area() {
                    return this._area;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.isEmpty)
                        return;
                    if (rect.width > 0 && rect.height > 0) {
                        context.fillRectangle(this._area.brush, rect, null);
                    }
                }
            }
            Chart.StiAreaGeom = StiAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var List = Stimulsoft.System.Collections.List;
            class StiLineF {
                constructor(x1, y1, x2, y2) {
                    this.x1 = x1;
                    this.y1 = y1;
                    this.x2 = x2;
                    this.y2 = y2;
                }
            }
            Chart.StiLineF = StiLineF;
            class StiAxisAreaGeom extends Chart.StiAreaGeom {
                constructor(view, area, clientRectangle) {
                    super(area, clientRectangle);
                    this.minWidth = 6;
                    this._view = view;
                }
                get view() {
                    return this._view;
                }
                drawInterlacingHor(context, rect) {
                    rect.x = 0;
                    rect.width = this.view.clientRectangle.width;
                    let axisArea = this.area;
                    if (!axisArea.interlacingHor.visible)
                        return;
                    let positionsTemp = [];
                    let count = axisArea.yAxis.info.stripPositions.length;
                    let positions = StiArray.create(Number, count);
                    for (let indexReorder = 0; indexReorder < count; indexReorder++) {
                        positions[count - 1 - indexReorder] = axisArea.yAxis.info.stripPositions[indexReorder];
                    }
                    let firstPosition = 0;
                    let first = true;
                    let indexTemp = 0;
                    for (let pos of positions) {
                        indexTemp++;
                        if (first) {
                            firstPosition = pos;
                            positionsTemp.push(pos);
                            first = false;
                            continue;
                        }
                        let step = firstPosition - pos;
                        if (step < this.minWidth && indexTemp != positions.length) {
                            continue;
                        }
                        firstPosition = pos;
                        positionsTemp.push(pos);
                    }
                    let positionsNew = StiArray.create(Number, positionsTemp.length);
                    positionsTemp.stimulsoft().copyTo(positionsNew);
                    let index = 0;
                    let draw = true;
                    for (let posY of positionsNew) {
                        let posY2 = positionsNew[index + 1];
                        if (draw) {
                            let stripRect = new RectangleD(rect.x, rect.y + posY2, rect.width, posY - posY2);
                            if (stripRect.bottom >= 0 && stripRect.y < this.view.clientRectangle.height)
                                context.fillRectangle(axisArea.interlacingHor.interlacedBrush, stripRect, null);
                        }
                        draw = !draw;
                        index++;
                        if (index == positionsNew.length - 1)
                            break;
                    }
                }
                drawInterlacingVer(context, rect) {
                    rect.y = 0;
                    rect.height = this.view.clientRectangle.height;
                    let axisArea = this.area;
                    if (!axisArea.interlacingVert.visible)
                        return;
                    let index = 0;
                    let areaIndex = 0;
                    if (axisArea.reverseHor)
                        areaIndex = 1;
                    let positionsTemp = [];
                    let positions = axisArea.xAxis.info.stripPositions;
                    let firstPosition = 0;
                    let first = true;
                    let indexTemp = 0;
                    for (let pos of positions) {
                        indexTemp++;
                        if (first) {
                            firstPosition = pos;
                            positionsTemp.push(pos);
                            first = false;
                            continue;
                        }
                        let step = pos - firstPosition;
                        if (step < this.minWidth && indexTemp != positions.length) {
                            continue;
                        }
                        firstPosition = pos;
                        positionsTemp.push(pos);
                    }
                    let positionsNew = StiArray.create(Number, positionsTemp.length);
                    positionsTemp.stimulsoft().copyTo(positionsNew);
                    for (let posX of positionsNew) {
                        let posX2 = positionsNew[index + 1];
                        if ((areaIndex & 1) > 0) {
                            let stripRect = new RectangleD(posX + rect.x, rect.y, posX2 - posX, rect.height);
                            if (stripRect.right >= 0 && stripRect.x < this.view.clientRectangle.width)
                                context.fillRectangle(axisArea.interlacingVert.interlacedBrush, stripRect, null);
                        }
                        areaIndex++;
                        index++;
                        if (index == positionsNew.length - 1)
                            break;
                    }
                }
                getGridLinesHorMajor(rect, gridLinesHor, isLeftAxis) {
                    let lines = new List();
                    rect.x = 0;
                    rect.width = this.view.clientRectangle.width;
                    let axisArea = this.area;
                    let positions = isLeftAxis ? axisArea.yAxis.info.stripPositions : axisArea.yRightAxis.info.stripPositions;
                    let count = positions.length;
                    let positionsTemp = StiArray.create(Number, count);
                    for (let indexTemp = 0; indexTemp < count; indexTemp++) {
                        positionsTemp[count - indexTemp - 1] = positions[indexTemp];
                    }
                    positions = positionsTemp;
                    let firstPosition = positions[0];
                    for (let posY of positions) {
                        let step = firstPosition - posY;
                        if (step < this.minWidth && step > 0) {
                            continue;
                        }
                        firstPosition = posY;
                        if (gridLinesHor.visible && gridLinesHor.style != StiPenStyle.None) {
                            let pointY = posY + rect.y;
                            if (pointY >= 0 && pointY <= this.clientRectangle.height)
                                lines.add(new StiLineF(rect.x, pointY, rect.right, pointY));
                        }
                    }
                    return lines;
                }
                getGridLinesHorMinor(rect, gridLinesHor, isLeftAxis) {
                    let lines = new List();
                    rect.x = 0;
                    rect.width = this.view.clientRectangle.width;
                    let axisArea = this.area;
                    let positions = isLeftAxis ? axisArea.yAxis.info.stripPositions : axisArea.yRightAxis.info.stripPositions;
                    let count = positions.length;
                    let positionsTemp = StiArray.create(Number, count);
                    for (let indexTemp = 0; indexTemp < count; indexTemp++) {
                        positionsTemp[count - indexTemp - 1] = positions[indexTemp];
                    }
                    positions = positionsTemp;
                    let firstPosition = positions[0];
                    let index = 0;
                    for (let posY of positions) {
                        let step = firstPosition - posY;
                        if (step < this.minWidth && step > 0) {
                            continue;
                        }
                        firstPosition = posY;
                        if (gridLinesHor.minorVisible && gridLinesHor.minorStyle != StiPenStyle.None && index != positions.length - 1) {
                            let posY2 = positions[index + 1];
                            if ((posY - posY2) < this.minWidth)
                                continue;
                            let minorCount = gridLinesHor.minorCount == 0 ? axisArea.yAxis.ticks.minorCount : gridLinesHor.minorCount;
                            let posMinorY = posY;
                            let minorStep = (posY2 - posY) / (minorCount + 1);
                            for (let minorIndex = 1; minorIndex <= minorCount; minorIndex++) {
                                posMinorY = posY + minorStep * minorIndex;
                                let pointMinorY = posMinorY + rect.y;
                                if (pointMinorY >= 0 && pointMinorY <= this.clientRectangle.height)
                                    lines.add(new StiLineF(rect.x, pointMinorY, rect.right, pointMinorY));
                            }
                        }
                        index++;
                    }
                    return lines;
                }
                getGridLinesVerMajor(rect, gridLinesVert, isBottomAxis) {
                    let lines = new List();
                    rect.y = 0;
                    rect.height = this.view.clientRectangle.height;
                    let axisArea = this.area;
                    let positions = isBottomAxis ? axisArea.xAxis.info.stripPositions : axisArea.xTopAxis.info.stripPositions;
                    let firstPosition = 0;
                    for (let posX of positions) {
                        let step = posX - firstPosition;
                        if (step < this.minWidth && step > 0) {
                            continue;
                        }
                        firstPosition = posX;
                        if (gridLinesVert.visible && gridLinesVert.style != StiPenStyle.None) {
                            let pointX = posX + rect.x;
                            if (pointX >= 0 && pointX <= this.clientRectangle.width)
                                lines.add(new StiLineF(pointX, rect.y, pointX, rect.bottom));
                        }
                    }
                    return lines;
                }
                getGridLinesVerMinor(rect, gridLinesVert, isBottomAxis) {
                    let lines = new List();
                    rect.y = 0;
                    rect.height = this.view.clientRectangle.height;
                    let axisArea = this.area;
                    let positions = isBottomAxis ? axisArea.xAxis.info.stripPositions : axisArea.xTopAxis.info.stripPositions;
                    let firstPosition = 0;
                    let index = 0;
                    for (let posX of positions) {
                        let step = posX - firstPosition;
                        if (step < this.minWidth && step > 0) {
                            continue;
                        }
                        firstPosition = posX;
                        if (gridLinesVert.minorVisible && gridLinesVert.minorStyle != StiPenStyle.None && index != positions.length - 1) {
                            let posX2 = positions[index + 1];
                            if ((posX2 - posX) < this.minWidth)
                                continue;
                            let minorCount = gridLinesVert.minorCount == 0 ? axisArea.yAxis.ticks.minorCount : gridLinesVert.minorCount;
                            let posMinorX = posX;
                            let minorStep = (posX2 - posX) / (minorCount + 1);
                            for (let minorIndex = 1; minorIndex <= minorCount; minorIndex++) {
                                posMinorX = posX + minorStep * minorIndex;
                                let pointMinorX = posMinorX + rect.x;
                                if (pointMinorX >= 0 && pointMinorX <= this.clientRectangle.width)
                                    lines.add(new StiLineF(pointMinorX, rect.y, pointMinorX, rect.bottom));
                            }
                        }
                        index++;
                    }
                    return lines;
                }
                allowChildDrawing(cellGeom) {
                    return cellGeom != null && this.isChildVisibleInView(cellGeom);
                }
                isChildVisibleInView(cellGeom) {
                    let clipRect = this.view.clientRectangle.clone();
                    clipRect.x = 0;
                    clipRect.y = 0;
                    let cellRect = cellGeom.clientRectangle.clone();
                    cellRect.x -= this.area.core.scrollDistanceX;
                    cellRect.y -= this.area.core.scrollDistanceY;
                    return cellGeom != null && clipRect.intersectsWith(cellRect);
                }
                draw(context) {
                    super.draw(context);
                    let axisArea = this.area;
                    let rect = this.clientRectangle.clone();
                    if (rect.isEmpty)
                        return;
                    let seriesCollection = axisArea.axisCore.getSeries();
                    if (seriesCollection.length > 0) {
                        this.drawInterlacingHor(context, rect);
                        this.drawInterlacingVer(context, rect);
                    }
                    if (seriesCollection.length > 0) {
                        let linesHorMajor = this.getGridLinesHorMajor(rect, axisArea.gridLinesHor, true);
                        let linesHorMinor = this.getGridLinesHorMinor(rect, axisArea.gridLinesHor, true);
                        let linesHorMajorRight = this.getGridLinesHorMajor(rect, axisArea.gridLinesHorRight, true);
                        let linesHorMinorRight = this.getGridLinesHorMinor(rect, axisArea.gridLinesHorRight, true);
                        let linesVerMajor = this.getGridLinesVerMajor(rect, axisArea.gridLinesVert, true);
                        let linesVerMinor = this.getGridLinesVerMinor(rect, axisArea.gridLinesVert, true);
                        let penGridLine = new StiPenGeom(axisArea.gridLinesHor.minorColor, 1);
                        penGridLine.penStyle = axisArea.gridLinesHor.minorStyle;
                        this.drawLines(context, linesHorMinor, penGridLine);
                        penGridLine = new StiPenGeom(axisArea.gridLinesHorRight.minorColor, 1);
                        penGridLine.penStyle = axisArea.gridLinesHorRight.minorStyle;
                        this.drawLines(context, linesHorMinorRight, penGridLine);
                        penGridLine = new StiPenGeom(axisArea.gridLinesVert.minorColor, 1);
                        penGridLine.penStyle = axisArea.gridLinesVert.minorStyle;
                        this.drawLines(context, linesVerMinor, penGridLine);
                        penGridLine = new StiPenGeom(axisArea.gridLinesHor.color, 1);
                        penGridLine.penStyle = axisArea.gridLinesHor.style;
                        this.drawLines(context, linesHorMajor, penGridLine);
                        penGridLine = new StiPenGeom(axisArea.gridLinesHorRight.color, 1);
                        penGridLine.penStyle = axisArea.gridLinesHorRight.style;
                        this.drawLines(context, linesHorMajorRight, penGridLine);
                        penGridLine = new StiPenGeom(axisArea.gridLinesVert.color, 1);
                        penGridLine.penStyle = axisArea.gridLinesVert.style;
                        this.drawLines(context, linesVerMajor, penGridLine);
                    }
                }
                drawLines(context, lines, pen) {
                    for (let line of lines)
                        context.drawLine(pen, line.x1, line.y1, line.x2, line.y2);
                }
            }
            Chart.StiAxisAreaGeom = StiAxisAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiAxisAreaViewGeom extends Chart.StiAreaGeom {
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.isEmpty)
                        return;
                    if (rect.width > 0 && rect.height > 0) {
                        if (this._area.showShadow)
                            context.drawCachedShadow(rect, StiShadowSides.All, context.options.isPrinting);
                    }
                    super.draw(context);
                }
                drawGeom(context) {
                    super.drawGeom(context);
                    this.drawBorder(context);
                }
                drawChildGeoms(context) {
                    if (this.childGeoms != null) {
                        let clipRect = this.clientRectangle.clone();
                        clipRect.x = 0;
                        clipRect.y = 0;
                        context.pushTranslateTransform(this.clientRectangle.x, this.clientRectangle.y);
                        for (let childGeom of this.childGeoms) {
                            let allowClip = childGeom.is(Chart.StiAxisAreaGeom) ||
                                (childGeom.is(Chart.StiXAxisGeom) && childGeom.isCenterAxis) ||
                                (childGeom.is(Chart.StiYAxisGeom) && childGeom.isCenterAxis);
                            if (allowClip)
                                context.pushClip(clipRect);
                            if (this.allowChildDrawing(childGeom))
                                childGeom.drawGeom(context);
                            if (allowClip)
                                context.popClip();
                        }
                        context.popTransform();
                    }
                }
                drawBorder(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.isEmpty)
                        return;
                    let pen = new StiPenGeom(this.area.borderColor);
                    context.drawRectangle2(pen, rect.x, rect.y, rect.width, rect.height);
                }
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiAxisAreaViewGeom = StiAxisAreaViewGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            class StiPieAreaGeom extends Chart.StiAreaGeom {
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width > 0 && rect.height > 0) {
                        if (this.area.showShadow)
                            context.drawCachedShadow(rect, StiShadowSides.All, context.options.isPrinting);
                        context.fillRectangle2(this.area.brush, rect.x, rect.y, rect.width, rect.height, null);
                        let pen = new StiPenGeom(this.area.borderColor);
                        context.drawRectangle2(pen, rect.x, rect.y, rect.width, rect.height);
                    }
                }
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiPieAreaGeom = StiPieAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiDoughnutAreaGeom extends Chart.StiPieAreaGeom {
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiDoughnutAreaGeom = StiDoughnutAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiPictorialAreaGeom extends Chart.StiAreaGeom {
                draw(context) {
                }
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiPictorialAreaGeom = StiPictorialAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            class StiRadarAreaGeom extends Chart.StiAreaGeom {
                constructor(area, clientRectangle, valuesCount) {
                    super(area, clientRectangle);
                    this._valuesCount = valuesCount;
                }
                get valuesCount() {
                    return this._valuesCount;
                }
                drawHor(context, fill, draw) {
                    let rect = this.clientRectangle.clone();
                    let radarArea = this.area;
                    if (radarArea.yAxis.info.stripPositions == null)
                        return;
                    let radarAreaCore = radarArea.core;
                    let index = 0;
                    for (let radius of radarArea.yAxis.info.stripPositions) {
                        if (radius != 0) {
                            let arcRect = new RectangleD(radarAreaCore.centerPoint.x - radius, radarAreaCore.centerPoint.y - radius, radius * 2, radius * 2);
                            if (radarArea.radarStyle == Chart.StiRadarStyle.Circle) {
                                if (fill && radarArea.interlacingHor.visible) {
                                    if (index != radarArea.yAxis.info.stripPositions.length - 1 && ((index & 1) == 0)) {
                                        let path = [];
                                        let radius2 = radarArea.yAxis.info.stripPositions[index + 1];
                                        let arcRect2 = new RectangleD(radarAreaCore.centerPoint.x - radius2, radarAreaCore.centerPoint.y - radius2, radius2 * 2, radius2 * 2);
                                        path.push(new StiArcSegmentGeom(arcRect, 0, 360));
                                        path.push(new StiArcSegmentGeom(arcRect2, 0, 360));
                                        context.fillPath(radarArea.interlacingHor.interlacedBrush, path, rect, null);
                                    }
                                }
                                if (draw && radarArea.gridLinesHor.visible) {
                                    let pen;
                                    if (index == radarArea.yAxis.info.stripPositions.length - 1) {
                                        pen = new StiPenGeom(radarArea.borderColor);
                                    }
                                    else {
                                        pen = new StiPenGeom(radarArea.gridLinesHor.color);
                                        pen.penStyle = radarArea.gridLinesHor.style;
                                    }
                                    context.drawEllipse2(pen, arcRect);
                                }
                            }
                            else {
                                if (fill && radarArea.interlacingHor.visible) {
                                    if (index != radarArea.yAxis.info.stripPositions.length - 1 && ((index & 1) == 1)) {
                                        let path = [];
                                        let pointIndex2 = 0;
                                        for (let curPoint of radarAreaCore.points) {
                                            let nextPoint;
                                            if (pointIndex2 == radarAreaCore.points.length - 1)
                                                nextPoint = radarAreaCore.points[0];
                                            else
                                                nextPoint = radarAreaCore.points[pointIndex2 + 1];
                                            let point1 = new PointD(radarAreaCore.centerPoint.x + radius * curPoint.x, radarAreaCore.centerPoint.y + radius * curPoint.y);
                                            let point2 = new PointD(radarAreaCore.centerPoint.x + radius * nextPoint.x, radarAreaCore.centerPoint.y + radius * nextPoint.y);
                                            path.push(new StiLineSegmentGeom(point1.x, point1.y, point2.x, point2.y));
                                            pointIndex2++;
                                        }
                                        let radius2 = radarArea.yAxis.info.stripPositions[index + 1];
                                        pointIndex2 = 0;
                                        for (let curPoint of radarAreaCore.points) {
                                            let nextPoint;
                                            if (pointIndex2 == radarAreaCore.points.length - 1)
                                                nextPoint = radarAreaCore.points[0];
                                            else
                                                nextPoint = radarAreaCore.points[pointIndex2 + 1];
                                            let point1 = new PointD(radarAreaCore.centerPoint.x + radius2 * curPoint.x, radarAreaCore.centerPoint.y + radius2 * curPoint.y);
                                            let point2 = new PointD(radarAreaCore.centerPoint.x + radius2 * nextPoint.x, radarAreaCore.centerPoint.y + radius2 * nextPoint.y);
                                            path.push(new StiLineSegmentGeom(point1.x, point1.y, point2.x, point2.y));
                                            pointIndex2++;
                                        }
                                        context.fillPath(radarArea.interlacingHor.interlacedBrush, path, rect, null);
                                    }
                                }
                                if (draw && radarArea.gridLinesHor.visible) {
                                    let pointIndex = 0;
                                    for (let curPoint of radarAreaCore.points) {
                                        let nextPoint;
                                        if (pointIndex == radarAreaCore.points.length - 1)
                                            nextPoint = radarAreaCore.points[0];
                                        else
                                            nextPoint = radarAreaCore.points[pointIndex + 1];
                                        let pen;
                                        if (index == radarArea.yAxis.info.stripPositions.length - 1) {
                                            pen = new StiPenGeom(radarArea.borderColor);
                                        }
                                        else {
                                            pen = new StiPenGeom(radarArea.gridLinesHor.color);
                                            pen.penStyle = radarArea.gridLinesHor.style;
                                        }
                                        context.drawLine(pen, radarAreaCore.centerPoint.x + radius * curPoint.x, radarAreaCore.centerPoint.y + radius * curPoint.y, radarAreaCore.centerPoint.x + radius * nextPoint.x, radarAreaCore.centerPoint.y + radius * nextPoint.y);
                                        pointIndex++;
                                    }
                                }
                            }
                        }
                        index++;
                    }
                }
                drawVert(context, fill, draw) {
                    let rect = this.clientRectangle.clone();
                    let radarArea = this.area;
                    let radarAreaCore = radarArea.core;
                    let index = 0;
                    let sweepAngle = 360 / radarAreaCore.points.length;
                    let startAngle = 0;
                    for (let endPoint of radarAreaCore.points) {
                        let point1 = radarAreaCore.centerPoint;
                        let point2 = new PointD(point1.x + rect.width / 2 * endPoint.x, point1.y + rect.width / 2 * endPoint.y);
                        if (fill && radarArea.interlacingVert.visible) {
                            let point3 = index < radarAreaCore.points.length - 1 ?
                                new PointD(point1.x + rect.width / 2 * radarAreaCore.points[index + 1].x, point1.y + rect.height / 2 * radarAreaCore.points[index + 1].y) :
                                new PointD(point1.x + rect.width / 2 * radarAreaCore.points[0].x, point1.y + rect.height / 2 * radarAreaCore.points[0].y);
                            if ((index & 1) == 1) {
                                let path = [];
                                if (radarArea.radarStyle == Chart.StiRadarStyle.Circle) {
                                    path.push(new StiLineSegmentGeom(point1.x, point1.y, point2.x, point2.y));
                                    path.push(new StiArcSegmentGeom(rect, startAngle - 90, sweepAngle));
                                    path.push(new StiLineSegmentGeom(point3.x, point3.y, point1.x, point1.y));
                                }
                                else {
                                    path.push(new StiLineSegmentGeom(point1.x, point1.y, point2.x, point2.y));
                                    path.push(new StiLineSegmentGeom(point2.x, point2.y, point3.x, point3.y));
                                    path.push(new StiLineSegmentGeom(point3.x, point3.y, point1.x, point1.y));
                                }
                                context.fillPath(radarArea.interlacingVert.interlacedBrush, path, rect, null);
                            }
                        }
                        if (draw && radarArea.gridLinesVert.visible) {
                            let pen = new StiPenGeom(radarArea.gridLinesVert.color);
                            pen.penStyle = radarArea.gridLinesVert.style;
                            context.drawLine(pen, point1.x, point1.y, point2.x, point2.y);
                        }
                        startAngle += sweepAngle;
                        index++;
                    }
                }
                drawBackground(context) {
                    let rect = this.clientRectangle.clone();
                    let radarArea = this.area;
                    if (radarArea.yAxis.info.stripPositions == null)
                        return;
                    let radarAreaCore = radarArea.core;
                    if (radarArea.radarStyle == Chart.StiRadarStyle.Circle) {
                        context.fillEllipse2(radarArea.brush, rect, null);
                    }
                    else {
                        let radius = radarArea.yAxis.info.stripPositions[radarArea.yAxis.info.stripPositions.length - 1];
                        let path = [];
                        let pointIndex = 0;
                        for (let curPoint of radarAreaCore.points) {
                            let nextPoint = pointIndex == radarAreaCore.points.length - 1 ?
                                radarAreaCore.points[0] :
                                radarAreaCore.points[pointIndex + 1];
                            path.push(new StiLineSegmentGeom(radarAreaCore.centerPoint.x + radius * curPoint.x, radarAreaCore.centerPoint.y + radius * curPoint.y, radarAreaCore.centerPoint.x + radius * nextPoint.x, radarAreaCore.centerPoint.y + radius * nextPoint.y));
                            pointIndex++;
                        }
                        context.fillPath(radarArea.brush, path, rect, null);
                    }
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width > 0 && rect.height > 0) {
                        context.pushSmoothingModeToAntiAlias();
                        this.drawBackground(context);
                        this.drawVert(context, true, false);
                        this.drawHor(context, true, false);
                        this.drawVert(context, false, true);
                        this.drawHor(context, false, true);
                        context.popSmoothingMode();
                    }
                }
            }
            Chart.StiRadarAreaGeom = StiRadarAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiSunburstAreaGeom extends Chart.StiPieAreaGeom {
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiSunburstAreaGeom = StiSunburstAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            class StiTreemapAreaGeom extends Chart.StiAreaGeom {
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width > 0 && rect.height > 0) {
                        if (this.area.showShadow)
                            context.drawCachedShadow(rect, StiShadowSides.All, context.options.isPrinting);
                        context.fillRectangle2(this.area.brush, rect.x, rect.y, rect.width, rect.height, null);
                        let pen = new StiPenGeom(this.area.borderColor);
                        context.drawRectangle2(pen, rect.x, rect.y, rect.width, rect.height);
                    }
                }
                constructor(area, clientRectangle) {
                    super(area, clientRectangle);
                }
            }
            Chart.StiTreemapAreaGeom = StiTreemapAreaGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiAxisLabelGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, textPoint, text, stripLine, angle, rotationMode) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._text = text;
                    this._stripLine = stripLine;
                    this._textPoint = textPoint;
                    this._angle = angle;
                    this._rotationMode = rotationMode;
                }
                get rotationMode() {
                    return this._rotationMode;
                }
                get textPoint() {
                    return this._textPoint;
                }
                get angle() {
                    return this._angle;
                }
                get axis() {
                    return this._axis;
                }
                get text() {
                    return this._text;
                }
                get stripLine() {
                    return this._stripLine;
                }
                draw(context) {
                    let sf = this.axis.core.getStringFormatGeom(context);
                    let font = this.axis.core.getFontGeom(context);
                    let labelBrush = new StiSolidBrush(this.axis.labels.color);
                    context.drawRotatedString9(this.text, font, labelBrush, this.textPoint, sf, this.rotationMode, this.angle, this.axis.labels.antialiasing, Math.trunc(this.axis.labels.width * context.options.zoom));
                }
            }
            Chart.StiAxisLabelGeom = StiAxisLabelGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiAxisTitleGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, angle, stringAlignment, font) {
                    super(clientRectangle);
                    this._angle = 0;
                    this._axis = axis;
                    this._angle = angle;
                    this._font = font;
                }
                get axis() {
                    return this._axis;
                }
                get angle() {
                    return this._angle;
                }
                get font() {
                    return this._font;
                }
                draw(context) {
                    let brush = new StiSolidBrush(this.axis.title.color);
                    let sf = context.getDefaultStringFormat();
                    context.drawRotatedString5(this.axis.title.text, this.font, brush, this.clientRectangle, sf, StiRotationMode.CenterCenter, this.angle, this.axis.title.antialiasing);
                }
            }
            Chart.StiAxisTitleGeom = StiAxisTitleGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var DateTime = Stimulsoft.System.DateTime;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiXAxisGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, isCenterAxis) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._isCenterAxis = isCenterAxis;
                }
                get axis() {
                    return this._axis;
                }
                get isCenterAxis() {
                    return this._isCenterAxis;
                }
                get view() {
                    return this._view;
                }
                set view(value) {
                    this._view = value;
                }
                drawArrow(context, rect) {
                    let zoom = context.options.zoom;
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    let penArrow = new StiPenGeom(this.axis.lineColor);
                    let brushLine = new StiSolidBrush(this.axis.lineColor);
                    let posY = 0;
                    if (this.axis.core.isBottomSide)
                        posY = rect.y;
                    if (this.axis.core.isTopSide)
                        posY = rect.bottom;
                    let arrowStart = PointD.empty;
                    if (this.axis.area.reverseHor)
                        arrowStart = new PointD(rect.x, posY);
                    else
                        arrowStart = new PointD(rect.right, posY);
                    switch (this.axis.arrowStyle) {
                        case Chart.StiArrowStyle.Triangle: {
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x + this.axis.core.arrowHeight * zoom, arrowStart.y);
                            context.pushSmoothingModeToAntiAlias();
                            let path = [];
                            path.push(new StiLineSegmentGeom(arrowStart.x + this.axis.core.arrowHeight * zoom, arrowStart.y - this.axis.core.arrowWidth * zoom, arrowStart.x + this.axis.core.arrowHeight * 4 * zoom, arrowStart.y));
                            path.push(new StiLineSegmentGeom(arrowStart.x + this.axis.core.arrowHeight * 4 * zoom, arrowStart.y, arrowStart.x + this.axis.core.arrowHeight * zoom, arrowStart.y + this.axis.core.arrowWidth * zoom));
                            context.fillPath(brushLine, path, rect, null);
                            context.popSmoothingMode();
                            break;
                        }
                        case Chart.StiArrowStyle.Lines:
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x + this.axis.core.arrowHeight * 4 * zoom, arrowStart.y);
                            context.pushSmoothingModeToAntiAlias();
                            context.drawLine(penArrow, arrowStart.x + this.axis.core.arrowHeight * zoom, arrowStart.y - this.axis.core.arrowWidth * zoom, arrowStart.x + this.axis.core.arrowHeight * 4 * zoom, arrowStart.y);
                            context.drawLine(penArrow, arrowStart.x + this.axis.core.arrowHeight * 4 * zoom, arrowStart.y, arrowStart.x + this.axis.core.arrowHeight * zoom, arrowStart.y + this.axis.core.arrowWidth * zoom);
                            context.popSmoothingMode();
                            break;
                        case Chart.StiArrowStyle.Circle: {
                            let armCircle = this.axis.core.arrowHeight * zoom;
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x + armCircle * 2, arrowStart.y);
                            let pointCircle = new PointD(arrowStart.x + armCircle * 2, arrowStart.y - armCircle / 2);
                            context.pushSmoothingModeToAntiAlias();
                            let rectCircle = new RectangleD(pointCircle.x, pointCircle.y, armCircle, armCircle);
                            context.drawEllipse2(penLine, rectCircle);
                            context.popSmoothingMode();
                            break;
                        }
                        case Chart.StiArrowStyle.Arc:
                        case Chart.StiArrowStyle.ArcAndCircle: {
                            let armArc = this.axis.core.arrowHeight * zoom;
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x + armArc * 2, arrowStart.y);
                            context.pushSmoothingModeToAntiAlias();
                            let pathArc = [];
                            if (this.axis.area.reverseHor) {
                                let pointArc = new PointD(arrowStart.x + armArc * 3, arrowStart.y + armArc / 2);
                                let rectArc = new RectangleD(pointArc.x, pointArc.y, Math.abs(armArc), Math.abs(armArc));
                                if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                    rectArc.x -= zoom;
                                    rectArc.inflate(1, 1);
                                }
                                pathArc.push(new StiArcSegmentGeom(rectArc, 270, 180));
                            }
                            else {
                                let pointArc = new PointD(arrowStart.x + armArc * 2, arrowStart.y - armArc / 2);
                                let rectArc = new RectangleD(pointArc.x, pointArc.y, Math.abs(armArc), Math.abs(armArc));
                                if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                    rectArc.x += zoom;
                                    rectArc.inflate(1, 1);
                                }
                                pathArc.push(new StiArcSegmentGeom(rectArc, 90, 180));
                            }
                            context.drawPath(penLine, pathArc, StiPathGeom.getBoundsState);
                            if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                let armAC = this.axis.core.arrowHeight * zoom;
                                let pointAC = new PointD(arrowStart.x + armAC * 2 + zoom, arrowStart.y - armAC / 2);
                                let rectAC = new RectangleD(pointAC.x, pointAC.y, armAC, armAC);
                                if (this.axis.area.reverseHor) {
                                    rectAC.inflate(0.5 * zoom, 0.5 * zoom);
                                    rectAC.x -= zoom * 3;
                                }
                                else {
                                    rectAC.inflate(-0.5 * zoom, -0.5 * zoom);
                                    rectAC.x += zoom;
                                }
                                context.fillEllipse2(brushLine, rectAC, null);
                            }
                            context.popSmoothingMode();
                            break;
                        }
                    }
                }
                drawAxisLine(context, rect) {
                    let posY = 0;
                    if (this.axis.core.isTopSide)
                        posY = rect.bottom;
                    if (this.axis.core.isBottomSide)
                        posY = rect.top;
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    if (this.isCenterAxis && (this.axis.showXAxis == Chart.StiShowXAxis.Both || this.axis.showXAxis == Chart.StiShowXAxis.Center)) {
                        if (this.axis.area.reverseVert)
                            context.drawLine(penLine, rect.x, posY, rect.right, posY);
                        else
                            context.drawLine(penLine, rect.x, posY + rect.height, rect.right, posY + rect.height);
                    }
                    else if (!this.isCenterAxis && (this.axis.showXAxis == Chart.StiShowXAxis.Both || this.axis.showXAxis == Chart.StiShowXAxis.Bottom))
                        context.drawLine(penLine, rect.x, posY, rect.right, posY);
                }
                drawMinorTicks(context, pen, posX1, posX2, posY, ticks) {
                    let step = posX2 - posX1;
                    let minorStep = step / (ticks.minorCount + 1);
                    let minorLength = ticks.minorLength * context.options.zoom;
                    for (let minorIndex = 1; minorIndex <= ticks.minorCount; minorIndex++) {
                        let posX = posX1 + minorStep * minorIndex;
                        let posY2 = this.axis.core.isTopSide || this.isCenterAxis ? posY - minorLength : posY + minorLength;
                        if (this.axis.area.reverseVert && this.isCenterAxis)
                            posY2 = posY + minorLength;
                        context.drawLine(pen, posX, posY, posX, posY2);
                    }
                }
                drawTicks(context, rect, ticks, penLine) {
                    if (!ticks.visible)
                        return;
                    let ticksLength = ticks.length * context.options.zoom;
                    let posY1 = this.axis.core.isTopSide || this.isCenterAxis ? rect.bottom : rect.top;
                    let posY2 = this.axis.core.isTopSide || this.isCenterAxis ? posY1 - ticksLength : posY1 + ticksLength;
                    if (this.isCenterAxis && this.axis.area.reverseVert)
                        posY2 = posY1 + ticksLength;
                    let infos = this.axis.info.ticksCollection;
                    if (this.isArgumentDateTime(infos) && this.axis.area.xAxis.dateTimeStep.step != Chart.StiTimeDateStep.None) {
                        let date;
                        let dateNext;
                        let startTick = true;
                        let text = "";
                        let startX = 0;
                        for (let index = 0; index < infos.length; index++) {
                            if (startTick) {
                                startX = infos[index].position;
                                startTick = false;
                            }
                            if (!(infos[index].stripLine.valueObject != null && infos[index].stripLine.valueObject instanceof DateTime))
                                continue;
                            date = infos[index].stripLine.valueObject;
                            if (index < infos.length - 2) {
                                dateNext = infos[index + 1].stripLine.valueObject;
                            }
                            else {
                                dateNext = date;
                            }
                            switch (this.axis.area.xAxis.dateTimeStep.step) {
                                case Chart.StiTimeDateStep.Day:
                                    if (date.toString("yyyyMMMMdd") != dateNext.toString("yyyyMMMMdd") || index == infos.length - 2)
                                        text = date.toString("dd");
                                    break;
                                case Chart.StiTimeDateStep.Hour:
                                    if (date.toString("yyyyMMMMddHH") != dateNext.toString("yyyyMMMMddHH") || index == infos.length - 2)
                                        text = date.toString("HH");
                                    break;
                                case Chart.StiTimeDateStep.Minute:
                                    if (date.toString("yyyyMMMMddhhmm") != dateNext.toString("yyyyMMMMddhhmm") || index == infos.length - 2)
                                        text = date.toString("mm");
                                    break;
                                case Chart.StiTimeDateStep.Month:
                                    if (date.toString("yyyyMMMM") != dateNext.toString("yyyyMMMM") || index == infos.length - 2)
                                        text = date.toString("MMMM");
                                    break;
                                case Chart.StiTimeDateStep.Second:
                                    if (date.toString("yyyyMMMMddHHmmss") != dateNext.toString("yyyyMMMMddHHmmss") || index == infos.length - 2)
                                        text = date.toString("ss");
                                    break;
                                case Chart.StiTimeDateStep.Year:
                                    if (date.toString("yyyy") != dateNext.toString("yyyy") || index == infos.length - 2)
                                        text = date.toString("yyyy");
                                    break;
                            }
                            if (text != "") {
                                let endX = 0;
                                if (index == infos.length - 2) {
                                    endX = infos[index + 1].position;
                                }
                                else {
                                    endX = infos[index].position + (infos[index + 1].position - infos[index].position) / 2;
                                }
                                context.drawRectangle2(penLine, startX, posY1, endX - startX, posY2);
                                text = "";
                                startX = endX;
                            }
                        }
                    }
                    else {
                        let index = 0;
                        for (let strip of this.axis.info.ticksCollection) {
                            let posX = strip.position;
                            context.drawLine(penLine, posX, posY1, posX, posY2);
                            if (ticks.minorVisible && index != this.axis.info.ticksCollection.length - 1) {
                                let posX2 = this.axis.info.ticksCollection[index + 1].position;
                                this.drawMinorTicks(context, penLine, posX, posX2, posY1, ticks);
                            }
                            index++;
                        }
                    }
                }
                isArgumentDateTime(infos) {
                    for (let info of infos) {
                        if (info.stripLine.valueObject != null && info.stripLine.valueObject instanceof DateTime)
                            return true;
                    }
                    return false;
                }
                drawAxis(context, rect) {
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    if (this.isCenterAxis && (this.axis.showXAxis == Chart.StiShowXAxis.Both || this.axis.showXAxis == Chart.StiShowXAxis.Center)) {
                        this.drawTicks(context, rect, this.axis.ticks, penLine);
                    }
                    else if (!this.isCenterAxis) {
                        if (this.axis.core.isTopSide)
                            this.drawTicks(context, rect, this.axis.ticks, penLine);
                        if (this.axis.core.isBottomSide && (this.axis.showXAxis == Chart.StiShowXAxis.Both || this.axis.showXAxis == Chart.StiShowXAxis.Bottom))
                            this.drawTicks(context, rect, this.axis.ticks, penLine);
                    }
                    this.drawAxisLine(context, rect);
                }
                getViewclipRect() {
                    let clipRect = this.view.clientRectangle.clone();
                    clipRect.x = this.axis.area.core.scrollDistanceX;
                    clipRect.y = 0;
                    clipRect.inflate(1, 1);
                    if (this.isCenterAxis)
                        clipRect.inflate(0, 2);
                    return clipRect;
                }
                allowChildDrawing(cellGeom) {
                    let geom = cellGeom;
                    if (geom == null)
                        return true;
                    if (this.view == null)
                        return true;
                    let clipRect = this.getViewclipRect();
                    let geomRect = geom.clientRectangle;
                    return !(geomRect.right < clipRect.x || geomRect.x > clipRect.right);
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width <= 0 || rect.height <= 0)
                        return;
                    if (this.view != null) {
                        let clipRect = this.getViewclipRect();
                        context.pushClip(clipRect);
                    }
                    this.drawAxis(context, rect);
                    if (this.view != null)
                        context.popClip();
                }
            }
            Chart.StiXAxisGeom = StiXAxisGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiXAxisViewGeom extends Chart.StiXAxisGeom {
                drawChildGeoms(context) {
                    let rect = this.clientRectangle.clone();
                    if (this.isCenterAxis) {
                        rect.y += (this.axis.area.core.getDividerY() - this.axis.area.core.scrollDistanceY);
                    }
                    if (this.childGeoms != null) {
                        for (let childGeom of this.childGeoms) {
                            if (this.allowChildDrawing(childGeom)) {
                                if (!(childGeom.is(Chart.StiHorzScrollBarGeom)))
                                    context.pushTranslateTransform(-this.axis.area.core.scrollDistanceX, 0);
                                context.pushTranslateTransform(rect.x, rect.y);
                                childGeom.drawGeom(context);
                                context.popTransform();
                                if (!(childGeom.is(Chart.StiHorzScrollBarGeom)))
                                    context.popTransform();
                            }
                        }
                    }
                    this.draw(context);
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (this.isCenterAxis) {
                        rect.y += (this.axis.area.core.getDividerY() - this.axis.area.core.scrollDistanceY);
                    }
                    if (rect.width <= 0 || rect.height <= 0)
                        return;
                    if (this.axis.arrowStyle != Chart.StiArrowStyle.None && (!this.isCenterAxis))
                        this.drawArrow(context, rect);
                }
                constructor(axis, clientRectangle, isCenterAxis) {
                    super(axis, clientRectangle, isCenterAxis);
                }
            }
            Chart.StiXAxisViewGeom = StiXAxisViewGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiYAxisGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, isCenterAxis) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._isCenterAxis = isCenterAxis;
                }
                get axis() {
                    return this._axis;
                }
                get isCenterAxis() {
                    return this._isCenterAxis;
                }
                get view() {
                    return this._view;
                }
                set view(value) {
                    this._view = value;
                }
                drawArrow(context, rect) {
                    let zoom = context.options.zoom;
                    let penLine = new StiPenGeom(this.axis.lineColor);
                    let brushLine = new StiSolidBrush(this.axis.lineColor);
                    let penArrow = new StiPenGeom(this.axis.lineColor);
                    if (!this.axis.visible)
                        this.drawAxisLine(context, rect);
                    let arrowStart = PointD.empty;
                    if (!this.axis.area.reverseVert)
                        arrowStart = new PointD(rect.right, rect.y);
                    else
                        arrowStart = new PointD(rect.right, rect.bottom);
                    if (this.axis.core.isRightSide)
                        arrowStart.x = rect.x;
                    switch (this.axis.arrowStyle) {
                        case Chart.StiArrowStyle.Triangle: {
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * zoom);
                            context.pushSmoothingModeToAntiAlias();
                            let path = [];
                            path.push(new StiLineSegmentGeom(arrowStart.x - this.axis.core.arrowWidth * zoom, arrowStart.y - this.axis.core.arrowHeight * zoom, arrowStart.x + this.axis.core.arrowWidth * zoom, arrowStart.y - this.axis.core.arrowHeight * zoom));
                            path.push(new StiLineSegmentGeom(arrowStart.x + this.axis.core.arrowWidth * zoom, arrowStart.y - this.axis.core.arrowHeight * zoom, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * 4 * zoom));
                            context.fillPath(brushLine, path, StiPathGeom.getBoundsState, null);
                            context.popSmoothingMode();
                            break;
                        }
                        case Chart.StiArrowStyle.Lines:
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * 4 * zoom);
                            context.pushSmoothingModeToAntiAlias();
                            context.drawLine(penArrow, arrowStart.x - this.axis.core.arrowWidth * zoom, arrowStart.y - this.axis.core.arrowHeight * zoom, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * 4 * zoom);
                            context.drawLine(penArrow, arrowStart.x + this.axis.core.arrowWidth * zoom, arrowStart.y - this.axis.core.arrowHeight * zoom, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * 4 * zoom);
                            context.popSmoothingMode();
                            break;
                        case Chart.StiArrowStyle.Circle: {
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x, arrowStart.y - this.axis.core.arrowHeight * zoom * 2);
                            let armCircle = this.axis.core.arrowHeight * zoom;
                            let pointCircle = new PointD(arrowStart.x - armCircle / 2, arrowStart.y - armCircle * 3);
                            context.pushSmoothingModeToAntiAlias();
                            let rectCircle = new RectangleD(pointCircle.x, pointCircle.y, this.axis.core.arrowHeight * zoom, this.axis.core.arrowHeight * zoom);
                            context.drawEllipse2(penLine, rectCircle);
                            context.popSmoothingMode();
                            break;
                        }
                        case Chart.StiArrowStyle.Arc:
                        case Chart.StiArrowStyle.ArcAndCircle: {
                            let armArc = this.axis.core.arrowHeight * zoom;
                            context.drawLine(penLine, arrowStart.x, arrowStart.y, arrowStart.x, arrowStart.y - armArc * 2);
                            context.pushSmoothingModeToAntiAlias();
                            let pathArc = [];
                            if (this.axis.area.reverseVert) {
                                let pointArc = new PointD(arrowStart.x + armArc / 2, arrowStart.y - armArc * 2);
                                let rectArc = new RectangleD(pointArc.x, pointArc.y, Math.abs(armArc), Math.abs(armArc));
                                if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                    rectArc.y += zoom;
                                    rectArc.inflate(1, 1);
                                }
                                pathArc.push(new StiArcSegmentGeom(rectArc, 180, 180));
                            }
                            else {
                                let pointArc = new PointD(arrowStart.x - armArc / 2, arrowStart.y - armArc * 3);
                                let rectArc = new RectangleD(pointArc.x, pointArc.y, armArc, armArc);
                                if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                    rectArc.y -= zoom;
                                    rectArc.inflate(1, 1);
                                }
                                pathArc.push(new StiArcSegmentGeom(rectArc, 0, 180));
                            }
                            context.drawPath(penLine, pathArc, StiPathGeom.getBoundsState);
                            if (this.axis.arrowStyle == Chart.StiArrowStyle.ArcAndCircle) {
                                let armAC = this.axis.core.arrowHeight * zoom;
                                let pointAC = new PointD(arrowStart.x - armAC / 2, arrowStart.y - armAC * 3 - zoom);
                                let rectAC = new RectangleD(pointAC.x, pointAC.y, armAC, armAC);
                                if (this.axis.area.reverseVert) {
                                    rectAC.inflate(0.5 * zoom, 0.5 * zoom);
                                    rectAC.y += zoom * 3;
                                }
                                else {
                                    rectAC.inflate(-0.5 * zoom, -0.5 * zoom);
                                    rectAC.y -= zoom;
                                }
                                context.fillEllipse2(brushLine, rectAC, null);
                            }
                            context.popSmoothingMode();
                            break;
                        }
                    }
                }
                drawAxisLine(context, rect) {
                    let posX = rect.right;
                    if (this.axis.core.isRightSide)
                        posX = rect.left;
                    if (this.isCenterAxis && this.axis.area.reverseHor)
                        posX = rect.right;
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    if ((this.isCenterAxis && (this.axis.showYAxis == Chart.StiShowYAxis.Both || this.axis.showYAxis == Chart.StiShowYAxis.Center)) ||
                        (!this.isCenterAxis && (this.axis.showYAxis == Chart.StiShowYAxis.Both || this.axis.showYAxis == Chart.StiShowYAxis.Left))) {
                        context.drawLine(penLine, posX, rect.y, posX, rect.bottom);
                    }
                }
                drawMinorTicks(context, pen, posX, posY1, posY2, ticks) {
                    let step = posY2 - posY1;
                    let minorStep = step / (ticks.minorCount + 1);
                    let minorLength = ticks.minorLength * context.options.zoom;
                    for (let minorIndex = 1; minorIndex <= ticks.minorCount; minorIndex++) {
                        let posY = posY1 + minorStep * minorIndex;
                        let posX2 = this.axis.core.isLeftSide || this.isCenterAxis ? posX - minorLength : posX + minorLength;
                        if (this.axis.area.reverseHor && this.isCenterAxis)
                            posX2 = posX + minorLength;
                        context.drawLine(pen, posX, posY, posX2, posY);
                    }
                }
                drawTicks(context, rect, ticks, penLine) {
                    if (!ticks.visible)
                        return;
                    let ticksLength = ticks.length * context.options.zoom;
                    let posX1 = this.axis.core.isLeftSide ? rect.right : rect.left;
                    let posX2 = this.axis.core.isLeftSide ? posX1 - ticksLength : posX1 + ticksLength;
                    if (this.isCenterAxis && this.axis.area.reverseHor) {
                        posX1 = rect.right;
                        posX2 = rect.right + ticksLength;
                    }
                    let index = 0;
                    for (let strip of this.axis.info.ticksCollection) {
                        let posY = strip.position;
                        context.drawLine(penLine, posX1, posY, posX2, posY);
                        if (ticks.minorVisible && index != this.axis.info.ticksCollection.length - 1) {
                            let posY2 = this.axis.info.ticksCollection[index + 1].position;
                            this.drawMinorTicks(context, penLine, posX1, posY, posY2, ticks);
                        }
                        index++;
                    }
                }
                drawAxis(context, rect) {
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    if (this.isCenterAxis && (this.axis.showYAxis == Chart.StiShowYAxis.Both || this.axis.showYAxis == Chart.StiShowYAxis.Center)) {
                        this.drawTicks(context, rect, this.axis.ticks, penLine);
                    }
                    else if (!this.isCenterAxis) {
                        if (this.axis.core.isLeftSide && (this.axis.showYAxis == Chart.StiShowYAxis.Both || this.axis.showYAxis == Chart.StiShowYAxis.Left))
                            this.drawTicks(context, rect, this.axis.area.yAxis.ticks, penLine);
                        if (this.axis.core.isRightSide)
                            this.drawTicks(context, rect, this.axis.area.yRightAxis.ticks, penLine);
                    }
                    this.drawAxisLine(context, rect);
                }
                getViewclipRect() {
                    let clipRect = this.view.clientRectangle.clone();
                    clipRect.x = 0;
                    clipRect.y = this.axis.area.core.scrollDistanceY;
                    clipRect.inflate(1, 1);
                    if (this.isCenterAxis)
                        clipRect.inflate(2, 0);
                    return clipRect;
                }
                allowChildDrawing(cellGeom) {
                    let geom = cellGeom;
                    if (geom == null)
                        return true;
                    if (this.view == null)
                        return true;
                    let clipRect = this.getViewclipRect();
                    let geomRect = geom.clientRectangle;
                    return !(geomRect.bottom < clipRect.y || geomRect.y > clipRect.bottom);
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width <= 0 || rect.height <= 0)
                        return;
                    if (this.view != null) {
                        let clipRect = this.getViewclipRect();
                        context.pushClip(clipRect);
                    }
                    this.drawAxis(context, rect);
                    if (this.view != null)
                        context.popClip();
                }
            }
            Chart.StiYAxisGeom = StiYAxisGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiYAxisViewGeom extends Chart.StiYAxisGeom {
                drawChildGeoms(context) {
                    let rect = this.clientRectangle.clone();
                    if (this.isCenterAxis) {
                        rect.x += this.axis.area.core.getDividerX() - this.axis.area.core.scrollDistanceX;
                    }
                    if (this.childGeoms != null) {
                        for (let childGeom of this.childGeoms) {
                            if (this.allowChildDrawing(childGeom)) {
                                if (!(childGeom.is(Chart.StiVertScrollBarGeom)))
                                    context.pushTranslateTransform(0, -this.axis.area.core.scrollDistanceY);
                                context.pushTranslateTransform(rect.x, rect.y);
                                childGeom.drawGeom(context);
                                context.popTransform();
                                if (!(childGeom.is(Chart.StiVertScrollBarGeom)))
                                    context.popTransform();
                            }
                        }
                    }
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (this.isCenterAxis) {
                        rect.x += this.axis.area.core.getDividerX() -
                            this.axis.area.core.scrollDistanceX;
                    }
                    if (rect.width <= 0 || rect.height <= 0)
                        return;
                    if (this.axis.arrowStyle != Chart.StiArrowStyle.None && (!this.isCenterAxis))
                        this.drawArrow(context, rect);
                }
                constructor(axis, clientRectangle, isCenterAxis) {
                    super(axis, clientRectangle, isCenterAxis);
                }
            }
            Chart.StiYAxisViewGeom = StiYAxisViewGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiDownButtonGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverIncreaseButton) {
                        this.axis.core.isMouseOverIncreaseButton = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverIncreaseButton) {
                        this.axis.core.isMouseOverIncreaseButton = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    options.updateContext = this.moveDown();
                    if (options.updateContext) {
                        if (!options.isRecalled)
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarFirstRecallTime);
                        else
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarOtherRecallTime);
                        options.recallEvent = true;
                    }
                }
                moveDown() {
                    let axisCore = this.axis.area.core;
                    if (axisCore.scrollValueY >= (axisCore.scrollRangeY - axisCore.scrollViewY))
                        return false;
                    else {
                        axisCore.scrollValueY +=
                            axisCore.scrollViewY * Chart.StiAxisCoreXF.defaultScrollBarSmallFactor;
                        if (axisCore.scrollValueY >= (axisCore.scrollRangeY - axisCore.scrollViewY))
                            axisCore.scrollValueY = axisCore.scrollRangeY - axisCore.scrollViewY;
                        axisCore.blockScrollValueY = true;
                        return true;
                    }
                }
                get axis() {
                    return this._axis;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let colorArrow = Color.white;
                    if (this.axis.core.isMouseOverIncreaseButton) {
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                        context.drawRectangle2(new StiPenGeom(this.axis.lineColor), rect.x, rect.y, rect.width, rect.height);
                    }
                    else {
                        colorArrow = this.axis.lineColor;
                    }
                    let arrowWidth = rect.width / 3;
                    let arrowHeight = rect.height / 4;
                    let arrowStart = new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2);
                    context.pushSmoothingModeToAntiAlias();
                    let path = [];
                    path.push(new StiLineSegmentGeom(arrowStart.x - arrowWidth, arrowStart.y - arrowHeight, arrowStart.x, arrowStart.y + arrowHeight));
                    path.push(new StiLineSegmentGeom(arrowStart.x, arrowStart.y + arrowHeight, arrowStart.x + arrowWidth, arrowStart.y - arrowHeight));
                    context.fillPath(colorArrow, path, rect, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiDownButtonGeom = StiDownButtonGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiHorzScrollBarGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    axisCore.blockScrollValueX = true;
                    let buttonSize = this.clientRectangle.height;
                    let mousePointX = options.mousePoint.x - buttonSize;
                    let width = this.clientRectangle.width - buttonSize * 2;
                    axisCore.scrollValueX = mousePointX / width * axisCore.scrollRangeX;
                    if (axisCore.scrollValueX < 0)
                        axisCore.scrollValueX = 0;
                    if (axisCore.scrollValueX >= (axisCore.scrollRangeX - axisCore.scrollViewX))
                        axisCore.scrollValueX = axisCore.scrollRangeX - axisCore.scrollViewX;
                    options.updateContext = true;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let penLine = new StiPenGeom(this.axis.lineColor);
                    context.drawRectangle2(penLine, rect.x, rect.y, rect.width, rect.height);
                }
                get axis() {
                    return this._axis;
                }
            }
            Chart.StiHorzScrollBarGeom = StiHorzScrollBarGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiHorzTrackBarGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, scrollBar) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._scrollBar = scrollBar;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverTrackBar) {
                        this.axis.core.isMouseOverTrackBar = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverTrackBar) {
                        this.axis.core.isMouseOverTrackBar = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    options.dragEnabled = true;
                    axisCore.scrollDragStartValue = axisCore.scrollValueX;
                }
                invokeDrag(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    axisCore.blockScrollValueX = true;
                    let buttonSize = this.scrollBar.clientRectangle.height;
                    let width = this.scrollBar.clientRectangle.width - buttonSize * 2;
                    axisCore.scrollValueX = options.dragDelta.width / width * axisCore.scrollRangeX + axisCore.scrollDragStartValue;
                    if (axisCore.scrollValueX < 0)
                        axisCore.scrollValueX = 0;
                    if (axisCore.scrollValueX >= (axisCore.scrollRangeX - axisCore.scrollViewX))
                        axisCore.scrollValueX = axisCore.scrollRangeX - axisCore.scrollViewX;
                    options.updateContext = true;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let penLine = new StiPenGeom(this.axis.lineColor);
                    let penWhite = new StiPenGeom(Color.white);
                    if (this.axis.core.isMouseOverTrackBar)
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                    else
                        context.fillRectangle2(this.axis.lineColor, rect.x, rect.y, rect.width, rect.height, null);
                    context.drawRectangle2(penLine, rect.x, rect.y, rect.width, rect.height);
                    if (rect.width > 10 && rect.height > 4) {
                        let rollerCenterX = rect.x + rect.width / 2;
                        context.drawLine(penWhite, rollerCenterX - 2, rect.y + 2, rollerCenterX - 2, rect.bottom - 2);
                        context.drawLine(penWhite, rollerCenterX, rect.y + 2, rollerCenterX, rect.bottom - 2);
                        context.drawLine(penWhite, rollerCenterX + 2, rect.y + 2, rollerCenterX + 2, rect.bottom - 2);
                    }
                }
                get axis() {
                    return this._axis;
                }
                get scrollBar() {
                    return this._scrollBar;
                }
            }
            Chart.StiHorzTrackBarGeom = StiHorzTrackBarGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiLeftButtonGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverDecreaseButton) {
                        this.axis.core.isMouseOverDecreaseButton = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverDecreaseButton) {
                        this.axis.core.isMouseOverDecreaseButton = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    options.updateContext = this.moveLeft();
                    if (options.updateContext) {
                        if (!options.isRecalled)
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarFirstRecallTime);
                        else
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarOtherRecallTime);
                        options.recallEvent = true;
                    }
                }
                moveLeft() {
                    let axisCore = this.axis.area.core;
                    if (axisCore.scrollValueX == 0)
                        return false;
                    else {
                        axisCore.scrollValueX -=
                            axisCore.scrollViewX * Chart.StiAxisCoreXF.defaultScrollBarSmallFactor;
                        if (axisCore.scrollValueX < 0)
                            axisCore.scrollValueX = 0;
                        axisCore.blockScrollValueX = true;
                        return true;
                    }
                }
                get axis() {
                    return this._axis;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let colorArrow = Color.white;
                    if (this.axis.core.isMouseOverDecreaseButton) {
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                        context.drawRectangle2(new StiPenGeom(this.axis.lineColor), rect.x, rect.y, rect.width, rect.height);
                    }
                    else {
                        colorArrow = this.axis.lineColor;
                    }
                    let arrowWidth = rect.width / 4;
                    let arrowHeight = rect.height / 3;
                    let arrowStart = new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2);
                    context.pushSmoothingModeToAntiAlias();
                    let path = [];
                    path.push(new StiLineSegmentGeom(arrowStart.x + arrowWidth, arrowStart.y - arrowHeight, arrowStart.x - arrowWidth, arrowStart.y));
                    path.push(new StiLineSegmentGeom(arrowStart.x - arrowWidth, arrowStart.y, arrowStart.x + arrowWidth, arrowStart.y + arrowHeight));
                    context.fillPath(colorArrow, path, rect, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLeftButtonGeom = StiLeftButtonGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiRightButtonGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverIncreaseButton) {
                        this.axis.core.isMouseOverIncreaseButton = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverIncreaseButton) {
                        this.axis.core.isMouseOverIncreaseButton = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    options.updateContext = this.moveRight();
                    if (options.updateContext) {
                        if (!options.isRecalled)
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarFirstRecallTime);
                        else
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarOtherRecallTime);
                        options.recallEvent = true;
                    }
                }
                moveRight() {
                    let axisCore = this.axis.area.core;
                    if (axisCore.scrollValueX >= (axisCore.scrollRangeX - axisCore.scrollViewX))
                        return false;
                    else {
                        axisCore.scrollValueX +=
                            axisCore.scrollViewX * Chart.StiAxisCoreXF.defaultScrollBarSmallFactor;
                        if (axisCore.scrollValueX >= (axisCore.scrollRangeX - axisCore.scrollViewX))
                            axisCore.scrollValueX = axisCore.scrollRangeX - axisCore.scrollViewX;
                        axisCore.blockScrollValueX = true;
                        return true;
                    }
                }
                get axis() {
                    return this._axis;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let colorArrow = Color.white;
                    if (this.axis.core.isMouseOverIncreaseButton) {
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                        context.drawRectangle2(new StiPenGeom(this.axis.lineColor), rect.x, rect.y, rect.width, rect.height);
                    }
                    else {
                        colorArrow = this.axis.lineColor;
                    }
                    let arrowWidth = rect.width / 4;
                    let arrowHeight = rect.height / 3;
                    let arrowStart = new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2);
                    context.pushSmoothingModeToAntiAlias();
                    let path = [];
                    path.push(new StiLineSegmentGeom(arrowStart.x - arrowWidth, arrowStart.y - arrowHeight, arrowStart.x + arrowWidth, arrowStart.y));
                    path.push(new StiLineSegmentGeom(arrowStart.x + arrowWidth, arrowStart.y, arrowStart.x - arrowWidth, arrowStart.y + arrowHeight));
                    context.fillPath(colorArrow, path, rect, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiRightButtonGeom = StiRightButtonGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiUpButtonGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverDecreaseButton) {
                        this.axis.core.isMouseOverDecreaseButton = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverDecreaseButton) {
                        this.axis.core.isMouseOverDecreaseButton = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    options.updateContext = this.moveUp();
                    if (options.updateContext) {
                        if (!options.isRecalled)
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarFirstRecallTime);
                        else
                            options.recallTime = TimeSpan.fromSeconds(Chart.StiAxisCoreXF.defaultScrollBarOtherRecallTime);
                        options.recallEvent = true;
                    }
                }
                moveUp() {
                    let axisCore = this.axis.area.core;
                    if (axisCore.scrollValueY == 0)
                        return false;
                    else {
                        axisCore.scrollValueY -=
                            axisCore.scrollViewY * Chart.StiAxisCoreXF.defaultScrollBarSmallFactor;
                        if (axisCore.scrollValueY < 0)
                            axisCore.scrollValueY = 0;
                        axisCore.blockScrollValueY = true;
                        return true;
                    }
                }
                get axis() {
                    return this._axis;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let colorArrow = Color.white;
                    if (this.axis.core.isMouseOverDecreaseButton) {
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                        context.drawRectangle2(new StiPenGeom(this.axis.lineColor), rect.x, rect.y, rect.width, rect.height);
                    }
                    else {
                        colorArrow = this.axis.lineColor;
                    }
                    let arrowWidth = rect.width / 3;
                    let arrowHeight = rect.height / 4;
                    let arrowStart = new PointD(rect.x + rect.width / 2, rect.y + rect.height / 2);
                    context.pushSmoothingModeToAntiAlias();
                    let path = [];
                    path.push(new StiLineSegmentGeom(arrowStart.x - arrowWidth, arrowStart.y + arrowHeight, arrowStart.x, arrowStart.y - arrowHeight));
                    path.push(new StiLineSegmentGeom(arrowStart.x, arrowStart.y - arrowHeight, arrowStart.x + arrowWidth, arrowStart.y + arrowHeight));
                    context.fillPath(colorArrow, path, rect, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiUpButtonGeom = StiUpButtonGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiVertScrollBarGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    axisCore.blockScrollValueY = true;
                    let buttonSize = this.clientRectangle.width;
                    let mousePointY = options.mousePoint.y - buttonSize;
                    let height = this.clientRectangle.height - buttonSize * 2;
                    axisCore.scrollValueY = mousePointY / height * axisCore.scrollRangeY;
                    if (axisCore.scrollValueY < 0)
                        axisCore.scrollValueY = 0;
                    if (axisCore.scrollValueY >= (axisCore.scrollRangeY - axisCore.scrollViewY))
                        axisCore.scrollValueY = axisCore.scrollRangeY - axisCore.scrollViewY;
                    options.updateContext = true;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let penLine = new StiPenGeom(this.axis.lineColor);
                    context.drawRectangle2(penLine, rect.x, rect.y, rect.width, rect.height);
                }
                get axis() {
                    return this._axis;
                }
            }
            Chart.StiVertScrollBarGeom = StiVertScrollBarGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiVertTrackBarGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, scrollBar) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._scrollBar = scrollBar;
                }
                invokeMouseEnter(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (!this.axis.core.isMouseOverTrackBar) {
                        this.axis.core.isMouseOverTrackBar = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    if (this.axis.core.isMouseOverTrackBar) {
                        this.axis.core.isMouseOverTrackBar = false;
                        options.updateContext = true;
                    }
                }
                invokeMouseDown(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    options.dragEnabled = true;
                    axisCore.scrollDragStartValue = axisCore.scrollValueY;
                }
                invokeDrag(options) {
                    if (!this.axis.interaction.rangeScrollEnabled)
                        return;
                    let axisCore = this.axis.area.core;
                    axisCore.blockScrollValueY = true;
                    let buttonSize = this.scrollBar.clientRectangle.height;
                    let height = this.scrollBar.clientRectangle.height - buttonSize * 2;
                    axisCore.scrollValueY = -options.dragDelta.height / height * axisCore.scrollRangeY + axisCore.scrollDragStartValue;
                    if (axisCore.scrollValueY < 0)
                        axisCore.scrollValueY = 0;
                    if (axisCore.scrollValueY >= (axisCore.scrollRangeY - axisCore.scrollViewY))
                        axisCore.scrollValueY = axisCore.scrollRangeY - axisCore.scrollViewY;
                    options.updateContext = true;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let penLine = new StiPenGeom(this.axis.lineColor);
                    let penWhite = new StiPenGeom(Color.white);
                    if (this.axis.core.isMouseOverTrackBar)
                        context.fillRectangle2(StiColorUtils.light(this.axis.lineColor, 50), rect.x, rect.y, rect.width, rect.height, null);
                    else
                        context.fillRectangle2(this.axis.lineColor, rect.x, rect.y, rect.width, rect.height, null);
                    context.drawRectangle2(penLine, rect.x, rect.y, rect.width, rect.height);
                    if (rect.height > 10 && rect.width > 4) {
                        let rollerCenterY = rect.y + rect.height / 2;
                        context.drawLine(penWhite, rect.x + 2, rollerCenterY - 2, rect.right - 2, rollerCenterY - 2);
                        context.drawLine(penWhite, rect.x + 2, rollerCenterY, rect.right - 2, rollerCenterY);
                        context.drawLine(penWhite, rect.x + 2, rollerCenterY + 2, rect.right - 2, rollerCenterY + 2);
                    }
                }
                get axis() {
                    return this._axis;
                }
                get scrollBar() {
                    return this._scrollBar;
                }
            }
            Chart.StiVertTrackBarGeom = StiVertTrackBarGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            class StiChartTitleGeom extends Chart.StiCellGeom {
                constructor(title, clientRectangle) {
                    super(clientRectangle);
                    this._title = title;
                }
                get title() {
                    return this._title;
                }
                draw(context) {
                    if (this.title.visible) {
                        let angle = this.title.dock;
                        if (this.title.dock == Chart.StiChartTitleDock.Bottom)
                            angle = 0;
                        let font = StiFontGeom.changeFontSize(this.title.font, this.title.font.size * context.options.zoom);
                        let sf = context.getDefaultStringFormat();
                        sf.alignment = this.title.alignment;
                        sf.trimming = StringTrimming.None;
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap | StringFormatFlags.NoClip;
                        context.drawRotatedString8(this.title.text, font, this.title.brush, this.clientRectangle, sf, StiRotationMode.CenterCenter, angle, this.title.antialiasing);
                    }
                }
            }
            Chart.StiChartTitleGeom = StiChartTitleGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiConstantLinesVerticalGeom extends Chart.StiCellGeom {
                constructor(line, clientRectangle, point, mode) {
                    super(clientRectangle);
                    this._line = line;
                    this._point = point;
                    this._mode = mode;
                }
                get line() {
                    return this._line;
                }
                get point() {
                    return this._point;
                }
                get mode() {
                    return this._mode;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.line.lineColor, this.line.lineWidth);
                    pen.penStyle = this.line.lineStyle;
                    context.drawLine(pen, rect.left, rect.top, rect.left, rect.bottom);
                    if (this.line.titleVisible) {
                        let brush = new StiSolidBrush(this.line.lineColor);
                        let font = StiFontGeom.changeFontSize(this.line.font, (this.line.font.size * context.options.zoom));
                        let sf = context.getGenericStringFormat();
                        context.drawRotatedString9(this.line.text, font, brush, this.point, sf, this.mode, 90, this.line.antialiasing, 0);
                    }
                }
            }
            Chart.StiConstantLinesVerticalGeom = StiConstantLinesVerticalGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiConstantLinesYGeom extends Chart.StiCellGeom {
                constructor(line, clientRectangle, point, mode) {
                    super(clientRectangle);
                    this._line = line;
                    this._point = point;
                    this._mode = mode;
                }
                get line() {
                    return this._line;
                }
                get point() {
                    return this._point;
                }
                get mode() {
                    return this._mode;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.line.lineColor, this.line.lineWidth);
                    pen.penStyle = this.line.lineStyle;
                    context.drawLine(pen, rect.left, rect.top, rect.left + rect.width, rect.top);
                    if (this.line.titleVisible) {
                        let brush = new StiSolidBrush(this.line.lineColor);
                        let font = StiFontGeom.changeFontSize(this.line.font, (this.line.font.size * context.options.zoom));
                        let sf = context.getGenericStringFormat();
                        context.drawRotatedString9(this.line.text, font, brush, this.point, sf, this.mode, 0, this.line.antialiasing, 0);
                    }
                }
            }
            Chart.StiConstantLinesYGeom = StiConstantLinesYGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiLegendGeom extends Chart.StiCellGeom {
                constructor(legend, clientRectangle, seriesItems) {
                    super(clientRectangle);
                    this._legend = legend;
                    this._seriesItems = seriesItems;
                }
                get legend() {
                    return this._legend;
                }
                get seriesItems() {
                    return this._seriesItems;
                }
                get legendTitleGeom() {
                    return this._legendTitleGeom;
                }
                set legendTitleGeom(value) {
                    this._legendTitleGeom = value;
                }
                dispose() {
                    super.dispose();
                    this._seriesItems.stimulsoft().clear();
                    this._seriesItems = null;
                }
                draw(context) {
                    if ((!this.legend.visible) || this.seriesItems.length == 0)
                        return;
                    let rect = this.clientRectangle.clone();
                    if (this.legendTitleGeom != null) {
                        rect.y += this.legendTitleGeom.clientRectangle.height;
                        rect.height -= this.legendTitleGeom.clientRectangle.height;
                    }
                    if (rect.width > 0 && rect.height > 0) {
                        if (this.legend.showShadow) {
                            if (this.legend.chart.isAnimation) {
                                let animation = new StiOpacityAnimation(new TimeSpan(0), new TimeSpan(0));
                                context.drawShadowRect(rect, 6, animation);
                            }
                            else
                                context.drawCachedShadow(rect, StiShadowSides.All, context.options.isPrinting);
                        }
                        context.fillRectangle2(this.legend.brush, rect.x, rect.y, rect.width, rect.height, null);
                        let pen = new StiPenGeom(this.legend.borderColor);
                        context.drawRectangle2(pen, rect.x, rect.y, rect.width, rect.height);
                    }
                }
            }
            Chart.StiLegendGeom = StiLegendGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiSeriesInteractionData = Stimulsoft.Base.Context.StiSeriesInteractionData;
            class StiLegendItemGeom extends Chart.StiCellGeom {
                constructor(legend, item, clientRectangle, colorIndex, legendItemsCount, legendItemIndex) {
                    super(clientRectangle);
                    this._legend = legend;
                    this._item = item;
                    this._colorIndex = colorIndex;
                    this._legendItemsCount = legendItemsCount;
                    this.legendItemIndex = legendItemIndex;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                invokeClick(options) {
                    if (this.item.series.interaction != null &&
                        this.item.series.interaction.drillDownEnabled &&
                        this.item.series.interaction.allowSeries) {
                        let data = new StiSeriesInteractionData();
                        if (this.isColorEach) {
                            data.fill(this.item.series.chart.area, this.item.series, this.item.index);
                            data.isElements = true;
                        }
                        else {
                            data.series = this.item.series;
                            data.isElements = false;
                        }
                        this.isMouseOver = false;
                        options.updateContext = true;
                        options.seriesInteractionData = data;
                    }
                }
                get allowMouseOver() {
                    return this.item != null &&
                        this.item.series != null &&
                        this.item.series.interaction != null &&
                        this.item.series.interaction.allowSeries &&
                        this.item.series.interaction.drillDownEnabled;
                }
                get isColorEach() {
                    return this.item.series.chart.area.colorEach;
                }
                get isMouseOver() {
                    if (this.isColorEach) {
                        if (this.item.index == -1)
                            return false;
                        return this.item.series.core.getIsMouseOverSeriesElement(this.item.index);
                    }
                    return this.item.series.core.isMouseOver;
                }
                set isMouseOver(value) {
                    if (this.isColorEach) {
                        if (this.item.index != -1)
                            this.item.series.core.setIsMouseOverSeriesElement(this.item.index, value);
                    }
                    else
                        this.item.series.core.isMouseOver = value;
                }
                get legend() {
                    return this._legend;
                }
                get item() {
                    return this._item;
                }
                get colorIndex() {
                    return this._colorIndex;
                }
                get legendItemsCount() {
                    return this._legendItemsCount;
                }
                draw(context) {
                    let textRect = this.clientRectangle.clone();
                    if (this.legend.markerVisible) {
                        let markerRect = new RectangleD(this.clientRectangle.x, this.clientRectangle.y + (this.clientRectangle.height - this.legend.markerSize.height * context.options.zoom) / 2, this.legend.markerSize.width * context.options.zoom, this.legend.markerSize.height * context.options.zoom);
                        if (this.legend.markerAlignment == Chart.StiMarkerAlignment.Right)
                            markerRect.x = this.clientRectangle.right - markerRect.width;
                        let legendMarker = Chart.StiMarkerLegendFactory.createMarker(this.item.series);
                        legendMarker.draw(context, this.item.series, markerRect, this.colorIndex, this.legendItemsCount, this.legendItemIndex);
                        if (this.legend.markerAlignment == Chart.StiMarkerAlignment.Left)
                            textRect.x += this.legend.markerSize.width * context.options.zoom;
                        textRect.width -= this.legend.markerSize.width * context.options.zoom;
                    }
                    if (this.legend.markerAlignment != Chart.StiMarkerAlignment.Right)
                        textRect.x += 2;
                    textRect.width += 4;
                    let brush = new StiSolidBrush(this.legend.labelsColor);
                    let newFont = StiFontGeom.changeFontSize(this.legend.font, this.legend.font.size * context.options.zoom);
                    let sf = context.getDefaultStringFormat();
                    sf.alignment = StringAlignment.Near;
                    sf.lineAlignment = StringAlignment.Center;
                    sf.formatFlags = 0;
                    if (this.legend.markerAlignment == Chart.StiMarkerAlignment.Right) {
                        sf.formatFlags = StringFormatFlags.NoWrap;
                    }
                    context.drawRotatedString6(this.item.text, newFont, brush, textRect, sf, StiRotationMode.LeftTop, 0, true, 0, false);
                }
            }
            Chart.StiLegendItemGeom = StiLegendItemGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiLegendTitleGeom extends Chart.StiCellGeom {
                constructor(legend, clientRectangle) {
                    super(clientRectangle);
                    this._legend = legend;
                }
                get legend() {
                    return this._legend;
                }
                draw(context) {
                    let brush = new StiSolidBrush(this.legend.titleColor);
                    let newFont = StiFontGeom.changeFontSize(this.legend.titleFont, this.legend.titleFont.size * context.options.zoom);
                    let sf = context.getDefaultStringFormat();
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    sf.formatFlags = 0;
                    context.drawString(this.legend.title, newFont, brush, this.clientRectangle, sf);
                }
            }
            Chart.StiLegendTitleGeom = StiLegendTitleGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendAreaMarker {
                implements() {
                    if (!StiLegendAreaMarker.implementsStiLegendAreaMarker)
                        StiLegendAreaMarker.implementsStiLegendAreaMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendAreaMarker.implementsStiLegendAreaMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiAreaSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getAreaMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    let points = Chart.StiLegendMarkerHelper.getAreaMarkerLinePoints(rect);
                    context.drawLines(pen, points);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendAreaMarker = StiLegendAreaMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiLegendCandelstickMarker {
                implements() {
                    if (!StiLegendCandelstickMarker.implementsStiLegendCandelstickMarker)
                        StiLegendCandelstickMarker.implementsStiLegendCandelstickMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendCandelstickMarker.implementsStiLegendCandelstickMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let series = serie;
                    let seriesBrush = series.brush;
                    let borderColor = series.borderColor;
                    let pen = new StiPenGeom(borderColor);
                    context.pushSmoothingModeToAntiAlias();
                    let pointLeftTop = new PointD(rect.left + rect.width / 4, rect.top + rect.height / 4);
                    let width = rect.width / 2;
                    let height = rect.height / 2;
                    context.fillRectangle2(seriesBrush, pointLeftTop.x, pointLeftTop.y, width, height, null);
                    context.drawRectangle2(pen, pointLeftTop.x, pointLeftTop.y, width, height);
                    context.drawLine(pen, rect.x + rect.width / 2, rect.y, rect.x + rect.width / 2, rect.top + rect.height / 4);
                    context.drawLine(pen, rect.x + rect.width / 2, rect.bottom, rect.x + rect.width / 2, rect.bottom - rect.height / 4);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendCandelstickMarker = StiLegendCandelstickMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiLegendColumnMarker {
                implements() {
                    if (!StiLegendColumnMarker.implementsStiLegendColumnMarker)
                        StiLegendColumnMarker.implementsStiLegendColumnMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendColumnMarker.implementsStiLegendColumnMarker;
                }
                draw(context, series, rect, colorIndex, colorCount, index) {
                    let colorLegend = series.legendColor;
                    let br = colorLegend != null ? new StiSolidBrush(colorLegend) : series.core.getSeriesBrush(colorIndex, colorCount);
                    let pen2 = new StiPenGeom(series.core.getSeriesBorderColor(colorIndex, colorCount));
                    if (series.chart != null && series.chart.style != null)
                        series.chart.style.core.fillColumn(context, rect, br, null);
                    context.drawRectangle2(pen2, rect.x, rect.y, rect.width, rect.height);
                }
            }
            Chart.StiLegendColumnMarker = StiLegendColumnMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiLegendDoughnutMarker {
                implements() {
                    if (!StiLegendDoughnutMarker.implementsStiLegendDoughnutMarker)
                        StiLegendDoughnutMarker.implementsStiLegendDoughnutMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendDoughnutMarker.implementsStiLegendDoughnutMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let series = serie;
                    let seriesBrush = series.brush;
                    if (series.allowApplyBrush) {
                        seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                        seriesBrush = series.processSeriesBrushes(index, seriesBrush);
                    }
                    let borderColor = series.borderColor;
                    if (series.allowApplyBorderColor) {
                        borderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    }
                    let path = [];
                    let pen = new StiPenGeom(borderColor);
                    context.pushSmoothingModeToAntiAlias();
                    path.push(new StiArcSegmentGeom(new RectangleD(rect.x - rect.width, rect.y, rect.width * 2, rect.height * 2), 270, 90));
                    path.push(new StiLineSegmentGeom(rect.right, rect.bottom, rect.x + rect.width / 2, rect.bottom));
                    path.push(new StiArcSegmentGeom(new RectangleD(rect.x - rect.width / 2, rect.bottom - rect.height / 2, rect.width, rect.height), 360, -90));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + rect.height / 2, rect.x, rect.y));
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, rect);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendDoughnutMarker = StiLegendDoughnutMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var SizeF = Stimulsoft.System.Drawing.Size;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var IStiFontIconsSeries = Stimulsoft.Report.Chart.IStiFontIconsSeries;
            class StiLegendFontIconMarker {
                draw(context, series, rect, colorIndex, colorCount, index) {
                    try {
                        let fontIconsSeries = series.as(IStiFontIconsSeries);
                        let icon = fontIconsSeries.icon;
                        let colorLegend = series.legendColor;
                        let br = colorLegend != null ? new StiSolidBrush(colorLegend) : series.core.getSeriesBrush(colorIndex, colorCount);
                        Report.StiFontIconsHelper.drawDirectionIcons(context, br, rect, new SizeF(rect.height, rect.height), icon, null, true);
                    }
                    catch (_a) { }
                }
            }
            Chart.StiLegendFontIconMarker = StiLegendFontIconMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var StiCloseFigureSegmentGeom = Stimulsoft.Base.Context.StiCloseFigureSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiLegendFunnelMarker {
                implements() {
                    if (!StiLegendFunnelMarker.implementsStiLegendFunnelMarker)
                        StiLegendFunnelMarker.implementsStiLegendFunnelMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendFunnelMarker.implementsStiLegendFunnelMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let series = serie;
                    let seriesBrush = series.brush;
                    if (series.allowApplyBrush) {
                        seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                        seriesBrush = series.processSeriesBrushes(colorIndex, seriesBrush);
                    }
                    let borderColor = series.borderColor;
                    if (series.allowApplyBorderColor) {
                        borderColor = series.core.getSeriesBorderColor(colorIndex, colorCount);
                    }
                    let path = [];
                    let pen = new StiPenGeom(borderColor);
                    context.pushSmoothingModeToAntiAlias();
                    let points = [new PointD(rect.x, rect.y), new PointD(rect.right, rect.y),
                        new PointD(rect.x + rect.width * 3 / 4, rect.top + rect.height / 2), new PointD(rect.x + rect.width * 3 / 4, rect.bottom),
                        new PointD(rect.x + rect.width * 1 / 4, rect.bottom), new PointD(rect.x + rect.width * 1 / 4, rect.top + rect.height / 2)];
                    path.push(new StiLinesSegmentGeom(points));
                    path.push(new StiCloseFigureSegmentGeom());
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendFunnelMarker = StiLegendFunnelMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var SizeF = Stimulsoft.System.Drawing.Size;
            class StiLegendLineMarker {
                implements() {
                    if (!StiLegendLineMarker.implementsStiLegendLineMarker)
                        StiLegendLineMarker.implementsStiLegendLineMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendLineMarker.implementsStiLegendLineMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let colorMarker = Color.transparent;
                    let drawLine = false;
                    let drawMarker = false;
                    let icon = null;
                    let radarSeries = serie.stimulsoft().as(Chart.IStiRadarSeries);
                    if (radarSeries != null) {
                        colorMarker = StiBrush.toColor(radarSeries.marker.brush);
                        icon = radarSeries.marker.icon;
                        drawMarker = true;
                    }
                    let radarLineSeries = serie.stimulsoft().as(Chart.IStiRadarLineSeries);
                    if (radarLineSeries != null) {
                        colorMarker = radarLineSeries.lineColor;
                        drawMarker = radarLineSeries.marker.visible;
                        icon = radarLineSeries.marker.icon;
                        drawLine = true;
                    }
                    let lineSeries = serie.stimulsoft().as(Chart.IStiBaseLineSeries);
                    if (lineSeries != null) {
                        colorMarker = lineSeries.lineColor;
                        drawMarker = lineSeries.marker.visible;
                        icon = lineSeries.marker.icon;
                        drawLine = true;
                    }
                    let stackedLineSeries = serie.stimulsoft().as(Chart.IStiStackedBaseLineSeries);
                    if (stackedLineSeries != null) {
                        colorMarker = stackedLineSeries.lineColor;
                        drawMarker = stackedLineSeries.marker.visible;
                        icon = stackedLineSeries.marker.icon;
                        drawLine = true;
                    }
                    let scatterSeries = serie.stimulsoft().as(Chart.IStiScatterSeries);
                    if (scatterSeries != null) {
                        colorMarker = StiBrush.toColor(scatterSeries.marker.brush);
                        icon = scatterSeries.marker.icon;
                        drawMarker = true;
                        drawLine = false;
                    }
                    let scatterLineSeries = serie.stimulsoft().as(Chart.IStiScatterLineSeries);
                    if (scatterLineSeries != null) {
                        colorMarker = scatterLineSeries.lineColor;
                        drawMarker = scatterLineSeries.marker.visible;
                        icon = scatterLineSeries.marker.icon;
                        drawLine = true;
                    }
                    let bubbleSeries = serie.stimulsoft().as(Chart.IStiBubbleSeries);
                    if (bubbleSeries != null) {
                        let seriesBrush = bubbleSeries.brush;
                        if (bubbleSeries.allowApplyStyle) {
                            seriesBrush = bubbleSeries.core.getSeriesBrush(colorIndex, colorCount);
                            seriesBrush = bubbleSeries.processSeriesBrushes(colorIndex, seriesBrush);
                        }
                        colorMarker = StiBrush.toColor(seriesBrush);
                        drawMarker = true;
                        drawLine = false;
                    }
                    if (icon != null) {
                        Report.StiFontIconsHelper.drawDirectionIcons(context, new StiSolidBrush(colorMarker), rect, new SizeF(rect.height, rect.height), icon, null, false);
                    }
                    else {
                        if (drawLine) {
                            let pen = new StiPenGeom(colorMarker);
                            context.drawRectangle(pen, rect);
                            context.drawLine(pen, rect.x, rect.y + rect.height / 2, rect.right, rect.y + rect.height / 2);
                        }
                        if (drawMarker) {
                            if (drawLine)
                                rect = new Rectangle(rect.x + rect.width / 4, rect.y + rect.height / 4, rect.width / 2, rect.height / 2);
                            context.pushSmoothingModeToAntiAlias();
                            context.fillEllipse2(new StiSolidBrush(colorMarker), rect, null);
                            context.popSmoothingMode();
                        }
                    }
                }
            }
            Chart.StiLegendLineMarker = StiLegendLineMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
            class StiLegendMarkerHelper {
                static getSteppedMarkerPath(rect) {
                    let path = [];
                    path.push(new StiLineSegmentGeom(rect.x, rect.y, rect.x + rect.width, rect.y));
                    path.push(new StiLineSegmentGeom(rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height));
                    path.push(new StiLineSegmentGeom(rect.x + rect.width, rect.y + rect.height, rect.x, rect.y + rect.height));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + rect.height, rect.x, rect.y));
                    return path;
                }
                static getAreaMarkerPath(rect) {
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    let path = [];
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 3.5, rect.x, rect.y + height1 * 3.5));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 3.5, rect.x + width1 * 2, rect.y + height1 * 0.5));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 2, rect.y + height1 * 0.5, rect.x + width1 * 4, rect.y + height1 * 2.5));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 4, rect.y + height1 * 2.5, rect.x + width1 * 5, rect.y + height1 * 1.5));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 1.5, rect.x + width1 * 5, rect.y + height1 * 5));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 5, rect.x, rect.y + height1 * 5));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 5, rect.x, rect.y + height1 * 3));
                    return path;
                }
                static getAreaMarkerLinePoints(rect) {
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    let points = [];
                    points.push(new PointD(rect.x, rect.y + height1 * 3.5));
                    points.push(new PointD(rect.x + width1 * 2, rect.y + height1 * 0.5));
                    points.push(new PointD(rect.x + width1 * 4, rect.y + height1 * 2.5));
                    points.push(new PointD(rect.x + width1 * 5, rect.y + height1 * 1.5));
                    return points;
                }
                static getSplineAreaMarkerPath(rect) {
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    let path = [];
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 5, rect.x, rect.y + height1 * 3.5));
                    let points = StiLegendMarkerHelper.getSplineAreaMarkerLinePoints(rect);
                    path.push(new StiCurveSegmentGeom(points, 0.55));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 1.5, rect.x + width1 * 5, rect.y + height1 * 5));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 5, rect.x, rect.y + height1 * 5));
                    return path;
                }
                static getSplineAreaMarkerLinePoints(rect) {
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    let points = [];
                    points.push(new PointD(rect.x, rect.y + height1 * 3.5));
                    points.push(new PointD(rect.x + width1 * 2, rect.y + height1 * 0.5));
                    points.push(new PointD(rect.x + width1 * 4, rect.y + height1 * 2.5));
                    points.push(new PointD(rect.x + width1 * 5, rect.y + height1 * 1.5));
                    return points;
                }
            }
            Chart.StiLegendMarkerHelper = StiLegendMarkerHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiLegendPictorialMarker {
                implements() {
                    if (!StiLegendPictorialMarker.implementsStiLegendPictorialMarker)
                        StiLegendPictorialMarker.implementsStiLegendPictorialMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendPictorialMarker.implementsStiLegendPictorialMarker;
                }
                draw(context, series, rect, colorIndex, colorCount, index) {
                    let brush = series.core.getSeriesBrush(colorIndex, colorCount);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillEllipse2(brush, rect, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendPictorialMarker = StiLegendPictorialMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiLegendPieMarker {
                implements() {
                    if (!StiLegendPieMarker.implementsStiLegendPieMarker)
                        StiLegendPieMarker.implementsStiLegendPieMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendPieMarker.implementsStiLegendPieMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let series = serie;
                    let seriesBrush = series.brush;
                    if (series.allowApplyBrush) {
                        seriesBrush = series.core.getSeriesBrush(colorIndex, colorCount);
                        seriesBrush = series.processSeriesBrushes(colorIndex, seriesBrush);
                    }
                    let borderColor = series.borderColor;
                    if (series.allowApplyBorderColor) {
                        borderColor = serie.core.getSeriesBorderColor(colorIndex, colorCount);
                    }
                    let path = [];
                    let pen = new StiPenGeom(borderColor);
                    context.pushSmoothingModeToAntiAlias();
                    path.push(new StiArcSegmentGeom(new RectangleD(rect.x - rect.width, rect.y, rect.width * 2, rect.height * 2), 270, 90));
                    path.push(new StiLineSegmentGeom(rect.right, rect.bottom, rect.x, rect.bottom));
                    path.push(new StiLineSegmentGeom(rect.x, rect.bottom, rect.x, rect.y));
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, null);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendPieMarker = StiLegendPieMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            class StiLegendRangeMarker {
                implements() {
                    if (!StiLegendRangeMarker.implementsStiLegendRangeMarker)
                        StiLegendRangeMarker.implementsStiLegendRangeMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendRangeMarker.implementsStiLegendRangeMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let rangeSeries = serie.stimulsoft().as(Chart.StiRangeSeries);
                    let lineColor = rangeSeries.lineColor;
                    let seriesBrush = rangeSeries.brush;
                    let path = [];
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 3, rect.x, rect.y + height1 * 3));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 3, rect.x + width1 * 2, rect.y));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 2, rect.y, rect.x + width1 * 4, rect.y + height1 * 2));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 4, rect.y + height1 * 2, rect.x + width1 * 5, rect.y + height1 * 1));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 1, rect.x + width1 * 5, rect.y + height1 * 3));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 3, rect.x + width1 * 4, rect.y + height1 * 4));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 4, rect.y + height1 * 4, rect.x + width1 * 2, rect.y + height1 * 3));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 2, rect.y + height1 * 3, rect.x, rect.y + height1 * 5));
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 5, rect.x, rect.y + height1 * 3));
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, rect);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendRangeMarker = StiLegendRangeMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendSplineAreaMarker {
                implements() {
                    if (!StiLegendSplineAreaMarker.implementsStiLegendSplineAreaMarker)
                        StiLegendSplineAreaMarker.implementsStiLegendSplineAreaMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendSplineAreaMarker.implementsStiLegendSplineAreaMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiSplineAreaSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getSplineAreaMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    let points = Chart.StiLegendMarkerHelper.getSplineAreaMarkerLinePoints(rect);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawLines(pen, points);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendSplineAreaMarker = StiLegendSplineAreaMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
            class StiLegendSplineRangeMarker {
                implements() {
                    if (!StiLegendSplineRangeMarker.implementsStiLegendSplineRangeMarker)
                        StiLegendSplineRangeMarker.implementsStiLegendSplineRangeMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendSplineRangeMarker.implementsStiLegendSplineRangeMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let rangeSeries = serie.stimulsoft().as(Chart.StiSplineRangeSeries);
                    let lineColor = rangeSeries.lineColor;
                    let seriesBrush = rangeSeries.brush;
                    let path = [];
                    let width1 = rect.width / 5;
                    let height1 = rect.height / 5;
                    path.push(new StiLineSegmentGeom(rect.x, rect.y + height1 * 5, rect.x, rect.y + height1 * 3));
                    let points1 = [];
                    points1.push(new PointD(rect.x, rect.y + height1 * 3));
                    points1.push(new PointD(rect.x + width1 * 2, rect.y));
                    points1.push(new PointD(rect.x + width1 * 4, rect.y + height1 * 2));
                    points1.push(new PointD(rect.x + width1 * 5, rect.y + height1 * 1));
                    path.push(new StiCurveSegmentGeom(points1, rangeSeries.tension));
                    path.push(new StiLineSegmentGeom(rect.x + width1 * 5, rect.y + height1 * 1, rect.x + width1 * 5, rect.y + height1 * 3));
                    let points2 = [];
                    points2.push(new PointD(rect.x + width1 * 5, rect.y + height1 * 3));
                    points2.push(new PointD(rect.x + width1 * 4, rect.y + height1 * 4));
                    points2.push(new PointD(rect.x + width1 * 2, rect.y + height1 * 4));
                    points2.push(new PointD(rect.x, rect.y + height1 * 5));
                    path.push(new StiCurveSegmentGeom(points2, rangeSeries.tension));
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawCurve(pen, points1, rangeSeries.tension);
                    context.drawCurve(pen, points2, rangeSeries.tension);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendSplineRangeMarker = StiLegendSplineRangeMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendStackedAreaMarker {
                implements() {
                    if (!StiLegendStackedAreaMarker.implementsStiLegendStackedAreaMarker)
                        StiLegendStackedAreaMarker.implementsStiLegendStackedAreaMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendStackedAreaMarker.implementsStiLegendStackedAreaMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiStackedAreaSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getAreaMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    let points = Chart.StiLegendMarkerHelper.getAreaMarkerLinePoints(rect);
                    context.drawLines(pen, points);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendStackedAreaMarker = StiLegendStackedAreaMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendStackedSplineAreaMarker {
                implements() {
                    if (!StiLegendStackedSplineAreaMarker.implementsStiLegendStackedSplineAreaMarker)
                        StiLegendStackedSplineAreaMarker.implementsStiLegendStackedSplineAreaMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendStackedSplineAreaMarker.implementsStiLegendStackedSplineAreaMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiStackedSplineAreaSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getSplineAreaMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    let points = Chart.StiLegendMarkerHelper.getSplineAreaMarkerLinePoints(rect);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawLines(pen, points);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendStackedSplineAreaMarker = StiLegendStackedSplineAreaMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendSteppedAreaMarker {
                implements() {
                    if (!StiLegendSteppedAreaMarker.implementsStiLegendSteppedAreaMarker)
                        StiLegendSteppedAreaMarker.implementsStiLegendSteppedAreaMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendSteppedAreaMarker.implementsStiLegendSteppedAreaMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiSteppedAreaSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getSteppedMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, rect);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendSteppedAreaMarker = StiLegendSteppedAreaMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendSteppedRangeMarker {
                implements() {
                    if (!StiLegendSteppedRangeMarker.implementsStiSteppedRangeSeries)
                        StiLegendSteppedRangeMarker.implementsStiSteppedRangeSeries = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendSteppedRangeMarker.implementsStiSteppedRangeSeries;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let areaSeries = serie.stimulsoft().as(Chart.StiSteppedRangeSeries);
                    let lineColor = areaSeries.lineColor;
                    let seriesBrush = areaSeries.brush;
                    let path = Chart.StiLegendMarkerHelper.getSteppedMarkerPath(rect);
                    let pen = new StiPenGeom(lineColor);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(seriesBrush, path, rect, null);
                    context.drawPath(pen, path, rect);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendSteppedRangeMarker = StiLegendSteppedRangeMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiLegendStockMarker {
                implements() {
                    if (!StiLegendStockMarker.implementsStiLegendStockMarker)
                        StiLegendStockMarker.implementsStiLegendStockMarker = [
                            Chart.IStiLegendMarker
                        ];
                    return StiLegendStockMarker.implementsStiLegendStockMarker;
                }
                draw(context, serie, rect, colorIndex, colorCount, index) {
                    let series = serie;
                    let color = series.lineColor;
                    let pen = new StiPenGeom(color);
                    context.pushSmoothingModeToAntiAlias();
                    context.drawLine(pen, rect.left + rect.width / 4, rect.top + rect.height / 4, rect.left + rect.width / 2, rect.top + rect.height / 4);
                    context.drawLine(pen, rect.left + rect.width / 2, rect.top, rect.left + rect.width / 2, rect.bottom);
                    context.drawLine(pen, rect.left + rect.width / 2, rect.bottom - rect.height / 4, rect.right - rect.width / 4, rect.bottom - rect.height / 4);
                    context.popSmoothingMode();
                }
            }
            Chart.StiLegendStockMarker = StiLegendStockMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiMarkerLegendFactory {
                static createMarker(series) {
                    if (series.is(Chart.IStiFontIconsSeries) && series.icon != null)
                        return new Chart.StiLegendFontIconMarker();
                    else if (series.is(Chart.IStiDoughnutSeries))
                        return new Chart.StiLegendDoughnutMarker();
                    if (series.is(Chart.IStiPieSeries))
                        return new Chart.StiLegendPieMarker();
                    else if (series.is(Chart.StiAreaSeries))
                        return new Chart.StiLegendAreaMarker();
                    else if (series.is(Chart.StiStackedAreaSeries))
                        return new Chart.StiLegendStackedAreaMarker();
                    else if (series.is(Chart.StiSplineAreaSeries))
                        return new Chart.StiLegendSplineAreaMarker();
                    else if (series.is(Chart.StiStackedSplineAreaSeries))
                        return new Chart.StiLegendStackedSplineAreaMarker();
                    else if (series.is(Chart.StiSteppedAreaSeries))
                        return new Chart.StiLegendSteppedAreaMarker();
                    else if (series.is(Chart.StiRangeSeries))
                        return new Chart.StiLegendRangeMarker();
                    else if (series.is(Chart.StiSplineRangeSeries))
                        return new Chart.StiLegendSplineRangeMarker();
                    else if (series.is(Chart.StiSteppedRangeSeries))
                        return new Chart.StiLegendSteppedRangeMarker();
                    else if (series.is(Chart.IStiBaseLineSeries) || series.is(Chart.IStiStackedBaseLineSeries) || series.is(Chart.IStiRadarSeries))
                        return new Chart.StiLegendLineMarker();
                    else if (series.is(Chart.IStiFunnelSeries))
                        return new Chart.StiLegendFunnelMarker();
                    else if (series.is(Chart.IStiStockSeries))
                        return new Chart.StiLegendStockMarker();
                    else if (series.is(Chart.IStiCandlestickSeries))
                        return new Chart.StiLegendCandelstickMarker();
                    else if (series.is(Chart.IStiPictorialSeries))
                        return new Chart.StiLegendPictorialMarker();
                    return new Chart.StiLegendColumnMarker();
                }
            }
            Chart.StiMarkerLegendFactory = StiMarkerLegendFactory;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
            var IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            class StiMarkerGeom extends Chart.StiCellGeom {
                constructor(series, index, value, point, marker, showShadow, zoom, isTooltipMode) {
                    super(Chart.StiMarkerCoreXF.getMarkerRect(point, marker.size, zoom));
                    this._series = series;
                    this._index = index;
                    this._value = value;
                    this._point = point;
                    this._marker = marker;
                    this._showShadow = showShadow;
                    this._isTooltipMode = isTooltipMode;
                }
                implements() {
                    if (!StiMarkerGeom.implementsStiMarkerGeom)
                        StiMarkerGeom.implementsStiMarkerGeom = super.implements().concat([
                            IStiSeriesElement
                        ]);
                    return StiMarkerGeom.implementsStiMarkerGeom;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                    let valueIndex = this.getValueIndex();
                    options.interactionToolTip = this.getToolTip2(valueIndex);
                    options.interactionHyperlink = this.getHyperlink2(valueIndex);
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                invokeClick(options) {
                    let valueIndex = this.getValueIndex();
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length) {
                        options.interactionHyperlink = this.series.hyperlinks[valueIndex];
                    }
                    if (this.series.interaction.drillDownEnabled) {
                        options.seriesInteractionData = this.interaction;
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                getValueIndex() {
                    let valueIndex = this.index;
                    if (this.series.is(Chart.IStiClusteredBarSeries) ||
                        this.series.is(Chart.IStiStackedBarSeries) ||
                        this.series.is(Chart.IStiFullStackedBarSeries)) {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && !this.series.chart.area.reverseVert)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    else {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && this.series.chart.area.reverseHor)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    return valueIndex;
                }
                getHyperlink() {
                    return this.getHyperlink2(this.getValueIndex());
                }
                getHyperlink2(valueIndex) {
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                getToolTip() {
                    return this.getToolTip2(this.getValueIndex());
                }
                getToolTip2(valueIndex) {
                    let textTooltip = null;
                    if (this.series.toolTips != null && valueIndex < this.series.toolTips.length)
                        textTooltip = this.series.toolTips[valueIndex];
                    if (!StiString.isNullOrEmpty(textTooltip) && textTooltip.stimulsoft().contains("\"StiColor\":\"#ffffff\"")) {
                        let color = StiBrush.toColor(this.series.processSeriesBrushes(this.index, this.marker.brush));
                        textTooltip = textTooltip.replace("\"StiColor\":\"#ffffff\"", StiString.format("\"StiColor\":\"{0}\"", Stimulsoft.System.Drawing.ColorTranslator.toHtml2(color, false)));
                    }
                    return textTooltip;
                }
                get allowMouseOver() {
                    let index = this.getValueIndex();
                    return this.getHyperlink2(this.getValueIndex()) != null ||
                        (this.series.toolTips != null && index < this.series.toolTips.length) ||
                        (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeriesElements);
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.getIsMouseOverSeriesElement(this.index);
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.setIsMouseOverSeriesElement(this.index, value);
                }
                get interaction() {
                    return this._interaction;
                }
                set interaction(value) {
                    this._interaction = value;
                }
                get index() {
                    return this._index;
                }
                get point() {
                    return this._point;
                }
                get marker() {
                    return this._marker;
                }
                get value() {
                    return this._value;
                }
                get showShadow() {
                    return this._showShadow;
                }
                get series() {
                    return this._series;
                }
                get elementIndex() {
                    return this._elementIndex;
                }
                set elementIndex(value) {
                    this._elementIndex = value;
                }
                get isTooltipMode() {
                    return this._isTooltipMode;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    return this.getMouseOverRect().contains(x, y);
                }
                getMouseOverRect() {
                    let rect = this.clientRectangle.clone();
                    rect.inflate(rect.width / 2, rect.height / 2);
                    return rect;
                }
                draw(context) {
                    context.pushSmoothingModeToAntiAlias();
                    let chartZoom = context.options.zoom;
                    if (this.isMouseOver)
                        context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), this.getMouseOverRect(), null);
                    let chart = this.series.chart;
                    let markerClone = this.marker.clone();
                    let conditionVisible = this.series.processSeriesMarkerVisible(this.index) || this.marker.visible;
                    if (!this._isTooltipMode || conditionVisible) {
                        markerClone.brush = this.series.processSeriesBrushes(this.index, this.marker.brush);
                        markerClone.angle = this.series.processSeriesMarkerAngle(this.index, this.marker.angle);
                        markerClone.type = this.series.processSeriesMarkerType(this.index, this.marker.type);
                        markerClone.visible = conditionVisible;
                    }
                    if (this._isTooltipMode && !conditionVisible) {
                        markerClone.brush = null;
                        markerClone.borderColor = Color.transparent;
                    }
                    let interaction = null;
                    if (chart.isAnimation) {
                        interaction = new StiInteractionDataGeom();
                        interaction.componentName = chart.name;
                        interaction.componentIndex = chart.page.components.indexOf(chart).toString();
                        interaction.pageGuid = this._series.stimulsoft().as(Chart.StiSeries).drillDownPageGuid;
                        interaction.pageIndex = chart.page.report.renderedPages.indexOf(chart.page).toString();
                        interaction.elementIndex = this.elementIndex.toString();
                        interaction.interactionData = this.interaction;
                    }
                    this.marker.core.draw(context, markerClone, this.point, chartZoom, this.showShadow, this.isMouseOver || this.series.core.isMouseOver, this.isTooltipMode, chart.isAnimation, this.getToolTip(), this, interaction);
                    context.popSmoothingMode();
                }
            }
            Chart.StiMarkerGeom = StiMarkerGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiRadarAxisGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle) {
                    super(clientRectangle);
                    this._axis = axis;
                }
                get axis() {
                    return this._axis;
                }
                drawAxisLine(context, rect) {
                    let posX = rect.right;
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    context.drawLine(penLine, posX, rect.y, posX, rect.bottom);
                }
                drawMinorTicks(context, pen, posX, posY1, posY2, ticks) {
                    let step = posY2 - posY1;
                    let minorStep = step / (ticks.minorCount + 1);
                    let minorLength = ticks.minorLength * context.options.zoom;
                    for (let minorIndex = 1; minorIndex <= ticks.minorCount; minorIndex++) {
                        let posY = posY1 + minorStep * minorIndex;
                        let posX2 = posX - minorLength;
                        context.drawLine(pen, posX, posY, posX2, posY);
                    }
                }
                drawTicks(context, rect, ticks, penLine) {
                    if (!ticks.visible)
                        return;
                    let ticksLength = ticks.length * context.options.zoom;
                    let posX1 = rect.right;
                    let posX2 = posX1 - ticksLength;
                    let index = 0;
                    for (let strip of this.axis.info.ticksCollection) {
                        let posY = strip.position;
                        context.drawLine(penLine, posX1, posY, posX2, posY);
                        if (ticks.minorVisible && index != this.axis.info.ticksCollection.length - 1) {
                            let posY2 = this.axis.info.ticksCollection[index + 1].position;
                            this.drawMinorTicks(context, penLine, posX1, posY, posY2, ticks);
                        }
                        index++;
                    }
                }
                drawAxis(context, rect) {
                    let penLine = new StiPenGeom(this.axis.lineColor, this.axis.lineWidth);
                    penLine.penStyle = this.axis.lineStyle;
                    this.drawTicks(context, rect, this.axis.area.yAxis.ticks, penLine);
                    this.drawAxisLine(context, rect);
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    if (rect.width <= 0 || rect.height <= 0)
                        return;
                    this.drawAxis(context, rect);
                }
            }
            Chart.StiRadarAxisGeom = StiRadarAxisGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            class StiXRadarAxisLabelGeom extends Chart.StiCellGeom {
                constructor(axis, text, labelBrush, borderColor, angle, clientRectangle, labelRect, point) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._labelRect = labelRect;
                    this._text = text;
                    this._angle = angle;
                    this._point = point;
                    this._labelBrush = labelBrush;
                    this._borderColor = borderColor;
                }
                get borderColor() {
                    return this._borderColor;
                }
                get labelBrush() {
                    return this._labelBrush;
                }
                get text() {
                    return this._text;
                }
                get angle() {
                    return this._angle;
                }
                get point() {
                    return this._point;
                }
                get labelRect() {
                    return this._labelRect;
                }
                get axis() {
                    return this._axis;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let borderPen = new StiPenGeom(this.borderColor);
                    let font = StiFontGeom.changeFontSize(this.axis.labels.font, (this.axis.labels.font.size * context.options.zoom));
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    if (!this.axis.labels.wordWrap)
                        sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    if (this.axis.labels.antialiasing)
                        context.pushSmoothingModeToAntiAlias();
                    let distX = Math.round2(this.labelRect.x + this.labelRect.width / 2, 0);
                    let distY = Math.round2(this.labelRect.y + this.labelRect.height / 2, 0);
                    context.pushTranslateTransform(distX, distY);
                    context.pushRotateTransform(this.angle);
                    if (!rect.isEmpty) {
                        context.fillRectangle(this.axis.labels.brush, rect, null);
                        if (this.axis.labels.drawBorder)
                            context.drawRectangle2(borderPen, rect.x, rect.y, rect.width, rect.height);
                    }
                    context.popTransform();
                    context.popTransform();
                    if (this.axis.labels.antialiasing)
                        context.popSmoothingMode();
                    let mode = StiRotationMode.CenterBottom;
                    let textAngle = this.angle;
                    if (this.angle >= 90 && this.angle <= 270) {
                        textAngle = this.angle + 180;
                        mode = StiRotationMode.CenterTop;
                    }
                    if (!(this.axis.labels.rotationLabels)) {
                        if (this.angle > 0 && this.angle < 180) {
                            mode = StiRotationMode.LeftCenter;
                        }
                        else if (this.angle < 360 && this.angle > 180) {
                            mode = StiRotationMode.RightCenter;
                        }
                        else if (this.angle == 0) {
                            mode = StiRotationMode.CenterBottom;
                        }
                        else if (this.angle == 180) {
                            mode = StiRotationMode.CenterTop;
                        }
                        textAngle = 0;
                    }
                    context.drawRotatedString9(this.text, font, this.labelBrush, this.point, sf, mode, textAngle, this.axis.labels.antialiasing, Math.trunc(this.axis.labels.width * context.options.zoom));
                }
            }
            Chart.StiXRadarAxisLabelGeom = StiXRadarAxisLabelGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiYRadarAxisLabelGeom extends Chart.StiCellGeom {
                constructor(axis, clientRectangle, textPoint, text, stripLine, angle, rotationMode) {
                    super(clientRectangle);
                    this._axis = axis;
                    this._text = text;
                    this._stripLine = stripLine;
                    this._textPoint = textPoint;
                    this._angle = angle;
                    this._rotationMode = rotationMode;
                }
                get rotationMode() {
                    return this._rotationMode;
                }
                get textPoint() {
                    return this._textPoint;
                }
                get angle() {
                    return this._angle;
                }
                get axis() {
                    return this._axis;
                }
                get text() {
                    return this._text;
                }
                get stripLine() {
                    return this._stripLine;
                }
                draw(context) {
                    let sf = this.axis.yCore.getStringFormatGeom(context);
                    let font = this.axis.yCore.getFontGeom(context);
                    let labelBrush = new StiSolidBrush(this.axis.labels.color);
                    context.drawRotatedString9(this.text, font, labelBrush, this.textPoint, sf, this.rotationMode, this.angle, this.axis.labels.antialiasing, Math.trunc(this.axis.labels.width * context.options.zoom));
                }
            }
            Chart.StiYRadarAxisLabelGeom = StiYRadarAxisLabelGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Color = Stimulsoft.System.Drawing.Color;
            class StiMouseOverHelper {
                static getMouseOverColor() {
                    return Color.fromArgb(100, Color.white);
                }
                static getLineMouseOverColor() {
                    return Color.fromArgb(100, Color.red);
                }
            }
            StiMouseOverHelper.mouseOverLineDistance = 8;
            StiMouseOverHelper.mouseOverSplineDistance = 15;
            Chart.StiMouseOverHelper = StiMouseOverHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
            var IStiSeriesElement = Stimulsoft.Report.Chart.IStiSeriesElement;
            class StiSeriesElementGeom extends Chart.StiCellGeom {
                constructor(areaGeom, value, index, series, clientRectangle, brush) {
                    super(clientRectangle);
                    this.seriesBrush = brush;
                    this.areaGeom = areaGeom;
                    this.series = series;
                    this.value = value;
                    this.index = index;
                }
                implements() {
                    if (!StiSeriesElementGeom.implementsStiSeriesElementGeom)
                        StiSeriesElementGeom.implementsStiSeriesElementGeom = super.implements().concat([
                            IStiSeriesElement
                        ]);
                    return StiSeriesElementGeom.implementsStiSeriesElementGeom;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = this.series.interaction.drillDownEnabled;
                    }
                    let valueIndex = this.getValueIndex();
                    options.interactionToolTip = this.getToolTip2(valueIndex);
                    options.interactionHyperlink = this.getHyperlink2(valueIndex);
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = this.series.interaction.drillDownEnabled;
                    }
                }
                invokeClick(options) {
                    let valueIndex = this.getValueIndex();
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length) {
                        options.interactionHyperlink = this.series.hyperlinks[valueIndex];
                    }
                    if (this.series.interaction.drillDownEnabled) {
                        options.seriesInteractionData = this.interaction;
                        this.isMouseOver = false;
                        options.updateContext = this.series.interaction.drillDownEnabled;
                    }
                }
                getValueIndex() {
                    let valueIndex = this.index;
                    if (this.series.is(Chart.IStiClusteredBarSeries) ||
                        this.series.is(Chart.IStiStackedBarSeries) ||
                        this.series.is(Chart.IStiFullStackedBarSeries)) {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && !this.series.chart.area.reverseVert)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    else {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && this.series.chart.area.reverseHor)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    return valueIndex;
                }
                getHyperlink() {
                    return this.getHyperlink2(this.getValueIndex());
                }
                getHyperlink2(valueIndex) {
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                getToolTip() {
                    let valueIndex = this.getValueIndex();
                    return this.getToolTip2(valueIndex);
                }
                getToolTip2(valueIndex) {
                    let textTooltip = null;
                    if (this.series.toolTips != null && valueIndex < this.series.toolTips.length)
                        textTooltip = this.series.toolTips[valueIndex];
                    if (!StiString.isNullOrEmpty(textTooltip) && textTooltip.stimulsoft().contains("\"StiColor\":\"#ffffff\"")) {
                        let seriesBrush = this.seriesBrush || (this.series != null ? this.series["brush"] : null);
                        if (seriesBrush != null) {
                            let color = Stimulsoft.Base.Drawing.StiBrush.toColor(seriesBrush);
                            textTooltip = textTooltip.replace("\"StiColor\":\"#ffffff\"", StiString.format("\"StiColor\":\"{0}\"", Stimulsoft.System.Drawing.ColorTranslator.toHtml2(color, false)));
                        }
                    }
                    return textTooltip;
                }
                get allowMouseOver() {
                    let index = this.getValueIndex();
                    return ((this.series.hyperlinks != null && index < this.series.hyperlinks.length) ||
                        (this.series.toolTips != null && index < this.series.toolTips.length)) ||
                        (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeriesElements);
                }
                get isMouseOver() {
                    return this.series.core.getIsMouseOverSeriesElement(this.index);
                }
                set isMouseOver(value) {
                    this.series.core.setIsMouseOverSeriesElement(this.index, value);
                }
                draw(context) {
                }
                getInteractionData() {
                    let chart = this.series.chart;
                    let interaction = new StiInteractionDataGeom();
                    interaction.componentName = chart.name;
                    interaction.componentIndex = chart.page.components.indexOf(chart).toString();
                    interaction.pageGuid = this.series.stimulsoft().as(Chart.StiSeries).drillDownPageGuid;
                    interaction.pageIndex = chart.page.report.renderedPages.indexOf(chart.page).toString();
                    interaction.elementIndex = this.elementIndex.toString();
                    interaction.interactionData = this.interaction;
                    return interaction;
                }
            }
            Chart.StiSeriesElementGeom = StiSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiSeriesGeom extends Chart.StiCellGeom {
                constructor(areaGeom, series, clientRectangle) {
                    super(clientRectangle);
                    this._areaGeom = areaGeom;
                    this._series = series;
                }
                get series() {
                    return this._series;
                }
                get interactions() {
                    return this._interactions;
                }
                set interactions(value) {
                    this._interactions = value;
                }
                get areaGeom() {
                    return this._areaGeom;
                }
                set areaGeom(value) {
                    this._areaGeom = value;
                }
                draw(context) {
                }
            }
            Chart.StiSeriesGeom = StiSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var PointF = Stimulsoft.System.Drawing.Point;
            class StiBoxAndWhiskerSeriesElementGeom extends Chart.StiCellGeom {
                constructor(areaGeom, series, positionX, minimum, maximim, firstQuartile, thirdQuartile, median, values, mean, clientRectangle, brush, borderColor, beginTime) {
                    super(clientRectangle);
                    this.series = series;
                    this.areaGeom = areaGeom;
                    this.positionX = positionX;
                    this.minimum = minimum;
                    this.maximum = maximim;
                    this.firstQuartile = firstQuartile;
                    this.thirdQuartile = thirdQuartile;
                    this.median = median;
                    this.mean = mean;
                    this.values = values;
                    this.brush = brush;
                    this.borderColor = borderColor;
                    this.beginTime = beginTime;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let area = this.areaGeom.area;
                    let pen = new StiPenGeom(this.borderColor, 1);
                    let width = area.xAxis.info.dpi / 2;
                    let widthWhisker = width / 3;
                    let widthMarker = widthWhisker / 6;
                    context.pushSmoothingModeToAntiAlias();
                    if (chart.isAnimation) {
                        let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, this.beginTime);
                        context.drawAnimationLines(pen, [new PointF(this.positionX - widthWhisker / 2, this.maximum), new PointF(this.positionX + widthWhisker / 2, this.maximum)], animation);
                        context.drawAnimationLines(pen, [new PointF(this.positionX - widthWhisker / 2, this.minimum), new PointF(this.positionX + widthWhisker / 2, this.minimum)], animation);
                        context.drawAnimationLines(pen, [new PointF(this.positionX, this.maximum), new PointF(this.positionX, this.thirdQuartile)], animation);
                        context.drawAnimationLines(pen, [new PointF(this.positionX, this.firstQuartile), new PointF(this.positionX, this.minimum)], animation);
                        context.drawAnimationRectangle(this.brush, pen, new Rectangle(this.positionX - width / 2, this.thirdQuartile, width, this.firstQuartile - this.thirdQuartile), null, animation, null, null);
                        context.drawAnimationLines(pen, [new PointF(this.positionX - width / 2, this.median), new PointF(this.positionX + width / 2, this.median)], animation);
                        if (this.values != null) {
                            let index = 1;
                            for (let valuePoint of this.values) {
                                let animationPoint = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, new TimeSpan(this.beginTime.ticks + Chart.StiChartHelper.globalBeginTimeElement.ticks / this.values.length * index));
                                context.fillDrawAnimationEllipse(null, pen, this.positionX - widthMarker / 2, valuePoint - widthMarker / 2, widthMarker, widthMarker, null, null, animationPoint, null);
                                index++;
                            }
                        }
                        if (this.mean != null) {
                            let meanValue = this.mean;
                            context.drawAnimationLines(pen, [new PointF(this.positionX - widthMarker, meanValue - widthMarker), new PointF(this.positionX + widthMarker, meanValue + widthMarker)], animation);
                            context.drawAnimationLines(pen, [new PointF(this.positionX + widthMarker, meanValue - widthMarker), new PointF(this.positionX - widthMarker, meanValue + widthMarker)], animation);
                        }
                    }
                    else {
                        context.drawLine(pen, this.positionX - widthWhisker / 2, this.maximum, this.positionX + widthWhisker / 2, this.maximum);
                        context.drawLine(pen, this.positionX - widthWhisker / 2, this.minimum, this.positionX + widthWhisker / 2, this.minimum);
                        context.drawLine(pen, this.positionX, this.maximum, this.positionX, this.thirdQuartile);
                        context.drawLine(pen, this.positionX, this.firstQuartile, this.positionX, this.minimum);
                        context.fillRectangle2(this.brush, this.positionX - width / 2, this.thirdQuartile, width, this.firstQuartile - this.thirdQuartile, null);
                        context.drawRectangle2(pen, this.positionX - width / 2, this.thirdQuartile, width, this.firstQuartile - this.thirdQuartile);
                        context.drawLine(pen, this.positionX - width / 2, this.median, this.positionX + width / 2, this.median);
                        if (this.values != null) {
                            for (let valuePoint of this.values) {
                                context.drawEllipse2(pen, new Rectangle(this.positionX - widthMarker / 2, valuePoint - widthMarker / 2, widthMarker, widthMarker));
                            }
                        }
                        if (this.mean != null) {
                            let meanValue = this.mean;
                            context.drawLine(pen, this.positionX - widthMarker, meanValue - widthMarker, this.positionX + widthMarker, meanValue + widthMarker);
                            context.drawLine(pen, this.positionX + widthMarker, meanValue - widthMarker, this.positionX - widthMarker, meanValue + widthMarker);
                        }
                    }
                    context.popSmoothingMode();
                }
            }
            Chart.StiBoxAndWhiskerSeriesElementGeom = StiBoxAndWhiskerSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiScaleAnimation = Stimulsoft.Base.Context.Animation.StiScaleAnimation;
            class StiBubbleSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, seriesBorderColor, series, clientRectangle, beginTime) {
                    super(areaGeom, value, index, series, clientRectangle, seriesBrush);
                    this.seriesBrush = seriesBrush;
                    this.seriesBorderColor = seriesBorderColor;
                    this.beginTime = beginTime;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let center = new PointD(this.clientRectangle.x + this.clientRectangle.width / 2, this.clientRectangle.y + this.clientRectangle.height / 2);
                    let dx = Math.abs(center.x - x);
                    let dy = Math.abs(center.y - y);
                    let radius = Math.sqrt(dx * dx + dy * dy);
                    return radius <= this.clientRectangle.width / 2;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.seriesBorderColor, 1);
                    let chart = this.series.chart;
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, rect, new Size(rect.height, rect.height), fontIconsSeries.icon, this.getToolTip(), false);
                        return;
                    }
                    if (chart.isAnimation) {
                        let animation = new StiScaleAnimation(0, 0, 0, 0, 0, 0, Chart.StiChartHelper.globalDurationElement, this.beginTime);
                        context.fillDrawAnimationEllipse(this.seriesBrush, pen, rect.x, rect.y, rect.width, rect.height, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        if (this.series.showShadow) {
                            let shadowBrush = new StiSolidBrush(Color.fromArgb(100, Color.black));
                            let shadowContext = context.createShadowGraphics();
                            let rectShadow = rect.clone();
                            rectShadow.x = 0;
                            rectShadow.y = 0;
                            rectShadow.x += 4 * context.options.zoom;
                            rectShadow.y += 4 * context.options.zoom;
                            shadowContext.fillEllipse2(shadowBrush, rectShadow, this.getInteractionData());
                            context.drawShadow(shadowContext, rect, 0);
                        }
                        context.fillEllipse2(this.seriesBrush, rect, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver)
                            context.fillEllipse(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        context.pushSmoothingModeToAntiAlias();
                        context.drawEllipse2(pen, rect);
                        context.popSmoothingMode();
                    }
                }
            }
            Chart.StiBubbleSeriesElementGeom = StiBubbleSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiClusteredBarSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, valueStart, value, index, seriesBrush, seriesBorderColor, series, columnRectStart, columnRect) {
                    super(areaGeom, value, index, series, columnRect, seriesBrush);
                    this.seriesBorderColor = seriesBorderColor;
                    this.valueStart = valueStart;
                    this.columnRectStart = columnRectStart;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let columnRect = this.clientRectangle.clone();
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        let roundValuesArea = chart.area.as(Chart.IStiRoundValuesArea);
                        let roundValues = roundValuesArea === null || roundValuesArea === void 0 ? void 0 : roundValuesArea.roundValues;
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, columnRect, new Size(columnRect.height, columnRect.height), fontIconsSeries.icon, this.getToolTip(), false, roundValues);
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        let rect = this.clientRectangle.clone();
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        if (this.series.showShadow) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(rect, 5, animationOpacity);
                        }
                        context.drawAnimationBar(this.seriesBrush, pen, columnRect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        let rect = this.clientRectangle.clone();
                        if (this.series.showShadow && rect.width > 4 && rect.height > 4) {
                            let shadowRect = rect.clone();
                            if (this.value < 0) {
                                shadowRect.y--;
                                context.drawCachedShadow(shadowRect, StiShadowSides.Left |
                                    StiShadowSides.Bottom, context.options.isPrinting);
                            }
                            else if (this.value > 0) {
                                context.drawCachedShadow(new RectangleD(shadowRect.x - 8, shadowRect.y, shadowRect.width + 8, shadowRect.height), StiShadowSides.Top |
                                    StiShadowSides.Right |
                                    StiShadowSides.Edge |
                                    StiShadowSides.Bottom, context.options.isPrinting, shadowRect);
                            }
                        }
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        this.series.chart.style.core.fillColumn(context, rect, this.seriesBrush, this.getInteractionData());
                        let points = null;
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        }
                        if (this.value > 0) {
                            points = [
                                new PointD(rect.right, rect.y),
                                new PointD(rect.x, rect.y),
                                new PointD(rect.x, rect.bottom),
                                new PointD(rect.right, rect.bottom)
                            ];
                        }
                        else {
                            points = [
                                new PointD(rect.x, rect.y),
                                new PointD(rect.right, rect.y),
                                new PointD(rect.right, rect.bottom),
                                new PointD(rect.x, rect.bottom)
                            ];
                        }
                        context.drawLines(pen, points);
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let axisArea = this.areaGeom.area;
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                    let columnAnimation = new StiColumnAnimation(this.columnRectStart, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let getStartFromZero = axisArea.yAxis.core.getStartFromZero();
                    let argId = (getStartFromZero ?
                        axisArea.yAxis.info.stripLines.getByIndex(this.index + 1).valueObject :
                        axisArea.yAxis.info.stripLines.getByIndex(this.index).valueObject);
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiClusteredBarSeriesElementGeom = StiClusteredBarSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiTranslationAnimation = Stimulsoft.Base.Context.Animation.StiTranslationAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiString = Stimulsoft.System.StiString;
            class StiBaseLineSeriesGeom extends Chart.StiSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, series, StiBaseLineSeriesGeom.getClientRectangle(pointsInfo.points, series.is(Chart.StiBaseLineSeries) ? series.lineWidth : 0));
                    this.points = pointsInfo.points.map(p => p);
                    if (pointsInfo.pointsFrom == null || pointsInfo.pointsFrom[0] == null)
                        pointsInfo.pointsFrom = pointsInfo.points.map(p => p);
                    this.pointsFrom = pointsInfo.pointsFrom.map(p => p);
                    this.pointsIds = pointsInfo.pointsIds.map(p => p);
                    this.additionalSeriesId = pointsInfo.additionalSeriesId;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                get allowMouseOver() {
                    return (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeries);
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.isMouseOver;
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.isMouseOver = value;
                }
                static getClientRectangle(points, lineWidth) {
                    if (points == null || points.length == 0)
                        return RectangleD.empty;
                    let minPoint = PointD.empty;
                    let maxPoint = PointD.empty;
                    for (let point of points) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    return new RectangleD(minPoint.x - lineWidth / 2, minPoint.y - lineWidth / 2, maxPoint.x - minPoint.x + lineWidth, maxPoint.y - minPoint.y + lineWidth);
                }
                draw(context) {
                }
                getAnimation(points = this.points) {
                    if (!this.series.chart.isAnimation)
                        return null;
                    if (this.pointsFrom == null || this.pointsIds == null)
                        return null;
                    let pointsFrom = [];
                    let points2 = [];
                    let pointsIds = [];
                    for (let index = 0; index < this.pointsFrom.length; index++) {
                        if (this.pointsFrom[index] != null && this.points[index] != null && this.pointsIds[index] != null) {
                            pointsFrom.push(this.pointsFrom[index]);
                            points2.push(this.points[index]);
                            pointsIds.push(this.pointsIds[index]);
                        }
                    }
                    return this.getAnimation2(pointsFrom, points2, pointsIds);
                }
                getAnimationConnect(points = this.points) {
                    if (!this.series.chart.isAnimation)
                        return null;
                    if (this.pointsFrom == null || this.pointsIds == null)
                        return null;
                    let pointsFrom = [];
                    let points2 = [];
                    let pointsIds = [];
                    let index = 0;
                    for (let point of points) {
                        if (point != null && !points2.stimulsoft().toList().exists(p => p.equals(point))) {
                            let pointFrom = this.pointsFrom[index];
                            if (pointFrom == null)
                                pointFrom = point;
                            let pointId = this.pointsIds[index];
                            if (StiString.isNullOrEmpty(pointId))
                                pointId = index.toString() + "_";
                            pointsFrom.push(pointFrom);
                            points2.push(point);
                            pointsIds.push(pointId);
                            index++;
                        }
                    }
                    return this.getAnimation2(pointsFrom, points2, pointsIds);
                }
                getAnimation2(pointsFrom, points, pointsIds) {
                    if (!this.series.chart.isAnimation)
                        return null;
                    if (pointsFrom.length == 0)
                        return null;
                    let animation = null;
                    let pointsAnimation = null;
                    if (this.series.chart.isAnimationChangingValues && pointsFrom != null && pointsFrom[0] != null && pointsIds != null) {
                        pointsAnimation = new StiPointsAnimation(pointsFrom, points, pointsIds, Chart.StiChartHelper.globalDurationElement, TimeSpan.zero);
                        pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}` + this.additionalSeriesId;
                        if (StiPointsAnimation.isAnimationChangingValues(this.series, pointsIds, pointsAnimation.id)) {
                            pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                            animation = pointsAnimation;
                        }
                    }
                    if (animation == null) {
                        let translationAnimation = new StiTranslationAnimation(PointD.empty, PointD.empty, Chart.StiChartHelper.globalDurationElement, TimeSpan.zero);
                        translationAnimation.anotherAnimation = pointsAnimation;
                        translationAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}` + this.additionalSeriesId;
                        animation = translationAnimation;
                    }
                    return animation;
                }
            }
            Chart.StiBaseLineSeriesGeom = StiBaseLineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiLineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                    this.pointsNullConnect = pointsInfo.pointsNullConnect;
                    this.pointsZeroConnect = pointsInfo.pointsZeroConnect;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isLineContainsPoint(point1, point2, Chart.StiMouseOverHelper.mouseOverLineDistance, new PointD(x, y));
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let coreLineStyle = StiPenStyle.Solid;
                    let lineWidth = 1;
                    let coreLineColor = Color.black;
                    let showShadow = true;
                    let lineMarker = null;
                    let lighting = true;
                    let animation = this.getAnimation();
                    let lineSeries = this.series.stimulsoft().as(Chart.IStiBaseLineSeries);
                    if (lineSeries != null) {
                        coreLineStyle = lineSeries.lineStyle;
                        lineWidth = lineSeries.lineWidth;
                        coreLineColor = lineSeries.lineColor;
                        showShadow = lineSeries.showShadow;
                        lineMarker = lineSeries.lineMarker;
                        lighting = lineSeries.lighting;
                    }
                    let radarLineSeries = this.series.stimulsoft().as(Chart.IStiRadarLineSeries);
                    if (radarLineSeries != null) {
                        coreLineStyle = radarLineSeries.lineStyle;
                        lineWidth = radarLineSeries.lineWidth;
                        coreLineColor = radarLineSeries.lineColor;
                        showShadow = radarLineSeries.showShadow;
                        lighting = radarLineSeries.lighting;
                    }
                    let radarAreaSeries = this.series.stimulsoft().as(Chart.IStiRadarAreaSeries);
                    if (radarAreaSeries != null) {
                        coreLineStyle = radarAreaSeries.lineStyle;
                        lineWidth = radarAreaSeries.lineWidth;
                        coreLineColor = radarAreaSeries.lineColor;
                        showShadow = radarAreaSeries.showShadow;
                        lighting = radarAreaSeries.lighting;
                    }
                    context.pushSmoothingModeToAntiAlias();
                    let dashStyle = coreLineStyle;
                    let scaledLineWidth = lineWidth * context.options.zoom;
                    let pen = new StiPenGeom(coreLineColor, scaledLineWidth);
                    pen.penStyle = dashStyle;
                    if (showShadow) {
                        let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                        penShadow.penStyle = dashStyle;
                        context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                        Chart.StiNullableDrawing.drawLines(context, penShadow, this.points, animation);
                        if (lineMarker != null && lineMarker.visible) {
                            let brushShadow = new StiSolidBrush(Color.fromArgb(50, 0, 0, 0));
                            lineMarker.core.drawLines(context, this.points, context.options.zoom, brushShadow, null, lineMarker.type, lineMarker.step, lineMarker.size, lineMarker.angle);
                        }
                        context.popTransform();
                    }
                    if (this.series.core.isMouseOver) {
                        let zoom = context.options.zoom;
                        let pointSize = 11 + lineWidth;
                        for (let point of this.points) {
                            if (point == null)
                                continue;
                            let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                            context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                        }
                        let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                        penMouseOver.startCap = StiPenLineCap.Round;
                        penMouseOver.endCap = StiPenLineCap.Round;
                        Chart.StiNullableDrawing.drawLines(context, penMouseOver, this.points, animation);
                    }
                    if (this.pointsZeroConnect != null) {
                        let penZeroConnect = new StiPenGeom(coreLineColor, scaledLineWidth);
                        penZeroConnect.penStyle = StiPenStyle.Dash;
                        let zeroAnimation = this.getAnimationConnect(this.pointsZeroConnect);
                        Chart.StiNullableDrawing.drawLines(context, penZeroConnect, this.pointsZeroConnect, zeroAnimation);
                    }
                    if (this.pointsNullConnect != null) {
                        let penNullConnect = new StiPenGeom(coreLineColor, scaledLineWidth);
                        penNullConnect.penStyle = StiPenStyle.Dash;
                        let nullAnimation = this.getAnimationConnect(this.pointsNullConnect);
                        Chart.StiNullableDrawing.drawLines(context, penNullConnect, this.pointsNullConnect, nullAnimation);
                    }
                    if ((this.series.is(Chart.StiLineSeries)) && this.series.allowApplyColorNegative) {
                        let coreLineColorNegative = this.series.lineColorNegative;
                        let penNegative = new StiPenGeom(coreLineColorNegative, scaledLineWidth);
                        penNegative.penStyle = dashStyle;
                        let axisArea = this.series.chart.area;
                        let posY = axisArea.axisCore.getDividerY();
                        let pointsNegative = [];
                        let pointsPositive = [];
                        for (let index = 0; index < this.points.length; index++) {
                            let point = this.points[index];
                            let pointNext = (index != (this.points.length - 1)) ? this.points[index + 1] : null;
                            if (point.y > posY) {
                                pointsNegative.push(point);
                                if (pointNext == null ||
                                    pointNext.y < posY ||
                                    pointNext.y == posY && ((index + 2) < this.points.length) && ((this.points[index + 2].y) <= posY)) {
                                    if (pointNext != null) {
                                        let point0 = this.getPointCross(point, this.points[index + 1], posY);
                                        pointsNegative.push(point0);
                                        if (pointNext.y == posY && ((index + 2) < this.points.length) && ((this.points[index + 2].y) <= posY)) {
                                            pointsNegative.push(this.points[index + 2]);
                                        }
                                        pointsPositive.push(point0);
                                    }
                                    Chart.StiNullableDrawing.drawLines(context, penNegative, pointsNegative, animation);
                                    if (scaledLineWidth >= 2 * context.options.zoom && lighting) {
                                        let step = 0.5 * context.options.zoom;
                                        context.pushTranslateTransform(-step, -step);
                                        let penLight = new StiPenGeom(StiColorUtils.light(coreLineColorNegative, 70), scaledLineWidth);
                                        penLight.penStyle = dashStyle;
                                        Chart.StiNullableDrawing.drawLines(context, penLight, pointsNegative, animation);
                                        context.popTransform();
                                    }
                                    pointsNegative.stimulsoft().clear();
                                }
                            }
                            else {
                                pointsPositive.push(point);
                                if (pointNext == null || pointNext.y > posY) {
                                    if (pointNext != null) {
                                        let point0 = this.getPointCross(point, this.points[index + 1], posY);
                                        pointsNegative.push(point0);
                                        pointsPositive.push(point0);
                                        pointsPositive.push(pointNext);
                                    }
                                    Chart.StiNullableDrawing.drawLines(context, pen, pointsPositive, animation);
                                    if (scaledLineWidth >= 2 * context.options.zoom && lighting) {
                                        let step = 0.5 * context.options.zoom;
                                        context.pushTranslateTransform(-step, -step);
                                        let penLight = new StiPenGeom(StiColorUtils.light(coreLineColor, 70), scaledLineWidth);
                                        penLight.penStyle = dashStyle;
                                        Chart.StiNullableDrawing.drawLines(context, penLight, pointsPositive, animation);
                                        context.popTransform();
                                    }
                                    pointsPositive.stimulsoft().clear();
                                }
                            }
                        }
                    }
                    else {
                        Chart.StiNullableDrawing.drawLines(context, pen, this.points, animation);
                        if (scaledLineWidth >= 2 * context.options.zoom && lighting) {
                            let step = 0.5 * context.options.zoom;
                            context.pushTranslateTransform(-step, -step);
                            let penLight = new StiPenGeom(StiColorUtils.light(coreLineColor, 70), scaledLineWidth);
                            penLight.penStyle = dashStyle;
                            Chart.StiNullableDrawing.drawLines(context, penLight, this.points, animation);
                            context.popTransform();
                        }
                    }
                    if (lineMarker != null && lineMarker.visible) {
                        let borderPen = new StiPenGeom(lineMarker.borderColor);
                        lineMarker.core.drawLines(context, this.points, context.options.zoom, lineMarker.brush, borderPen, lineMarker.type, lineMarker.step, lineMarker.size, lineMarker.angle);
                    }
                    context.popSmoothingMode();
                }
                getPointCross(point1, point2, posY) {
                    let y1 = point1.y;
                    let x1 = point1.x;
                    let y2 = point2.y;
                    let x2 = point2.x;
                    let x0 = (Math.tan(Math.atan((x2 - x1) / (y1 - y2)))) * (y1 - posY) + x1;
                    return new PointD(x0, posY);
                }
            }
            Chart.StiLineSeriesGeom = StiLineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            class StiAreaSeriesGeom extends Chart.StiLineSeriesGeom {
                contains(x, y) {
                    let axisArea = this.series.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let point3 = new PointD(point2.x, posY);
                        let point4 = new PointD(point1.x, posY);
                        let result = Chart.StiPointHelper.isPointInPolygon(new PointD(x, y), [point1, point4, point3, point2]);
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let areaSeries = this.series;
                    let axisArea = this.series.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    let list = Chart.StiNullableDrawing.getPointsList(this.points);
                    let listFrom = this.pointsFrom != null ? Chart.StiNullableDrawing.getPointsList(this.pointsFrom) : null;
                    let chart = this.series.chart;
                    if (chart.isAnimation) {
                        for (let index = 0; index < list.length; index++) {
                            let newPoints = list[index];
                            let path = [];
                            let lineSegment1 = new StiLineSegmentGeom(newPoints[0].x, posY, newPoints[0].x, newPoints[0].y);
                            let lineSegments = new StiLinesSegmentGeom(newPoints);
                            let lineSegment2 = new StiLineSegmentGeom(newPoints[newPoints.length - 1].x, newPoints[newPoints.length - 1].y, newPoints[newPoints.length - 1].x, posY);
                            path.push(lineSegment1);
                            path.push(lineSegments);
                            path.push(lineSegment2);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, this.pointsIds)) {
                                let newPointsFrom = listFrom[index];
                                let pointsAnimation = new StiPointsAnimation(newPointsFrom, newPoints, this.pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}`;
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                lineSegment1.animation = new StiPointsAnimation([new PointD(pointsAnimation.pointsFrom[0].x, posY), pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegments.animation = pointsAnimation;
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], new PointD(pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1].x, posY)], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                context.animations.push(pointsAnimation);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, null, null);
                                if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                    let width = axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX;
                                    let height = axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY;
                                    let clipRect = new RectangleD(0, posY, width, height);
                                    context.pushClip(clipRect);
                                    context.fillDrawAnimationPath(areaSeries.brushNegative, null, path, StiPathGeom.getBoundsState, null, null, null);
                                    context.popClip();
                                }
                            }
                            else if (areaSeries.brush != null) {
                                let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                        }
                    }
                    else {
                        for (let newPoints of list) {
                            let path = [];
                            path.push(new StiLineSegmentGeom(newPoints[0].x, posY, newPoints[0].x, newPoints[0].y));
                            path.push(new StiLinesSegmentGeom(newPoints));
                            path.push(new StiLineSegmentGeom(newPoints[newPoints.length - 1].x, newPoints[newPoints.length - 1].y, newPoints[newPoints.length - 1].x, posY));
                            if (areaSeries.brush != null)
                                context.fillPath(areaSeries.brush, path, StiPathGeom.getBoundsState, null);
                            if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                                let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                                let clipRect = new RectangleD(0, posY, width, height);
                                context.pushClip(clipRect);
                                context.fillPath(areaSeries.brushNegative, path, StiPathGeom.getBoundsState, null);
                                context.popClip();
                            }
                            if (this.isMouseOver || this.series.core.isMouseOver) {
                                context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                            }
                        }
                    }
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiAreaSeriesGeom = StiAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var IStiRoundValuesArea = Stimulsoft.Report.Chart.IStiRoundValuesArea;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            class StiClusteredColumnSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, seriesBorderColor, series, columnRect, columnRectStart) {
                    super(areaGeom, value, index, series, columnRect, seriesBrush);
                    this.seriesBrush = seriesBrush;
                    this.seriesBorderColor = seriesBorderColor;
                    this.columnRectStart = columnRectStart;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let columnRect = this.clientRectangle.clone();
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        let roundValuesArea = chart.area.as(IStiRoundValuesArea);
                        let roundValues = roundValuesArea === null || roundValuesArea === void 0 ? void 0 : roundValuesArea.roundValues;
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, columnRect, new Size(columnRect.width, columnRect.width), fontIconsSeries.icon, this.getToolTip(), true, roundValues);
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        if (this.series.showShadow && columnRect.width > 1) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(columnRect, 5, animationOpacity);
                        }
                        context.drawAnimationColumn(this.seriesBrush, pen, columnRect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        let rect = this.clientRectangle.clone();
                        if (this.series.showShadow && rect.width > 4 && rect.height > 4) {
                            if (this.value > 0) {
                                context.drawCachedShadow(rect, StiShadowSides.Top |
                                    StiShadowSides.Right, context.options.isPrinting);
                            }
                            else if (this.value < 0) {
                                context.drawCachedShadow(new RectangleD(rect.x, rect.y - 8, rect.width, rect.height + 8), StiShadowSides.Right |
                                    StiShadowSides.Edge |
                                    StiShadowSides.Bottom |
                                    StiShadowSides.Left, context.options.isPrinting, rect);
                            }
                        }
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        this.series.chart.style.core.fillColumn(context, rect, this.seriesBrush, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        }
                        let points = null;
                        if (this.value > 0) {
                            points = [
                                new PointD(rect.x, rect.bottom),
                                new PointD(rect.x, rect.y),
                                new PointD(rect.right, rect.y),
                                new PointD(rect.right, rect.bottom)
                            ];
                        }
                        else {
                            points = [
                                new PointD(rect.x, rect.y),
                                new PointD(rect.x, rect.bottom),
                                new PointD(rect.right, rect.bottom),
                                new PointD(rect.right, rect.y)
                            ];
                        }
                        context.drawLines(pen, points);
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let axisArea = this.areaGeom.area;
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                    let columnAnimation = new StiColumnAnimation(this.columnRectStart, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    let argId = getStartFromZero ?
                        axisArea.xAxis.info.stripLines.getByIndex(this.index + 1).valueObject :
                        axisArea.xAxis.info.stripLines.getByIndex(this.index).valueObject;
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiClusteredColumnSeriesElementGeom = StiClusteredColumnSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiSplineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                    this.pointsNullConnect = pointsInfo.pointsNullConnect;
                    this.pointsZeroConnect = pointsInfo.pointsZeroConnect;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isLineContainsPoint(point1, point2, Chart.StiMouseOverHelper.mouseOverSplineDistance, new PointD(x, y));
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let coreLineStyle = StiPenStyle.Solid;
                    let lineWidth = 1;
                    let coreLineColor = Color.black;
                    let showShadow = true;
                    let lighting = true;
                    let tension = 1;
                    let animation = this.getAnimation();
                    let splineSeries = this.series.stimulsoft().as(Chart.IStiSplineSeries);
                    if (splineSeries != null) {
                        coreLineStyle = splineSeries.lineStyle;
                        lineWidth = splineSeries.lineWidth;
                        coreLineColor = splineSeries.lineColor;
                        showShadow = splineSeries.showShadow;
                        lighting = splineSeries.lighting;
                        tension = splineSeries.tension;
                    }
                    let radarLineSeries = this.series.stimulsoft().as(Chart.IStiRadarLineSeries);
                    if (radarLineSeries != null) {
                        coreLineStyle = radarLineSeries.lineStyle;
                        lineWidth = radarLineSeries.lineWidth;
                        coreLineColor = radarLineSeries.lineColor;
                        showShadow = radarLineSeries.showShadow;
                        lighting = radarLineSeries.lighting;
                    }
                    let radarAreaSeries = this.series.stimulsoft().as(Chart.IStiRadarAreaSeries);
                    if (radarAreaSeries != null) {
                        coreLineStyle = radarAreaSeries.lineStyle;
                        lineWidth = radarAreaSeries.lineWidth;
                        coreLineColor = radarAreaSeries.lineColor;
                        showShadow = radarAreaSeries.showShadow;
                        lighting = radarAreaSeries.lighting;
                    }
                    context.pushSmoothingModeToAntiAlias();
                    let dashStyle = coreLineStyle;
                    let scaledLineWidth = lineWidth * context.options.zoom;
                    let pen = new StiPenGeom(coreLineColor, scaledLineWidth);
                    pen.penStyle = dashStyle;
                    if (showShadow) {
                        let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                        penShadow.penStyle = dashStyle;
                        context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                        Chart.StiNullableDrawing.drawCurve(context, penShadow, this.points, tension, animation);
                        context.popTransform();
                    }
                    if (this.series.core.isMouseOver) {
                        let zoom = context.options.zoom;
                        let pointSize = 11 + lineWidth;
                        for (let point of this.points) {
                            if (point == null)
                                continue;
                            let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                            context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                        }
                        let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                        penMouseOver.startCap = StiPenLineCap.Round;
                        penMouseOver.endCap = StiPenLineCap.Round;
                        Chart.StiNullableDrawing.drawCurve(context, penMouseOver, this.points, tension, animation);
                    }
                    if (this.pointsZeroConnect != null) {
                        let penZeroConnect = new StiPenGeom(coreLineColor, scaledLineWidth);
                        penZeroConnect.penStyle = StiPenStyle.Dash;
                        let zeroAnimation = this.getAnimationConnect(this.pointsZeroConnect);
                        Chart.StiNullableDrawing.drawCurve(context, penZeroConnect, this.pointsZeroConnect, tension, zeroAnimation);
                    }
                    if (this.pointsNullConnect != null) {
                        let penNullConnect = new StiPenGeom(coreLineColor, scaledLineWidth);
                        penNullConnect.penStyle = StiPenStyle.Dash;
                        let nullAnimation = this.getAnimationConnect(this.pointsNullConnect);
                        Chart.StiNullableDrawing.drawCurve(context, penNullConnect, this.pointsNullConnect, tension, nullAnimation);
                    }
                    Chart.StiNullableDrawing.drawCurve(context, pen, this.points, tension, animation);
                    if (scaledLineWidth >= 2 && lighting) {
                        let step = 0.5 * context.options.zoom;
                        context.pushTranslateTransform(-step, -step);
                        let penLight = new StiPenGeom(StiColorUtils.light(coreLineColor, 70), scaledLineWidth);
                        penLight.penStyle = dashStyle;
                        Chart.StiNullableDrawing.drawCurve(context, penLight, this.points, tension, animation);
                        context.popTransform();
                    }
                    if (splineSeries != null && splineSeries.allowApplyColorNegative) {
                        let penNegative = new StiPenGeom(splineSeries.lineColorNegative, scaledLineWidth);
                        penNegative.penStyle = dashStyle;
                        let axisArea = this.series.chart.area;
                        let posY = axisArea.axisCore.getDividerY();
                        let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                        let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                        let clipRect = new RectangleD(0, posY, width, height);
                        context.pushClip(clipRect);
                        Chart.StiNullableDrawing.drawCurve(context, penNegative, this.points, tension, animation);
                        if (scaledLineWidth >= 2 && lighting) {
                            let step = 0.5 * context.options.zoom;
                            context.pushTranslateTransform(-step, -step);
                            let penLight = new StiPenGeom(StiColorUtils.light(splineSeries.lineColorNegative, 70), scaledLineWidth);
                            penLight.penStyle = dashStyle;
                            Chart.StiNullableDrawing.drawCurve(context, penLight, this.points, tension, animation);
                            context.popTransform();
                        }
                        context.popClip();
                    }
                    context.popSmoothingMode();
                }
            }
            Chart.StiSplineSeriesGeom = StiSplineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            class StiSplineAreaSeriesGeom extends Chart.StiSplineSeriesGeom {
                contains(x, y) {
                    let axisArea = this.series.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let point3 = new PointD(point2.x, posY);
                        let point4 = new PointD(point1.x, posY);
                        let result = Chart.StiPointHelper.isPointInPolygon(new PointD(x, y), [point1, point4, point3, point2]);
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let areaSeries = this.series;
                    let chart = this.series.chart;
                    let axisArea = this.series.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    let list = Chart.StiNullableDrawing.getPointsList(this.points);
                    let listFrom = this.pointsFrom != null ? Chart.StiNullableDrawing.getPointsList(this.pointsFrom) : null;
                    if (chart.isAnimation) {
                        for (let index = 0; index < list.length; index++) {
                            let newPoints = list[index];
                            let path = [];
                            let lineSegment1 = new StiLineSegmentGeom(new PointD(newPoints[0].x, posY), newPoints[0]);
                            let curveSegments = new StiCurveSegmentGeom(newPoints, areaSeries.tension);
                            let lineSegment2 = new StiLineSegmentGeom(newPoints[newPoints.length - 1], new PointD(newPoints[newPoints.length - 1].x, posY));
                            path.push(lineSegment1);
                            path.push(curveSegments);
                            path.push(lineSegment2);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, this.pointsIds)) {
                                let newPointsFrom = listFrom[index];
                                let pointsAnimation = new StiPointsAnimation(newPointsFrom, newPoints, this.pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}`;
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                lineSegment1.animation = new StiPointsAnimation([new PointD(pointsAnimation.pointsFrom[0].x, posY), pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                curveSegments.animation = pointsAnimation;
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], new PointD(pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1].x, posY)], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                context.animations.push(pointsAnimation);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, null, null);
                                if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                    let width = axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX;
                                    let height = axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY;
                                    let clipRect = new RectangleD(0, posY, width, height);
                                    context.pushClip(clipRect);
                                    context.fillDrawAnimationPath(areaSeries.brushNegative, null, path, StiPathGeom.getBoundsState, null, null, null);
                                    context.popClip();
                                }
                            }
                            else {
                                let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            index++;
                        }
                    }
                    else {
                        for (let newPoints of list) {
                            let path = [];
                            path.push(new StiLineSegmentGeom(newPoints[0].x, posY, newPoints[0].x, newPoints[0].y));
                            path.push(new StiCurveSegmentGeom(newPoints, areaSeries.tension));
                            path.push(new StiLineSegmentGeom(newPoints[newPoints.length - 1].x, newPoints[newPoints.length - 1].y, newPoints[newPoints.length - 1].x, posY));
                            if (areaSeries.brush != null) {
                                if (chart.isAnimation) {
                                    let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                    context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                                }
                                else
                                    context.fillPath(areaSeries.brush, path, StiPathGeom.getBoundsState, null);
                            }
                            if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                                let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                                let clipRect = new RectangleD(0, posY, width, height);
                                context.pushClip(clipRect);
                                if (chart.isAnimation) {
                                    let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                    context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                                }
                                else
                                    context.fillPath(areaSeries.brushNegative, path, StiPathGeom.getBoundsState, null);
                                context.popClip();
                            }
                            if (this.isMouseOver || this.series.core.isMouseOver) {
                                context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                            }
                        }
                    }
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiSplineAreaSeriesGeom = StiSplineAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiSteppedLineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                getSteppedPoints(points) {
                    let lineSeries = this.series;
                    let list = [];
                    let distX = lineSeries.chart.area.xAxis.info.dpi / 2;
                    for (let index = 0; index < points.length - 1; index++) {
                        let point = points[index];
                        let nextPoint = points[index + 1];
                        if (point != null && nextPoint != null) {
                            if (lineSeries.pointAtCenter) {
                                point = new PointD(point.x - distX, point.y);
                                nextPoint = new PointD(nextPoint.x - distX, nextPoint.y);
                            }
                            list.push(point);
                            list.push(new PointD(nextPoint.x, point.y));
                        }
                        else {
                            list.push(null);
                            list.push(null);
                        }
                    }
                    let pos = points[points.length - 1];
                    if (pos != null) {
                        if (lineSeries.pointAtCenter) {
                            pos = new PointD(pos.x - distX, pos.y);
                            list.push(pos);
                            pos = new PointD(pos.x + distX * 2, pos.y);
                            list.push(pos);
                        }
                        else
                            list.push(pos);
                    }
                    else {
                        list.push(null);
                    }
                    return list.stimulsoft().toArray();
                }
                getSteppedPointsIds(ids) {
                    let list = [];
                    for (let index = 0; index < ids.length - 1; index++) {
                        let id = ids[index] + "_l";
                        let nextId = ids[index + 1] + "_h";
                        list.push(id);
                        list.push(nextId);
                    }
                    let lastId = ids[ids.length - 1] + "_l";
                    list.push(lastId);
                    return list;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let newPoints = this.getSteppedPoints(this.points);
                    let pointIndex = 0;
                    for (let point of newPoints) {
                        if (this.points.length <= pointIndex + 1)
                            continue;
                        let nextPoint = newPoints[pointIndex + 1];
                        if (point == null || nextPoint == null)
                            continue;
                        let pointRect = RectangleD.empty;
                        if (nextPoint.x > point.x) {
                            pointRect = new RectangleD(point.x, point.y, nextPoint.x - point.x, 1);
                            pointRect.inflate(0, 5);
                        }
                        else if (nextPoint.y > point.y) {
                            pointRect = new RectangleD(point.x, point.y, 1, nextPoint.y - point.y);
                            pointRect.inflate(5, 0);
                        }
                        else {
                            pointRect = new RectangleD(nextPoint.x, nextPoint.y, 1, point.y - nextPoint.y);
                            pointRect.inflate(5, 0);
                        }
                        if (pointRect.contains(x, y))
                            return true;
                        pointIndex++;
                        if (pointIndex == newPoints.length - 1)
                            break;
                    }
                    return false;
                }
                draw(context) {
                    let lineSeries = this.series;
                    context.pushSmoothingModeToAntiAlias();
                    let dashStyle = lineSeries.lineStyle;
                    let scaledLineWidth = lineSeries.lineWidth * context.options.zoom;
                    let pen = new StiPenGeom(lineSeries.lineColor, scaledLineWidth);
                    pen.penStyle = dashStyle;
                    let list = Chart.StiNullableDrawing.getNullablePointsList(this.points);
                    for (let newPoints2 of list) {
                        let newPoints = this.getSteppedPoints(newPoints2);
                        let newPointsFrom = this.getSteppedPoints(this.pointsFrom);
                        let newPointsIds = this.getSteppedPointsIds(this.pointsIds);
                        let animation = this.getAnimation2(newPointsFrom, newPoints, newPointsIds);
                        if (lineSeries.showShadow) {
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                            penShadow.penStyle = dashStyle;
                            context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                            Chart.StiNullableDrawing.drawLines(context, penShadow, newPoints, animation);
                            if (lineSeries.lineMarker.visible) {
                                let brushShadow = new StiSolidBrush(Color.fromArgb(50, 0, 0, 0));
                                lineSeries.lineMarker.core.drawLines(context, newPoints, context.options.zoom, brushShadow, null, lineSeries.lineMarker.type, lineSeries.lineMarker.step, lineSeries.lineMarker.size, lineSeries.lineMarker.angle);
                            }
                            context.popTransform();
                        }
                        if (this.series.core.isMouseOver) {
                            let lineWidth = lineSeries.lineWidth;
                            let zoom = context.options.zoom;
                            let pointSize = 11 + lineWidth;
                            for (let point of this.points) {
                                if (point == null)
                                    continue;
                                let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                                context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                            }
                            let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                            penMouseOver.startCap = StiPenLineCap.Round;
                            penMouseOver.endCap = StiPenLineCap.Round;
                            Chart.StiNullableDrawing.drawLines(context, penMouseOver, newPoints, animation);
                        }
                        let axisArea = this.series.chart.area;
                        let posY = axisArea.axisCore.getDividerY();
                        if (lineSeries.allowApplyColorNegative) {
                            let penNegative = new StiPenGeom(lineSeries.lineColorNegative, scaledLineWidth);
                            penNegative.penStyle = dashStyle;
                            let pointsNegative = [];
                            let pointsPositive = [];
                            for (let index = 0; index < newPoints.length; index++) {
                                let point = newPoints[index];
                                let pointNext = (index != (newPoints.length - 1)) ? newPoints[index + 1] : null;
                                if (point.y > posY) {
                                    pointsNegative.push(point);
                                    if (pointNext == null ||
                                        pointNext.y <= posY) {
                                        this.intersectionAxis(point, pointNext, pointsNegative, pointsPositive, posY);
                                        let points = StiArray.create(PointD, pointsNegative.length, true);
                                        pointsNegative.stimulsoft().copyTo(points);
                                        Chart.StiNullableDrawing.drawLines(context, penNegative, points, animation);
                                        if (scaledLineWidth >= 2 && lineSeries.lighting) {
                                            let step = 0.5 * context.options.zoom;
                                            context.pushTranslateTransform(-step, -step);
                                            let penLight = new StiPenGeom(StiColorUtils.light(lineSeries.lineColorNegative, 70), scaledLineWidth);
                                            penLight.penStyle = dashStyle;
                                            Chart.StiNullableDrawing.drawLines(context, penLight, points, animation);
                                            context.popTransform();
                                        }
                                        pointsNegative.stimulsoft().clear();
                                    }
                                }
                                else {
                                    pointsPositive.push(point);
                                    if (pointNext == null ||
                                        pointNext.y > posY) {
                                        this.intersectionAxis(point, pointNext, pointsPositive, pointsNegative, posY);
                                        let points = StiArray.create(PointD, pointsPositive.length, true);
                                        pointsPositive.stimulsoft().copyTo(points);
                                        Chart.StiNullableDrawing.drawLines(context, pen, points, animation);
                                        if (scaledLineWidth >= 2 && lineSeries.lighting) {
                                            let step = 0.5 * context.options.zoom;
                                            context.pushTranslateTransform(-step, -step);
                                            let penLight = new StiPenGeom(StiColorUtils.light(lineSeries.lineColor, 70), scaledLineWidth);
                                            penLight.penStyle = dashStyle;
                                            Chart.StiNullableDrawing.drawLines(context, penLight, points, animation);
                                            context.popTransform();
                                        }
                                        pointsPositive.stimulsoft().clear();
                                    }
                                }
                            }
                        }
                        else {
                            if (list.length == 1) {
                                let newPointsStart = this.pointsFrom != null ? this.getSteppedPoints(this.pointsFrom) : null;
                                Chart.StiNullableDrawing.drawLines2(context, pen, newPointsStart, newPoints, animation);
                            }
                            else {
                                Chart.StiNullableDrawing.drawLines(context, pen, newPoints, animation);
                            }
                            if (scaledLineWidth >= 2 && lineSeries.lighting) {
                                let step = 0.5 * context.options.zoom;
                                context.pushTranslateTransform(-step, -step);
                                let penLight = new StiPenGeom(StiColorUtils.light(lineSeries.lineColor, 70), 1);
                                penLight.penStyle = dashStyle;
                                Chart.StiNullableDrawing.drawLines(context, penLight, newPoints, animation);
                                context.popTransform();
                            }
                        }
                        if (lineSeries.lineMarker.visible) {
                            let borderPen = new StiPenGeom(lineSeries.lineMarker.borderColor);
                            lineSeries.lineMarker.core.drawLines(context, newPoints, context.options.zoom, lineSeries.lineMarker.brush, borderPen, lineSeries.lineMarker.type, lineSeries.lineMarker.step, lineSeries.lineMarker.size, lineSeries.lineMarker.angle);
                        }
                    }
                    context.popSmoothingMode();
                }
                intersectionAxis(point, pointNext, points, pointsNext, posY) {
                    if (pointNext != null) {
                        let pointCross = new PointD(point.x, posY);
                        points.push(pointCross);
                        pointsNext.push(pointCross);
                    }
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiSteppedLineSeriesGeom = StiSteppedLineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            class StiSteppedAreaSeriesGeom extends Chart.StiSteppedLineSeriesGeom {
                draw(context) {
                    let areaSeries = this.series;
                    let axisArea = this.series.chart.area;
                    let posY = axisArea.axisCore.getDividerY();
                    let list = Chart.StiNullableDrawing.getNullablePointsList(this.points);
                    let listFrom = this.pointsFrom != null ? Chart.StiNullableDrawing.getNullablePointsList(this.pointsFrom) : null;
                    if (this.series.chart.isAnimation) {
                        for (let index = 0; index < list.length; index++) {
                            let newPoints = this.getSteppedPoints(list[index]);
                            let path = [];
                            let lineSegment1 = new StiLineSegmentGeom(new PointD(newPoints[0].x, posY), newPoints[0]);
                            let lineSegments = new StiLinesSegmentGeom(newPoints);
                            let lineSegment2 = new StiLineSegmentGeom(newPoints[newPoints.length - 1], new PointD(newPoints[newPoints.length - 1].x, posY));
                            path.push(lineSegment1);
                            path.push(lineSegments);
                            path.push(lineSegment2);
                            let newPointsFrom = this.getSteppedPoints(listFrom[index]);
                            let newPointsIds = this.getSteppedPointsIds(this.pointsIds);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, newPointsIds)) {
                                let pointsAnimation = new StiPointsAnimation(newPointsFrom, newPoints, newPointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}`;
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                lineSegment1.animation = new StiPointsAnimation([new PointD(pointsAnimation.pointsFrom[0].x, posY), pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegments.animation = pointsAnimation;
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], new PointD(pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1].x, posY)], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                context.animations.add(pointsAnimation);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, null, null);
                                if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                    let width = axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX;
                                    let height = axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY;
                                    let clipRect = new RectangleD(0, posY, width, height);
                                    context.pushClip(clipRect);
                                    context.fillDrawAnimationPath(areaSeries.brushNegative, null, path, StiPathGeom.getBoundsState, null, null, null);
                                    context.popClip();
                                }
                            }
                            else if (areaSeries.brush != null) {
                                let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            index++;
                        }
                    }
                    else {
                        for (let newPoints of list) {
                            let newPoints2 = this.getSteppedPoints(newPoints);
                            let path = [];
                            path.push(new StiLineSegmentGeom(newPoints2[0].x, posY, newPoints2[0].x, newPoints2[0].y));
                            path.push(new StiLinesSegmentGeom(newPoints2));
                            path.push(new StiLineSegmentGeom(newPoints2[newPoints2.length - 1].x, newPoints2[newPoints2.length - 1].y, newPoints2[newPoints2.length - 1].x, posY));
                            if (areaSeries.brush != null) {
                                context.fillPath(areaSeries.brush, path, StiPathGeom.getBoundsState, null);
                            }
                            if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                                let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                                let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                                let clipRect = new RectangleD(0, posY, width, height);
                                context.pushClip(clipRect);
                                context.fillPath(areaSeries.brushNegative, path, StiPathGeom.getBoundsState, null);
                                context.popClip();
                            }
                            if (this.isMouseOver || this.series.core.isMouseOver) {
                                context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                            }
                        }
                    }
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiSteppedAreaSeriesGeom = StiSteppedAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointF = Stimulsoft.System.Drawing.Point;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiChartHelper = Stimulsoft.Report.Chart.StiChartHelper;
            var StiTranslationAnimation = Stimulsoft.Base.Context.Animation.StiTranslationAnimation;
            class StiWaterfallLineGeom extends Chart.StiCellGeom {
                constructor(pointStart, pointEnd, pen, clientRectangle, animation) {
                    super(clientRectangle);
                    this.pen = pen;
                    this.pointStart = pointStart;
                    this.pointEnd = pointEnd;
                    this.animation = animation;
                }
                draw(context) {
                    if (this.animation) {
                        let animation = new StiTranslationAnimation(PointF.empty, PointF.empty, StiChartHelper.globalDurationElement, TimeSpan.zero);
                        context.drawAnimationLines(this.pen, [this.pointStart, this.pointEnd], animation);
                    }
                    else {
                        context.drawLine(this.pen, this.pointStart.x, this.pointStart.y, this.pointEnd.x, this.pointEnd.y);
                    }
                }
            }
            Chart.StiWaterfallLineGeom = StiWaterfallLineGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var Color = Stimulsoft.System.Drawing.Color;
            var List = Stimulsoft.System.Collections.List;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            class StiDoughnutEmptySeriesElementGeom extends Chart.StiCellGeom {
                draw(context) {
                    let rectPie = this.clientRectangle;
                    let pen = new StiPenGeom(Color.lightGray);
                    let path = new List();
                    path.add(new StiArcSegmentGeom(rectPie, 0, 360));
                    path.add(new StiLineSegmentGeom(rectPie.right, rectPie.y + rectPie.height / 2, rectPie.x + rectPie.width * 3 / 4, rectPie.y + rectPie.height / 2));
                    path.add(new StiArcSegmentGeom(new Rectangle(rectPie.x + rectPie.width / 4, rectPie.y + rectPie.height / 4, rectPie.width / 2, rectPie.height / 2), 0, 360));
                    path.add(new StiLineSegmentGeom(rectPie.x + rectPie.width * 3 / 4, rectPie.y + rectPie.height / 2, rectPie.right, rectPie.y + rectPie.height / 2));
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(Color.fromArgb(50, Color.lightGray.r, Color.lightGray.g, Color.lightGray.b), path, rectPie, null);
                    context.drawPath(pen, path, rectPie);
                    context.drawLine(pen, rectPie.x + rectPie.width / 2, rectPie.y + rectPie.height * 3 / 4, rectPie.x + rectPie.width / 2, rectPie.bottom);
                    context.popSmoothingMode();
                }
                constructor(clientRectangle) {
                    super(clientRectangle);
                }
            }
            Chart.StiDoughnutEmptySeriesElementGeom = StiDoughnutEmptySeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenAlignment = Stimulsoft.Base.Context.StiPenAlignment;
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPieSegmentAnimation = Stimulsoft.Base.Context.Animation.StiPieSegmentAnimation;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            class StiDoughnutSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, clientRectangle, clientRectangleDt, path, pathLight, pathDark, borderColor, brush, brushLight, brushDark, startAngle, endAngle, radiusFrom, radiusTo, beginTime) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this.clientRectangleDt = clientRectangleDt;
                    this.path = path;
                    this.pathLight = pathLight;
                    this.pathDark = pathDark;
                    this.borderColor = borderColor;
                    this.brush = brush;
                    this.brushLight = brushLight;
                    this.brushDark = brushDark;
                    this.startAngle = startAngle;
                    this.endAngle = endAngle;
                    this.radiusFrom = radiusFrom;
                    this.radiusTo = radiusTo;
                    this.beginTime = beginTime;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let center = new PointD(this.clientRectangle.x + this.clientRectangle.width / 2, this.clientRectangle.y + this.clientRectangle.height / 2);
                    let dx = x - center.x;
                    let dy = y - center.y;
                    let radius = Math.sqrt(dx * dx + dy * dy);
                    if (radius < this.radiusTo || radius > this.radiusFrom)
                        return false;
                    let alpha = (Math.atan2(dy, dx) * 180 / Math.PI);
                    if (alpha < 0)
                        alpha += 360;
                    return alpha >= this.startAngle && alpha <= this.endAngle;
                }
                draw(context) {
                    let rectPie = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.borderColor);
                    pen.alignment = StiPenAlignment.Inset;
                    let fontIconSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconSeries != null && fontIconSeries.icon != null) {
                        let sizeIcon = 30;
                        context.pushClipPath(this.path);
                        Report.StiFontIconsHelper.drawFillIcons(context, this.seriesBrush, rectPie, new Size(sizeIcon, sizeIcon), fontIconSeries.icon, this.getToolTip());
                        context.popClip();
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        context.drawAnimationPathElement(this.brush, pen, this.path, rectPie, this.getToolTip(), this, animation, this.getInteractionData());
                        if (this.pathLight != null)
                            context.drawAnimationPathElement(this.brushLight, null, this.pathLight, rectPie, this.getToolTip(), null, animation, this.getInteractionData());
                        if (this.pathDark != null)
                            context.drawAnimationPathElement(this.brushDark, null, this.pathDark, rectPie, this.getToolTip(), null, animation, this.getInteractionData());
                    }
                    else {
                        context.pushSmoothingModeToAntiAlias();
                        if (this.path != null) {
                            context.fillPath(this.brush, this.path, rectPie, this.getInteractionData());
                            if (this.isMouseOver || this.series.core.isMouseOver)
                                context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), this.path, rectPie, null);
                        }
                        if (this.pathLight != null)
                            context.fillPath(this.brushLight, this.pathLight, rectPie, null);
                        if (this.pathDark != null)
                            context.fillPath(this.brushDark, this.pathDark, rectPie, null);
                        context.drawPath(pen, this.path, StiPathGeom.getBoundsState);
                        context.popSmoothingMode();
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    let animation = null;
                    let pieAnimation = null;
                    if (this.series.chart.isAnimationChangingValues) {
                        let startAngleTo = this.startAngle;
                        let endAngleTo = this.endAngle;
                        let rectTo = this.clientRectangle;
                        let rectDtTo = this.clientRectangle;
                        if (this.path.length == 4 && this.path[0].is(StiArcSegmentGeom) && this.path[2].is(StiArcSegmentGeom)) {
                            let arcGeom1 = this.path[0];
                            let arcGeom2 = this.path[2];
                            startAngleTo = arcGeom1.startAngle;
                            endAngleTo = arcGeom1.startAngle + arcGeom1.sweepAngle;
                            rectTo = arcGeom1.rect;
                            rectDtTo = arcGeom2.rect;
                        }
                        pieAnimation = new StiPieSegmentAnimation(this.clientRectangle, rectTo, this.clientRectangleDt, rectDtTo, this.startAngle, this.endAngle, startAngleTo, endAngleTo, duration, TimeSpan.zero);
                        pieAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}`;
                        if (StiPieSegmentAnimation.isAnimationChangingValues(this.series, pieAnimation.id)) {
                            pieAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                            animation = pieAnimation;
                        }
                    }
                    if (animation == null) {
                        let beginTimeAnimationOpacity = new TimeSpan(beginTime.ticks / this.series.values.length * this.index);
                        if (this.series.chart.previousAnimations.length > 0)
                            beginTimeAnimationOpacity = TimeSpan.fromMilliseconds(300);
                        let opacityAnimation = new StiOpacityAnimation(duration, beginTimeAnimationOpacity);
                        opacityAnimation.anotherAnimation = pieAnimation;
                        opacityAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}`;
                        animation = opacityAnimation;
                    }
                    return animation;
                }
            }
            Chart.StiDoughnutSeriesElementGeom = StiDoughnutSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiFinancialSeriesElementGeom extends Chart.StiCellGeom {
                constructor(areaGeom, series, clientRectangle, open, close, high, low, positionX, index) {
                    super(clientRectangle);
                    this._areaGeom = areaGeom;
                    this._series = series;
                    this._open = open;
                    this._close = close;
                    this._high = high;
                    this._low = low;
                    this._positionX = positionX;
                    this._index = index;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = this.series.interaction.drillDownEnabled;
                    }
                    let valueIndex = this.getValueIndex();
                    options.interactionToolTip = this.getToolTip(valueIndex);
                    options.interactionHyperlink = this.getHyperlink(valueIndex);
                }
                invokeClick(options) {
                    let valueIndex = this.getValueIndex();
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length) {
                        options.interactionHyperlink = this.series.hyperlinks[valueIndex];
                    }
                    if (this.series.interaction.drillDownEnabled) {
                        options.seriesInteractionData = this.interaction;
                        this.isMouseOver = false;
                        options.updateContext = this.series.interaction.drillDownEnabled;
                    }
                }
                getValueIndex() {
                    let valueIndex = this.index;
                    if (this.series.chart.area.is(Chart.IStiAxisArea) && this.series.chart.area.reverseHor)
                        valueIndex = this.series.arguments.length - valueIndex - 1;
                    return valueIndex;
                }
                getHyperlink(valueIndex) {
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                getToolTip(valueIndex) {
                    if (this.series.toolTips != null && valueIndex < this.series.toolTips.length)
                        return this.series.toolTips[valueIndex];
                    else
                        return null;
                }
                get allowMouseOver() {
                    let index = this.getValueIndex();
                    return ((this.series.hyperlinks != null && index < this.series.hyperlinks.length) ||
                        (this.series.toolTips != null && index < this.series.toolTips.length)) ||
                        (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeriesElements);
                }
                get isMouseOver() {
                    return this.series.core.getIsMouseOverSeriesElement(this.index);
                }
                set isMouseOver(value) {
                    this.series.core.setIsMouseOverSeriesElement(this.index, value);
                }
                get series() {
                    return this._series;
                }
                get interaction() {
                    return this._interaction;
                }
                set interaction(value) {
                    this._interaction = value;
                }
                get open() {
                    return this._open;
                }
                get close() {
                    return this._close;
                }
                get high() {
                    return this._high;
                }
                get low() {
                    return this._low;
                }
                get positionX() {
                    return this._positionX;
                }
                get areaGeom() {
                    return this._areaGeom;
                }
                get index() {
                    return this._index;
                }
                draw(context) {
                }
            }
            Chart.StiFinancialSeriesElementGeom = StiFinancialSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiCloseFigureSegmentGeom = Stimulsoft.Base.Context.StiCloseFigureSegmentGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiCandlestickSeriesElementGeom extends Chart.StiFinancialSeriesElementGeom {
                constructor(areaGeom, series, clientRectangle, bodyStart, bodyEnd, high, low, positionX, index, brush, borderColor, beginTime) {
                    super(areaGeom, series, clientRectangle, bodyStart, bodyEnd, high, low, positionX, index);
                    this._brush = brush;
                    this._borderColor = borderColor;
                    this._beginTime = beginTime;
                }
                get brush() {
                    return this._brush;
                }
                get borderColor() {
                    return this._borderColor;
                }
                get beginTime() {
                    return this._beginTime;
                }
                draw(context) {
                    let candlestickArea = this.areaGeom.area;
                    let candlestickSeries = this.series;
                    let borderWidht = candlestickSeries.borderWidth * context.options.zoom;
                    let width = candlestickArea.xAxis.info.dpi / 2;
                    let open = this.open;
                    let close = this.close;
                    let high = this.high;
                    let low = this.low;
                    let positionX = this.positionX;
                    let pen = new StiPenGeom(this._borderColor, borderWidht);
                    if (close == open)
                        open -= 1;
                    let chart = this.series.chart;
                    if (chart.isAnimation) {
                        let duration = Chart.StiChartHelper.globalDurationElement;
                        let pointsOpen = [new PointD(positionX, high), new PointD(positionX, open)];
                        let pointsClose = [new PointD(positionX, close), new PointD(positionX, low)];
                        let path = [];
                        let x1 = positionX - width / 2;
                        let y1 = open;
                        let x2 = x1 + width;
                        let y2 = y1 + close - open;
                        path.push(new StiLineSegmentGeom(x1, y1, x2, y1));
                        path.push(new StiLineSegmentGeom(x2, y1, x2, y2));
                        path.push(new StiLineSegmentGeom(x2, y2, x1, y2));
                        path.push(new StiLineSegmentGeom(x1, y2, x1, y1));
                        path.push(new StiCloseFigureSegmentGeom());
                        let animation = new StiOpacityAnimation(duration, this.beginTime);
                        if (candlestickSeries.showShadow) {
                            let borderWidhtShadow = borderWidht + 0.5 * context.options.zoom;
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), borderWidhtShadow);
                            let pointsOpenShadow = [new PointD(positionX + borderWidhtShadow / 2, high + borderWidhtShadow / 2), new PointD(positionX + borderWidhtShadow / 2, open + borderWidhtShadow / 2)];
                            let pointsCloseShadow = [new PointD(positionX + borderWidhtShadow / 2, close + borderWidhtShadow / 2), new PointD(positionX + borderWidhtShadow / 2, low + borderWidhtShadow / 2)];
                            context.drawAnimationLines(penShadow, pointsOpenShadow, animation);
                            context.drawAnimationLines(penShadow, pointsCloseShadow, animation);
                            let pathShadow = [];
                            pathShadow.push(new StiLineSegmentGeom(x1 + borderWidhtShadow / 2, y1 + borderWidhtShadow / 2, x2 + borderWidhtShadow / 2, y1 + borderWidhtShadow / 2));
                            pathShadow.push(new StiLineSegmentGeom(x2 + borderWidhtShadow / 2, y1 + borderWidhtShadow / 2, x2 + borderWidhtShadow / 2, y2 + borderWidhtShadow / 2));
                            pathShadow.push(new StiLineSegmentGeom(x2 + borderWidhtShadow / 2, y2 + borderWidhtShadow / 2, x1 + borderWidhtShadow / 2, y2 + borderWidhtShadow / 2));
                            pathShadow.push(new StiLineSegmentGeom(x1 + borderWidhtShadow / 2, y2 + borderWidhtShadow / 2, x1 + borderWidhtShadow / 2, y1 + borderWidhtShadow / 2));
                            pathShadow.push(new StiCloseFigureSegmentGeom());
                            context.fillDrawAnimationPath(null, penShadow, pathShadow, new RectangleD(x1 + borderWidhtShadow / 2, y1 + borderWidhtShadow / 2, width, close - open), null, animation, null);
                        }
                        context.drawAnimationLines(pen, pointsOpen, animation);
                        context.drawAnimationLines(pen, pointsClose, animation);
                        context.fillDrawAnimationPath(this.brush, pen, path, new RectangleD(x1, y1, width, close - open), this, animation, null);
                    }
                    else {
                        if (candlestickSeries.showShadow) {
                            let borderWidhtShadow = borderWidht + 0.5 * context.options.zoom;
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), borderWidhtShadow);
                            context.pushTranslateTransform(borderWidht, borderWidht);
                            context.drawLine(penShadow, positionX, close + borderWidhtShadow / 2, positionX, low + borderWidhtShadow / 2);
                            context.drawLine(penShadow, positionX, high, positionX, open - borderWidhtShadow / 2);
                            context.drawRectangle2(penShadow, positionX - width / 2, open, width, close - open);
                            context.popTransform();
                        }
                        context.drawLine(pen, positionX, high, positionX, open);
                        context.drawLine(pen, positionX, close, positionX, low);
                        context.fillRectangle2(this.brush, positionX - width / 2, open, width, close - open, null);
                        context.drawRectangle2(pen, positionX - width / 2, open, width, close - open);
                    }
                }
            }
            Chart.StiCandlestickSeriesElementGeom = StiCandlestickSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiStockSeriesElementGeom extends Chart.StiFinancialSeriesElementGeom {
                constructor(areaGeom, series, clientRectangle, open, close, high, low, positionX, index, color, beginTime) {
                    super(areaGeom, series, clientRectangle, open, close, high, low, positionX, index);
                    this._color = color;
                    this._beginTime = beginTime;
                }
                get color() {
                    return this._color;
                }
                get beginTime() {
                    return this._beginTime;
                }
                draw(context) {
                    let stockArea = this.areaGeom.area;
                    let stockSeries = this.series;
                    let lineWidht = stockSeries.lineWidth * context.options.zoom;
                    let width = stockArea.xAxis.info.dpi / 3;
                    let pen = new StiPenGeom(this.color, lineWidht);
                    pen.penStyle = stockSeries.lineStyle;
                    let chart = this.series.chart;
                    if (chart.isAnimation) {
                        let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, this.beginTime);
                        if (stockSeries.showShadow) {
                            let lineWidgtShadow = lineWidht + 0.5 * context.options.zoom;
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), lineWidgtShadow);
                            penShadow.penStyle = stockSeries.lineStyle;
                            let pointsShadow1 = [new PointD(this.positionX, this.high), new PointD(this.positionX, this.low)];
                            let pointsShadow2 = [new PointD(this.positionX - width, this.open), new PointD(this.positionX - lineWidgtShadow / 2, this.open)];
                            let pointsShadow3 = [new PointD(this.positionX + width, this.close), new PointD(this.positionX + lineWidgtShadow / 2, this.close)];
                            context.drawAnimationLines(penShadow, pointsShadow1, animationOpacity);
                            context.drawAnimationLines(penShadow, pointsShadow2, animationOpacity);
                            context.drawAnimationLines(penShadow, pointsShadow3, animationOpacity);
                        }
                        let points1 = [new PointD(this.positionX, this.high), new PointD(this.positionX, this.low)];
                        let points2 = [new PointD(this.positionX - width, this.open), new PointD(this.positionX, this.open)];
                        let points3 = [new PointD(this.positionX + width, this.close), new PointD(this.positionX, this.close)];
                        context.drawAnimationLines(pen, points1, animationOpacity);
                        context.drawAnimationLines(pen, points2, animationOpacity);
                        context.drawAnimationLines(pen, points3, animationOpacity);
                    }
                    else {
                        if (stockSeries.showShadow) {
                            let lineWidgtShadow = lineWidht + 0.5 * context.options.zoom;
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), lineWidgtShadow);
                            penShadow.penStyle = stockSeries.lineStyle;
                            context.pushTranslateTransform(lineWidht, lineWidht);
                            context.drawLine(penShadow, this.positionX, this.high, this.positionX, this.low);
                            context.drawLine(penShadow, this.positionX - width, this.open, this.positionX - lineWidgtShadow / 2, this.open);
                            context.drawLine(penShadow, this.positionX + width, this.close, this.positionX + lineWidgtShadow / 2, this.close);
                            context.popTransform();
                        }
                        context.drawLine(pen, this.positionX, this.high, this.positionX, this.low);
                        context.drawLine(pen, this.positionX - width, this.open, this.positionX, this.open);
                        context.drawLine(pen, this.positionX + width, this.close, this.positionX, this.close);
                    }
                }
            }
            Chart.StiStockSeriesElementGeom = StiStockSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiFunnelEmptySeriesElementGeom extends Chart.StiCellGeom {
                constructor(clientRectangle, path) {
                    super(clientRectangle);
                    this.path = path;
                }
                draw(context) {
                    context.pushSmoothingModeToAntiAlias();
                    context.fillPath(Color.fromArgb(50, Color.lightGray), this.path, this.clientRectangle, null);
                    context.drawPath(new StiPenGeom(Color.gray), this.path, this.clientRectangle);
                    context.popSmoothingMode();
                }
            }
            Chart.StiFunnelEmptySeriesElementGeom = StiFunnelEmptySeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenAlignment = Stimulsoft.Base.Context.StiPenAlignment;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiFunnelSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, clientRectangle, brush, borderColor, path, beginTime) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this.path = path;
                    this.borderColor = borderColor;
                    this.brush = brush;
                    this.beginTime = beginTime;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(StiColorUtils.dark(this.borderColor, 10));
                    pen.alignment = StiPenAlignment.Inset;
                    let chart = this.series.chart;
                    let fontIconSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconSeries != null && fontIconSeries.icon != null) {
                        let sizeIcon = 30;
                        context.pushClipPath(this.path);
                        Report.StiFontIconsHelper.drawFillIcons(context, this.seriesBrush, rect, new Size(sizeIcon, sizeIcon), fontIconSeries.icon, this.getToolTip());
                        context.popClip();
                        return;
                    }
                    if (chart.isAnimation) {
                        let animationOpacity = new StiOpacityAnimation(TimeSpan.fromSeconds(1), this.beginTime);
                        if (this.series.showShadow) {
                            context.pushTranslateTransform(4, 4);
                            context.drawAnimationPathElement(new StiSolidBrush(Color.fromArgb(50, 100, 100, 100)), null, this.path, rect, null, this, animationOpacity, null);
                            context.popTransform();
                        }
                        context.drawAnimationPathElement(this.brush, null, this.path, rect, this.getToolTip(), this, animationOpacity, this.getInteractionData());
                        if (!Color.transparent.equals(this.borderColor))
                            context.drawAnimationPathElement(null, pen, this.path, rect, null, this, animationOpacity, null);
                    }
                    else {
                        context.pushSmoothingModeToAntiAlias();
                        if (this.series.showShadow) {
                            context.pushTranslateTransform(4, 4);
                            context.fillPath(Color.fromArgb(50, 100, 100, 100), this.path, rect, null);
                            context.popTransform();
                        }
                        context.fillPath(this.brush, this.path, rect, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver)
                            context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), this.path, rect, null);
                        if (!Color.transparent.equals(this.borderColor))
                            context.drawPath(pen, this.path, null);
                        context.popSmoothingMode();
                    }
                }
            }
            Chart.StiFunnelSeriesElementGeom = StiFunnelSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiGanttSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, clientRectangle, rectFrom, brush) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this.rectFrom = rectFrom;
                }
                draw(context) {
                    let currSeries = this.series;
                    let rect = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        let roundValuesArea = chart.area.as(Chart.IStiRoundValuesArea);
                        let roundValues = roundValuesArea === null || roundValuesArea === void 0 ? void 0 : roundValuesArea.roundValues;
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, rect, new Size(rect.height, rect.height), fontIconsSeries.icon, this.getToolTip(), false, roundValues);
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        if (this.series.showShadow) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(rect, 5, animationOpacity);
                        }
                        let pen = new StiPenGeom(currSeries.borderColor);
                        context.drawAnimationBar(this.seriesBrush, pen, rect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        if (currSeries.showShadow && rect.width > 4 && rect.height > 4) {
                            context.drawCachedShadow(rect, StiShadowSides.All, context.options.isPrinting);
                        }
                        let pen = new StiPenGeom(currSeries.borderColor);
                        context.fillRectangle2(this.seriesBrush, rect.x, rect.y, rect.width, rect.height, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        }
                        context.drawRectangle2(pen, rect.x, rect.y, rect.width, rect.height);
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let axisArea = this.areaGeom.area;
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                    let columnAnimation = new StiColumnAnimation(this.rectFrom, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let getStartFromZero = axisArea.yAxis.core.getStartFromZero();
                    let argId = getStartFromZero ?
                        axisArea.yAxis.info.stripLines.getByIndex(this.index + 1).valueObject :
                        axisArea.yAxis.info.stripLines.getByIndex(this.index).valueObject;
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiGanttSeriesElementGeom = StiGanttSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiFontIconsHelper = Stimulsoft.Report.StiFontIconsHelper;
            class StiPictorialSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, series, icon, drawRectangles, clipRectangles, clientRectangle, animation) {
                    super(areaGeom, value, index, series, clientRectangle, seriesBrush);
                    this.icon = icon;
                    this.drawRectangles = drawRectangles;
                    this.clipRectangles = clipRectangles;
                    this.seriesBrush = seriesBrush;
                    this.animation = animation;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let index = 0; index < this.drawRectangles.length; index++) {
                        let drawRect = this.drawRectangles[index];
                        if (drawRect.contains(x, y))
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let singleSize = (this.series.core).getSingleSize(context);
                    super.draw(context);
                    let fontGeom = new StiFontGeom("Stimulsoft", 15 * context.options.zoom, Stimulsoft.System.Drawing.FontStyle.Regular, Stimulsoft.System.Drawing.GraphicsUnit.Pixel);
                    for (let index = 0; index < this.drawRectangles.length; index++) {
                        let drawRect = this.drawRectangles[index];
                        let clipRect = this.clipRectangles[index];
                        let draw = true;
                        let startPointDraw = new PointD(drawRect.x, drawRect.y);
                        context.pushClip(clipRect);
                        while (draw) {
                            let drawElementRect = new RectangleD(startPointDraw.x + context.options.zoom, startPointDraw.y + context.options.zoom, singleSize.width, singleSize.height);
                            context.drawString3(StiFontIconsHelper.getContent(this.icon), fontGeom, this.seriesBrush, drawElementRect, this.getStringFormatGeom(context), this.getToolTip());
                            startPointDraw = new PointD(startPointDraw.x + singleSize.width, startPointDraw.y);
                            if (startPointDraw.x >= drawRect.right)
                                draw = false;
                        }
                        context.popClip();
                    }
                }
                getStringFormatGeom(context) {
                    let sf = context.getGenericStringFormat();
                    sf.trimming = StringTrimming.None;
                    sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    return sf;
                }
            }
            Chart.StiPictorialSeriesElementGeom = StiPictorialSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiPieEmptySeriesElementGeom extends Chart.StiCellGeom {
                draw(context) {
                    let rectPie = this.clientRectangle;
                    let pen = new StiPenGeom(Color.lightGray);
                    context.pushSmoothingModeToAntiAlias();
                    context.fillEllipse2(Color.fromArgb(50, Color.lightGray), rectPie, null);
                    context.drawEllipse2(pen, rectPie);
                    context.drawLine(pen, rectPie.x + rectPie.width / 2, rectPie.y + rectPie.height / 2, rectPie.right, rectPie.y + rectPie.height / 2);
                    context.drawLine(pen, rectPie.x + rectPie.width / 2, rectPie.y + rectPie.height / 2, rectPie.x + rectPie.width / 2, rectPie.bottom);
                    context.popSmoothingMode();
                }
                constructor(clientRectangle) {
                    super(clientRectangle);
                }
            }
            Chart.StiPieEmptySeriesElementGeom = StiPieEmptySeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenAlignment = Stimulsoft.Base.Context.StiPenAlignment;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPieSegmentAnimation = Stimulsoft.Base.Context.Animation.StiPieSegmentAnimation;
            var StiPieSegmentGeom = Stimulsoft.Base.Context.StiPieSegmentGeom;
            class StiPieSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, clientRectangle, path, pathLight, borderColor, brush, startAngle, endAngle, radius) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this.path = path;
                    this.pathLight = pathLight;
                    this.borderColor = borderColor;
                    this.brush = brush;
                    this.startAngle = startAngle;
                    this.endAngle = endAngle;
                    this.radius = radius;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let center = new PointD(this.clientRectangle.x + this.clientRectangle.width / 2, this.clientRectangle.y + this.clientRectangle.height / 2);
                    let dx = x - center.x;
                    let dy = y - center.y;
                    let radius = Math.sqrt(dx * dx + dy * dy);
                    if (radius >= this.radius)
                        return false;
                    let alpha = (Math.atan2(dy, dx) * 180 / Math.PI);
                    if (alpha < 0)
                        alpha += 360;
                    return alpha >= this.startAngle && alpha <= this.endAngle;
                }
                draw(context) {
                    let rectPie = this.clientRectangle.clone();
                    let penColor = Color.transparent.equals(this.borderColor) ? this.borderColor : StiColorUtils.dark(this.borderColor, 10);
                    let pen = new StiPenGeom(penColor);
                    pen.alignment = StiPenAlignment.Inset;
                    let fontIconSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconSeries != null && fontIconSeries.icon != null) {
                        let sizeIcon = 30;
                        context.pushClipPath(this.path);
                        Report.StiFontIconsHelper.drawFillIcons(context, this.seriesBrush, rectPie, new Size(sizeIcon, sizeIcon), fontIconSeries.icon, this.getToolTip());
                        context.popClip();
                        return;
                    }
                    context.pushSmoothingModeToAntiAlias();
                    let animation = this.getAnimation();
                    if (animation != null) {
                        context.drawAnimationPathElement(this.brush, pen, this.path, rectPie, this.getToolTip(), this, animation, this.getInteractionData());
                        if (this.pathLight != null) {
                            let brLight = new StiSolidBrush(Color.fromArgb(30, Color.black));
                            context.drawAnimationPathElement(brLight, null, this.pathLight, rectPie, this.getToolTip(), null, animation, this.getInteractionData());
                        }
                    }
                    else {
                        context.fillPath(this.brush, this.path, rectPie, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver)
                            context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), this.path, rectPie, null);
                        if (this.pathLight != null) {
                            let brLight = new StiSolidBrush(Color.fromArgb(30, Color.black));
                            context.fillPath(brLight, this.pathLight, rectPie, this.getInteractionData());
                        }
                        if (!Color.transparent.equals(this.borderColor))
                            context.drawPath(pen, this.path, null);
                    }
                    context.popSmoothingMode();
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                    let animation = null;
                    let pieAnimation = null;
                    if (this.series.chart.isAnimationChangingValues) {
                        let startAngleTo = this.startAngle;
                        let endAngleTo = this.endAngle;
                        let rectTo = this.clientRectangle;
                        if (this.path[0].is(StiPieSegmentGeom)) {
                            let pieGeom = this.path[0];
                            startAngleTo = pieGeom.startAngle;
                            endAngleTo = pieGeom.startAngle + pieGeom.sweepAngle;
                            rectTo = pieGeom.rect;
                        }
                        pieAnimation = new StiPieSegmentAnimation(this.clientRectangle, rectTo, RectangleD.empty, RectangleD.empty, this.startAngle, this.endAngle, startAngleTo, endAngleTo, duration, TimeSpan.zero);
                        pieAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}`;
                        if (StiPieSegmentAnimation.isAnimationChangingValues(this.series, pieAnimation.id)) {
                            pieAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                            animation = pieAnimation;
                        }
                    }
                    if (animation == null) {
                        let beginTimeAnimationOpacity = new TimeSpan(beginTime.ticks / this.count * this.index);
                        if (this.series.chart.previousAnimations.length > 0)
                            beginTimeAnimationOpacity = TimeSpan.fromMilliseconds(300);
                        let opacityAnimation = new StiOpacityAnimation(duration, beginTimeAnimationOpacity);
                        opacityAnimation.anotherAnimation = pieAnimation;
                        opacityAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}`;
                        animation = opacityAnimation;
                    }
                    return animation;
                }
            }
            Chart.StiPieSeriesElementGeom = StiPieSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiPieSeriesFullElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, clientRectangle, brush, borderColor) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this._brush = brush;
                    this._borderColor = borderColor;
                }
                get brush() {
                    return this._brush;
                }
                get borderColor() {
                    return this._borderColor;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let rectPie = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.borderColor);
                    if (chart.isAnimation) {
                        let duration = Chart.StiChartHelper.globalDurationElement;
                        let beginTime = Chart.StiChartHelper.globalBeginTimeElement;
                        let animation = new StiOpacityAnimation(duration, beginTime);
                        context.fillDrawAnimationEllipse(this.brush, pen, rectPie.x, rectPie.y, rectPie.width, rectPie.height, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        context.fillEllipse2(this.brush, rectPie, null);
                        context.drawEllipse2(pen, rectPie);
                    }
                }
            }
            Chart.StiPieSeriesFullElementGeom = StiPieSeriesFullElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiPieSeriesShadowElementGeom extends Chart.StiCellGeom {
                constructor(series, clientRectangle, radius, shadowContext, duration, beginTime) {
                    super(clientRectangle);
                    this._series = series;
                    this._shadowContext = shadowContext;
                    this._radius = radius;
                    this._duration = duration;
                    this._beginTime = beginTime;
                    this._isAnimation = series.chart.isAnimation;
                }
                get invisible() {
                    return true;
                }
                get series() {
                    return this._series;
                }
                get shadowContext() {
                    return this._shadowContext;
                }
                get radius() {
                    return this._radius;
                }
                get duration() {
                    return this._duration;
                }
                get beginTime() {
                    return this._beginTime;
                }
                get isAnimation() {
                    return this._isAnimation;
                }
                draw(context) {
                    let rectPie = this.clientRectangle.clone();
                    if (this.isAnimation) {
                        let animationOpacity = new StiOpacityAnimation(this.duration, this.beginTime);
                        context.drawShadowRect2(rectPie, rectPie.height / 2, rectPie.width / 2, Math.trunc(this.radius), animationOpacity);
                    }
                    else {
                        context.drawShadow(this.shadowContext, rectPie, this.radius);
                    }
                }
            }
            Chart.StiPieSeriesShadowElementGeom = StiPieSeriesShadowElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            class StiRadarAreaSeriesGeom extends Chart.StiCellGeom {
                constructor(series, pointsInfo) {
                    super(RectangleD.empty);
                    this.series = series;
                    this.pointsFrom = pointsInfo.pointsFrom;
                    this.points = pointsInfo.points;
                    this.pointsIds = pointsInfo.pointsIds;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                get allowMouseOver() {
                    return (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeries);
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.isMouseOver;
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.isMouseOver = value;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let radarArea = this.series.chart.area;
                    let radarCore = radarArea.core;
                    for (let pointIndex = 0; pointIndex < this.points.length; pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = pointIndex == this.points.length - 1 ? this.points[0] : this.points[pointIndex + 1];
                        let point3 = radarCore.centerPoint;
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isPointInTriangle(new PointD(x, y), point1, point3, point2);
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let radarSeries = this.series;
                    if (radarSeries.brush == null)
                        return;
                    let path = [];
                    if (this.series.chart.isAnimation) {
                        let animation = null;
                        let pointsAnimation = null;
                        if (StiPointsAnimation.isAnimationChangingValues(this.series, this.pointsIds)) {
                            pointsAnimation = new StiPointsAnimation(this.pointsFrom, this.points, this.pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}`;
                            pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                            context.animations.push(pointsAnimation);
                        }
                        else {
                            animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                        }
                        path.push(new StiLinesSegmentGeom(this.points, pointsAnimation));
                        context.fillDrawAnimationPath(radarSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                    }
                    else {
                        let index = 0;
                        for (let point of this.points) {
                            let curPoint = point;
                            let nextPoint = index < this.points.length - 1 ? this.points[index + 1] : this.points[0];
                            path.push(new StiLineSegmentGeom(curPoint.x, curPoint.y, nextPoint.x, nextPoint.y));
                            index++;
                        }
                        context.pushSmoothingModeToAntiAlias();
                        context.fillPath(radarSeries.brush, path, RectangleD.empty, null);
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, RectangleD.empty, null);
                        }
                        context.popSmoothingMode();
                    }
                }
            }
            Chart.StiRadarAreaSeriesGeom = StiRadarAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiInteractionDataGeom = Stimulsoft.Base.Context.StiInteractionDataGeom;
            class StiRadarPointSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, brush, series, point, zoom) {
                    super(areaGeom, value, index, series, Chart.StiMarkerCoreXF.getMarkerRect(point, series.marker.size, zoom), brush);
                    this._point = point;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                    let valueIndex = this.getValueIndex();
                    options.interactionToolTip = this.getToolTip3(valueIndex);
                    options.interactionHyperlink = this.getHyperlink3(valueIndex);
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                invokeClick(options) {
                    let valueIndex = this.getValueIndex();
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length) {
                        options.interactionHyperlink = this.series.hyperlinks[valueIndex];
                    }
                    if (this.series.interaction.drillDownEnabled) {
                        options.seriesInteractionData = this.interaction;
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                getValueIndex() {
                    let valueIndex = this.index;
                    if (this.series.is(Chart.IStiClusteredBarSeries) ||
                        this.series.is(Chart.IStiStackedBarSeries) ||
                        this.series.is(Chart.IStiFullStackedBarSeries)) {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && !this.series.chart.area.reverseVert)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    else {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && this.series.chart.area.reverseHor)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    return valueIndex;
                }
                getHyperlink3(valueIndex) {
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                getToolTip3(valueIndex) {
                    if (this.series.toolTips != null && valueIndex < this.series.toolTips.length)
                        return this.series.toolTips[valueIndex];
                    else
                        return null;
                }
                get point() {
                    return this._point;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    return this.getMouseOverRect().contains(x, y);
                }
                getMouseOverRect() {
                    let rect = this.clientRectangle.clone();
                    rect.inflate(rect.width / 2, rect.height / 2);
                    return rect;
                }
                draw(context) {
                    let radarSeries = this.series;
                    let isTooltipMarkerMode = !radarSeries.marker.visible && radarSeries.toolTips.length > 0;
                    if (radarSeries.marker != null && radarSeries.marker.visible) {
                        context.pushSmoothingModeToAntiAlias();
                        let chartZoom = context.options.zoom;
                        if (this.isMouseOver)
                            context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), this.getMouseOverRect(), null);
                        let chart = this.series.chart;
                        let interaction = null;
                        if (chart.isAnimation) {
                            interaction = new StiInteractionDataGeom();
                            interaction.componentName = chart.name;
                            interaction.componentIndex = chart.page.components.indexOf(chart).toString();
                            interaction.pageGuid = this.series.stimulsoft().as(Chart.StiSeries).drillDownPageGuid;
                            interaction.pageIndex = chart.page.report.renderedPages.indexOf(chart.page).toString();
                            interaction.elementIndex = this.elementIndex.toString();
                            interaction.interactionData = this.interaction;
                        }
                        radarSeries.marker.core.draw(context, radarSeries.marker, this.point, chartZoom, radarSeries.showShadow, this.isMouseOver, isTooltipMarkerMode, chart.isAnimation, this.getToolTip(), this, interaction);
                        context.popSmoothingMode();
                    }
                }
            }
            Chart.StiRadarPointSeriesElementGeom = StiRadarPointSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            class StiRangeBarElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, series, brush, clientRectangle, rectFrom) {
                    super(areaGeom, value, index, series, clientRectangle, brush);
                    this.rectFrom = rectFrom;
                }
                draw(context) {
                    let currSeries = this.series;
                    let seriesRect = this.clientRectangle.clone();
                    let animation = this.getAnimation();
                    if (animation != null) {
                        let pen = new StiPenGeom(currSeries.borderColor);
                        if (this.series.showShadow) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(seriesRect, 5, animationOpacity);
                        }
                        context.drawAnimationColumn(this.seriesBrush, pen, seriesRect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        if (currSeries.showShadow && seriesRect.width > 4 && seriesRect.height > 4) {
                            context.drawCachedShadow(seriesRect, StiShadowSides.All, context.options.isPrinting);
                        }
                        let pen = new StiPenGeom(currSeries.borderColor);
                        context.fillRectangle2(this.seriesBrush, seriesRect.x, seriesRect.y, seriesRect.width, seriesRect.height, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), seriesRect.x, seriesRect.y, seriesRect.width, seriesRect.height, null);
                        }
                        context.drawRectangle2(pen, seriesRect.x, seriesRect.y, seriesRect.width, seriesRect.height);
                    }
                }
                getAnimation() {
                    var _a;
                    if (!this.series.chart.isAnimation)
                        return null;
                    let currSeries = this.series;
                    let axisArea = this.areaGeom.area;
                    let valuesCount = this.series.values.length;
                    if (currSeries.valuesEnd.length < valuesCount)
                        valuesCount = currSeries.valuesEnd.length;
                    let argumentsCount = currSeries.arguments.length;
                    let count = Math.min(valuesCount, argumentsCount);
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / count * this.index);
                    let argumentIndex = axisArea.xAxis.info.stripLines.length - 1;
                    for (let line of axisArea.xAxis.info.stripLines.list) {
                        if (this.series.arguments[this.index].stimulsoft().toString() == ((_a = line.valueObject) === null || _a === void 0 ? void 0 : _a.toString()))
                            break;
                        argumentIndex--;
                    }
                    argumentIndex = axisArea.xAxis.info.stripLines.length - 1 - argumentIndex;
                    let columnAnimation = new StiColumnAnimation(this.rectFrom, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let argId = axisArea.xAxis.info.stripLines.getByIndex(axisArea.reverseVert ? axisArea.xAxis.info.stripLines.length - 1 - argumentIndex : argumentIndex).valueObject;
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiRangeBarElementGeom = StiRangeBarElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            class StiRangeSeriesGeom extends Chart.StiLineSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                    this.pointsEnd = pointsInfo.pointsEnd;
                }
                draw(context) {
                    let areaSeries = this.series;
                    let list = Chart.StiNullableDrawing.getPointsList(this.points);
                    let listEnd = Chart.StiNullableDrawing.getPointsList(this.pointsEnd);
                    if (list.length < 1 || listEnd.length < 1)
                        return;
                    let points = list[0];
                    let pointsEnd = listEnd[0];
                    let count = Math.min(points.length, pointsEnd.length);
                    let pointsLine = [];
                    let pointsLineEnd = [];
                    let pointsLineIds = [];
                    let pointsLineEndIds = [];
                    for (let index = 0; index < count; index++) {
                        let point = points[index];
                        let pointEnd = pointsEnd[index];
                        let pointId = this.pointsIds[index];
                        let pointEndId = this.pointsIds[index] + "_e";
                        let pointNext = null;
                        let pointNextEnd = null;
                        if (index != (count - 1)) {
                            pointNext = points[index + 1];
                            pointNextEnd = pointsEnd[index + 1];
                        }
                        let pointCross = null;
                        if (pointNext != null || this.intersection(point, pointEnd, pointNext, pointNextEnd))
                            pointCross = this.getPointCross2(point, pointEnd, pointNext, pointNextEnd);
                        pointsLine.push(point);
                        pointsLineEnd.push(pointEnd);
                        pointsLineIds.push(pointId);
                        pointsLineEndIds.push(pointEndId);
                        if (pointCross != null) {
                            pointsLine.push(pointCross);
                            pointsLineEnd.push(pointCross);
                            pointsLineIds.push(pointId + "_c");
                            pointsLineEndIds.push(pointId + "_c_e");
                            this.fillPath(context, this.getBrush(areaSeries, point, pointEnd), pointsLine.map(p => p), pointsLineEnd.map(p => p), pointsLineIds.map(p => p), pointsLineEndIds.map(p => p));
                            pointsLine.stimulsoft().clear();
                            pointsLineEnd.stimulsoft().clear();
                            pointsLineIds.stimulsoft().clear();
                            pointsLineEndIds.stimulsoft().clear();
                            pointsLine.push(pointCross);
                            pointsLineEnd.push(pointCross);
                            pointsLineIds.push(pointId + "_c");
                            pointsLineEndIds.push(pointId + "_c_e");
                        }
                        else if (pointNext == null) {
                            this.fillPath(context, this.getBrush(areaSeries, point, pointEnd), pointsLine.map(p => p), pointsLineEnd.map(p => p), pointsLineIds.map(p => p), pointsLineEndIds.map(p => p));
                        }
                    }
                }
                isPointsEqual(pointsLine, pointsLineEnd) {
                    if (pointsLine.length == pointsLineEnd.length) {
                        for (let index = 0; index < pointsLine.length; index++) {
                            if (!pointsLine[index].equals(pointsLineEnd[index]))
                                return false;
                        }
                        return true;
                    }
                    return false;
                }
                getBrush(areaSeries, point, pointEnd) {
                    let brush = areaSeries.brush;
                    if (areaSeries.allowApplyBrushNegative) {
                        brush = point.y < pointEnd.y ? areaSeries.brushNegative : areaSeries.brush;
                    }
                    return brush;
                }
                fillPath(context, brush, pointsLine, pointsLineEnd, pointsIds, pointsEndIds) {
                    if (this.isPointsEqual(pointsLine.stimulsoft().toList(), pointsLineEnd.stimulsoft().toList()))
                        return;
                    let path = [];
                    let reversePointsLineEnd = pointsLineEnd.map(p => p).reverse();
                    let lineSegment1 = new StiLineSegmentGeom(reversePointsLineEnd[reversePointsLineEnd.length - 1], pointsLine[0]);
                    let lineSegments = new StiLinesSegmentGeom(pointsLine);
                    let lineSegment2 = new StiLineSegmentGeom(pointsLine[pointsLine.length - 1], reversePointsLineEnd[0]);
                    let lineEndSegments = new StiLinesSegmentGeom(reversePointsLineEnd);
                    path.push(lineSegment1);
                    path.push(lineSegments);
                    path.push(lineSegment2);
                    path.push(lineEndSegments);
                    if (this.series.chart.isAnimation) {
                        let animation = null;
                        if (this.series.chart.isAnimationChangingValues) {
                            let pointsAnimation = new StiPointsAnimation(pointsLine, pointsLine, pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_a`;
                            let pointsAnimationEnd = new StiPointsAnimation(pointsLineEnd, pointsLineEnd, pointsEndIds, pointsAnimation.duration, pointsAnimation.beginTime);
                            pointsAnimationEnd.id = `series_${this.series.chart.series.indexOf(this.series)}_a_e`;
                            context.animations.push(pointsAnimation);
                            context.animations.push(pointsAnimationEnd);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, pointsIds, pointsAnimation.id)) {
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.reverse();
                                lineSegment1.animation = new StiPointsAnimation([pointsAnimationEnd.pointsFrom[pointsAnimationEnd.pointsFrom.length - 1], pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], pointsAnimationEnd.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegments.animation = pointsAnimation;
                                lineEndSegments.animation = pointsAnimationEnd;
                            }
                            else {
                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            }
                        }
                        context.fillDrawAnimationPath(brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                    }
                    else
                        context.fillPath(brush, path, StiPathGeom.getBoundsState, null);
                    if (this.isMouseOver || this.series.core.isMouseOver) {
                        context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                    }
                }
                intersection(point, pointEnd, pointNext, pointNextEnd) {
                    if (pointNext == null)
                        return false;
                    if (point.y > pointEnd.y && pointNext.y < pointNextEnd.y ||
                        point.y < pointEnd.y && pointNext.y > pointNextEnd.y ||
                        pointNext.y == pointNextEnd.y)
                        return true;
                    else
                        return false;
                }
                getPointCross2(point, pointEnd, pointNext, pointNextEnd) {
                    if (pointNext == pointNextEnd)
                        return pointNext;
                    let x1 = point.x;
                    let y1 = point.y;
                    let x2 = pointNext.x;
                    let y2 = pointNext.y;
                    let x3 = pointEnd.x;
                    let y3 = pointEnd.y;
                    let x4 = pointNextEnd.x;
                    let y4 = pointNextEnd.y;
                    let x = -((x1 * y2 - x2 * y1) * (x4 - x3) - (x3 * y4 - x4 * y3) * (x2 - x1)) / ((y1 - y2) * (x4 - x3) - (y3 - y4) * (x2 - x1));
                    let y = ((y3 - y4) * (-x) - (x3 * y4 - x4 * y3)) / (x4 - x3);
                    if (x > x1 && x < x2) {
                        return new PointD(x, y);
                    }
                    else {
                        return null;
                    }
                }
            }
            Chart.StiRangeSeriesGeom = StiRangeSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            class StiSplineRangeSeriesGeom extends Chart.StiSplineSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                    this.pointsEnd = pointsInfo.pointsEnd;
                }
                draw(context) {
                    let list = Chart.StiNullableDrawing.getPointsList(this.points);
                    let listEnd = Chart.StiNullableDrawing.getPointsList(this.pointsEnd);
                    if (list.length < 1 || listEnd.length < 1)
                        return;
                    let points = list[0];
                    let pointsEnd = listEnd[0];
                    let pointsEndIds = this.pointsIds.map(id => id + "_e");
                    this.fillPath(context, points, pointsEnd, this.pointsIds, pointsEndIds);
                }
                fillPath(context, points, pointsEnd, pointsIds, pointsEndIds) {
                    let areaSeries = this.series;
                    let brush = areaSeries.brush;
                    let path = [];
                    let reversePointsEnd = pointsEnd.map(p => p).reverse();
                    let lineSegment1 = new StiLineSegmentGeom(reversePointsEnd[reversePointsEnd.length - 1], points[0]);
                    let lineSegments = new StiCurveSegmentGeom(points, areaSeries.tension);
                    let lineSegment2 = new StiLineSegmentGeom(points[points.length - 1], reversePointsEnd[0]);
                    let lineEndSegments = new StiCurveSegmentGeom(reversePointsEnd, areaSeries.tension);
                    path.push(lineSegment1);
                    path.push(lineSegments);
                    path.push(lineSegment2);
                    path.push(lineEndSegments);
                    if (this.series.chart.isAnimation) {
                        let animation = null;
                        if (this.series.chart.isAnimationChangingValues) {
                            let pointsAnimation = new StiPointsAnimation(points, points, pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_a`;
                            let pointsAnimationEnd = new StiPointsAnimation(pointsEnd, pointsEnd, pointsEndIds, pointsAnimation.duration, pointsAnimation.beginTime);
                            pointsAnimationEnd.id = `series_${this.series.chart.series.indexOf(this.series)}_a_e`;
                            context.animations.push(pointsAnimation);
                            context.animations.push(pointsAnimationEnd);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, pointsIds, pointsAnimation.id)) {
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.reverse();
                                lineSegment1.animation = new StiPointsAnimation([pointsAnimationEnd.pointsFrom[pointsAnimationEnd.pointsFrom.length - 1], pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], pointsAnimationEnd.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegments.animation = pointsAnimation;
                                lineEndSegments.animation = pointsAnimationEnd;
                            }
                            else {
                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            }
                        }
                        context.fillDrawAnimationPath(brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                    }
                    else
                        context.fillPath(brush, path, StiPathGeom.getBoundsState, null);
                    if (this.isMouseOver || this.series.core.isMouseOver) {
                        context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                    }
                }
            }
            Chart.StiSplineRangeSeriesGeom = StiSplineRangeSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            class StiSteppedRangeSeriesGeom extends Chart.StiSteppedLineSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                    this.pointsEnd = pointsInfo.pointsEnd;
                }
                get pointsEnd() {
                    return this._pointsEnd;
                }
                set pointsEnd(value) {
                    this._pointsEnd = value;
                }
                draw(context) {
                    let areaSeries = this.series;
                    let list = Chart.StiNullableDrawing.getPointsList(this.getSteppedPoints(this.points));
                    let listEnd = Chart.StiNullableDrawing.getPointsList(this.getSteppedPoints(this.pointsEnd));
                    let newPointsIds = this.getSteppedPointsIds(this.pointsIds);
                    if (list.length < 1 || listEnd.length < 1)
                        return;
                    let points = list[0];
                    let pointsEnd = listEnd[0];
                    let count = Math.min(points.length, pointsEnd.length);
                    let pointsLineIds = [];
                    let pointsLineEndIds = [];
                    let pointsLine = [];
                    let pointsLineEnd = [];
                    for (let index = 0; index < count; index++) {
                        let point = points[index];
                        let pointEnd = pointsEnd[index];
                        let pointId = newPointsIds[index];
                        let pointEndId = newPointsIds[index] + "_e";
                        let pointNext = null;
                        let pointNextEnd = null;
                        if (index != (count - 1)) {
                            pointNext = points[index + 1];
                            pointNextEnd = pointsEnd[index + 1];
                        }
                        pointsLine.push(point);
                        pointsLineEnd.push(pointEnd);
                        pointsLineIds.push(pointId);
                        pointsLineEndIds.push(pointEndId);
                        if (this.intersection(point, pointEnd, pointNext, pointNextEnd)) {
                            pointsLine.push(pointNext);
                            pointsLineEnd.push(pointNextEnd);
                            pointsLineIds.push(pointId + "_c");
                            pointsLineEndIds.push(pointId + "_c_e");
                            this.fillPath(context, this.getBrush(areaSeries, point, pointEnd), pointsLine.map(p => p), pointsLineEnd.map(p => p), pointsLineIds.map(p => p), pointsLineEndIds.map(p => p));
                            pointsLine.stimulsoft().clear();
                            pointsLineEnd.stimulsoft().clear();
                            pointsLineIds.stimulsoft().clear();
                            pointsLineEndIds.stimulsoft().clear();
                            pointsLine.push(pointNext);
                            pointsLineEnd.push(pointNextEnd);
                            pointsLineIds.push(pointId + "_c");
                            pointsLineEndIds.push(pointId + "_c_e");
                        }
                        else if (pointNext == null) {
                            this.fillPath(context, this.getBrush(areaSeries, point, pointEnd), pointsLine.map(p => p), pointsLineEnd.map(p => p), pointsLineIds.map(p => p), pointsLineEndIds.map(p => p));
                        }
                    }
                }
                getBrush(areaSeries, point, pointEnd) {
                    let brush = areaSeries.brush;
                    if (areaSeries.allowApplyBrushNegative) {
                        brush = point.y < pointEnd.y ? areaSeries.brushNegative : areaSeries.brush;
                    }
                    return brush;
                }
                fillPath(context, brush, pointsLine, pointsLineEnd, pointsIds, pointsEndIds) {
                    let path = [];
                    let reversePointsLineEnd = pointsLineEnd.map(p => p).reverse();
                    let lineSegment1 = new StiLineSegmentGeom(reversePointsLineEnd[reversePointsLineEnd.length - 1], pointsLine[0]);
                    let lineSegments = new StiLinesSegmentGeom(pointsLine);
                    let lineSegment2 = new StiLineSegmentGeom(pointsLine[pointsLine.length - 1], reversePointsLineEnd[0]);
                    let lineEndSegments = new StiLinesSegmentGeom(reversePointsLineEnd);
                    path.push(lineSegment1);
                    path.push(lineSegments);
                    path.push(lineSegment2);
                    path.push(lineEndSegments);
                    if (this.series.chart.isAnimation) {
                        let animation = null;
                        if (this.series.chart.isAnimationChangingValues) {
                            let pointsAnimation = new StiPointsAnimation(pointsLine, pointsLine, pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_a`;
                            let pointsAnimationEnd = new StiPointsAnimation(pointsLineEnd, pointsLineEnd, pointsEndIds, pointsAnimation.duration, pointsAnimation.beginTime);
                            pointsAnimationEnd.id = `series_${this.series.chart.series.indexOf(this.series)}_a_e`;
                            context.animations.push(pointsAnimation);
                            context.animations.push(pointsAnimationEnd);
                            if (StiPointsAnimation.isAnimationChangingValues(this.series, pointsIds, pointsAnimation.id)) {
                                pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.applyPreviousAnimation(this.series.chart.previousAnimations);
                                pointsAnimationEnd.reverse();
                                lineSegment1.animation = new StiPointsAnimation([pointsAnimationEnd.pointsFrom[pointsAnimationEnd.pointsFrom.length - 1], pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], pointsAnimationEnd.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                lineSegments.animation = pointsAnimation;
                                lineEndSegments.animation = pointsAnimationEnd;
                            }
                            else {
                                animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                            }
                        }
                        context.fillDrawAnimationPath(brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                    }
                    else
                        context.fillPath(brush, path, StiPathGeom.getBoundsState, null);
                    if (this.isMouseOver || this.series.core.isMouseOver) {
                        context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                    }
                }
                intersection(point, pointEnd, pointNext, pointNextEnd) {
                    if (pointNext == null)
                        return false;
                    if (point.y > pointEnd.y && pointNext.y < pointNextEnd.y ||
                        point.y < pointEnd.y && pointNext.y > pointNextEnd.y ||
                        pointNext.y == pointNextEnd.y)
                        return true;
                    else
                        return false;
                }
            }
            Chart.StiSteppedRangeSeriesGeom = StiSteppedRangeSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiScatterSplineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isLineContainsPoint(point1, point2, Chart.StiMouseOverHelper.mouseOverLineDistance, new PointD(x, y));
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let splineSeries = this.series;
                    context.pushSmoothingModeToAntiAlias();
                    let dashStyle = splineSeries.lineStyle;
                    let scaledLineWidth = splineSeries.lineWidth * context.options.zoom;
                    let animation = this.getAnimation();
                    let pen = new StiPenGeom(splineSeries.lineColor, splineSeries.lineWidth);
                    pen.penStyle = dashStyle;
                    if (splineSeries.showShadow) {
                        let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                        penShadow.penStyle = dashStyle;
                        context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                        Chart.StiNullableDrawing.drawCurve(context, penShadow, this.points, splineSeries.tension, animation);
                        context.popTransform();
                    }
                    if (this.series.core.isMouseOver) {
                        let lineWidth = splineSeries.lineWidth;
                        let zoom = context.options.zoom;
                        let pointSize = 11 + lineWidth;
                        for (let point of this.points) {
                            if (point == null)
                                continue;
                            let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                            context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                        }
                        let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                        penMouseOver.startCap = StiPenLineCap.Round;
                        penMouseOver.endCap = StiPenLineCap.Round;
                        Chart.StiNullableDrawing.drawCurve(context, penMouseOver, this.points, splineSeries.tension, animation);
                    }
                    Chart.StiNullableDrawing.drawCurve(context, pen, this.points, splineSeries.tension, animation);
                    if (scaledLineWidth >= 2 && splineSeries.lighting) {
                        let step = 0.5 * context.options.zoom;
                        context.pushTranslateTransform(-step, -step);
                        let penLight = new StiPenGeom(StiColorUtils.light(splineSeries.lineColor, 70), 1);
                        penLight.penStyle = dashStyle;
                        Chart.StiNullableDrawing.drawCurve(context, penLight, this.points, splineSeries.tension, animation);
                        context.popTransform();
                    }
                    context.popSmoothingMode();
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiScatterSplineSeriesGeom = StiScatterSplineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            class StiStackedBarSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, seriesBorderColor, series, clientRectangle, columnRectStart) {
                    super(areaGeom, value, index, series, clientRectangle, seriesBrush);
                    this.seriesBorderColor = seriesBorderColor;
                    this.columnRectStart = columnRectStart;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.seriesBorderColor, 1);
                    let chart = this.series.chart;
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        let roundValuesArea = chart.area.as(Chart.IStiRoundValuesArea);
                        let roundValues = roundValuesArea === null || roundValuesArea === void 0 ? void 0 : roundValuesArea.roundValues;
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, rect, new Size(rect.height, rect.height), fontIconsSeries.icon, this.getToolTip(), false, roundValues);
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        if (this.series.showShadow) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(this.clientRectangle, 5, animationOpacity);
                        }
                        context.drawAnimationBar(this.seriesBrush, pen, rect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        this.series.chart.style.core.fillColumn(context, rect, this.seriesBrush, this.getInteractionData());
                        let points = null;
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        }
                        if (this.value > 0) {
                            points = [
                                new PointD(rect.right, rect.y),
                                new PointD(rect.x, rect.y),
                                new PointD(rect.x, rect.bottom),
                                new PointD(rect.right, rect.bottom)
                            ];
                        }
                        else {
                            points = [
                                new PointD(rect.x, rect.y),
                                new PointD(rect.right, rect.y),
                                new PointD(rect.right, rect.bottom),
                                new PointD(rect.x, rect.bottom)
                            ];
                        }
                        context.drawLines(pen, points);
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let axisArea = this.areaGeom.area;
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                    let columnAnimation = new StiColumnAnimation(this.columnRectStart, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let getStartFromZero = axisArea.yAxis.core.getStartFromZero();
                    let argId = getStartFromZero ?
                        axisArea.yAxis.info.stripLines.getByIndex(this.index + 1).valueObject :
                        axisArea.yAxis.info.stripLines.getByIndex(this.index).valueObject;
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiStackedBarSeriesElementGeom = StiStackedBarSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            class StiStackedBarSeriesShadowElementGeom extends Chart.StiCellGeom {
                constructor(series, clientRectangle, isLeftShadow, isRightShadow) {
                    super(clientRectangle);
                    this._series = series;
                    this._isLeftShadow = isLeftShadow;
                    this._isRightShadow = isRightShadow;
                }
                get invisible() {
                    return true;
                }
                get series() {
                    return this._series;
                }
                get isLeftShadow() {
                    return this._isLeftShadow;
                }
                get isRightShadow() {
                    return this._isRightShadow;
                }
                draw(context) {
                    let shadowRect = this.clientRectangle.clone();
                    if (this.series.is(Chart.IStiFullStackedBarSeries)) {
                        context.drawCachedShadow(shadowRect, StiShadowSides.Bottom, context.options.isPrinting);
                    }
                    else {
                        if (this.isLeftShadow) {
                            context.drawCachedShadow(shadowRect, StiShadowSides.Bottom |
                                StiShadowSides.Left, context.options.isPrinting);
                        }
                        if (this.isRightShadow) {
                            context.drawCachedShadow(shadowRect, StiShadowSides.Top |
                                StiShadowSides.Right |
                                StiShadowSides.Edge |
                                StiShadowSides.Bottom, context.options.isPrinting);
                        }
                    }
                }
            }
            Chart.StiStackedBarSeriesShadowElementGeom = StiStackedBarSeriesShadowElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLinesSegmentGeom = Stimulsoft.Base.Context.StiLinesSegmentGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            class StiStackedAreaSeriesGeom extends Chart.StiSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, series, StiStackedAreaSeriesGeom.getClientRectangle(pointsInfo.pointsStart, pointsInfo.pointsEnd));
                    this.startPoints = pointsInfo.pointsStart;
                    this.endPoints = pointsInfo.pointsEnd;
                    this.pointsIds = pointsInfo.pointsIds;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                get allowMouseOver() {
                    return (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeries);
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.isMouseOver;
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.isMouseOver = value;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.startPoints.length - 1); pointIndex++) {
                        let point1 = this.startPoints[pointIndex];
                        let point4 = this.startPoints[pointIndex + 1];
                        let point2 = this.endPoints[pointIndex];
                        let point3 = this.endPoints[pointIndex + 1];
                        if (point1 == null || point2 == null || point3 == null || point4 == null)
                            continue;
                        let result = Chart.StiPointHelper.isPointInPolygon(new PointD(x, y), [point1, point4, point3, point2]);
                        if (result)
                            return true;
                    }
                    return false;
                }
                static getClientRectangle(startPoints, endPoints) {
                    if (startPoints == null || startPoints.length == 0 || endPoints == null || endPoints.length == 0)
                        return RectangleD.empty;
                    let minPoint = PointD.empty;
                    let maxPoint = PointD.empty;
                    for (let point of startPoints) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    for (let point of endPoints) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    return new RectangleD(minPoint.x, minPoint.y, maxPoint.x - minPoint.x, maxPoint.y - minPoint.y);
                }
                draw(context) {
                    let areaSeries = this.series;
                    let isAnimation = areaSeries.chart.isAnimation;
                    let startList;
                    let endList;
                    let REFstartList = { ref: startList };
                    let REFendList = { ref: endList };
                    Chart.StiNullableDrawing.getPointsList2(this.startPoints, this.endPoints, REFstartList, REFendList);
                    startList = REFstartList.ref;
                    endList = REFendList.ref;
                    let listIndex = 0;
                    for (let newStartPoints of startList) {
                        let newEndPoints = endList[listIndex];
                        let reverseStartPoint = newStartPoints.map(p => p).reverse();
                        let path = [];
                        let lineSegment1 = new StiLineSegmentGeom(newStartPoints[0], newEndPoints[0]);
                        let lineSegments = new StiLinesSegmentGeom(newEndPoints);
                        let lineSegment2 = new StiLineSegmentGeom(newEndPoints[newEndPoints.length - 1], newStartPoints[newStartPoints.length - 1]);
                        let reverseLineSegment = new StiLinesSegmentGeom(reverseStartPoint);
                        path.push(lineSegment1);
                        path.push(lineSegments);
                        path.push(lineSegment2);
                        path.push(reverseLineSegment);
                        let animation = null;
                        if (isAnimation) {
                            if (areaSeries.chart.isAnimationChangingValues) {
                                let pointsAnimation = new StiPointsAnimation(newEndPoints, newEndPoints, this.pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_a`;
                                let pointsAnimationReverse = new StiPointsAnimation(newStartPoints, newStartPoints, this.pointsIds, pointsAnimation.duration, pointsAnimation.beginTime);
                                pointsAnimationReverse.id = `series_${this.series.chart.series.indexOf(this.series)}_a_r`;
                                context.animations.push(pointsAnimation);
                                context.animations.push(pointsAnimationReverse);
                                if (StiPointsAnimation.isAnimationChangingValues(this.series, this.pointsIds, pointsAnimation.id)) {
                                    pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                    pointsAnimationReverse.applyPreviousAnimation(this.series.chart.previousAnimations);
                                    pointsAnimationReverse.reverse();
                                    lineSegment1.animation = new StiPointsAnimation([pointsAnimationReverse.pointsFrom[pointsAnimationReverse.pointsFrom.length - 1], pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                    lineSegments.animation = pointsAnimation;
                                    lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], pointsAnimationReverse.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                    lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                    lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                    reverseLineSegment.animation = pointsAnimationReverse;
                                }
                                else {
                                    animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                }
                            }
                        }
                        if (areaSeries.brush != null) {
                            if (isAnimation) {
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            else {
                                context.fillPath(areaSeries.brush, path, StiPathGeom.getBoundsState, null);
                            }
                        }
                        if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                            let axisArea = this.series.chart.area;
                            let posY = axisArea.axisCore.getDividerY();
                            let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                            let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                            let clipRect = new RectangleD(0, posY, width, height);
                            context.pushClip(clipRect);
                            if (isAnimation) {
                                context.fillDrawAnimationPath(areaSeries.brushNegative, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            else {
                                context.fillPath(areaSeries.brushNegative, path, StiPathGeom.getBoundsState, null);
                            }
                            context.popClip();
                        }
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                        }
                        listIndex++;
                    }
                }
            }
            Chart.StiStackedAreaSeriesGeom = StiStackedAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiStackedBaseLineSeriesGeom extends Chart.StiSeriesGeom {
                constructor(areaGeom, points, series) {
                    super(areaGeom, series, StiStackedBaseLineSeriesGeom.getClientRectangle(points));
                    this._points = points;
                }
                get points() {
                    return this._points;
                }
                static getClientRectangle(points) {
                    if (points == null || points.length == 0)
                        return RectangleD.empty;
                    let minPoint = PointD.empty;
                    let maxPoint = PointD.empty;
                    for (let point of points) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    return new RectangleD(minPoint.x, minPoint.y, maxPoint.x - minPoint.x, maxPoint.y - minPoint.y);
                }
                draw(context) {
                }
            }
            Chart.StiStackedBaseLineSeriesGeom = StiStackedBaseLineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiColumnAnimation = Stimulsoft.Base.Context.Animation.StiColumnAnimation;
            class StiStackedColumnSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, seriesBorderColor, series, clientRectangle, columnRectStart) {
                    super(areaGeom, value, index, series, clientRectangle, seriesBrush);
                    this.seriesBorderColor = seriesBorderColor;
                    this.columnRectStart = columnRectStart;
                }
                draw(context) {
                    let columnRect = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.seriesBorderColor, 1);
                    let chart = this.series.chart;
                    let fontIconsSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconsSeries != null && fontIconsSeries.icon != null) {
                        let roundValuesArea = chart.area.as(Chart.IStiRoundValuesArea);
                        let roundValues = roundValuesArea === null || roundValuesArea === void 0 ? void 0 : roundValuesArea.roundValues;
                        Report.StiFontIconsHelper.drawDirectionIcons(context, this.seriesBrush, columnRect, new Size(columnRect.width, columnRect.width), fontIconsSeries.icon, this.getToolTip(), true, roundValues);
                        return;
                    }
                    let animation = this.getAnimation();
                    if (animation != null) {
                        if (this.series.showShadow) {
                            let axisArea = this.areaGeom.area;
                            let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                            let animationOpacity = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, new TimeSpan(beginTime.ticks + Chart.StiChartHelper.globalDurationElement.ticks));
                            context.drawShadowRect(columnRect, 5, animationOpacity);
                        }
                        context.drawAnimationColumn(this.seriesBrush, pen, columnRect, this.value, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        this.series.chart.style.core.fillColumn(context, columnRect, this.seriesBrush, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), columnRect.x, columnRect.y, columnRect.width, columnRect.height, null);
                        }
                        let points = null;
                        if (this.value > 0) {
                            points = [
                                new PointD(columnRect.x, columnRect.bottom),
                                new PointD(columnRect.x, columnRect.y),
                                new PointD(columnRect.right, columnRect.y),
                                new PointD(columnRect.right, columnRect.bottom)
                            ];
                        }
                        else {
                            points = [
                                new PointD(columnRect.x, columnRect.y),
                                new PointD(columnRect.x, columnRect.bottom),
                                new PointD(columnRect.right, columnRect.bottom),
                                new PointD(columnRect.right, columnRect.y)
                            ];
                        }
                        context.drawLines(pen, points);
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let axisArea = this.areaGeom.area;
                    let beginTime = new TimeSpan(Chart.StiChartHelper.globalBeginTimeElement.ticks / axisArea.core.valuesCount * this.index);
                    let columnAnimation = new StiColumnAnimation(this.columnRectStart, this.clientRectangle, Chart.StiChartHelper.globalDurationElement, beginTime);
                    let getStartFromZero = axisArea.xAxis.core.getStartFromZero();
                    let argId = getStartFromZero ?
                        axisArea.xAxis.info.stripLines.getByIndex(this.index + 1).valueObject :
                        axisArea.xAxis.info.stripLines.getByIndex(this.index).valueObject;
                    argId = argId == null ? "" : argId.stimulsoft().toString();
                    columnAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${argId}`;
                    if (StiColumnAnimation.isAnimationChangingValues(this.series, columnAnimation.id)) {
                        columnAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                    }
                    return columnAnimation;
                }
            }
            Chart.StiStackedColumnSeriesElementGeom = StiStackedColumnSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiShadowSides = Stimulsoft.Base.Drawing.StiShadowSides;
            class StiStackedColumnSeriesShadowElementGeom extends Chart.StiCellGeom {
                constructor(series, clientRectangle, isTopShadow, isBottomShadow) {
                    super(clientRectangle);
                    this._series = series;
                    this._isTopShadow = isTopShadow;
                    this._isBottomShadow = isBottomShadow;
                }
                get invisible() {
                    return true;
                }
                get series() {
                    return this._series;
                }
                get isTopShadow() {
                    return this._isTopShadow;
                }
                get isBottomShadow() {
                    return this._isBottomShadow;
                }
                draw(context) {
                    let shadowRect = this.clientRectangle.clone();
                    if (this.series.is(Chart.IStiFullStackedColumnSeries)) {
                        context.drawCachedShadow(shadowRect, StiShadowSides.Right, context.options.isPrinting);
                    }
                    else {
                        if (this.isTopShadow) {
                            context.drawCachedShadow(shadowRect, StiShadowSides.Top |
                                StiShadowSides.Right, context.options.isPrinting);
                        }
                        if (this.isBottomShadow) {
                            context.drawCachedShadow(shadowRect, StiShadowSides.Right |
                                StiShadowSides.Edge |
                                StiShadowSides.Bottom |
                                StiShadowSides.Left, context.options.isPrinting);
                        }
                    }
                }
            }
            Chart.StiStackedColumnSeriesShadowElementGeom = StiStackedColumnSeriesShadowElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiStackedLineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isLineContainsPoint(point1, point2, Chart.StiMouseOverHelper.mouseOverLineDistance, new PointD(x, y));
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    let lineSeries = this.series;
                    if (this.points.length == 0)
                        return;
                    if (this.points.length > 1) {
                        let animation = this.getAnimation();
                        context.pushSmoothingModeToAntiAlias();
                        let dashStyle = lineSeries.lineStyle;
                        let scaledLineWidth = lineSeries.lineWidth * context.options.zoom;
                        let pen = new StiPenGeom(lineSeries.lineColor, scaledLineWidth);
                        pen.penStyle = dashStyle;
                        let lighting = lineSeries.lighting;
                        if (lineSeries.showShadow) {
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                            penShadow.penStyle = dashStyle;
                            context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                            Chart.StiNullableDrawing.drawLines(context, penShadow, this.points, animation);
                            context.popTransform();
                        }
                        if (this.series.core.isMouseOver) {
                            let lineWidth = lineSeries.lineWidth;
                            let zoom = context.options.zoom;
                            let pointSize = 11 + lineWidth;
                            for (let point of this.points) {
                                if (point == null)
                                    continue;
                                let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                                context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                            }
                            let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                            penMouseOver.startCap = StiPenLineCap.Round,
                                penMouseOver.endCap = StiPenLineCap.Round;
                            Chart.StiNullableDrawing.drawLines(context, penMouseOver, this.points, animation);
                        }
                        let coreLineColor = this.series.lineColor;
                        if ((this.series).allowApplyColorNegative) {
                            let coreLineColorNegative = this.series.lineColorNegative;
                            let penNegative = new StiPenGeom(coreLineColorNegative, scaledLineWidth);
                            penNegative.penStyle = dashStyle;
                            let axisArea = this.series.chart.area;
                            let posY = axisArea.axisCore.getDividerY();
                            let pointsNegative = [];
                            let pointsPositive = [];
                            for (let index = 0; index < this.points.length; index++) {
                                let point = this.points[index];
                                let pointNext = (index != (this.points.length - 1)) ? this.points[index + 1] : null;
                                if (point.y > posY) {
                                    pointsNegative.push(point);
                                    if (pointNext == null ||
                                        pointNext.y < posY ||
                                        pointNext.y == posY && ((index + 2) < this.points.length) && ((this.points[index + 2].y) <= posY)) {
                                        if (pointNext != null) {
                                            let point0 = this.getPointCross(point, this.points[index + 1], posY);
                                            pointsNegative.push(point0);
                                            if (pointNext.y == posY && ((index + 2) < this.points.length) && ((this.points[index + 2].y) <= posY)) {
                                                pointsNegative.push(this.points[index + 2]);
                                            }
                                            pointsPositive.push(point0);
                                        }
                                        Chart.StiNullableDrawing.drawLines(context, penNegative, pointsNegative, animation);
                                        if (scaledLineWidth >= 2 * context.options.zoom && lighting) {
                                            let step = 0.5 * context.options.zoom;
                                            context.pushTranslateTransform(-step, -step);
                                            let penLight = new StiPenGeom(StiColorUtils.light(coreLineColorNegative, 70), scaledLineWidth);
                                            penLight.penStyle = dashStyle;
                                            Chart.StiNullableDrawing.drawLines(context, penLight, pointsNegative, animation);
                                            context.popTransform();
                                        }
                                        pointsNegative.stimulsoft().clear();
                                    }
                                }
                                else {
                                    pointsPositive.push(point);
                                    if (pointNext == null || pointNext.y > posY) {
                                        if (pointNext != null) {
                                            let point0 = this.getPointCross(point, this.points[index + 1], posY);
                                            pointsNegative.push(point0);
                                            pointsPositive.push(point0);
                                            pointsPositive.push(pointNext);
                                        }
                                        Chart.StiNullableDrawing.drawLines(context, pen, pointsPositive, animation);
                                        if (scaledLineWidth >= 2 * context.options.zoom && lighting) {
                                            let step = 0.5 * context.options.zoom;
                                            context.pushTranslateTransform(-step, -step);
                                            let penLight = new StiPenGeom(StiColorUtils.light(coreLineColor, 70), scaledLineWidth);
                                            penLight.penStyle = dashStyle;
                                            Chart.StiNullableDrawing.drawLines(context, penLight, pointsPositive, animation);
                                            context.popTransform();
                                        }
                                        pointsPositive.stimulsoft().clear();
                                    }
                                }
                            }
                        }
                        else {
                            Chart.StiNullableDrawing.drawLines(context, pen, this.points, animation);
                            if (scaledLineWidth >= 2 * context.options.zoom && lineSeries.lighting) {
                                let step = 0.5 * context.options.zoom;
                                context.pushTranslateTransform(-step, -step);
                                let penLight = new StiPenGeom(StiColorUtils.light(coreLineColor, 70), scaledLineWidth);
                                penLight.penStyle = dashStyle;
                                Chart.StiNullableDrawing.drawLines(context, penLight, this.points, animation);
                                context.popTransform();
                            }
                        }
                        context.popSmoothingMode();
                    }
                }
                getPointCross(point1, point2, posY) {
                    let y1 = point1.y;
                    let x1 = point1.x;
                    let y2 = point2.y;
                    let x2 = point2.x;
                    let x0 = (Math.tan(Math.atan((x2 - x1) / (y1 - y2)))) * (y1 - posY) + x1;
                    return new PointD(x0, posY);
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiStackedLineSeriesGeom = StiStackedLineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiLineSegmentGeom = Stimulsoft.Base.Context.StiLineSegmentGeom;
            var StiCurveSegmentGeom = Stimulsoft.Base.Context.StiCurveSegmentGeom;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPointsAnimation = Stimulsoft.Base.Context.Animation.StiPointsAnimation;
            class StiStackedSplineAreaSeriesGeom extends Chart.StiSeriesGeom {
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, series, StiStackedSplineAreaSeriesGeom.getClientRectangle(pointsInfo.pointsStart, pointsInfo.pointsEnd));
                    this.startPoints = pointsInfo.pointsStart;
                    this.endPoints = pointsInfo.pointsEnd;
                    this.pointsIds = pointsInfo.pointsIds;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                get allowMouseOver() {
                    return (this.series.interaction.drillDownEnabled && this.series.interaction.allowSeries);
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.isMouseOver;
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.isMouseOver = value;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.startPoints.length - 1); pointIndex++) {
                        let point1 = this.startPoints[pointIndex];
                        let point4 = this.startPoints[pointIndex + 1];
                        let point2 = this.endPoints[pointIndex];
                        let point3 = this.endPoints[pointIndex + 1];
                        if (point1 == null || point2 == null || point3 == null || point4 == null)
                            continue;
                        let result = Chart.StiPointHelper.isPointInPolygon(new PointD(x, y), [point1, point4, point3, point2]);
                        if (result)
                            return true;
                    }
                    return false;
                }
                static getClientRectangle(startPoints, endPoints) {
                    if (startPoints == null || startPoints.length == 0 || endPoints == null || endPoints.length == 0)
                        return RectangleD.empty;
                    let minPoint = PointD.empty;
                    let maxPoint = PointD.empty;
                    for (let point of startPoints) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    for (let point of endPoints) {
                        if (point == null)
                            continue;
                        if (minPoint == PointD.empty) {
                            minPoint = point;
                            maxPoint = point;
                        }
                        else {
                            minPoint.x = Math.min(minPoint.x, point.x);
                            minPoint.y = Math.min(minPoint.y, point.y);
                            maxPoint.x = Math.max(maxPoint.x, point.x);
                            maxPoint.y = Math.max(maxPoint.y, point.y);
                        }
                    }
                    return new RectangleD(minPoint.x, minPoint.y, maxPoint.x - minPoint.x, maxPoint.y - minPoint.y);
                }
                draw(context) {
                    let areaSeries = this.series;
                    let axisArea = this.series.chart.area;
                    let startList;
                    let endList;
                    let REFstartList = { ref: startList };
                    let REFendList = { ref: endList };
                    Chart.StiNullableDrawing.getPointsList2(this.startPoints, this.endPoints, REFstartList, REFendList);
                    startList = REFstartList.ref;
                    endList = REFendList.ref;
                    let chart = this.series.chart;
                    let listIndex = 0;
                    for (let newStartPoints of startList) {
                        let newEndPoints = endList[listIndex];
                        let reverseStartPoint = newStartPoints.map(p => p).reverse();
                        let path = [];
                        let lineSegment1 = new StiLineSegmentGeom(newStartPoints[0], newEndPoints[0]);
                        let lineSegments = new StiCurveSegmentGeom(newEndPoints, areaSeries.tension);
                        let lineSegment2 = new StiLineSegmentGeom(newEndPoints[newEndPoints.length - 1], newStartPoints[newStartPoints.length - 1]);
                        let reverseLineSegment = new StiCurveSegmentGeom(reverseStartPoint, areaSeries.tension);
                        path.push(lineSegment1);
                        path.push(lineSegments);
                        path.push(lineSegment2);
                        path.push(reverseLineSegment);
                        let animation = null;
                        if (this.series.chart.isAnimation) {
                            if (areaSeries.chart.isAnimationChangingValues) {
                                let pointsAnimation = new StiPointsAnimation(newEndPoints, newEndPoints, this.pointsIds, Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                pointsAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_a`;
                                let pointsAnimationReverse = new StiPointsAnimation(newStartPoints, newStartPoints, this.pointsIds, pointsAnimation.duration, pointsAnimation.beginTime);
                                pointsAnimationReverse.id = `series_${this.series.chart.series.indexOf(this.series)}_a_r`;
                                context.animations.push(pointsAnimation);
                                context.animations.push(pointsAnimationReverse);
                                if (StiPointsAnimation.isAnimationChangingValues(this.series, this.pointsIds, pointsAnimation.id)) {
                                    pointsAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                                    pointsAnimationReverse.applyPreviousAnimation(this.series.chart.previousAnimations);
                                    pointsAnimationReverse.reverse();
                                    lineSegment1.animation = new StiPointsAnimation([pointsAnimationReverse.pointsFrom[pointsAnimationReverse.pointsFrom.length - 1], pointsAnimation.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                    lineSegments.animation = pointsAnimation;
                                    lineSegment2.animation = new StiPointsAnimation([pointsAnimation.pointsFrom[pointsAnimation.pointsFrom.length - 1], pointsAnimationReverse.pointsFrom[0]], null, null, pointsAnimation.duration, pointsAnimation.beginTime);
                                    lineSegment1.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                    lineSegment2.animation.beginTimeCorrect = pointsAnimation.beginTimeCorrect;
                                    reverseLineSegment.animation = pointsAnimationReverse;
                                }
                                else {
                                    animation = new StiOpacityAnimation(Chart.StiChartHelper.globalDurationElement, Chart.StiChartHelper.globalBeginTimeElement);
                                }
                            }
                        }
                        if (areaSeries.brush != null) {
                            if (chart.isAnimation) {
                                context.fillDrawAnimationPath(areaSeries.brush, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            else
                                context.fillPath(areaSeries.brush, path, StiPathGeom.getBoundsState, null);
                        }
                        if (areaSeries.allowApplyBrushNegative && areaSeries.brushNegative != null) {
                            let posY = axisArea.axisCore.getDividerY();
                            let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                            let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                            let clipRect = new RectangleD(0, posY, width, height);
                            context.pushClip(clipRect);
                            if (chart.isAnimation) {
                                context.fillDrawAnimationPath(areaSeries.brushNegative, null, path, StiPathGeom.getBoundsState, null, animation, null);
                            }
                            else
                                context.fillPath(areaSeries.brushNegative, path, StiPathGeom.getBoundsState, null);
                            context.popClip();
                        }
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), path, StiPathGeom.getBoundsState, null);
                        }
                        listIndex++;
                    }
                }
            }
            Chart.StiStackedSplineAreaSeriesGeom = StiStackedSplineAreaSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenLineCap = Stimulsoft.Base.Context.StiPenLineCap;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiStackedSplineSeriesGeom extends Chart.StiBaseLineSeriesGeom {
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    for (let pointIndex = 0; pointIndex < (this.points.length - 1); pointIndex++) {
                        let point1 = this.points[pointIndex];
                        let point2 = this.points[pointIndex + 1];
                        if (point1 == null || point2 == null)
                            continue;
                        let result = Chart.StiPointHelper.isLineContainsPoint(point1, point2, Chart.StiMouseOverHelper.mouseOverSplineDistance, new PointD(x, y));
                        if (result)
                            return true;
                    }
                    return false;
                }
                draw(context) {
                    if (this.points.length == 0)
                        return;
                    let lineSeries = this.series;
                    let animation = this.getAnimation();
                    context.pushSmoothingModeToAntiAlias();
                    let dashStyle = lineSeries.lineStyle;
                    let scaledLineWidth = lineSeries.lineWidth * context.options.zoom;
                    let pen = new StiPenGeom(lineSeries.lineColor, scaledLineWidth);
                    pen.penStyle = dashStyle;
                    if (this.points != null && this.points.length > 1) {
                        if (lineSeries.showShadow) {
                            let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                            penShadow.penStyle = dashStyle;
                            context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                            Chart.StiNullableDrawing.drawCurve(context, penShadow, this.points, lineSeries.tension, animation);
                            context.popTransform();
                        }
                        if (this.series.core.isMouseOver) {
                            let lineWidth = lineSeries.lineWidth;
                            let zoom = context.options.zoom;
                            let pointSize = 11 + lineWidth;
                            for (let point of this.points) {
                                if (point == null)
                                    continue;
                                let pointRect = new RectangleD(point.x - pointSize / 2 * zoom, point.y - pointSize / 2 * zoom, pointSize * zoom, pointSize * zoom);
                                context.fillEllipse2(Chart.StiMouseOverHelper.getLineMouseOverColor(), pointRect, null);
                            }
                            let penMouseOver = new StiPenGeom(Chart.StiMouseOverHelper.getLineMouseOverColor(), (4 + lineWidth) * context.options.zoom);
                            penMouseOver.startCap = StiPenLineCap.Round;
                            penMouseOver.endCap = StiPenLineCap.Round;
                            Chart.StiNullableDrawing.drawCurve(context, penMouseOver, this.points, lineSeries.tension, animation);
                        }
                        Chart.StiNullableDrawing.drawCurve(context, pen, this.points, lineSeries.tension, animation);
                        if (scaledLineWidth >= 2 && lineSeries.lighting) {
                            let step = 0.5 * context.options.zoom;
                            context.pushTranslateTransform(-step, -step);
                            let penLight = new StiPenGeom(StiColorUtils.light(lineSeries.lineColor, 70), scaledLineWidth);
                            penLight.penStyle = dashStyle;
                            Chart.StiNullableDrawing.drawCurve(context, penLight, this.points, lineSeries.tension, animation);
                            context.popTransform();
                        }
                        if (lineSeries.allowApplyColorNegative) {
                            let penNegative = new StiPenGeom(lineSeries.lineColorNegative, scaledLineWidth);
                            penNegative.penStyle = dashStyle;
                            let axisArea = this.series.chart.area;
                            let posY = axisArea.axisCore.getDividerY();
                            let width = (axisArea.axisCore.scrollRangeX * axisArea.axisCore.scrollDpiX);
                            let height = (axisArea.axisCore.scrollRangeY * axisArea.axisCore.scrollDpiY - posY);
                            let clipRect = new RectangleD(0, posY, width, height);
                            context.pushClip(clipRect);
                            Chart.StiNullableDrawing.drawCurve(context, penNegative, this.points, lineSeries.tension, animation);
                            if (scaledLineWidth >= 2 && lineSeries.lighting) {
                                let step = 0.5 * context.options.zoom;
                                context.pushTranslateTransform(-step, -step);
                                let penLight = new StiPenGeom(StiColorUtils.light(lineSeries.lineColorNegative, 70), scaledLineWidth);
                                penLight.penStyle = dashStyle;
                                Chart.StiNullableDrawing.drawCurve(context, penLight, this.points, lineSeries.tension, animation);
                                context.popTransform();
                            }
                            context.popClip();
                        }
                    }
                    context.popSmoothingMode();
                }
                constructor(areaGeom, pointsInfo, series) {
                    super(areaGeom, pointsInfo, series);
                }
            }
            Chart.StiStackedSplineSeriesGeom = StiStackedSplineSeriesGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenAlignment = Stimulsoft.Base.Context.StiPenAlignment;
            var StiPathGeom = Stimulsoft.Base.Context.StiPathGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiArcSegmentGeom = Stimulsoft.Base.Context.StiArcSegmentGeom;
            var StiPieSegmentAnimation = Stimulsoft.Base.Context.Animation.StiPieSegmentAnimation;
            class StiSunburstSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index1, index2, index3, series, clientRectangle, clientRectangleDt, path, borderColor, brush, startAngle, endAngle, radiusFrom, radiusTo, beginTime) {
                    super(areaGeom, value, index1, series, clientRectangle, brush);
                    this.index2 = 0;
                    this.index3 = 0;
                    this.index2 = index2;
                    this.index3 = index3;
                    this.clientRectangleDt = clientRectangleDt;
                    this.path = path;
                    this.borderColor = borderColor;
                    this.brush = brush;
                    this.startAngle = startAngle;
                    this.endAngle = endAngle;
                    this.radiusFrom = radiusFrom;
                    this.radiusTo = radiusTo;
                    this.beginTime = beginTime;
                }
                contains(x, y) {
                    if (this.invisible)
                        return false;
                    let center = new PointD(this.clientRectangle.x + this.clientRectangle.width / 2, this.clientRectangle.y + this.clientRectangle.height / 2);
                    let dx = x - center.x;
                    let dy = y - center.y;
                    let radius = Math.sqrt(dx * dx + dy * dy);
                    if (radius < this.radiusTo || radius > this.radiusFrom)
                        return false;
                    let alpha = (Math.atan2(dy, dx) * 180 / Math.PI);
                    if (alpha < 0)
                        alpha += 360;
                    return alpha >= this.startAngle && alpha <= this.endAngle;
                }
                draw(context) {
                    let rectPie = this.clientRectangle.clone();
                    let pen = new StiPenGeom(this.borderColor);
                    pen.alignment = StiPenAlignment.Inset;
                    let animation = this.getAnimation();
                    if (animation != null) {
                        context.drawAnimationPathElement(this.brush, pen, this.path, rectPie, this.getToolTip(), this, animation, this.getInteractionData());
                    }
                    else {
                        context.pushSmoothingModeToAntiAlias();
                        if (this.path != null) {
                            context.fillPath(this.brush, this.path, rectPie, this.getInteractionData());
                            if (this.isMouseOver || this.series.core.isMouseOver)
                                context.fillPath(Chart.StiMouseOverHelper.getMouseOverColor(), this.path, rectPie, null);
                        }
                        context.drawPath(pen, this.path, StiPathGeom.getBoundsState);
                        context.popSmoothingMode();
                    }
                }
                getAnimation() {
                    if (!this.series.chart.isAnimation)
                        return null;
                    let duration = Chart.StiChartHelper.globalDurationElement;
                    let animation = null;
                    let pieAnimation = null;
                    if (this.series.chart.isAnimationChangingValues) {
                        let startAngleTo = this.startAngle;
                        let endAngleTo = this.endAngle;
                        let rectTo = this.clientRectangle.clone();
                        let rectDtTo = this.clientRectangle.clone();
                        if (this.path.length == 4 && this.path[0].is(StiArcSegmentGeom) && this.path[2].is(StiArcSegmentGeom)) {
                            let arcGeom1 = this.path[0];
                            let arcGeom2 = this.path[2];
                            startAngleTo = arcGeom1.startAngle;
                            endAngleTo = arcGeom1.startAngle + arcGeom1.sweepAngle;
                            rectTo = arcGeom1.rect;
                            rectDtTo = arcGeom2.rect;
                        }
                        pieAnimation = new StiPieSegmentAnimation(this.clientRectangle, rectTo, this.clientRectangleDt, rectDtTo, this.startAngle, this.endAngle, startAngleTo, endAngleTo, duration, TimeSpan.zero);
                        pieAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}_${this.index2}_${this.index3}`;
                        if (StiPieSegmentAnimation.isAnimationChangingValues(this.series, pieAnimation.id)) {
                            pieAnimation.applyPreviousAnimation(this.series.chart.previousAnimations);
                            animation = pieAnimation;
                        }
                    }
                    if (animation == null) {
                        let beginTimeAnimationOpacity = this.beginTime;
                        if (this.series.chart.previousAnimations.length > 0)
                            beginTimeAnimationOpacity = TimeSpan.fromMilliseconds(300);
                        let opacityAnimation = new StiOpacityAnimation(duration, beginTimeAnimationOpacity);
                        opacityAnimation.anotherAnimation = pieAnimation;
                        opacityAnimation.id = `series_${this.series.chart.series.indexOf(this.series)}_${this.index}_${this.index2}_${this.index3}`;
                        animation = opacityAnimation;
                    }
                    return animation;
                }
            }
            Chart.StiSunburstSeriesElementGeom = StiSunburstSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Size = Stimulsoft.System.Drawing.Size;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiTreemapSeriesElementGeom extends Chart.StiSeriesElementGeom {
                constructor(areaGeom, value, index, seriesBrush, seriesBorderColor, series, clientRectangle, animation) {
                    super(areaGeom, value, index, series, clientRectangle, seriesBrush);
                    this.seriesBrush = seriesBrush;
                    this.seriesBorderColor = seriesBorderColor;
                    this.animation = animation;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let rect = this.clientRectangle.clone();
                    let fontIconSeries = this.series.as(Chart.IStiFontIconsSeries);
                    if (fontIconSeries != null && fontIconSeries.icon != null) {
                        let sizeIcon = 30;
                        context.pushClip(rect);
                        Report.StiFontIconsHelper.drawFillIcons(context, this.seriesBrush, rect, new Size(sizeIcon, sizeIcon), fontIconSeries.icon, this.getToolTip());
                        context.popClip();
                        return;
                    }
                    if (chart.isAnimation) {
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        context.drawAnimationRectangle(this.seriesBrush, pen, new Rectangle(rect.x, rect.y, rect.width, rect.height), this, this.animation, this.getInteractionData(), this.getToolTip());
                    }
                    else {
                        super.draw(context);
                        this.series.chart.style.core.fillColumn(context, rect, this.seriesBrush, this.getInteractionData());
                        if (this.isMouseOver || this.series.core.isMouseOver) {
                            context.fillRectangle2(Chart.StiMouseOverHelper.getMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                        }
                        let pen = new StiPenGeom(this.seriesBorderColor, 1);
                        let points = [
                            new PointD(rect.x, rect.bottom),
                            new PointD(rect.x, rect.y),
                            new PointD(rect.right, rect.y),
                            new PointD(rect.right, rect.bottom),
                            new PointD(rect.x, rect.bottom)
                        ];
                        context.drawLines(pen, points);
                    }
                }
            }
            Chart.StiTreemapSeriesElementGeom = StiTreemapSeriesElementGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var TimeSpan = Stimulsoft.System.TimeSpan;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiSeriesLabelsGeom extends Chart.StiCellGeom {
                constructor(seriesLabels, series, index, value, clientRectangle) {
                    super(clientRectangle);
                    this._beginTime = new TimeSpan(0);
                    this._duration = new TimeSpan(0);
                    this._seriesLabels = seriesLabels;
                    this._series = series;
                    this._index = index;
                    this._value = value;
                }
                invokeMouseEnter(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (!this.isMouseOver) {
                        this.isMouseOver = true;
                        options.updateContext = true;
                    }
                }
                invokeMouseLeave(options) {
                    if (!this.allowMouseOver)
                        return;
                    if (this.isMouseOver) {
                        this.isMouseOver = false;
                        options.updateContext = true;
                    }
                }
                getValueIndex() {
                    let valueIndex = this.index;
                    if (this.series.is(Chart.IStiClusteredBarSeries) ||
                        this.series.is(Chart.IStiStackedBarSeries) ||
                        this.series.is(Chart.IStiFullStackedBarSeries)) {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && !this.series.chart.area.reverseVert)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    else {
                        if (this.series.chart.area.is(Chart.IStiAxisArea) && this.series.chart.area.reverseHor)
                            valueIndex = this.series.values.length - valueIndex - 1;
                    }
                    return valueIndex;
                }
                getHyperlink(valueIndex) {
                    if (this.series.hyperlinks != null && valueIndex < this.series.hyperlinks.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                getToolTip(valueIndex) {
                    if (this.series.toolTips != null && valueIndex < this.series.toolTips.length)
                        return this.series.hyperlinks[valueIndex];
                    else
                        return null;
                }
                get allowMouseOver() {
                    return this.getHyperlink(this.getValueIndex()) != null || this.series.interaction.drillDownEnabled;
                }
                get isMouseOver() {
                    if (this.series == null)
                        return false;
                    return this.series.core.getIsMouseOverSeriesElement(this.index);
                }
                set isMouseOver(value) {
                    if (this.series != null)
                        this.series.core.setIsMouseOverSeriesElement(this.index, value);
                }
                get value() {
                    return this._value;
                }
                get index() {
                    return this._index;
                }
                get series() {
                    return this._series;
                }
                get seriesLabels() {
                    return this._seriesLabels;
                }
                get beginTime() {
                    return this._beginTime;
                }
                set beginTime(value) {
                    this._beginTime = value;
                }
                get duration() {
                    return this._duration;
                }
                set duration(value) {
                    this._duration = value;
                }
                drawMarker(context, itemRect, markerColor, markerBrush) {
                    if (this.seriesLabels.markerVisible) {
                        let chart = this.series.chart;
                        let markerRect = Rectangle.empty;
                        if (this.seriesLabels.markerAlignment == Chart.StiMarkerAlignment.Right)
                            markerRect.x = Math.trunc(itemRect.right + 2 * context.options.zoom);
                        else
                            markerRect.x = Math.trunc(itemRect.left - (2 + this.seriesLabels.markerSize.width) * context.options.zoom);
                        switch (this.seriesLabels.markerAlignment) {
                            case Chart.StiMarkerAlignment.Right:
                                markerRect.x = Math.trunc(itemRect.right + 2 * context.options.zoom);
                                break;
                            case Chart.StiMarkerAlignment.Left:
                                markerRect.x = Math.trunc(itemRect.left - (2 + this.seriesLabels.markerSize.width) * context.options.zoom);
                                break;
                            case Chart.StiMarkerAlignment.Center:
                                markerRect.x = Math.trunc(itemRect.left + +itemRect.width / 2 - (2 + this.seriesLabels.markerSize.width) / 2 * context.options.zoom);
                                break;
                        }
                        markerRect.y = Math.trunc(itemRect.y + (itemRect.height - this.seriesLabels.markerSize.height * context.options.zoom) / 2);
                        markerRect.width = Math.trunc(this.seriesLabels.markerSize.width * context.options.zoom);
                        markerRect.height = Math.trunc(this.seriesLabels.markerSize.height * context.options.zoom);
                        let color = markerColor instanceof Color ? markerColor : Color.black;
                        let pen = new StiPenGeom(color, 1);
                        if (chart.isAnimation) {
                            let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalBeginTimeElement);
                            context.drawAnimationRectangle(markerBrush, pen, markerRect, null, animation, null, this.getToolTip(this.getValueIndex()));
                        }
                        else {
                            context.fillRectangle2(markerBrush, markerRect.x, markerRect.y, markerRect.width, markerRect.height, null);
                            context.drawRectangle2(pen, markerRect.x, markerRect.y, markerRect.width, markerRect.height);
                        }
                    }
                }
                draw(context) {
                }
            }
            Chart.StiSeriesLabelsGeom = StiSeriesLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiCenterAxisLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, labelColor, labelBorderColor, seriesBrush, seriesLabelsBrush, seriesBorderColor, font, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this._text = text;
                    this._labelColor = labelColor;
                    this._labelBorderColor = labelBorderColor;
                    this._seriesBrush = seriesBrush;
                    this._seriesLabelsBrush = seriesLabelsBrush;
                    this._seriesBorderColor = seriesBorderColor;
                    this._font = font;
                    this._animation = animation;
                }
                get labelColor() {
                    return this._labelColor;
                }
                get labelBorderColor() {
                    return this._labelBorderColor;
                }
                get seriesBrush() {
                    return this._seriesBrush;
                }
                get seriesLabelsBrush() {
                    return this._seriesLabelsBrush;
                }
                get seriesBorderColor() {
                    return this._seriesBorderColor;
                }
                get font() {
                    return this._font;
                }
                get text() {
                    return this._text;
                }
                get animation() {
                    return this._animation;
                }
                draw(context) {
                    let labelRect = this.clientRectangle.clone();
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    let chart = this.series.chart;
                    if (chart.isAnimation && this._animation == null)
                        this._animation = new StiOpacityAnimation(this.duration, this.beginTime);
                    this.drawMarker(context, labelRect, this.seriesBorderColor, this.seriesBrush);
                    let distX = labelRect.x + labelRect.width / 2;
                    let distY = labelRect.y + labelRect.height / 2;
                    context.pushTranslateTransform(distX, distY);
                    context.pushRotateTransform(this.seriesLabels.angle);
                    let rect = labelRect.clone();
                    rect.x = -rect.width / 2 - 1;
                    rect.y = -rect.height / 2 - 1;
                    rect.width += 2;
                    rect.height += 2;
                    this.drawLabelArea(context, rect);
                    this.drawLabelText(context, rect);
                    context.popTransform();
                    context.popTransform();
                    if (this.isMouseOver)
                        context.fillRectangle(Chart.StiMouseOverHelper.getLineMouseOverColor(), labelRect, null);
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.labelBorderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabelsBrush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabelsBrush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLabelText(context, rect) {
                    let labelBrush = new StiSolidBrush(this.labelColor);
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiCenterAxisLabelsGeom = StiCenterAxisLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiOutsideAxisLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, labelColor, labelBorderColor, seriesBrush, seriesBorderColor, font, startPoint, endPoint, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this._text = text;
                    this._labelColor = labelColor;
                    this._labelBorderColor = labelBorderColor;
                    this._seriesBrush = seriesBrush;
                    this._seriesBorderColor = seriesBorderColor;
                    this._font = font;
                    this._startPoint = startPoint;
                    this._endPoint = endPoint;
                    this._animation = animation;
                }
                get labelColor() {
                    return this._labelColor;
                }
                get labelBorderColor() {
                    return this._labelBorderColor;
                }
                get seriesBrush() {
                    return this._seriesBrush;
                }
                get seriesBorderColor() {
                    return this._seriesBorderColor;
                }
                get font() {
                    return this._font;
                }
                get text() {
                    return this._text;
                }
                get startPoint() {
                    return this._startPoint;
                }
                get endPoint() {
                    return this._endPoint;
                }
                get animation() {
                    return this._animation;
                }
                draw(context) {
                    let labelRect = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    if (chart.isAnimation && this._animation == null)
                        this._animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                    this.drawMarker(context, labelRect, this.seriesBorderColor, this.seriesBrush);
                    this.drawLines(context, labelRect);
                    context.pushTranslateTransform(labelRect.x + labelRect.width / 2, labelRect.y + labelRect.height / 2);
                    context.pushRotateTransform(this.seriesLabels.angle);
                    let rect = labelRect.clone();
                    rect.x = -rect.width / 2;
                    rect.y = -rect.height / 2;
                    this.drawLabelArea(context, rect);
                    this.drawLabelText(context, rect);
                    context.popTransform();
                    context.popTransform();
                    if (this.isMouseOver)
                        context.fillRectangle(Chart.StiMouseOverHelper.getLineMouseOverColor(), labelRect, null);
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.labelBorderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabels.brush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabels.brush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLines(context, rect) {
                    let chart = this.series.chart;
                    let borderPen = new StiPenGeom(this.labelBorderColor);
                    if (chart.isAnimation)
                        context.drawAnimationLines(borderPen, [this.endPoint, this.startPoint], this.animation);
                    else
                        context.drawLine(borderPen, this.endPoint.x, this.endPoint.y, this.startPoint.x, this.startPoint.y);
                }
                drawLabelText(context, rect) {
                    let labelBrush = new StiSolidBrush(this.labelColor);
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiOutsideAxisLabelsGeom = StiOutsideAxisLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiCenterFunnelLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, borderColor, seriesBorderColor, labelRect, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this._text = text;
                    this._labelBrush = labelBrush;
                    this._borderColor = borderColor;
                    this._seriesBorderColor = seriesBorderColor;
                    this._seriesBrush = seriesBrush;
                    this._labelRect = labelRect;
                    this._animation = animation;
                }
                get seriesBrush() {
                    return this._seriesBrush;
                }
                get borderColor() {
                    return this._borderColor;
                }
                get seriesBorderColor() {
                    return this._seriesBorderColor;
                }
                get labelBrush() {
                    return this._labelBrush;
                }
                get text() {
                    return this._text;
                }
                get labelRect() {
                    return this._labelRect;
                }
                get animation() {
                    return this._animation;
                }
                draw(context) {
                    let rectCurrent = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    if (chart.isAnimation && this._animation == null)
                        this._animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                    this.drawMarker(context, this.labelRect, this.seriesBorderColor, this.seriesBrush);
                    let distX = rectCurrent.x + rectCurrent.width / 2;
                    let distY = rectCurrent.y + rectCurrent.height / 2;
                    context.pushTranslateTransform(distX, distY);
                    context.pushRotateTransform(this.seriesLabels.angle);
                    let rect = rectCurrent;
                    rect.x = -rect.width / 2;
                    rect.y = -rect.height / 2;
                    this.drawLabelArea(context, rect);
                    this.drawLabelText(context, rect);
                    context.popTransform();
                    context.popTransform();
                    if (this.isMouseOver)
                        context.fillRectangle2(Chart.StiMouseOverHelper.getLineMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.borderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabels.brush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabels.brush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLabelText(context, rect) {
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiCenterFunnelLabelsGeom = StiCenterFunnelLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            class StiOutsideFunnelLabelsGeom extends Chart.StiCenterFunnelLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, borderColor, seriesBorderColor, labelRect, startPointLine, endPointLine) {
                    super(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, borderColor, seriesBorderColor, labelRect, null);
                    this._startPointLine = startPointLine;
                    this._endPointLine = endPointLine;
                }
                get startPointLine() {
                    return this._startPointLine;
                }
                get endPointLine() {
                    return this._endPointLine;
                }
                draw(context) {
                    let chart = this.series.chart;
                    let borderPen = new StiPenGeom(this.borderColor);
                    if (chart.isAnimation) {
                        let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                        context.drawAnimationLines(borderPen, [this.startPointLine, this.endPointLine], animation);
                    }
                    else
                        context.drawLine(borderPen, this.startPointLine.x, this.startPointLine.y, this.endPointLine.x, this.endPointLine.y);
                    super.draw(context);
                }
            }
            Chart.StiOutsideFunnelLabelsGeom = StiOutsideFunnelLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            class StiCenterPieLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, rotationMode, labelRect, angleToUse, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this.text = text;
                    this.labelBrush = labelBrush;
                    this.borderColor = borderColor;
                    this.seriesBorderColor = seriesBorderColor;
                    this.seriesLabelsBrush = seriesLabelsBrush;
                    this.seriesBrush = seriesBrush;
                    this.rotationMode = rotationMode;
                    this.labelRect = labelRect;
                    this.angleToUse = angleToUse;
                    this.animation = animation;
                }
                draw(context) {
                    let rect = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    if (chart.isAnimation && this.animation == null)
                        this.animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                    this.drawMarker(context, this.labelRect, this.seriesBorderColor, this.seriesBrush);
                    let distX = Math.round2(this.labelRect.x + this.labelRect.width / 2, 0);
                    let distY = Math.round2(this.labelRect.y + this.labelRect.height / 2, 0);
                    context.pushTranslateTransform(distX, distY);
                    context.pushRotateTransform(this.angleToUse);
                    this.drawLabelArea(context, rect);
                    this.drawLabelText(context, rect);
                    context.popTransform();
                    context.popTransform();
                    if (this.isMouseOver)
                        context.fillRectangle2(Chart.StiMouseOverHelper.getLineMouseOverColor(), rect.x, rect.y, rect.width, rect.height, null);
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.borderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabelsBrush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabelsBrush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLabelText(context, rect) {
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiCenterPieLabelsGeom = StiCenterPieLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiOutsidePieLabelsGeom extends Chart.StiCenterPieLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, rotationMode, labelRect, angleToUse, lineColor, labelPoint, startPoint) {
                    super(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, rotationMode, labelRect, angleToUse, null);
                    this.lineColor = lineColor;
                    this.labelPoint = labelPoint;
                    this.startPoint = startPoint;
                }
                draw(context) {
                    let outsidePieLabels = this.seriesLabels;
                    super.draw(context);
                    if (outsidePieLabels.drawBorder) {
                        let borderPen = new StiPenGeom(this.lineColor);
                        let chart = this.series.chart;
                        if (chart.isAnimation) {
                            let animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalBeginTimeElement);
                            context.drawAnimationLines(borderPen, [this.labelPoint, this.startPoint], animation);
                        }
                        else
                            context.drawLine(borderPen, this.labelPoint.x, this.labelPoint.y, this.startPoint.x, this.startPoint.y);
                    }
                }
            }
            Chart.StiOutsidePieLabelsGeom = StiOutsidePieLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var Rectangle = Stimulsoft.System.Drawing.Rectangle;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            class StiTwoColumnsPieLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, seriesBrush, labelBrush, seriesLabelsBrush, borderColor, seriesBorderColor, labelRect, lineColor, startPoint, endPoint, arcPoint, centerPie, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this.text = text;
                    this.seriesLabelsBrush = seriesLabelsBrush;
                    this.labelBrush = labelBrush;
                    this.lineColor = lineColor;
                    this.borderColor = borderColor;
                    this.seriesBorderColor = seriesBorderColor;
                    this.seriesBrush = seriesBrush;
                    this.labelRect = labelRect;
                    this.startPoint = startPoint;
                    this.endPoint = endPoint;
                    this.arcPoint = arcPoint;
                    this.centerPie = centerPie;
                    this.animation = animation;
                }
                draw(context) {
                    let labelRect = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    if (chart.isAnimation && this.animation == null)
                        this.animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                    this.drawLines(context);
                    this.drawMarker(context, labelRect, this.seriesBorderColor, this.seriesBrush);
                    this.drawLabelArea(context, labelRect);
                    this.drawLabelText(context, labelRect);
                    if (this.isMouseOver)
                        context.fillRectangle(Chart.StiMouseOverHelper.getLineMouseOverColor(), labelRect, null);
                }
                drawLines(context) {
                    if (this.seriesLabels.drawBorder) {
                        let endPoint0 = null;
                        let linePen = new StiPenGeom(this.lineColor, 1);
                        if (((this.centerPie.y > this.startPoint.y) && (this.endPoint.y > this.startPoint.y)) || ((this.centerPie.y < this.startPoint.y) && (this.endPoint.y < this.startPoint.y))) {
                            if (this.centerPie.x > this.endPoint.x) {
                                endPoint0 = new PointD(this.endPoint.x + 13, this.startPoint.y);
                            }
                            else {
                                endPoint0 = new PointD(this.endPoint.x - 13, this.startPoint.y);
                            }
                        }
                        let points = endPoint0 != null
                            ? [this.endPoint, endPoint0, this.startPoint, this.arcPoint]
                            : [this.endPoint, this.startPoint, this.arcPoint];
                        let chart = this.series.chart;
                        if (chart.isAnimation) {
                            context.drawAnimationLines(linePen, points, this.animation);
                        }
                        else {
                            context.drawLines(linePen, points);
                        }
                    }
                }
                drawMarker(context, itemRect, markerColor, markerBrush) {
                    if (this.seriesLabels.markerVisible) {
                        let markerRect = Rectangle.empty;
                        let rightPosition = Math.trunc(itemRect.right + 2 * context.options.zoom);
                        let leftPosition = Math.trunc(itemRect.left - (2 + this.seriesLabels.markerSize.width) * context.options.zoom);
                        if (Stimulsoft["StiOptions"].Engine.allowFixPieChartMarkerAlignment) {
                            if (this.seriesLabels.markerAlignment == Chart.StiMarkerAlignment.Right) {
                                markerRect.x = this.clientRectangle.x < this.centerPie.x ? rightPosition : leftPosition;
                            }
                            else {
                                markerRect.x = this.clientRectangle.x > this.centerPie.x ? rightPosition : leftPosition;
                            }
                        }
                        else {
                            markerRect.x = this.seriesLabels.markerAlignment == Chart.StiMarkerAlignment.Right ? rightPosition : leftPosition;
                        }
                        markerRect.y = Math.trunc(itemRect.y + (itemRect.height - this.seriesLabels.markerSize.height * context.options.zoom) / 2);
                        markerRect.width = Math.trunc(this.seriesLabels.markerSize.width * context.options.zoom);
                        markerRect.height = Math.trunc(this.seriesLabels.markerSize.height * context.options.zoom);
                        let color = markerColor instanceof Color ? markerColor : Color.black;
                        let pen = new StiPenGeom(color, 1);
                        context.fillRectangle2(markerBrush, markerRect.x, markerRect.y, markerRect.width, markerRect.height, null);
                        context.drawRectangle2(pen, markerRect.x, markerRect.y, markerRect.width, markerRect.height);
                    }
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.borderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabelsBrush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabelsBrush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLabelText(context, rect) {
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, this.labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiTwoColumnsPieLabelsGeom = StiTwoColumnsPieLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiOpacityAnimation = Stimulsoft.Base.Context.Animation.StiOpacityAnimation;
            class StiCenterTreemapLabelsGeom extends Chart.StiSeriesLabelsGeom {
                constructor(seriesLabels, series, index, value, clientRectangle, text, labelColor, labelBorderColor, seriesBrush, seriesLabelsBrush, seriesBorderColor, font, animation) {
                    super(seriesLabels, series, index, value, clientRectangle);
                    this._text = text;
                    this._labelColor = labelColor;
                    this._labelBorderColor = labelBorderColor;
                    this._seriesBrush = seriesBrush;
                    this._seriesLabelsBrush = seriesLabelsBrush;
                    this._seriesBorderColor = seriesBorderColor;
                    this._font = font;
                    this._animation = animation;
                }
                get labelColor() {
                    return this._labelColor;
                }
                get labelBorderColor() {
                    return this._labelBorderColor;
                }
                get seriesBrush() {
                    return this._seriesBrush;
                }
                get seriesLabelsBrush() {
                    return this._seriesLabelsBrush;
                }
                get seriesBorderColor() {
                    return this._seriesBorderColor;
                }
                get font() {
                    return this._font;
                }
                get text() {
                    return this._text;
                }
                get animation() {
                    return this._animation;
                }
                draw(context) {
                    super.draw(context);
                    let labelRect = this.clientRectangle.clone();
                    let chart = this.series.chart;
                    if (chart.isAnimation && this.animation == null)
                        this._animation = new StiOpacityAnimation(Chart.StiChartHelper.globalBeginTimeElement, Chart.StiChartHelper.globalDurationElement);
                    this.drawMarker(context, labelRect, this.seriesBorderColor, this.seriesBrush);
                    this.drawMarker(context, labelRect, this.seriesBorderColor, this.seriesBrush);
                    let distX = labelRect.x + labelRect.width / 2;
                    let distY = labelRect.y + labelRect.height / 2;
                    this.drawLabelArea(context, labelRect);
                    this.drawLabelText(context, labelRect);
                    context.pushTranslateTransform(distX, distY);
                    context.pushRotateTransform(this.seriesLabels.angle);
                    let rect = labelRect.clone();
                    rect.x = -rect.width / 2;
                    rect.y = -rect.height / 2;
                    context.popTransform();
                    context.popTransform();
                    if (this.isMouseOver)
                        context.fillRectangle(Chart.StiMouseOverHelper.getLineMouseOverColor(), labelRect, null);
                }
                drawLabelArea(context, rect) {
                    if (rect.isEmpty)
                        return;
                    let chart = this.series.chart;
                    let borderPen = this.seriesLabels.drawBorder ? new StiPenGeom(this.labelBorderColor, 1) : null;
                    if (chart.isAnimation)
                        context.drawAnimationRectangle(this.seriesLabelsBrush, borderPen, rect, null, this.animation, null, null);
                    else {
                        context.fillRectangle(this.seriesLabelsBrush, rect, null);
                        if (this.seriesLabels.drawBorder)
                            context.drawRectangle(borderPen, rect);
                    }
                }
                drawLabelText(context, rect) {
                    let labelBrush = new StiSolidBrush(this._labelColor);
                    let chart = this.series.chart;
                    let font = StiFontGeom.changeFontSize(this.seriesLabels.font, this.seriesLabels.font.size);
                    let sf = this.seriesLabels.core.getStringFormatGeom(context);
                    sf.alignment = StringAlignment.Center;
                    sf.lineAlignment = StringAlignment.Center;
                    if (chart.isAnimation)
                        context.drawAnimationText(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width, this.animation);
                    else
                        context.drawRotatedString6(this.text, font, labelBrush, rect, sf, StiRotationMode.CenterCenter, 0, this.seriesLabels.antialiasing, rect.width);
                }
            }
            Chart.StiCenterTreemapLabelsGeom = StiCenterTreemapLabelsGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStripsXGeom extends Chart.StiCellGeom {
                constructor(strip, clientRectangle) {
                    super(clientRectangle);
                    this._strip = strip;
                }
                get strip() {
                    return this._strip;
                }
                draw(context) {
                    let stripRect = this.clientRectangle.clone();
                    context.fillRectangle2(this.strip.stripBrush, stripRect.x, stripRect.y, stripRect.width, stripRect.height, null);
                    if (this.strip.titleVisible) {
                        let brush = new StiSolidBrush(this.strip.titleColor);
                        let font = StiFontGeom.changeFontSize(this.strip.font, (this.strip.font.size * context.options.zoom));
                        let sf = context.getGenericStringFormat();
                        context.drawRotatedString6(this.strip.text, font, brush, stripRect, sf, StiRotationMode.CenterCenter, 90, this.strip.antialiasing, 0);
                    }
                }
            }
            Chart.StiStripsXGeom = StiStripsXGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiStripsYGeom extends Chart.StiCellGeom {
                constructor(strip, clientRectangle) {
                    super(clientRectangle);
                    this._strip = strip;
                }
                get strip() {
                    return this._strip;
                }
                draw(context) {
                    let stripRect = this.clientRectangle.clone();
                    context.fillRectangle2(this.strip.stripBrush, stripRect.x, stripRect.y, stripRect.width, stripRect.height, null);
                    if (this.strip.titleVisible) {
                        let brush = new StiSolidBrush(this.strip.titleColor);
                        let font = StiFontGeom.changeFontSize(this.strip.font, (this.strip.font.size * context.options.zoom));
                        let sf = context.getGenericStringFormat();
                        context.drawRotatedString5(this.strip.text, font, brush, stripRect, sf, StiRotationMode.CenterCenter, 0, this.strip.antialiasing);
                    }
                }
            }
            Chart.StiStripsYGeom = StiStripsYGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var StringTrimming = Stimulsoft.System.Drawing.StringTrimming;
            var StringFormatFlags = Stimulsoft.System.Drawing.StringFormatFlags;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var RectangleD = Stimulsoft.System.Drawing.Rectangle;
            class StiChartTableGeom extends Chart.StiCellGeom {
                constructor(clientRectangle, table, widthCellLegendTableChart, heightCellHeader, chartTable) {
                    super(clientRectangle);
                    this.widthCellLegendTableChart = widthCellLegendTableChart;
                    this.heightCellHeader = heightCellHeader;
                    this.table = table;
                    this.chartTable = chartTable;
                    this.pen = new StiPenGeom(chartTable.gridLineColor);
                    this.labelBrush = new StiSolidBrush(chartTable.textColor);
                    this.labelHeaderBrush = new StiSolidBrush(chartTable.header.textColor);
                }
                draw(context) {
                    this.font = StiFontGeom.changeFontSize(this.chartTable.dataCells.font, this.chartTable.dataCells.font.size * context.options.zoom);
                    this.sf = context.getGenericStringFormat();
                    this.sf.trimming = StringTrimming.None;
                    this.sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    this.sf.alignment = StringAlignment.Center;
                    this.sf.lineAlignment = StringAlignment.Center;
                    this.fontHeader = StiFontGeom.changeFontSize(this.chartTable.header.font, this.chartTable.header.font.size * context.options.zoom);
                    this.sfHeader = context.getGenericStringFormat();
                    this.sf.trimming = StringTrimming.None;
                    if (!this.chartTable.header.wordWrap)
                        this.sf.formatFlags = StringFormatFlags.MeasureTrailingSpaces | StringFormatFlags.NoWrap;
                    this.sfHeader.alignment = StringAlignment.Center;
                    this.sfHeader.lineAlignment = StringAlignment.Center;
                    let rect = this.clientRectangle.clone();
                    let area = this.chartTable.chart.area;
                    let xTA = area.reverseHor ? rect.x : rect.x + this.widthCellLegendTableChart;
                    let yTA = rect.y;
                    let widthTA = rect.width - this.widthCellLegendTableChart;
                    let heightTA = this.heightCellHeader;
                    let rectHeaderArgument = new RectangleD(xTA, yTA, widthTA, heightTA);
                    let listArgument = [];
                    for (let index = 1; index < this.table.stimulsoft().getLength(1); index++) {
                        listArgument.push(this.table[0][index]);
                    }
                    this.drawHeaderArgument(context, rectHeaderArgument, listArgument, area.xAxis.startFromZero);
                    let xTL = area.reverseHor ? rect.right - this.widthCellLegendTableChart : rect.x;
                    let yTL = rect.y + this.heightCellHeader;
                    let widthTL = this.widthCellLegendTableChart;
                    let heightTL = rect.height - this.heightCellHeader;
                    let rectTitleLegend = new RectangleD(xTL, yTL, widthTL, heightTL);
                    let listTitleLegend = [];
                    for (let index = 1; index < this.table.stimulsoft().getLength(0); index++) {
                        listTitleLegend.push(this.table[index][0]);
                    }
                    this.drawTitleLegend(context, rectTitleLegend, listTitleLegend);
                    let xRT = area.reverseHor ? rect.x : rect.x + this.widthCellLegendTableChart;
                    let yRT = rect.y + this.heightCellHeader;
                    let widthRT = rect.width - this.widthCellLegendTableChart;
                    let heightRT = rect.height - this.heightCellHeader;
                    let rectRootTable = new RectangleD(xRT, yRT, widthRT, heightRT);
                    this.drawRootTable(context, rectRootTable, area.xAxis.startFromZero);
                }
                drawHeaderArgument(context, rect, listArgument, startFromZero) {
                    context.fillRectangle(this.chartTable.header.brush, new RectangleD(rect.x, rect.y, rect.width, rect.height), null);
                    if (this.chartTable.gridOutline)
                        context.drawRectangle(this.pen, rect);
                    let count = startFromZero ? listArgument.length + 1 : listArgument.length - 1;
                    let cellWidth = rect.width / count;
                    for (let indexColumn = 0; indexColumn < listArgument.length; indexColumn++) {
                        let deltaWidth = 0;
                        if (indexColumn == 0 || indexColumn == listArgument.length - 1) {
                            deltaWidth = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                        }
                        let deltaX = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                        if (indexColumn == 0)
                            deltaX = 0;
                        let rectangleF = new RectangleD(rect.x + indexColumn * cellWidth + deltaX, rect.y, cellWidth + deltaWidth, rect.height);
                        if (this.chartTable.header.wordWrap)
                            context.drawRotatedString6(listArgument[indexColumn], this.fontHeader, this.labelHeaderBrush, rectangleF, this.sfHeader, StiRotationMode.CenterCenter, 0, true, Math.trunc(cellWidth + deltaWidth));
                        else
                            context.drawRotatedString5(listArgument[indexColumn], this.fontHeader, this.labelHeaderBrush, rectangleF, this.sfHeader, StiRotationMode.CenterCenter, 0, true);
                        if (this.chartTable.gridLinesVert && indexColumn != listArgument.length - 1) {
                            let x = startFromZero ? rect.x + (indexColumn + 1) * cellWidth + cellWidth / 2 : rect.x + (indexColumn + 1) * cellWidth - cellWidth / 2;
                            context.drawLine(this.pen, x, rect.y, x, rect.bottom);
                        }
                    }
                }
                drawTitleLegend(context, rect, list) {
                    if (this.chartTable.gridOutline)
                        context.drawRectangle2(this.pen, rect.x, rect.y, rect.width, rect.height);
                    let cellHeight = rect.height / list.length;
                    for (let indexRow = 0; indexRow < list.length; indexRow++) {
                        let x = rect.x;
                        let y = rect.y;
                        let width = rect.width;
                        if (this.chartTable.gridLinesHor && indexRow != 0)
                            context.drawLine(this.pen, x, y + cellHeight * indexRow, x + width, y + cellHeight * indexRow);
                        if (this.chartTable.markerVisible) {
                            let rectMarker = new RectangleD(x + 2, y + 2 + cellHeight * indexRow, cellHeight - 4, cellHeight - 4);
                            let legendMarker = Chart.StiMarkerLegendFactory.createMarker(this.chartTable.chart.series.getByIndex(indexRow));
                            legendMarker.draw(context, this.chartTable.chart.series.getByIndex(indexRow), rectMarker, indexRow, list.length, -1);
                            x += cellHeight;
                            width -= cellHeight;
                        }
                        let rectangleF = new RectangleD(x, y + cellHeight * indexRow, width, cellHeight);
                        context.drawString(list[indexRow], this.font, this.labelBrush, rectangleF, this.sf);
                    }
                }
                drawRootTable(context, rect, startFromZero) {
                    if (this.chartTable.gridOutline)
                        context.drawRectangle2(this.pen, rect.x, rect.y, rect.width, rect.height);
                    let countRow = this.table.stimulsoft().getLength(0);
                    let countColumn = this.table.stimulsoft().getLength(1);
                    let count = startFromZero ? this.table.stimulsoft().getLength(1) : this.table.stimulsoft().getLength(1) - 2;
                    let cellWidth = rect.width / count;
                    let cellHeight = rect.height / (countRow - 1);
                    let defaultFont = this.font;
                    if (this.chartTable.dataCells.shrinkFontToFit) {
                        for (let indexRow = 1; indexRow < countRow; indexRow++) {
                            if (this.chartTable.gridLinesHor && indexRow != countRow - 1)
                                context.drawLine(this.pen, rect.x, rect.y + indexRow * cellHeight, rect.right, rect.y + indexRow * cellHeight);
                            for (let indexColumn = 1; indexColumn < countColumn; indexColumn++) {
                                let deltaWidth = 0;
                                if (indexColumn == 1 || indexColumn == countColumn - 1) {
                                    deltaWidth = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                                }
                                let deltaX = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                                if (indexColumn == 1)
                                    deltaX = 0;
                                let rectangleF = new RectangleD(rect.x + (indexColumn - 1) * cellWidth + deltaX, rect.y + (indexRow - 1) * cellHeight, cellWidth + deltaWidth, cellHeight);
                                let isFontSize = this.checkFontSize(context, this.table[indexRow][indexColumn], defaultFont, rectangleF);
                                while (!isFontSize) {
                                    defaultFont.fontSize -= 0.5;
                                    if (defaultFont.fontSize <= this.chartTable.dataCells.shrinkFontToFitMinimumSize) {
                                        defaultFont.fontSize = this.chartTable.dataCells.shrinkFontToFitMinimumSize;
                                        break;
                                    }
                                    isFontSize = this.checkFontSize(context, this.table[indexRow][indexColumn], defaultFont, rectangleF);
                                }
                            }
                        }
                    }
                    for (let indexRow = 1; indexRow < countRow; indexRow++) {
                        if (this.chartTable.gridLinesHor && indexRow != countRow - 1)
                            context.drawLine(this.pen, rect.x, rect.y + indexRow * cellHeight, rect.right, rect.y + indexRow * cellHeight);
                        for (let indexColumn = 1; indexColumn < countColumn; indexColumn++) {
                            let deltaWidth = 0;
                            if (indexColumn == 1 || indexColumn == countColumn - 1) {
                                deltaWidth = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                            }
                            let deltaX = startFromZero ? cellWidth / 2 : -cellWidth / 2;
                            if (indexColumn == 1)
                                deltaX = 0;
                            let rectangleF = new RectangleD(rect.x + (indexColumn - 1) * cellWidth + deltaX, rect.y + (indexRow - 1) * cellHeight, cellWidth + deltaWidth, cellHeight);
                            context.drawRotatedString5(this.table[indexRow][indexColumn], defaultFont, this.labelBrush, rectangleF, this.sf, StiRotationMode.CenterCenter, 0, true);
                            if (this.chartTable.gridLinesVert && indexColumn < countColumn - 1) {
                                let x = startFromZero ? rect.x + indexColumn * cellWidth + cellWidth / 2 : rect.x + indexColumn * cellWidth - cellWidth / 2;
                                context.drawLine(this.pen, x, rect.y, x, rect.bottom);
                            }
                        }
                    }
                }
                checkFontSize(context, text, fontGeom, rectangleF) {
                    let measureRect = context.measureRotatedString(text, fontGeom, rectangleF, this.sf, 0);
                    return measureRect.width < rectangleF.width;
                }
            }
            Chart.StiChartTableGeom = StiChartTableGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var Point = Stimulsoft.System.Drawing.Point;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiTrendCurveGeom extends Chart.StiCellGeom {
                constructor(points, trendLine) {
                    super(Chart.StiBaseLineSeriesGeom.getClientRectangle(points, trendLine.lineWidth));
                    this._points = points;
                    this._trendLine = trendLine;
                }
                get points() {
                    return this._points;
                }
                get trendLine() {
                    return this._trendLine;
                }
                draw(context) {
                    let pointsNull = StiArray.create(PointD, this.points.length, true);
                    for (let index = 0; index < this.points.length; index++) {
                        pointsNull[index] = this.points[index];
                    }
                    let lineColor = this.trendLine.lineColor;
                    let lineWidth = this.trendLine.lineWidth;
                    let style = this.trendLine.lineStyle;
                    let showShadow = this.trendLine.showShadow;
                    let scaledLineWidth = lineWidth * context.options.zoom;
                    context.pushSmoothingModeToAntiAlias();
                    if (showShadow) {
                        let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                        penShadow.penStyle = style;
                        context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                        Chart.StiNullableDrawing.drawCurve(context, penShadow, this.points, 0);
                        context.popTransform();
                    }
                    let pen = new StiPenGeom(lineColor, lineWidth * context.options.zoom);
                    pen.penStyle = style;
                    context.drawCurve(pen, pointsNull, 0);
                    if (this.trendLine.titleVisible && pointsNull.length > 0) {
                        let brush = new StiSolidBrush(this.trendLine.lineColor);
                        let font = StiFontGeom.changeFontSize(this.trendLine.font, this.trendLine.font.size * context.options.zoom);
                        let sf = context.getGenericStringFormat();
                        let point = Point.empty;
                        let pointStart = pointsNull[0];
                        let pointEnd = pointsNull[pointsNull.length - 1];
                        let mode = StiRotationMode.CenterCenter;
                        switch (this.trendLine.position) {
                            case Chart.StiTrendLine_StiTextPosition.LeftBottom:
                                point = pointStart;
                                mode = StiRotationMode.LeftTop;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.LeftTop:
                                point = pointStart;
                                mode = StiRotationMode.LeftBottom;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.RightBottom:
                                point = pointEnd;
                                mode = StiRotationMode.RightTop;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.RightTop:
                                point = pointEnd;
                                mode = StiRotationMode.RightBottom;
                                break;
                        }
                        context.drawRotatedString9(this.trendLine.text, font, brush, point, sf, mode, 0, true, 0);
                    }
                    context.popSmoothingMode();
                }
            }
            Chart.StiTrendCurveGeom = StiTrendCurveGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiPenGeom = Stimulsoft.Base.Context.StiPenGeom;
            var Color = Stimulsoft.System.Drawing.Color;
            var PointD = Stimulsoft.System.Drawing.Point;
            var StiRotationMode = Stimulsoft.Base.Drawing.StiRotationMode;
            var StiFontGeom = Stimulsoft.Base.Context.StiFontGeom;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            class StiTrendLineGeom extends Chart.StiCellGeom {
                constructor(pointStart, pointEnd, trendLine) {
                    super(Chart.StiBaseLineSeriesGeom.getClientRectangle(StiTrendLineGeom.getArray(pointStart, pointEnd), trendLine.lineWidth));
                    this.pointStart = pointStart;
                    this.pointEnd = pointEnd;
                    this.trendLine = trendLine;
                }
                draw(context) {
                    let lineColor = this.trendLine.lineColor;
                    let lineWidth = this.trendLine.lineWidth;
                    let style = this.trendLine.lineStyle;
                    let showShadow = this.trendLine.showShadow;
                    let scaledLineWidth = lineWidth * context.options.zoom;
                    context.pushSmoothingModeToAntiAlias();
                    if (showShadow) {
                        let penShadow = new StiPenGeom(Color.fromArgb(50, 0, 0, 0), scaledLineWidth + 0.5 * context.options.zoom);
                        penShadow.penStyle = style;
                        context.pushTranslateTransform(scaledLineWidth, scaledLineWidth);
                        Chart.StiNullableDrawing.drawLines(context, penShadow, StiTrendLineGeom.getArray(this.pointStart, this.pointEnd));
                        context.popTransform();
                    }
                    let pen = new StiPenGeom(lineColor, lineWidth * context.options.zoom);
                    pen.penStyle = style;
                    context.drawLine(pen, this.pointStart.x, this.pointStart.y, this.pointEnd.x, this.pointEnd.y);
                    if (this.trendLine.titleVisible) {
                        let brush = new StiSolidBrush(this.trendLine.lineColor);
                        let font = StiFontGeom.changeFontSize(this.trendLine.font, this.trendLine.font.size * context.options.zoom);
                        let sf = context.getGenericStringFormat();
                        let point = PointD.empty;
                        let mode = StiRotationMode.CenterCenter;
                        switch (this.trendLine.position) {
                            case Chart.StiTrendLine_StiTextPosition.LeftBottom:
                                point = this.pointStart;
                                mode = StiRotationMode.LeftTop;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.LeftTop:
                                point = this.pointStart;
                                mode = StiRotationMode.LeftBottom;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.RightBottom:
                                point = this.pointEnd;
                                mode = StiRotationMode.RightTop;
                                break;
                            case Chart.StiTrendLine_StiTextPosition.RightTop:
                                point = this.pointEnd;
                                mode = StiRotationMode.RightBottom;
                                break;
                        }
                        context.drawRotatedString9(this.trendLine.text, font, brush, point, sf, mode, 0, true, 0);
                    }
                    context.popSmoothingMode();
                }
                static getArray(pointStart, pointEnd) {
                    let points = [pointStart, pointEnd];
                    return points;
                }
            }
            Chart.StiTrendLineGeom = StiTrendLineGeom;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiBoxAndWhiskerHelper {
                static checkArgument(chart) {
                    let argArray = [];
                    for (let series of chart.series.toCast()) {
                        let boxAndWhiskerSeries = series.as(Chart.StiBoxAndWhiskerSeries);
                        if (boxAndWhiskerSeries != null)
                            argArray.push(boxAndWhiskerSeries.coreTitle);
                    }
                    for (let series of chart.series.toCast()) {
                        let boxAndWhiskerSeries = series.as(Chart.StiBoxAndWhiskerSeries);
                        if (boxAndWhiskerSeries != null) {
                            boxAndWhiskerSeries.arguments = argArray;
                            boxAndWhiskerSeries.originalArguments = argArray;
                        }
                    }
                }
            }
            Chart.StiBoxAndWhiskerHelper = StiBoxAndWhiskerHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var List = Stimulsoft.System.Collections.List;
            class StiHistogramHelper {
                static checkValuesAndArguments(series, formatService) {
                    if (!(series.is(Chart.StiHistogramSeries)))
                        return;
                    let values = series.values;
                    let deviation = this.getStandardDeviation(values);
                    let scottH = 3.5 * deviation / Math.pow(values.length, 1 / 3);
                    if (!scottH)
                        scottH = 1;
                    scottH = this.roundToSignificantDigits(scottH, 6);
                    let minValue = values.stimulsoft().toList().min();
                    let startValue = minValue - scottH / 2;
                    if (minValue < 0 && startValue < 0) {
                        startValue = values.stimulsoft().toList().min();
                    }
                    else if (startValue < 0) {
                        startValue = 0;
                    }
                    let listValues = new List();
                    let listArguments = new List();
                    let sumCurrent = 0;
                    let index = 0;
                    let indexRangeCurrent = 0;
                    let endValueCurrnet = startValue + scottH;
                    let area = series.chart.area.as(Chart.StiAxisArea);
                    for (let valueCurrent of values.stimulsoft().toList().orderBy(v => v)) {
                        if (valueCurrent > endValueCurrnet || index == values.length - 1) {
                            listValues.add(sumCurrent);
                            let formatStartValue = formatService != null
                                ? formatService.format(startValue)
                                : area.xAxis.core.getLabelText2(startValue, startValue, series);
                            let formatEndValueCurrnet = formatService != null
                                ? formatService.format(endValueCurrnet)
                                : area.xAxis.core.getLabelText2(endValueCurrnet, endValueCurrnet, series);
                            let argumentCurrent = indexRangeCurrent == 0
                                ? "[" + formatStartValue + ", " + formatEndValueCurrnet + "]"
                                : "(" + formatStartValue + ", " + formatEndValueCurrnet + "]";
                            listArguments.add(argumentCurrent);
                            sumCurrent = 0;
                            indexRangeCurrent++;
                            startValue = startValue + scottH * indexRangeCurrent;
                            endValueCurrnet = startValue + scottH;
                        }
                        index++;
                        sumCurrent++;
                    }
                    series.values = listValues.stimulsoft().toArray();
                    series.arguments = listArguments.stimulsoft().toArray();
                    series.originalArguments = listArguments.stimulsoft().toArray();
                    series.valuesStart = [];
                }
                static roundToSignificantDigits(d, digits) {
                    if (d == 0)
                        return 0;
                    let scale = Math.pow(10, Math.floor(Math.log10(Math.abs(d))) + 1);
                    return (scale * Math.round2(d / scale, digits));
                }
                static getStandardDeviation(values) {
                    let xAverage = values.stimulsoft().toList().sum() / values.length;
                    let t1 = values.stimulsoft().toList().sum(v => Math.pow(v - xAverage, 2));
                    return Math.sqrt(t1 / (values.length - 1));
                }
            }
            Chart.StiHistogramHelper = StiHistogramHelper;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiBoxAndWhiskerArea extends Chart.StiAxisArea {
                constructor() {
                    super();
                    this.core = new Chart.StiBoxAndWhiskerAreaCoreXF(this);
                }
                implements() {
                    if (!StiBoxAndWhiskerArea.implementsStiBoxAndWhiskerArea)
                        StiBoxAndWhiskerArea.implementsStiBoxAndWhiskerArea = super.implements().concat([
                            Chart.IStiBoxAndWhiskerArea
                        ]);
                    return StiBoxAndWhiskerArea.implementsStiBoxAndWhiskerArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiBoxAndWhiskerSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiBoxAndWhiskerSeries
                    ];
                }
                getSeriesLabelsTypes() {
                    return [
                        Chart.StiNoneLabels,
                        Chart.StiCenterAxisLabels,
                        Chart.StiLeftAxisLabels,
                        Chart.StiRightAxisLabels
                    ];
                }
                get componentId() {
                    return Report.StiComponentId.StiBoxAndWhiskerArea;
                }
                createNew() {
                    return new StiBoxAndWhiskerArea();
                }
            }
            Chart.StiBoxAndWhiskerArea = StiBoxAndWhiskerArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiScatterArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiScatterAreaCoreXF(this);
                }
                implements() {
                    if (!StiScatterArea.implementsStiScatterArea)
                        StiScatterArea.implementsStiScatterArea = super.implements().concat([
                            Chart.IStiScatterArea,
                            Chart.IStiArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiScatterArea.implementsStiScatterArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiScatterLineSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiScatterSeries,
                        Chart.StiScatterLineSeries,
                        Chart.StiScatterSplineSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiScatterArea;
                }
                createNew() {
                    return new StiScatterArea();
                }
            }
            Chart.StiScatterArea = StiScatterArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiBubbleArea extends Chart.StiScatterArea {
                constructor() {
                    super();
                    this.core = new Chart.StiBubbleAreaCoreXF(this);
                    this.interlacingHor = new Chart.StiInterlacingHor();
                    this.interlacingVert = new Chart.StiInterlacingVert();
                }
                implements() {
                    if (!StiBubbleArea.implementsStiBubbleArea)
                        StiBubbleArea.implementsStiBubbleArea = super.implements().concat([
                            Chart.IStiScatterArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiBubbleArea
                        ]);
                    return StiBubbleArea.implementsStiBubbleArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiBubbleSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiBubbleSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiBubbleArea;
                }
                createNew() {
                    return new StiBubbleArea();
                }
            }
            Chart.StiBubbleArea = StiBubbleArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiCandlestickArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiCandlestickAreaCoreXF(this);
                }
                implements() {
                    if (!StiCandlestickArea.implementsStiCandlestickArea)
                        StiCandlestickArea.implementsStiCandlestickArea = super.implements().concat([
                            Chart.IStiCandlestickArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiCandlestickArea.implementsStiCandlestickArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiCandlestickSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiCandlestickSeries];
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels];
                }
                get componentId() {
                    return Report.StiComponentId.StiCandlestickArea;
                }
                createNew() {
                    return new StiCandlestickArea();
                }
            }
            Chart.StiCandlestickArea = StiCandlestickArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiClusteredBarArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiClusteredBarAreaCoreXF(this);
                }
                implements() {
                    if (!StiClusteredBarArea.implementsStiClusteredBarArea)
                        StiClusteredBarArea.implementsStiClusteredBarArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiClusteredBarArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiClusteredBarArea.implementsStiClusteredBarArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiClusteredBarSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiClusteredBarSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiClusteredBarArea;
                }
                createNew() {
                    return new StiClusteredBarArea();
                }
            }
            Chart.StiClusteredBarArea = StiClusteredBarArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiAreaArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiAreaArea.implementsStiAreaArea)
                        StiAreaArea.implementsStiAreaArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            Chart.IStiAreaArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiAreaArea.implementsStiAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiAreaArea;
                }
                createNew() {
                    return new StiAreaArea();
                }
            }
            Chart.StiAreaArea = StiAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiHistogramArea extends Chart.StiAxisArea {
                get componentId() {
                    return Report.StiComponentId.StiHistorgamArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiHistogramSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiHistogramSeries
                    ];
                }
                createNew() {
                    return new StiHistogramArea();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiHistogramAreaCoreXF(this);
                }
            }
            Chart.StiHistogramArea = StiHistogramArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiLineArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiLineAreaCoreXF(this);
                }
                implements() {
                    if (!StiLineArea.implementsStiLineArea)
                        StiLineArea.implementsStiLineArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiLineArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiLineArea.implementsStiLineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiLineArea;
                }
                createNew() {
                    return new StiLineArea();
                }
            }
            Chart.StiLineArea = StiLineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiParetoArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.yRightAxis.visible = true;
                    this.yRightAxis.range.auto = false;
                    this.yRightAxis.range.maximum = 100;
                    this.yRightAxis.labels.textAfter = "%";
                    this.core = new Chart.StiParetoAreaCoreXF(this);
                }
                implements() {
                    if (!StiParetoArea.implementsStiParetoArea)
                        StiParetoArea.implementsStiParetoArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiParetoArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiParetoArea.implementsStiParetoArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiParetoSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiParetoSeries
                    ];
                }
                get componentId() {
                    return Report.StiComponentId.StiParetoArea;
                }
                createNew() {
                    return new StiParetoArea();
                }
            }
            Chart.StiParetoArea = StiParetoArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSplineArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSplineAreaCoreXF(this);
                }
                implements() {
                    if (!StiSplineArea.implementsStiSplineArea)
                        StiSplineArea.implementsStiSplineArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiSplineArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSplineArea.implementsStiSplineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSplineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineArea;
                }
                createNew() {
                    return new StiSplineArea();
                }
            }
            Chart.StiSplineArea = StiSplineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSplineAreaArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSplineAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiSplineAreaArea.implementsStiSplineAreaArea)
                        StiSplineAreaArea.implementsStiSplineAreaArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiSplineAreaArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSplineAreaArea.implementsStiSplineAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSplineAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineAreaArea;
                }
                createNew() {
                    return new StiSplineAreaArea();
                }
            }
            Chart.StiSplineAreaArea = StiSplineAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSteppedAreaArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSteppedAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiSteppedAreaArea.implementsStiSteppedAreaArea)
                        StiSteppedAreaArea.implementsStiSteppedAreaArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiSteppedAreaArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSteppedAreaArea.implementsStiSteppedAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSteppedAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedAreaArea;
                }
                createNew() {
                    return new StiSteppedAreaArea();
                }
            }
            Chart.StiSteppedAreaArea = StiSteppedAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSteppedLineArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSteppedLineAreaCoreXF(this);
                }
                implements() {
                    if (!StiSteppedLineArea.implementsStiSteppedLineArea)
                        StiSteppedLineArea.implementsStiSteppedLineArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            Chart.IStiSteppedLineArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSteppedLineArea.implementsStiSteppedLineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSteppedLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedLineArea;
                }
                createNew() {
                    return new StiSteppedLineArea();
                }
            }
            Chart.StiSteppedLineArea = StiSteppedLineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiWaterfallArea extends Chart.StiAxisArea {
                constructor() {
                    super();
                    this.roundValues = false;
                    this.core = new Chart.StiWaterfallAreaCoreXF(this);
                }
                implements() {
                    if (!StiWaterfallArea.implementsStiWaterfallArea)
                        StiWaterfallArea.implementsStiWaterfallArea = super.implements().concat([
                            Chart.IStiWaterfallArea,
                            Chart.IStiRoundValuesArea,
                        ]);
                    return StiWaterfallArea.implementsStiWaterfallArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("RoundValues", this.roundValues);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "RoundValues":
                                this.roundValues = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "RoundValues":
                                this.roundValues = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiWaterfallArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiWaterfallSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiWaterfallSeries
                    ];
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiInsideBaseAxisLabels,
                        Chart.StiInsideEndAxisLabels,
                        Chart.StiCenterAxisLabels,
                        Chart.StiOutsideBaseAxisLabels,
                        Chart.StiOutsideEndAxisLabels,
                        Chart.StiOutsideAxisLabels,
                        Chart.StiValueAxisLabels];
                }
                createNew() {
                    return new StiWaterfallArea();
                }
            }
            Chart.StiWaterfallArea = StiWaterfallArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiPieArea extends Chart.StiArea {
                constructor() {
                    super();
                    this.core = new Chart.StiPieAreaCoreXF(this);
                    this.colorEach = true;
                }
                implements() {
                    if (!StiPieArea.implementsStiPieArea)
                        StiPieArea.implementsStiPieArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiPieArea,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiPieArea.implementsStiPieArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("ColorEach");
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiPieArea;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiCenterPieLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiInsideEndPieLabels,
                        Chart.StiCenterPieLabels,
                        Chart.StiOutsidePieLabels,
                        Chart.StiTwoColumnsPieLabels];
                }
                getDefaultSeriesType() {
                    return Chart.StiPieSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiPieSeries];
                }
                createNew() {
                    return new StiPieArea();
                }
            }
            Chart.StiPieArea = StiPieArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiDoughnutArea extends Chart.StiPieArea {
                constructor() {
                    super();
                    this.core = new Chart.StiDoughnutAreaCoreXF(this);
                    this.colorEach = true;
                }
                implements() {
                    if (!StiDoughnutArea.implementsStiDoughnutArea)
                        StiDoughnutArea.implementsStiDoughnutArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiPieArea,
                            Chart.IStiArea,
                            ICloneable,
                            Chart.IStiDoughnutArea
                        ]);
                    return StiDoughnutArea.implementsStiDoughnutArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("ColorEach");
                    return jObject;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiCenterPieLabels;
                }
                getSeriesLabelsTypes() {
                    return [
                        Chart.StiNoneLabels,
                        Chart.StiCenterPieLabels
                    ];
                }
                getDefaultSeriesType() {
                    return Chart.StiDoughnutSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiDoughnutSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiDoughnutArea;
                }
                createNew() {
                    return new StiDoughnutArea();
                }
            }
            Chart.StiDoughnutArea = StiDoughnutArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedBarArea extends Chart.StiClusteredBarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedBarAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedBarArea.implementsStiStackedBarArea)
                        StiStackedBarArea.implementsStiStackedBarArea = super.implements().concat([
                            Chart.IStiClusteredBarArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            Chart.IStiStackedBarArea,
                            ICloneable
                        ]);
                    return StiStackedBarArea.implementsStiStackedBarArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedBarSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiStackedBarSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedBarArea;
                }
                createNew() {
                    return new StiStackedBarArea();
                }
            }
            Chart.StiStackedBarArea = StiStackedBarArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedBarArea extends Chart.StiStackedBarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedBarAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedBarArea.implementsStiFullStackedBarArea)
                        StiFullStackedBarArea.implementsStiFullStackedBarArea = super.implements().concat([
                            Chart.IStiClusteredBarArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedBarArea,
                            Chart.IStiStackedBarArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiFullStackedBarArea.implementsStiFullStackedBarArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedBarSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiFullStackedBarSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedBarArea;
                }
                createNew() {
                    return new StiFullStackedBarArea();
                }
            }
            Chart.StiFullStackedBarArea = StiFullStackedBarArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedColumnArea extends Chart.StiAxisArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedColumnAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedColumnArea.implementsStiStackedColumnArea)
                        StiStackedColumnArea.implementsStiStackedColumnArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedColumnArea,
                            Chart.IStiAxisArea,
                            ICloneable,
                            Chart.IStiArea
                        ]);
                    return StiStackedColumnArea.implementsStiStackedColumnArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedColumnArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedColumnSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiStackedColumnSeries,
                        Chart.StiStackedLineSeries,
                        Chart.StiStackedSplineSeries,
                        Chart.StiStackedAreaSeries,
                        Chart.StiStackedSplineAreaSeries];
                }
                createNew() {
                    return new StiStackedColumnArea();
                }
            }
            Chart.StiStackedColumnArea = StiStackedColumnArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedColumnArea extends Chart.StiStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedColumnAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedColumnArea.implementsStiFullStackedColumnArea)
                        StiFullStackedColumnArea.implementsStiFullStackedColumnArea = super.implements().concat([
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedColumnArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiFullStackedColumnArea.implementsStiFullStackedColumnArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedColumnSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiFullStackedColumnSeries,
                        Chart.StiFullStackedLineSeries,
                        Chart.StiFullStackedAreaSeries,
                        Chart.StiFullStackedSplineSeries,
                        Chart.StiFullStackedSplineAreaSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedColumnArea();
                }
            }
            Chart.StiFullStackedColumnArea = StiFullStackedColumnArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedAreaArea extends Chart.StiFullStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedAreaArea.implementsStiFullStackedAreaArea)
                        StiFullStackedAreaArea.implementsStiFullStackedAreaArea = super.implements().concat([
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedColumnArea,
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiFullStackedAreaArea
                        ]);
                    return StiFullStackedAreaArea.implementsStiFullStackedAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedAreaArea;
                }
                createNew() {
                    return new StiFullStackedAreaArea();
                }
            }
            Chart.StiFullStackedAreaArea = StiFullStackedAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedLineArea extends Chart.StiFullStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedLineAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedLineArea.implementsStiFullStackedLineArea)
                        StiFullStackedLineArea.implementsStiFullStackedLineArea = super.implements().concat([
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedColumnArea,
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiFullStackedLineArea
                        ]);
                    return StiFullStackedLineArea.implementsStiFullStackedLineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedLineArea;
                }
                createNew() {
                    return new StiFullStackedLineArea();
                }
            }
            Chart.StiFullStackedLineArea = StiFullStackedLineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedSplineArea extends Chart.StiFullStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedSplineAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedSplineArea.implementsStiFullStackedSplineArea)
                        StiFullStackedSplineArea.implementsStiFullStackedSplineArea = super.implements().concat([
                            Chart.IStiFullStackedSplineArea,
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedColumnArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiFullStackedSplineArea.implementsStiFullStackedSplineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedSplineAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedSplineArea;
                }
                createNew() {
                    return new StiFullStackedSplineArea();
                }
            }
            Chart.StiFullStackedSplineArea = StiFullStackedSplineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedSplineAreaArea extends Chart.StiFullStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedSplineAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedSplineAreaArea.implementsStiFullStackedSplineAreaArea)
                        StiFullStackedSplineAreaArea.implementsStiFullStackedSplineAreaArea = super.implements().concat([
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiFullStackedColumnArea,
                            Chart.IStiFullStackedSplineAreaArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiFullStackedSplineAreaArea.implementsStiFullStackedSplineAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFullStackedSplineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedSplineAreaArea;
                }
                createNew() {
                    return new StiFullStackedSplineAreaArea();
                }
            }
            Chart.StiFullStackedSplineAreaArea = StiFullStackedSplineAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFunnelArea extends Chart.StiArea {
                constructor() {
                    super();
                    this.core = new Chart.StiFunnelAreaCoreXF(this);
                    this.colorEach = true;
                }
                implements() {
                    if (!StiFunnelArea.implementsStiFunnelArea)
                        StiFunnelArea.implementsStiFunnelArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiArea,
                            ICloneable,
                            Chart.IStiFunnelArea
                        ]);
                    return StiFunnelArea.implementsStiFunnelArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("ColorEach");
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiFunnelArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFunnelSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiFunnelSeries];
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiNoneLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiCenterFunnelLabels,
                        Chart.StiOutsideRightFunnelLabels,
                        Chart.StiOutsideLeftFunnelLabels];
                }
                createNew() {
                    return new StiFunnelArea();
                }
            }
            Chart.StiFunnelArea = StiFunnelArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiFunnelWeightedSlicesArea extends Chart.StiFunnelArea {
                get componentId() {
                    return Report.StiComponentId.StiFunnelWeightedSlicesArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiFunnelWeightedSlicesSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiFunnelWeightedSlicesSeries
                    ];
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiNoneLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels, Chart.StiCenterFunnelLabels];
                }
                createNew() {
                    return new StiFunnelWeightedSlicesArea();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiFunnelAreaCoreXF(this);
                    this.colorEach = true;
                }
            }
            Chart.StiFunnelWeightedSlicesArea = StiFunnelWeightedSlicesArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiGanttArea extends Chart.StiClusteredBarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiGanttAreaCoreXF(this);
                }
                implements() {
                    if (!StiGanttArea.implementsStiGanttArea)
                        StiGanttArea.implementsStiGanttArea = super.implements().concat([
                            Chart.IStiClusteredBarArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            Chart.IStiGanttArea,
                            ICloneable
                        ]);
                    return StiGanttArea.implementsStiGanttArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiGanttSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiGanttSeries];
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiValueAxisLabels,
                        Chart.StiCenterAxisLabels,
                        Chart.StiOutsideAxisLabels];
                }
                get componentId() {
                    return Report.StiComponentId.StiGanttArea;
                }
                createNew() {
                    return new StiGanttArea();
                }
            }
            Chart.StiGanttArea = StiGanttArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiPictorialArea extends Chart.StiArea {
                constructor() {
                    super();
                    this.roundValues = true;
                    this.actual = false;
                    this.core = new Chart.StiPictorialAreaCoreXF(this);
                    this.colorEach = true;
                    this.roundValues = true;
                }
                implements() {
                    if (!StiPictorialArea.implementsStiPictorialArea)
                        StiPictorialArea.implementsStiPictorialArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiPictorialArea,
                            Chart.IStiRoundValuesArea,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiPictorialArea.implementsStiPictorialArea;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("RoundValues", this.roundValues, true);
                    jObject.addPropertyBool("Actual", this.actual);
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiPictorialArea;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiNoneLabels;
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels];
                }
                getDefaultSeriesType() {
                    return Chart.StiPictorialSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiPictorialSeries];
                }
                createNew() {
                    return new StiPictorialArea();
                }
            }
            Chart.StiPictorialArea = StiPictorialArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarAreaArea extends Chart.StiRadarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiRadarAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiRadarAreaArea.implementsStiRadarAreaArea)
                        StiRadarAreaArea.implementsStiRadarAreaArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarArea,
                            Chart.IStiArea,
                            Chart.IStiRadarAreaArea,
                            ICloneable
                        ]);
                    return StiRadarAreaArea.implementsStiRadarAreaArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiRadarAreaSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiRadarPointSeries,
                        Chart.StiRadarLineSeries,
                        Chart.StiRadarAreaSeries];
                }
                createNew() {
                    return new StiRadarAreaArea();
                }
            }
            Chart.StiRadarAreaArea = StiRadarAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarLineArea extends Chart.StiRadarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiRadarLineAreaCoreXF(this);
                }
                implements() {
                    if (!StiRadarLineArea.implementsStiRadarLineArea)
                        StiRadarLineArea.implementsStiRadarLineArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarArea,
                            Chart.IStiArea,
                            ICloneable,
                            Chart.IStiRadarLineArea
                        ]);
                    return StiRadarLineArea.implementsStiRadarLineArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarLineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiRadarLineSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiRadarPointSeries,
                        Chart.StiRadarLineSeries,
                        Chart.StiRadarAreaSeries];
                }
                createNew() {
                    return new StiRadarLineArea();
                }
            }
            Chart.StiRadarLineArea = StiRadarLineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarPointArea extends Chart.StiRadarArea {
                constructor() {
                    super();
                    this.core = new Chart.StiRadarPointAreaCoreXF(this);
                }
                implements() {
                    if (!StiRadarPointArea.implementsStiRadarPointArea)
                        StiRadarPointArea.implementsStiRadarPointArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarPointArea,
                            Chart.IStiRadarArea,
                            Chart.IStiArea,
                            ICloneable
                        ]);
                    return StiRadarPointArea.implementsStiRadarPointArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarPointArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiRadarPointSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiRadarPointSeries,
                        Chart.StiRadarLineSeries,
                        Chart.StiRadarAreaSeries];
                }
                createNew() {
                    return new StiRadarPointArea();
                }
            }
            Chart.StiRadarPointArea = StiRadarPointArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRangeArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiRangeAreaCoreXF(this);
                }
                implements() {
                    if (!StiRangeArea.implementsStiRangeArea)
                        StiRangeArea.implementsStiRangeArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiRangeArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiRangeArea.implementsStiRangeArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiRangeSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiRangeSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiRangeArea;
                }
                createNew() {
                    return new StiRangeArea();
                }
            }
            Chart.StiRangeArea = StiRangeArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRangeBarArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiRangeBarAreaCoreXF(this);
                }
                implements() {
                    if (!StiRangeBarArea.implementsStiRangeBarArea)
                        StiRangeBarArea.implementsStiRangeBarArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiRangeBarArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiRangeBarArea.implementsStiRangeBarArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiRangeBarSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiRangeBarSeries];
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels,
                        Chart.StiInsideBaseAxisLabels,
                        Chart.StiOutsideBaseAxisLabels,
                        Chart.StiOutsideAxisLabels,
                        Chart.StiLeftAxisLabels,
                        Chart.StiValueAxisLabels,
                        Chart.StiRightAxisLabels];
                }
                get componentId() {
                    return Report.StiComponentId.StiRangeBarArea;
                }
                createNew() {
                    return new StiRangeBarArea();
                }
            }
            Chart.StiRangeBarArea = StiRangeBarArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSplineRangeArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSplineRangeAreaCoreXF(this);
                }
                implements() {
                    if (!StiSplineRangeArea.implementsStiSplineRangeArea)
                        StiSplineRangeArea.implementsStiSplineRangeArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiSplineRangeArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSplineRangeArea.implementsStiSplineRangeArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSplineRangeSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiSplineRangeSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineRangeArea;
                }
                createNew() {
                    return new StiSplineRangeArea();
                }
            }
            Chart.StiSplineRangeArea = StiSplineRangeArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSteppedRangeArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSteppedRangeAreaCoreXF(this);
                }
                implements() {
                    if (!StiSteppedRangeArea.implementsStiSteppedRangeArea)
                        StiSteppedRangeArea.implementsStiSteppedRangeArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiSteppedRangeArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiSteppedRangeArea.implementsStiSteppedRangeArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiSteppedRangeSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiSteppedRangeSeries];
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedRangeArea;
                }
                createNew() {
                    return new StiSteppedRangeArea();
                }
            }
            Chart.StiSteppedRangeArea = StiSteppedRangeArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedAreaArea extends Chart.StiStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedAreaArea.implementsStiStackedAreaArea)
                        StiStackedAreaArea.implementsStiStackedAreaArea = super.implements().concat([
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiStackedAreaArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiStackedAreaArea.implementsStiStackedAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedAreaArea;
                }
                createNew() {
                    return new StiStackedAreaArea();
                }
            }
            Chart.StiStackedAreaArea = StiStackedAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedLineArea extends Chart.StiStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedLineAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedLineArea.implementsStiStackedLineArea)
                        StiStackedLineArea.implementsStiStackedLineArea = super.implements().concat([
                            Chart.IStiStackedLineArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            Chart.IStiStackedColumnArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiStackedLineArea.implementsStiStackedLineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedLineArea;
                }
                createNew() {
                    return new StiStackedLineArea();
                }
            }
            Chart.StiStackedLineArea = StiStackedLineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedSplineArea extends Chart.StiStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedSplineAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedSplineArea.implementsStiStackedSplineArea)
                        StiStackedSplineArea.implementsStiStackedSplineArea = super.implements().concat([
                            Chart.IStiStackedSplineArea,
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiStackedSplineArea.implementsStiStackedSplineArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedSplineAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedSplineArea;
                }
                createNew() {
                    return new StiStackedSplineArea();
                }
            }
            Chart.StiStackedSplineArea = StiStackedSplineArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedSplineAreaArea extends Chart.StiStackedColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedSplineAreaAreaCoreXF(this);
                }
                implements() {
                    if (!StiStackedSplineAreaArea.implementsStiStackedSplineAreaArea)
                        StiStackedSplineAreaArea.implementsStiStackedSplineAreaArea = super.implements().concat([
                            Chart.IStiAxisArea,
                            Chart.IStiStackedColumnArea,
                            Chart.IStiArea,
                            Chart.IStiStackedSplineAreaArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiStackedSplineAreaArea.implementsStiStackedSplineAreaArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStackedSplineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedSplineAreaArea;
                }
                createNew() {
                    return new StiStackedSplineAreaArea();
                }
            }
            Chart.StiStackedSplineAreaArea = StiStackedSplineAreaArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStockArea extends Chart.StiClusteredColumnArea {
                constructor() {
                    super();
                    this.core = new Chart.StiStockAreaCoreXF(this);
                }
                implements() {
                    if (!StiStockArea.implementsStiStockArea)
                        StiStockArea.implementsStiStockArea = super.implements().concat([
                            Chart.IStiArea,
                            Chart.IStiStockArea,
                            Chart.IStiClusteredColumnArea,
                            Chart.IStiAxisArea,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiStockArea.implementsStiStockArea;
                }
                getDefaultSeriesType() {
                    return Chart.StiStockSeries;
                }
                getSeriesTypes() {
                    return [Chart.StiStockSeries];
                }
                getSeriesLabelsTypes() {
                    return [Chart.StiNoneLabels];
                }
                get componentId() {
                    return Report.StiComponentId.StiStockArea;
                }
                createNew() {
                    return new StiStockArea();
                }
            }
            Chart.StiStockArea = StiStockArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSunburstArea extends Chart.StiArea {
                constructor() {
                    super();
                    this.core = new Chart.StiSunburstAreaCoreXF(this);
                }
                implements() {
                    if (!StiSunburstArea.implementsStiSunburstArea)
                        StiSunburstArea.implementsStiSunburstArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSunburstArea,
                            ICloneable
                        ]);
                    return StiSunburstArea.implementsStiSunburstArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiSunburstArea;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiCenterPieLabels;
                }
                getSeriesLabelsTypes() {
                    return [
                        Chart.StiNoneLabels,
                        Chart.StiCenterPieLabels
                    ];
                }
                getDefaultSeriesType() {
                    return Chart.StiSunburstSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiSunburstSeries
                    ];
                }
                createNew() {
                    return new StiSunburstArea();
                }
            }
            Chart.StiSunburstArea = StiSunburstArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTreemapArea extends Chart.StiArea {
                constructor() {
                    super();
                    this.core = new Chart.StiTreemapAreaCoreXF(this);
                }
                implements() {
                    if (!StiTreemapArea.implementsStiTreemapArea)
                        StiTreemapArea.implementsStiTreemapArea = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiTreemapArea,
                            ICloneable
                        ]);
                    return StiTreemapArea.implementsStiTreemapArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiTreemapArea;
                }
                getDefaultSeriesLabelsType() {
                    return Chart.StiNoneLabels;
                }
                getSeriesLabelsTypes() {
                    return [
                        Chart.StiNoneLabels,
                        Chart.StiCenterTreemapLabels
                    ];
                }
                getDefaultSeriesType() {
                    return Chart.StiTreemapSeries;
                }
                getSeriesTypes() {
                    return [
                        Chart.StiTreemapSeries
                    ];
                }
                createNew() {
                    return new StiTreemapArea();
                }
            }
            Chart.StiTreemapArea = StiTreemapArea;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StringAlignment = Stimulsoft.System.Drawing.StringAlignment;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            var FontStyle = Stimulsoft.System.Drawing.FontStyle;
            class StiAxisTitle {
                constructor(font = new Font("Tahoma", 12, FontStyle.Bold), text = "", color = Color.black, antialiasing = true, alignment = StringAlignment.Center, direction = Chart.StiDirection.LeftToRight, allowApplyStyle = true, position = Chart.StiTitlePosition.Outside) {
                    this._allowApplyStyle = true;
                    this._font = new Font("Tahoma", 12, FontStyle.Bold);
                    this._text = "";
                    this._color = Color.black;
                    this._antialiasing = true;
                    this._alignment = StringAlignment.Center;
                    this._position = Chart.StiTitlePosition.Outside;
                    this._direction = Chart.StiDirection.LeftToRight;
                    this._font = font;
                    this._text = text;
                    this._color = color;
                    this._antialiasing = antialiasing;
                    this._alignment = alignment;
                    this._direction = direction;
                    this._allowApplyStyle = allowApplyStyle;
                    this._position = position;
                    this._core = new Chart.StiAxisTitleCoreXF(this);
                }
                implements() {
                    if (!StiAxisTitle.implementsStiAxisTitle)
                        StiAxisTitle.implementsStiAxisTitle = [Chart.IStiAxisTitle,
                            ICloneable,
                            IStiJsonReportObject];
                    return StiAxisTitle.implementsStiAxisTitle;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this._font, "Tahoma", 12, FontStyle.Bold));
                    jObject.addPropertyStringNullOrEmpty("Text", this._text);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this._color, Color.black));
                    jObject.addPropertyBool("Antialiasing", this._antialiasing, true);
                    jObject.addPropertyEnum("Alignment", StringAlignment, this._alignment, StringAlignment.Center);
                    jObject.addPropertyEnum("Position", Chart.StiTitlePosition, this._position, Chart.StiTitlePosition.Outside);
                    jObject.addPropertyEnum("Direction", Chart.StiDirection, this.direction, Chart.StiDirection.LeftToRight);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Font":
                                this._font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this._font);
                                break;
                            case "Text":
                                this._text = property.value.toString();
                                break;
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Antialiasing":
                                this._antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Alignment":
                                this._alignment = Enum.parse(StringAlignment, property.value.toString());
                                break;
                            case "Position":
                                this._position = Enum.parse(Chart.StiTitlePosition, property.value.toString());
                                break;
                            case "Direction":
                                this.direction = Enum.parse(Chart.StiDirection, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Font":
                            case "fn":
                                this._font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Text":
                            case "text":
                                this._text = node.textContent;
                                break;
                            case "Color":
                                this._color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Antialiasing":
                                this._antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Alignment":
                                this._alignment = Enum.parse(StringAlignment, node.textContent);
                                break;
                            case "Position":
                                this._position = Enum.parse(Chart.StiTitlePosition, node.textContent);
                                break;
                            case "Direction":
                                this.direction = Enum.parse(Chart.StiDirection, node.textContent);
                                break;
                        }
                    }
                }
                clone() {
                    let title = this.stimulsoft().memberwiseClone();
                    title.alignment = this.alignment;
                    title.direction = this.direction;
                    title.font = this.font.clone();
                    if (this.core != null) {
                        title.core = this.core.clone();
                        title.core.title = title;
                    }
                    return title;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get text() {
                    return this._text;
                }
                set text(value) {
                    this._text = value;
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get alignment() {
                    return this._alignment;
                }
                set alignment(value) {
                    this._alignment = value;
                }
                get position() {
                    return this._position;
                }
                set position(value) {
                    this._position = value;
                }
                get direction() {
                    return this._direction;
                }
                set direction(value) {
                    this._direction = value;
                }
            }
            Chart.StiAxisTitle = StiAxisTitle;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiService = Stimulsoft.Base.Services.StiService;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiConstantLines extends StiService {
                constructor() {
                    super();
                    this._allowApplyStyle = true;
                    this._antialiasing = true;
                    this._position = Chart.StiConstantLines_StiTextPosition.LeftTop;
                    this._font = new Font("Arial", 7);
                    this._text = "";
                    this._titleVisible = true;
                    this._orientation = Chart.StiConstantLines_StiOrientation.Horizontal;
                    this._lineWidth = 1;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lineColor = Color.black;
                    this._showInLegend = true;
                    this._showBehind = false;
                    this._axisValue = "1";
                    this._visible = true;
                    this._core = new Chart.StiConstantLinesCoreXF(this);
                }
                implements() {
                    if (!StiConstantLines.implementsStiConstantLines)
                        StiConstantLines.implementsStiConstantLines = super.implements().concat([
                            Chart.IStiConstantLines,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiConstantLines.implementsStiConstantLines;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyBool("Antialiasing", this.antialiasing, true);
                    jObject.addPropertyEnum("Position", Chart.StiConstantLines_StiTextPosition, this._position, Chart.StiConstantLines_StiTextPosition.LeftTop);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this.font, "Arial", 7));
                    jObject.addPropertyStringNullOrEmpty("Text", this._text);
                    jObject.addPropertyBool("TitleVisible", this._titleVisible, true);
                    jObject.addPropertyEnum("Orientation", Chart.StiConstantLines_StiOrientation, this._orientation, Chart.StiConstantLines_StiOrientation.Horizontal);
                    jObject.addPropertyNumber("LineWidth", this._lineWidth, 1);
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this._lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this._lineColor, Color.black));
                    jObject.addPropertyBool("ShowInLegend", this.showInLegend, true);
                    jObject.addPropertyBool("ShowBehind", this.showBehind);
                    jObject.addPropertyString("AxisValue", this.axisValue, "1");
                    jObject.addPropertyBool("Visible", this.visible, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Antialiasing":
                                this.antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Position":
                                this._position = Enum.parse(Chart.StiConstantLines_StiTextPosition, property.value.toString());
                                break;
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "Text":
                                this._text = property.value.toString();
                                break;
                            case "TitleVisible":
                                this._titleVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Orientation":
                                this._orientation = Enum.parse(Chart.StiConstantLines_StiOrientation, property.value.toString());
                                break;
                            case "LineWidth":
                                this._lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "ShowInLegend":
                                this.showInLegend = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowBehind":
                                this.showBehind = property.value.stimulsoft().toBoolean();
                                break;
                            case "AxisValue":
                                this.axisValue = property.value.toString();
                                break;
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Antialiasing":
                                this.antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Position":
                                this._position = Enum.parse(Chart.StiConstantLines_StiTextPosition, node.textContent);
                                break;
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Text":
                            case "text":
                                this._text = node.textContent;
                                break;
                            case "TitleVisible":
                                this._titleVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Orientation":
                                this._orientation = Enum.parse(Chart.StiConstantLines_StiOrientation, node.textContent);
                                break;
                            case "LineWidth":
                                this._lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "ShowInLegend":
                                this.showInLegend = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowBehind":
                                this.showBehind = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AxisValue":
                                this.axisValue = node.textContent;
                                break;
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiConstantLines;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let lines = this.stimulsoft().memberwiseClone();
                    if (this.core != null) {
                        lines.core = this.core.clone();
                        lines.core.constantLines = lines;
                    }
                    return lines;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get ServiceType() {
                    return StiConstantLines;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get position() {
                    return this._position;
                }
                set position(value) {
                    this._position = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get text() {
                    return this._text;
                }
                set text(value) {
                    this._text = value;
                }
                get titleVisible() {
                    return this._titleVisible;
                }
                set titleVisible(value) {
                    this._titleVisible = value;
                }
                get orientation() {
                    return this._orientation;
                }
                set orientation(value) {
                    this._orientation = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    this._lineWidth = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get showInLegend() {
                    return this._showInLegend;
                }
                set showInLegend(value) {
                    this._showInLegend = value;
                }
                get showBehind() {
                    return this._showBehind;
                }
                set showBehind(value) {
                    this._showBehind = value;
                }
                get axisValue() {
                    return this._axisValue;
                }
                set axisValue(value) {
                    this._axisValue = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
                toString() {
                    return this.serviceName;
                }
            }
            Chart.StiConstantLines = StiConstantLines;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            var Enum = Stimulsoft.System.Enum;
            var XMLConvert = Stimulsoft.System.Text.XMLConvert;
            var StiFilterCondition = Stimulsoft.Report.Components.StiFilterCondition;
            var StiFilterItem = Stimulsoft.Report.Components.StiFilterItem;
            var StiFilterDataType = Stimulsoft.Report.Components.StiFilterDataType;
            class StiChartFiltersCollection extends CollectionBase {
                implements() {
                    if (!StiChartFiltersCollection.implementsStiChartFiltersCollection)
                        StiChartFiltersCollection.implementsStiChartFiltersCollection = [
                            IStiJsonReportObject,
                            ICloneable
                        ];
                    return StiChartFiltersCollection.implementsStiChartFiltersCollection;
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let filter of this.list) {
                        jObject.addPropertyJObject(index.toString(), filter.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let filter = new Chart.StiChartFilter();
                        this.add(filter);
                        filter.loadFromJsonObject(property.value);
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.nodeName == "value") {
                            let words = node.textContent.split(",");
                            let filterCondition = words[2];
                            if (filterCondition == "GreaterThen")
                                filterCondition = "GreaterThan";
                            if (filterCondition == "GreaterThenOrEqualTo")
                                filterCondition = "GreaterThanOrEqualTo";
                            if (filterCondition == "LessThen")
                                filterCondition = "LessThan";
                            if (filterCondition == "LessThenOrEqualTo")
                                filterCondition = "LessThanOrEqualTo";
                            let filter = new Chart.StiChartFilter(Enum.parse(StiFilterItem, words[0]), Enum.parse(StiFilterDataType, words[1]), Enum.parse(StiFilterCondition, filterCondition), XMLConvert.decodeName(words[3]));
                            this.add(filter);
                        }
                    }
                }
                clone() {
                    let filters = new StiChartFiltersCollection();
                    for (let filter of this.list) {
                        filters.add(filter.clone());
                    }
                    return filters;
                }
                add(filter) {
                    this.list.push(filter);
                    if (filter.filters == null)
                        filter.filters = this;
                }
            }
            Chart.StiChartFiltersCollection = StiChartFiltersCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiDataItem {
                constructor(argument, value, valueEnd, weight, valueOpen, valueClose, valueLow, valueHight, title, key, color, toolTip, tag) {
                    this.argument = argument;
                    this.value = value;
                    this.valueEnd = valueEnd;
                    this.weight = weight;
                    this.valueOpen = valueOpen;
                    this.valueClose = valueClose;
                    this.valueLow = valueLow;
                    this.valueHigh = valueHight;
                    this.title = title;
                    this.key = key;
                    this.color = color;
                    this.toolTip = toolTip;
                    this.tag = tag;
                }
            }
            Chart.StiDataItem = StiDataItem;
            class StiDataItemComparer {
                constructor(sortType, sortDirection) {
                    this.directionFactor = 1;
                    this.sortType = Chart.StiSeriesSortType.None;
                    this.directionFactor = 1;
                    if (sortDirection == Chart.StiSeriesSortDirection.Descending)
                        this.directionFactor = -1;
                    this.sortType = sortType;
                }
                compare(x, y) {
                    let value1 = null;
                    let value2 = null;
                    if (this.sortType == Chart.StiSeriesSortType.Value) {
                        value1 = x.value;
                        value2 = y.value;
                    }
                    else {
                        value1 = x.argument;
                        value2 = y.argument;
                    }
                    if (value1 == null && value2 == null)
                        return 0;
                    if (value1 == null)
                        return 1;
                    if (value2 == null)
                        return -1;
                    return value1.stimulsoft().compareTo(value2) * this.directionFactor;
                }
            }
            Chart.StiDataItemComparer = StiDataItemComparer;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRadarGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Solid, visible = true, allowApplyStyle = true) {
                    this.needSetAreaJsonPropertyInternal = false;
                    this._allowApplyStyle = true;
                    this._color = Color.silver;
                    this._style = StiPenStyle.Solid;
                    this._visible = true;
                    this._color = color;
                    this._style = style;
                    this._visible = visible;
                    this._allowApplyStyle = allowApplyStyle;
                    this._core = new Chart.StiRadarGridLinesCoreXF(this);
                }
                implements() {
                    if (!StiRadarGridLines.implementsStiRadarGridLines)
                        StiRadarGridLines.implementsStiRadarGridLines = [
                            IStiJsonReportObject,
                            Chart.IStiRadarGridLines,
                            ICloneable
                        ];
                    return StiRadarGridLines.implementsStiRadarGridLines;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this._color, Color.silver));
                    jObject.addPropertyEnum("Style", StiPenStyle, this._style, StiPenStyle.Solid);
                    jObject.addPropertyBool("Visible", this._visible, true);
                    if (this._area != null)
                        jObject.addPropertyBool("Area", true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Style":
                                this._style = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Style":
                                this._style = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.needSetAreaJsonPropertyInternal = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarGridLines;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let gridLines = this.stimulsoft().memberwiseClone();
                    gridLines.style = this.style;
                    if (this.core != null) {
                        gridLines.core = this.core.clone();
                        gridLines.core.gridLines = gridLines;
                    }
                    return gridLines;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.area != null && this.area.chart != null)
                            this.core.applyStyle(this.area.chart.style);
                    }
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get style() {
                    return this._style;
                }
                set style(value) {
                    this._style = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
            }
            Chart.StiRadarGridLines = StiRadarGridLines;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRadarGridLinesHor extends Chart.StiRadarGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Solid, visible = true, allowApplyStyle = true) {
                    super(color, style, visible, allowApplyStyle);
                }
                implements() {
                    if (!StiRadarGridLinesHor.implementsStiRadarGridLinesHor)
                        StiRadarGridLinesHor.implementsStiRadarGridLinesHor = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarGridLines,
                            Chart.IStiRadarGridLinesHor,
                            ICloneable
                        ]);
                    return StiRadarGridLinesHor.implementsStiRadarGridLinesHor;
                }
            }
            Chart.StiRadarGridLinesHor = StiRadarGridLinesHor;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRadarGridLinesVert extends Chart.StiRadarGridLines {
                constructor(color = Color.silver, style = StiPenStyle.Solid, visible = true, allowApplyStyle = true) {
                    super(color, style, visible, allowApplyStyle);
                }
                implements() {
                    if (!StiRadarGridLinesVert.implementsStiRadarGridLinesVert)
                        StiRadarGridLinesVert.implementsStiRadarGridLinesVert = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarGridLines,
                            Chart.IStiRadarGridLinesVert,
                            ICloneable
                        ]);
                    return StiRadarGridLinesVert.implementsStiRadarGridLinesVert;
                }
            }
            Chart.StiRadarGridLinesVert = StiRadarGridLinesVert;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiMarker {
                constructor() {
                    this._showInLegend = true;
                    this._visible = true;
                    this._extendedVisible = Chart.StiExtendedStyleBool.FromStyle;
                    this._brush = new StiSolidBrush(Color.white);
                    this._borderColor = Color.black;
                    this._size = 7;
                    this._angle = 0;
                    this._type = Chart.StiMarkerType.Circle;
                    this.icon = null;
                    this._core = new Chart.StiMarkerCoreXF(this);
                }
                implements() {
                    if (!Chart.StiLineMarker.implementsStiMarker)
                        Chart.StiLineMarker.implementsStiMarker = [
                            IStiJsonReportObject,
                            Chart.IStiMarker,
                            ICloneable
                        ];
                    return Chart.StiLineMarker.implementsStiMarker;
                }
                is(type) {
                    if (type instanceof Stimulsoft.System.Interface)
                        return this.implements().indexOf(type) != -1;
                    if (typeof type == "function")
                        return this instanceof type;
                    if (type == undefined)
                        throw new Error("Type for comparison is 'undefined'");
                    return false;
                }
                is2(type) {
                    return this.is(type);
                }
                as(type) {
                    if (this.is(type))
                        return this;
                    return null;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("ShowInLegend", this.showInLegend, true);
                    jObject.addPropertyBool("Visible", this.visible, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.black));
                    jObject.addPropertyNumber("Size", this.size, 7);
                    jObject.addPropertyNumber("Angle", this.angle, 0);
                    jObject.addPropertyEnum("Type", Chart.StiMarkerType, this._type, Chart.StiMarkerType.Circle);
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowInLegend":
                                this._showInLegend = property.value.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this._visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this.brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Size":
                                this.size = property.value.stimulsoft().toNumber();
                                break;
                            case "Angle":
                                this.angle = property.value.stimulsoft().toNumber();
                                break;
                            case "Type":
                                this._type = Enum.parse(Chart.StiMarkerType, property.value.toString());
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowInLegend":
                                this._showInLegend = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this._visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this.brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Size":
                                this.size = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Angle":
                                this.angle = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Type":
                                this._type = Enum.parse(Chart.StiMarkerType, node.textContent);
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiMarker;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let marker = this.stimulsoft().memberwiseClone();
                    if (this.core != null) {
                        marker.core = this.core.clone();
                        marker.core.marker = marker;
                    }
                    return marker;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get showInLegend() {
                    return this._showInLegend;
                }
                set showInLegend(value) {
                    this._showInLegend = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get extendedVisible() {
                    return this._extendedVisible;
                }
                set extendedVisible(value) {
                    this._extendedVisible = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get size() {
                    return this._size;
                }
                set size(value) {
                    this._size = value;
                }
                get angle() {
                    return this._angle;
                }
                set angle(value) {
                    this._angle = value;
                }
                get type() {
                    return this._type;
                }
                set type(value) {
                    this._type = value;
                }
            }
            Chart.StiMarker = StiMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiLineMarker extends Chart.StiMarker {
                constructor() {
                    super();
                    this.step = 15;
                    this.visible = false;
                    this.borderColor = Color.transparent;
                    this.size = 5;
                }
                implements() {
                    if (!StiLineMarker.implementsStiLineMarker)
                        StiLineMarker.implementsStiLineMarker = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiLineMarker,
                            Chart.IStiMarker,
                            ICloneable
                        ]);
                    return StiLineMarker.implementsStiLineMarker;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyNumber("Step", this.step, 15);
                    jObject.addPropertyNumber("Size", this.size, 5);
                    jObject.addPropertyBool("Visible", this.visible, false);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this.borderColor, Color.transparent));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Step":
                                this.step = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Step":
                                this.step = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiLineMarker;
                }
            }
            Chart.StiLineMarker = StiLineMarker;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarAxis {
                constructor(range = new Chart.StiAxisRange(), visible = true, allowApplyStyle = true) {
                    this.jsonLoadFromJsonObjectArea = false;
                    this._allowApplyStyle = true;
                    this._visible = true;
                    this._range = range;
                    this._visible = visible;
                    this._allowApplyStyle = allowApplyStyle;
                }
                implements() {
                    if (!StiRadarAxis.implementsStiRadarAxis)
                        StiRadarAxis.implementsStiRadarAxis = [
                            IStiJsonReportObject,
                            Chart.IStiRadarAxis,
                            ICloneable
                        ];
                    return StiRadarAxis.implementsStiRadarAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyBool("Visible", this.visible, true);
                    if (this._area != null)
                        jObject.addPropertyBool("Area", true);
                    if (this._range != null)
                        jObject.addPropertyJObject("Range", this._range.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.jsonLoadFromJsonObjectArea = property.value.stimulsoft().toBoolean();
                                break;
                            case "Range":
                                this._range.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Area":
                                this.jsonLoadFromJsonObjectArea = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Range":
                                this._range.loadFromXml(node);
                                break;
                        }
                    }
                }
                clone() {
                    let axis = this.stimulsoft().memberwiseClone();
                    if (this.core != null) {
                        axis.core = this.core.clone();
                        axis.core.axis = axis;
                    }
                    return axis;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.area != null && this.area.chart != null)
                            this.core.applyStyle(this.area.chart.style);
                    }
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get area() {
                    return this._area;
                }
                set area(value) {
                    this._area = value;
                }
                get range() {
                    return this._range;
                }
                set range(value) {
                    this._range = value;
                }
            }
            Chart.StiRadarAxis = StiRadarAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiRadarAxisLabels {
                constructor(format = "", font = new Font("Tahoma", 8), antialiasing = true, drawBorder = false, color = Color.black, borderColor = Color.black, brush = new StiSolidBrush(Color.gainsboro), allowApplyStyle = true, rotationLabels = true, width = 0, wordWrap = false) {
                    this._rotationLabels = true;
                    this._textBefore = "";
                    this._textAfter = "";
                    this._allowApplyStyle = true;
                    this._drawBorder = false;
                    this._format = "";
                    this._font = new Font("Tahoma", 8);
                    this._antialiasing = true;
                    this._color = Color.black;
                    this._borderColor = Color.black;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._width = 0;
                    this._wordWrap = false;
                    this._format = format;
                    this._font = font;
                    this._antialiasing = antialiasing;
                    this._drawBorder = drawBorder;
                    this._color = color;
                    this._borderColor = borderColor;
                    this._allowApplyStyle = allowApplyStyle;
                    this._brush = brush;
                    this._rotationLabels = rotationLabels;
                    this._width = width;
                    this._wordWrap = wordWrap;
                    this._core = new Chart.StiRadarAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiRadarAxisLabels.implementsStiRadarAxisLabels)
                        StiRadarAxisLabels.implementsStiRadarAxisLabels = [IStiJsonReportObject,
                            Chart.IStiRadarAxisLabels,
                            ICloneable];
                    return StiRadarAxisLabels.implementsStiRadarAxisLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("RotationLabels", this._rotationLabels, true);
                    jObject.addPropertyStringNullOrEmpty("TextBefore", this._textBefore);
                    jObject.addPropertyStringNullOrEmpty("TextAfter", this._textAfter);
                    jObject.addPropertyBool("AllowApplyStyle", this._allowApplyStyle, true);
                    jObject.addPropertyBool("DrawBorder", this._drawBorder);
                    jObject.addPropertyStringNullOrEmpty("Format", this._format);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this._font, "Tahoma", 8));
                    jObject.addPropertyBool("Antialiasing", this._antialiasing, true);
                    jObject.addPropertyStringNullOrEmpty("Color", StiJsonReportObjectHelper.Serialize.jColor(this._color, Color.black));
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.black));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyNumber("Width", this._width, 0);
                    jObject.addPropertyBool("WordWrap", this._wordWrap);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "RotationLabels":
                                this._rotationLabels = property.value.stimulsoft().toBoolean();
                                break;
                            case "TextBefore":
                                this._textBefore = property.value.toString();
                                break;
                            case "TextAfter":
                                this._textAfter = property.value.toString();
                                break;
                            case "AllowApplyStyle":
                                this._allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "DrawBorder":
                                this._drawBorder = property.value.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = property.value.toString();
                                break;
                            case "Font":
                                this._font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this._font);
                                break;
                            case "Antialiasing":
                                this._antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "WordWrap":
                                this._wordWrap = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "RotationLabels":
                                this._rotationLabels = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "TextBefore":
                                this._textBefore = node.textContent;
                                break;
                            case "TextAfter":
                                this._textAfter = node.textContent;
                                break;
                            case "AllowApplyStyle":
                                this._allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "DrawBorder":
                                this._drawBorder = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this._format = node.textContent;
                                break;
                            case "Font":
                            case "fn":
                                this._font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Antialiasing":
                                this._antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Color":
                                this._color = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "WordWrap":
                                this._wordWrap = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let labels = this.stimulsoft().memberwiseClone();
                    labels.font = this.font.clone();
                    labels.brush = this.brush.clone();
                    if (this.core != null) {
                        labels.core = this.core.clone();
                        labels.core.labels = labels;
                    }
                    return labels;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get rotationLabels() {
                    return this._rotationLabels;
                }
                set rotationLabels(value) {
                    this._rotationLabels = value;
                }
                get textBefore() {
                    return this._textBefore;
                }
                set textBefore(value) {
                    this._textBefore = value;
                }
                get textAfter() {
                    return this._textAfter;
                }
                set textAfter(value) {
                    this._textAfter = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get drawBorder() {
                    return this._drawBorder;
                }
                set drawBorder(value) {
                    if (this._drawBorder != value) {
                        this._drawBorder = value;
                    }
                }
                get format() {
                    return this._format;
                }
                set format(value) {
                    this._format = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get color() {
                    return this._color;
                }
                set color(value) {
                    this._color = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    this._width = value;
                }
                get wordWrap() {
                    return this._wordWrap;
                }
                set wordWrap(value) {
                    this._wordWrap = value;
                }
            }
            Chart.StiRadarAxisLabels = StiRadarAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiXRadarAxis extends Chart.StiRadarAxis {
                constructor(labels = new Chart.StiRadarAxisLabels(), range = new Chart.StiAxisRange(), visible = true, allowApplyStyle = true) {
                    super(range, visible, allowApplyStyle);
                    this._labels = new Chart.StiRadarAxisLabels();
                    this.core = new Chart.StiXRadarAxisCoreXF(this);
                    this._labels = labels;
                }
                implements() {
                    if (!StiXRadarAxis.implementsStiXRadarAxis)
                        StiXRadarAxis.implementsStiXRadarAxis = super.implements().concat([
                            Chart.IStiXRadarAxis,
                            Chart.IStiRadarAxis,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiXRadarAxis.implementsStiXRadarAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyJObject("Labels", this._labels.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Labels":
                                this._labels.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Labels":
                                this._labels.loadFromXml(node);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiXRadarAxis;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let axis = super.clone();
                    axis.labels = this.labels.clone();
                    return axis;
                }
                get xCore() {
                    return this.core;
                }
                get labels() {
                    return this._labels;
                }
                set labels(value) {
                    this._labels = value;
                }
            }
            Chart.StiXRadarAxis = StiXRadarAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiYRadarAxis extends Chart.StiRadarAxis {
                constructor(labels = new Chart.StiAxisLabels(), range = new Chart.StiAxisRange(), ticks = new Chart.StiAxisTicks(), lineStyle = StiPenStyle.Solid, lineColor = Color.gray, lineWidth = 1, visible = true, allowApplyStyle = true) {
                    super(range, visible, allowApplyStyle);
                    this._labels = new Chart.StiAxisLabels();
                    this._ticks = new Chart.StiAxisTicks();
                    this._lineStyle = StiPenStyle.Solid;
                    this._lineColor = Color.gray;
                    this._lineWidth = 1;
                    this._info = new Chart.StiAxisInfoXF();
                    this.core = new Chart.StiYRadarAxisCoreXF(this);
                    this._labels = labels;
                    this._ticks = ticks;
                    this._lineStyle = lineStyle;
                    this._lineColor = lineColor;
                    this._lineWidth = lineWidth;
                }
                implements() {
                    if (!StiYRadarAxis.implementsStiYRadarAxis)
                        StiYRadarAxis.implementsStiYRadarAxis = super.implements().concat([
                            Chart.IStiYRadarAxis,
                            Chart.IStiRadarAxis,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiYRadarAxis.implementsStiYRadarAxis;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyJObject("Labels", this._labels.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Ticks", this._ticks.saveToJsonObject(mode));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this._lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this._lineColor, Color.gray));
                    jObject.addPropertyNumber("LineWidth", this._lineWidth, 1);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Labels":
                                this._labels.loadFromJsonObject(property.value);
                                break;
                            case "Ticks":
                                this._ticks.loadFromJsonObject(property.value);
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "LineColor":
                                this._lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineWidth":
                                this._lineWidth = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Labels":
                                this._labels.loadFromXml(node);
                                break;
                            case "Ticks":
                                this._ticks.loadFromXml(node);
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "LineColor":
                                this._lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineWidth":
                                this._lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiYRadarAxis;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let axis = super.clone();
                    axis.lineStyle = this.lineStyle;
                    axis.labels = this.labels.clone();
                    axis.ticks = this.ticks.clone();
                    return axis;
                }
                get yCore() {
                    return this.core;
                }
                get labels() {
                    return this._labels;
                }
                set labels(value) {
                    this._labels = value;
                }
                get ticks() {
                    return this._ticks;
                }
                set ticks(value) {
                    this._ticks = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    this._lineWidth = value;
                }
                get info() {
                    return this._info;
                }
                set info(value) {
                    this._info = value;
                }
            }
            Chart.StiYRadarAxis = StiYRadarAxis;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSeriesInteraction {
                constructor() {
                    this.parentSeries = null;
                }
                implements() {
                    if (!StiSeriesInteraction.implementsStiSeriesInteraction)
                        StiSeriesInteraction.implementsStiSeriesInteraction = [
                            Chart.IStiSeriesInteraction,
                            IStiJsonReportObject,
                            ICloneable
                        ];
                    return StiSeriesInteraction.implementsStiSeriesInteraction;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("DrillDownPageGuid", this.drillDownPageGuid);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "DrillDownPageGuid":
                                this.drillDownPageGuid = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "DrillDownPageGuid":
                                this.drillDownPageGuid = node.textContent;
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSeriesInteraction;
                }
                get propName() {
                    return "";
                }
                getReport() {
                    if (this.parentSeries == null)
                        return null;
                    if (this.parentSeries.chart == null)
                        return null;
                    return this.parentSeries.chart.report;
                }
                clone() {
                    let interaction = this.stimulsoft().memberwiseClone();
                    return interaction;
                }
                isDefault() {
                    return StiString.isNullOrEmpty(this.hyperlinkDataColumn) &&
                        StiString.isNullOrEmpty(this.tagDataColumn) &&
                        StiString.isNullOrEmpty(this.toolTipDataColumn) &&
                        StiString.isNullOrEmpty(this.hyperlink) &&
                        StiString.isNullOrEmpty(this.tag) &&
                        StiString.isNullOrEmpty(this.toolTip) &&
                        StiString.isNullOrEmpty(this.listOfHyperlinks) &&
                        StiString.isNullOrEmpty(this.listOfTags) &&
                        StiString.isNullOrEmpty(this.listOfToolTips);
                }
                get hyperlink() {
                    return this.parentSeries.hyperlink;
                }
                set hyperlink(value) {
                    this.parentSeries.hyperlink = value;
                }
                get tag() {
                    return this.parentSeries.tag;
                }
                set tag(value) {
                    this.parentSeries.tag = value;
                }
                get toolTip() {
                    return this.parentSeries.toolTip;
                }
                set toolTip(value) {
                    this.parentSeries.toolTip = value;
                }
                get hyperlinkDataColumn() {
                    return this.parentSeries.hyperlinkDataColumn;
                }
                set hyperlinkDataColumn(value) {
                    this.parentSeries.hyperlinkDataColumn = value;
                }
                get tagDataColumn() {
                    return this.parentSeries.tagDataColumn;
                }
                set tagDataColumn(value) {
                    this.parentSeries.tagDataColumn = value;
                }
                get toolTipDataColumn() {
                    return this.parentSeries.toolTipDataColumn;
                }
                set toolTipDataColumn(value) {
                    this.parentSeries.toolTipDataColumn = value;
                }
                get listOfHyperlinks() {
                    return this.parentSeries.listOfHyperlinks;
                }
                set listOfHyperlinks(value) {
                    this.parentSeries.listOfHyperlinks = value;
                }
                get listOfTags() {
                    return this.parentSeries.listOfTags;
                }
                set listOfTags(value) {
                    this.parentSeries.listOfTags = value;
                }
                get listOfToolTips() {
                    return this.parentSeries.listOfToolTips;
                }
                set listOfToolTips(value) {
                    this.parentSeries.listOfToolTips = value;
                }
                get allowSeries() {
                    return this.parentSeries.allowSeries;
                }
                set allowSeries(value) {
                    this.parentSeries.allowSeries = value;
                }
                get allowSeriesElements() {
                    return this.parentSeries.allowSeriesElements;
                }
                set allowSeriesElements(value) {
                    this.parentSeries.allowSeriesElements = value;
                }
                get drillDownEnabled() {
                    return this.parentSeries.drillDownEnabled;
                }
                set drillDownEnabled(value) {
                    this.parentSeries.drillDownEnabled = value;
                }
                get drillDownReport() {
                    return this.parentSeries.drillDownReport;
                }
                set drillDownReport(value) {
                    this.parentSeries.drillDownReport = value;
                }
                get drillDownPage() {
                    return this.parentSeries.drillDownPage;
                }
                set drillDownPage(value) {
                    this.parentSeries.drillDownPage = value;
                }
                get drillDownPageGuid() {
                    return this.parentSeries.drillDownPageGuid;
                }
                set drillDownPageGuid(value) {
                    this.parentSeries.drillDownPageGuid = value;
                }
                get parentComponent() {
                    if (this.parentSeries == null || this.parentSeries.chart == null)
                        return null;
                    return this.parentSeries.chart;
                }
            }
            Chart.StiSeriesInteraction = StiSeriesInteraction;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiSeriesPointsInfo {
                constructor() {
                    this.additionalSeriesId = "";
                }
            }
            Chart.StiSeriesPointsInfo = StiSeriesPointsInfo;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            class StiBoxAndWhiskerSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this.showInnerPoints = false;
                    this.showMeanMarkers = true;
                    this.seriesLabels = new Chart.StiNoneLabels();
                    this.core = new Chart.StiBoxAndWhiskerSeriesCoreXF(this);
                }
                implements() {
                    if (!StiBoxAndWhiskerSeries.implementsStiBoxAndWhiskerSeries)
                        StiBoxAndWhiskerSeries.implementsStiBoxAndWhiskerSeries = super.implements().concat([
                            Chart.IStiBoxAndWhiskerSeries
                        ]);
                    return StiBoxAndWhiskerSeries.implementsStiBoxAndWhiskerSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowInnerPoints", this.showInnerPoints);
                    jObject.addPropertyBool("ShowMeanMarkers", this.showMeanMarkers, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowInnerPoints":
                                this.showInnerPoints = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowMeanMarkers":
                                this.showMeanMarkers = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this.brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowInnerPoints":
                                this.showInnerPoints = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowMeanMarkers":
                                this.showMeanMarkers = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this.brush = StiBrush.convertToBrush(node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiBoxAndWhiskerSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiBoxAndWhiskerArea;
                }
                createNew() {
                    return new StiBoxAndWhiskerSeries();
                }
            }
            Chart.StiBoxAndWhiskerSeries = StiBoxAndWhiskerSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiBubbleSeries extends Chart.StiScatterSeries {
                constructor() {
                    super();
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._weights = [1, 3, 2];
                    this._weightDataColumn = "";
                    this._weight = "";
                    this._listOfWeights = "";
                    this.core = new Chart.StiBubbleSeriesCoreXF(this);
                }
                implements() {
                    if (!StiBubbleSeries.implementsStiBubbleSeries)
                        StiBubbleSeries.implementsStiBubbleSeries = super.implements().concat([
                            Chart.IStiBaseLineSeries,
                            Chart.IStiBubbleSeries,
                            Chart.IStiFontIconsSeries,
                            Chart.IStiScatterSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable
                        ]);
                    return StiBubbleSeries.implementsStiBubbleSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("LineMarker");
                    jObject.removeProperty("Marker");
                    jObject.addPropertyString("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("WeightDataColumn", this._weightDataColumn);
                    jObject.addPropertyJObject("Weight", new StiExpression(this.weight).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfWeights", new StiExpression(this.listOfWeights).saveToJsonObject(mode));
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "WeightDataColumn":
                                this._weightDataColumn = property.value.toString();
                                break;
                            case "GetWeightEvent":
                                break;
                            case "GetListOfWeightsEvent":
                                break;
                            case "Weight":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.weight = _expression.value;
                                    break;
                                }
                            case "ListOfWeights":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfWeights = _expression.value;
                                    break;
                                }
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "WeightDataColumn":
                                this._weightDataColumn = node.textContent;
                                break;
                            case "GetWeightEvent":
                                break;
                            case "GetListOfWeightsEvent":
                                break;
                            case "Weight":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.weight = _expression.value;
                                    break;
                                }
                            case "ListOfWeights":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfWeights = _expression.value;
                                    break;
                                }
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiBubbleSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiBubbleArea;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get weights() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfWeights)) {
                            return Chart.StiSeries.getValuesFromString(this.listOfWeights);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        if (serIndex == 0)
                            return this._weights;
                        return [3 + serIndex * 3, 5 + serIndex * 4, 9 + serIndex * 3];
                    }
                    return this._weights;
                }
                set weights(value) {
                    this._weights = value;
                }
                get weightsString() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.weights) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set weightsString(value) {
                    if (value == null || value.trim().length == 0) {
                        this._weights = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._weights = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this._weights[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get weightDataColumn() {
                    return this._weightDataColumn;
                }
                set weightDataColumn(value) {
                    this._weightDataColumn = value;
                }
                onGetWeight(e) {
                }
                invokeGetWeight(sender, e) {
                    try {
                        this.onGetWeight(e);
                        if (this.getWeight != null)
                            this.getWeight(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetWeight...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfWeights(e) {
                }
                invokeGetListOfWeights(sender, e, series) {
                    try {
                        this.onGetListOfWeights(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSeriesListOfWeights**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series._listOfWeights, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfWeights != null)
                            this.getListOfWeights(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfWeights...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get weight() {
                    return this._weight;
                }
                set weight(value) {
                    this._weight = value;
                }
                get listOfWeights() {
                    return this._listOfWeights;
                }
                set listOfWeights(value) {
                    this._listOfWeights = value;
                }
                createNew() {
                    return new StiBubbleSeries();
                }
            }
            Chart.StiBubbleSeries = StiBubbleSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiClusteredColumnSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showZeros = false;
                    this._width = 0.9;
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiClusteredColumnSeriesCoreXF(this);
                }
                implements() {
                    if (!StiClusteredColumnSeries.implementsStiClusteredColumnSeries)
                        StiClusteredColumnSeries.implementsStiClusteredColumnSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiClusteredColumnSeries,
                            Chart.IStiFontIconsSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyBrushNegative,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiClusteredColumnSeries.implementsStiClusteredColumnSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyNumber("Width", this._width, 0.9);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this.brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this.allowApplyBrushNegative);
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this.brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this.allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this.brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this.allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiClusteredColumnSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                createNew() {
                    return new StiClusteredColumnSeries();
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    if (value >= 0.01 && value <= 1)
                        this._width = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this._brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
            }
            Chart.StiClusteredColumnSeries = StiClusteredColumnSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiClusteredBarSeries extends Chart.StiClusteredColumnSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiClusteredBarSeriesCoreXF(this);
                }
                implements() {
                    if (!StiClusteredBarSeries.implementsStiClusteredBarSeries)
                        StiClusteredBarSeries.implementsStiClusteredBarSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiClusteredColumnSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiClusteredBarSeries,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiClusteredBarSeries.implementsStiClusteredBarSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiClusteredBarSeries;
                }
                get xAxis() {
                    if (this.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                        return Chart.StiSeriesXAxis.BottomXAxis;
                    return Chart.StiSeriesXAxis.TopXAxis;
                }
                set xAxis(value) {
                    this.yAxis = value == Chart.StiSeriesXAxis.BottomXAxis ? Chart.StiSeriesYAxis.LeftYAxis : Chart.StiSeriesYAxis.RightYAxis;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredBarArea;
                }
                createNew() {
                    return new StiClusteredBarSeries();
                }
            }
            Chart.StiClusteredBarSeries = StiClusteredBarSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiLineSeries extends Chart.StiBaseLineSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiLineSeries.implementsStiLineSeries)
                        StiLineSeries.implementsStiLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiLineSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiLineSeries.implementsStiLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiLineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                createNew() {
                    return new StiLineSeries();
                }
            }
            Chart.StiLineSeries = StiLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiAreaSeries extends Chart.StiLineSeries {
                constructor() {
                    super();
                    this._topmostLine = true;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiAreaSeries.implementsStiAreaSeries)
                        StiAreaSeries.implementsStiAreaSeries = super.implements().concat([
                            Chart.IStiLineSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiAreaSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiAreaSeries.implementsStiAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("TopmostLine", this._topmostLine, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "TopmostLine":
                                this._topmostLine = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "TopmostLine":
                                this._topmostLine = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiAreaSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                get topmostLine() {
                    return this._topmostLine;
                }
                set topmostLine(value) {
                    this._topmostLine = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                createNew() {
                    return new StiAreaSeries();
                }
            }
            Chart.StiAreaSeries = StiAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiHistogramSeries extends Chart.StiClusteredColumnSeries {
                constructor() {
                    super();
                    this._width1 = 0.98;
                    this.core = new Chart.StiHistogramSeriesCoreXF(this);
                }
                implements() {
                    if (!StiHistogramSeries.implementsStiHistogramSeries)
                        StiHistogramSeries.implementsStiHistogramSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiHistogramSeries,
                            ICloneable,
                            Chart.IStiSeries
                        ]);
                    return StiHistogramSeries.implementsStiHistogramSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiHistogramSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiHistogramArea;
                }
                createNew() {
                    return new StiHistogramSeries();
                }
                get width() {
                    return this._width1;
                }
                set width(value) {
                    if (value >= 0.01 && value <= 1)
                        this._width1 = value;
                }
            }
            Chart.StiHistogramSeries = StiHistogramSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var Enum = Stimulsoft.System.Enum;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiParetoSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showZeros = false;
                    this._width = 0.9;
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this._showNulls = true;
                    this._marker = new Chart.StiMarker();
                    this._lineMarker = new Chart.StiLineMarker();
                    this._lineColor = Color.black;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lighting = true;
                    this._lineWidth = 2;
                    this._labelsOffset = 0;
                    this._lineColorNegative = Color.firebrick;
                    this._allowApplyColorNegative = false;
                    this._allowApplyLineColor = false;
                    this.showNullsAs = Chart.StiShowEmptyCellsAs.Gap;
                    this.showZerosAs = Chart.StiShowEmptyCellsAs.Gap;
                    this.core = new Chart.StiParetoSeriesCoreXF(this);
                }
                implements() {
                    if (!StiParetoSeries.implementsStiParetoSeries)
                        StiParetoSeries.implementsStiParetoSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiParetoSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiClusteredColumnSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyBrushNegative,
                            Chart.IStiShowNullsSeries,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiParetoSeries.implementsStiParetoSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyNumber("Width", this._width, 0.9);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.removeProperty("Conditions");
                    jObject.addPropertyJObject("Marker", this.marker.saveToJsonObject(mode));
                    jObject.addPropertyJObject("LineMarker", this.lineMarker.saveToJsonObject(mode));
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("Lighting", this.lighting, true);
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 2);
                    jObject.addPropertyBool("AllowApplyLineColor", this.allowApplyStyle, false);
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyLineColor":
                                this.allowApplyLineColor = property.value.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Marker":
                                this._marker.loadFromJsonObject(property.value);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromJsonObject(property.value);
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Lighting":
                                this.lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyLineColor":
                                this.allowApplyLineColor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Marker":
                                this._marker.loadFromXml(node);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromXml(node);
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Lighting":
                                this.lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiParetoSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    series.marker = this.marker.clone();
                    series.lineStyle = this.lineStyle;
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiParetoArea;
                }
                createNew() {
                    return new StiParetoSeries();
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    if (value >= 0.01 && value <= 1)
                        this._width = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this._brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                get showNulls() {
                    return this._showNulls;
                }
                set showNulls(value) {
                    this._showNulls = value;
                }
                get showMarker() {
                    return this.marker.visible;
                }
                set showMarker(value) {
                    this.marker.visible = value;
                }
                get markerColor() {
                    return StiBrush.toColor(this.marker.brush);
                }
                set markerColor(value) {
                    this.marker.brush = new StiSolidBrush(value);
                    this.marker.borderColor = StiColorUtils.dark(value, 50);
                }
                get markerSize() {
                    return this.marker.size;
                }
                set markerSize(value) {
                    this.marker.size = value;
                }
                get markerType() {
                    return this.marker.type;
                }
                set markerType(value) {
                    this.marker.type = value;
                }
                get marker() {
                    return this._marker;
                }
                set marker(value) {
                    this._marker = value;
                }
                get lineMarker() {
                    return this._lineMarker;
                }
                set lineMarker(value) {
                    this._lineMarker = value;
                }
                get lineColor() {
                    return this.getLineColor();
                }
                set lineColor(value) {
                    this.setLineColor(value);
                }
                getLineColor() {
                    return this._lineColor;
                }
                setLineColor(value) {
                    this._lineColor = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                get labelsOffset() {
                    return this._labelsOffset;
                }
                set labelsOffset(value) {
                    this._labelsOffset = value;
                }
                get lineColorNegative() {
                    return this._lineColorNegative;
                }
                set lineColorNegative(value) {
                    this._lineColorNegative = value;
                }
                get allowApplyColorNegative() {
                    return this._allowApplyColorNegative;
                }
                set allowApplyColorNegative(value) {
                    this._allowApplyColorNegative = value;
                }
                get allowApplyLineColor() {
                    return this._allowApplyLineColor;
                }
                set allowApplyLineColor(value) {
                    this._allowApplyLineColor = value;
                }
            }
            Chart.StiParetoSeries = StiParetoSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSplineSeries extends Chart.StiBaseLineSeries {
                constructor() {
                    super();
                    this._tension = 0.55;
                    this.core = new Chart.StiSplineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSplineSeries.implementsStiSplineSeries)
                        StiSplineSeries.implementsStiSplineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiBaseLineSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiSplineSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSplineSeries.implementsStiSplineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("LineMarker");
                    jObject.addPropertyNumber("Tension", this._tension, 0.55);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Tension":
                                this._tension = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Tension":
                                this._tension = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                get tension() {
                    return this._tension;
                }
                set tension(value) {
                    this._tension = value;
                }
                createNew() {
                    return new StiSplineSeries();
                }
            }
            Chart.StiSplineSeries = StiSplineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiSplineAreaSeries extends Chart.StiSplineSeries {
                constructor() {
                    super();
                    this._topmostLine = true;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiSplineAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSplineAreaSeries.implementsStiSplineAreaSeries)
                        StiSplineAreaSeries.implementsStiSplineAreaSeries = super.implements().concat([
                            Chart.IStiSplineSeries,
                            Chart.IStiBaseLineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiSplineAreaSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSplineAreaSeries.implementsStiSplineAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("TopmostLine", this._topmostLine, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "TopmostLine":
                                this._topmostLine = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "TopmostLine":
                                this._topmostLine = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineAreaSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                get topmostLine() {
                    return this._topmostLine;
                }
                set topmostLine(value) {
                    this._topmostLine = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                createNew() {
                    return new StiSplineAreaSeries();
                }
            }
            Chart.StiSplineAreaSeries = StiSplineAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSteppedLineSeries extends Chart.StiBaseLineSeries {
                constructor() {
                    super();
                    this._pointAtCenter = false;
                    this.core = new Chart.StiSteppedLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSteppedLineSeries.implementsStiSteppedLineSeries)
                        StiSteppedLineSeries.implementsStiSteppedLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiSteppedLineSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSteppedLineSeries.implementsStiSteppedLineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("PointAtCenter", this._pointAtCenter);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "PointAtCenter":
                                this._pointAtCenter = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "PointAtCenter":
                                this._pointAtCenter = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedLineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                get pointAtCenter() {
                    return this._pointAtCenter;
                }
                set pointAtCenter(value) {
                    this._pointAtCenter = value;
                }
                createNew() {
                    return new StiSteppedLineSeries();
                }
            }
            Chart.StiSteppedLineSeries = StiSteppedLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiSteppedAreaSeries extends Chart.StiSteppedLineSeries {
                constructor() {
                    super();
                    this._topmostLine = true;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiSteppedAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSteppedAreaSeries.implementsStiSteppedAreaSeries)
                        StiSteppedAreaSeries.implementsStiSteppedAreaSeries = super.implements().concat([
                            Chart.IStiSteppedLineSeries,
                            Chart.IStiBaseLineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSteppedAreaSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSteppedAreaSeries.implementsStiSteppedAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("TopmostLine", this._topmostLine, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "TopmostLine":
                                this._topmostLine = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "TopmostLine":
                                this._topmostLine = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedAreaSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiClusteredColumnArea;
                }
                get topmostLine() {
                    return this._topmostLine;
                }
                set topmostLine(value) {
                    this._topmostLine = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                createNew() {
                    return new StiSteppedAreaSeries();
                }
            }
            Chart.StiSteppedAreaSeries = StiSteppedAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiWaterfallSeries extends Chart.StiClusteredColumnSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiWaterfallSeriesCoreXF(this);
                    this.connectorLine = new Chart.StiWaterfallConnectorLine();
                    this.total = new Chart.StiWaterfallTotal();
                }
                implements() {
                    if (!StiWaterfallSeries.implementsStiWaterfallSeries)
                        StiWaterfallSeries.implementsStiWaterfallSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSunburstSeries,
                            ICloneable,
                            Chart.IStiSeries
                        ]);
                    return StiWaterfallSeries.implementsStiWaterfallSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyJObject("ConnectorLine", this.connectorLine.saveToJsonObject(mode));
                    jObject.addPropertyJObject("Total", this.total.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ConnectorLine":
                                this.connectorLine.loadFromJsonObject(property.value);
                                break;
                            case "Total":
                                this.total.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ConnectorLine":
                                this.connectorLine.loadFromXml(node);
                                break;
                            case "Total":
                                this.total.loadFromXml(node);
                                break;
                        }
                    }
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiWaterfallArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiWaterfallSeries;
                }
                createNew() {
                    return new StiWaterfallSeries();
                }
            }
            Chart.StiWaterfallSeries = StiWaterfallSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Components;
        (function (Components) {
            var Design;
            (function (Design) {
                class StiSeriesInteractionConverter {
                }
                Design.StiSeriesInteractionConverter = StiSeriesInteractionConverter;
            })(Design = Components.Design || (Components.Design = {}));
        })(Components = Report.Components || (Report.Components = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiPieSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this.showZeros = false;
                    this._allowApplyBrush = true;
                    this._allowApplyBorderColor = true;
                    this._startAngle = 0;
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._lighting = true;
                    this._diameter = 0;
                    this._distance = 0;
                    this._cutPieListValues = [];
                    this._cutPieList = "";
                    this.core = new Chart.StiPieSeriesCoreXF(this);
                }
                implements() {
                    if (!StiPieSeries.implementsStiPieSeries)
                        StiPieSeries.implementsStiPieSeries = super.implements().concat([
                            Chart.IStiPieSeries,
                            Chart.IStiFontIconsSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            IStiJsonReportObject,
                            Chart.IStiAllowApplyBorderColor,
                            Chart.IStiAllowApplyBrush
                        ]);
                    return StiPieSeries.implementsStiPieSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyBool("AllowApplyBrush", this._allowApplyBrush, true);
                    jObject.addPropertyBool("AllowApplyBorderColor", this._allowApplyBorderColor, true);
                    jObject.addPropertyNumber("StartAngle", this.startAngle, 0);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyBool("Lighting", this._lighting, true);
                    jObject.addPropertyNumber("Diameter", this.diameter, 0);
                    jObject.addPropertyNumber("Distance", this.distance, 0);
                    jObject.addPropertyJObject("CutPieList", new StiExpression(this._cutPieList).saveToJsonObject(mode));
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBrush":
                                this._allowApplyBrush = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBorderColor":
                                this._allowApplyBorderColor = property.value.stimulsoft().toBoolean();
                                break;
                            case "StartAngle":
                                this.startAngle = property.value.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Lighting":
                                this._lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "Diameter":
                                this.diameter = property.value.stimulsoft().toNumber();
                                break;
                            case "Distance":
                                this.distance = property.value.stimulsoft().toNumber();
                                break;
                            case "CutPieList": {
                                let _expression = new StiExpression();
                                _expression.loadFromJsonObject(property.value);
                                this._cutPieList = _expression.value;
                                break;
                            }
                            case "GetCutPieListEvent":
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBrush":
                                this._allowApplyBrush = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBorderColor":
                                this._allowApplyBorderColor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "StartAngle":
                                this.startAngle = node.textContent.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Lighting":
                                this._lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Diameter":
                                this.diameter = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Distance":
                                this.distance = node.textContent.stimulsoft().toNumber();
                                break;
                            case "CutPieList": {
                                let _expression = new StiExpression();
                                _expression.loadFromXml(node);
                                this._cutPieList = _expression.value;
                                break;
                            }
                            case "GetCutPieListEvent":
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiPieSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiPieArea;
                }
                get allowApplyBrush() {
                    return this._allowApplyBrush;
                }
                set allowApplyBrush(value) {
                    if (this._allowApplyBrush != value) {
                        this._allowApplyBrush = value;
                    }
                }
                get allowApplyBorderColor() {
                    return this._allowApplyBorderColor;
                }
                set allowApplyBorderColor(value) {
                    if (this._allowApplyBorderColor != value) {
                        this._allowApplyBorderColor = value;
                    }
                }
                getArguments() {
                    let args = super.getArguments();
                    if (args.length == 0 && this.chart != null && this.chart.report != null && this.chart.report.isDesigning && !this.isDashboard) {
                        return [
                            "Arg1",
                            "Arg2",
                            "Arg3"
                        ];
                    }
                    return args;
                }
                setArguments(value) {
                    super.setArguments(value);
                }
                get startAngle() {
                    return this._startAngle;
                }
                set startAngle(value) {
                    this._startAngle = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get diameter() {
                    return this._diameter;
                }
                set diameter(value) {
                    this._diameter = value;
                    if (value < 5)
                        this._diameter = 0;
                }
                get distance() {
                    return this._distance;
                }
                set distance(value) {
                    this._distance = Math.max(0, value);
                }
                get cutPieListValues() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.cutPieList)) {
                            return Chart.StiSeries.getValuesFromString(this.cutPieList);
                        }
                        return [];
                    }
                    return this._cutPieListValues;
                }
                set cutPieListValues(value) {
                    this._cutPieListValues = value;
                }
                get cuttedPieList() {
                    return this.cutPieList;
                }
                set cuttedPieList(value) {
                    this.cutPieList = value;
                }
                get cutPieList() {
                    return this._cutPieList;
                }
                set cutPieList(value) {
                    this._cutPieList = value;
                }
                onGetCutPieList(e) {
                }
                invokeGetCutPieList(sender, e) {
                    try {
                        this.onGetCutPieList(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartPieSeriesCutPieList**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.cutPieList, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getCutPieList != null)
                            this.getCutPieList(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        let str = StiString.format("Expression in GetCutPieList property of '{0}' series from '{1}' chart can't be evaluated!", this.serviceName, this.chart.name);
                        Report.StiLogService.write(this.stimulsoft().getType(), str);
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                createNew() {
                    return new StiPieSeries();
                }
            }
            Chart.StiPieSeries = StiPieSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiDoughnutSeries extends Chart.StiPieSeries {
                constructor() {
                    super();
                    this.width = 0;
                    this.core = new Chart.StiDoughnutSeriesCoreXF(this);
                }
                implements() {
                    if (!StiDoughnutSeries.implementsStiDoughnutSeries)
                        StiDoughnutSeries.implementsStiDoughnutSeries = super.implements().concat([
                            Chart.IStiPieSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiDoughnutSeries,
                            IStiJsonReportObject,
                            Chart.IStiAllowApplyBorderColor,
                            Chart.IStiAllowApplyBrush
                        ]);
                    return StiDoughnutSeries.implementsStiDoughnutSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyNumber("Width", this.width, 0);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Width":
                                this.width = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Width":
                                this.width = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiDoughnutSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiDoughnutArea;
                }
                createNew() {
                    return new StiDoughnutSeries();
                }
            }
            Chart.StiDoughnutSeries = StiDoughnutSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiCandlestickSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._valuesOpen = [4, 7, 5];
                    this._valuesClose = [2, 3, 5];
                    this._valuesHigh = [6, 9, 7];
                    this._valuesLow = [1, 3, 4];
                    this._valueDataColumnOpen = "";
                    this._valueDataColumnClose = "";
                    this._valueDataColumnHigh = "";
                    this._valueDataColumnLow = "";
                    this._borderColor = Color.gray;
                    this._borderColorNegative = Color.gray;
                    this._borderWidth = 2;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.transparent);
                    this.valueObjOpen = "";
                    this._listOfValuesOpen = "";
                    this.valueObjClose = "";
                    this._listOfValuesClose = "";
                    this.valueObjHigh = "";
                    this._listOfValuesHigh = "";
                    this.valueObjLow = "";
                    this._listOfValuesLow = "";
                    this.core = new Chart.StiCandlestickSeriesCoreXF(this);
                }
                implements() {
                    if (!StiCandlestickSeries.implementsStiCandlestickSeries)
                        StiCandlestickSeries.implementsStiCandlestickSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            Chart.IStiFinancialSeries,
                            ICloneable,
                            Chart.IStiCandlestickSeries
                        ]);
                    return StiCandlestickSeries.implementsStiCandlestickSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.removeProperty("ValueDataColumn");
                    jObject.removeProperty("Value");
                    jObject.removeProperty("ListOfValues");
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnOpen", this._valueDataColumnOpen);
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnClose", this._valueDataColumnClose);
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnHigh", this._valueDataColumnHigh);
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnLow", this._valueDataColumnLow);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this.borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("BorderColorNegative", StiJsonReportObjectHelper.Serialize.jColor(this.borderColorNegative, Color.gray));
                    jObject.addPropertyNumber("BorderWidth", this.borderWidth, 2);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this.brushNegative));
                    jObject.addPropertyJObject("ValueOpen", new StiExpression(this.valueOpen).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesOpen", new StiExpression(this.listOfValuesOpen).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ValueClose", new StiExpression(this.valueClose).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesClose", new StiExpression(this.listOfValuesClose).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ValueHigh", new StiExpression(this.valueHigh).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesHigh", new StiExpression(this.listOfValuesHigh).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ValueLow", new StiExpression(this.valueLow).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesLow", new StiExpression(this.listOfValuesLow).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ValueDataColumnOpen":
                                this._valueDataColumnOpen = property.value.toString();
                                break;
                            case "ValueDataColumnClose":
                                this._valueDataColumnClose = property.value.toString();
                                break;
                            case "ValueDataColumnHigh":
                                this._valueDataColumnHigh = property.value.toString();
                                break;
                            case "ValueDataColumnLow":
                                this._valueDataColumnLow = property.value.toString();
                                break;
                            case "BorderColor":
                                this.borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "BorderColorNegative":
                                this.borderColorNegative = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "BorderWidth":
                                this.borderWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "Brush":
                                this.brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this.brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "GetValueOpenEvent":
                                break;
                            case "GetListOfValuesOpenEvent":
                                break;
                            case "GetValueCloseEvent":
                                break;
                            case "GetListOfValuesCloseEvent":
                                break;
                            case "GetValueHighEvent":
                                break;
                            case "GetListOfValuesHighEvent":
                                break;
                            case "GetValueLowEvent":
                                break;
                            case "GetListOfValuesLowEvent":
                                break;
                            case "ValueOpen":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueOpen = _expression.value;
                                    break;
                                }
                            case "ListOfValuesOpen":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesOpen = _expression.value;
                                    break;
                                }
                            case "ValueClose":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueClose = _expression.value;
                                    break;
                                }
                            case "ListOfValuesClose":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesClose = _expression.value;
                                    break;
                                }
                            case "ValueHigh":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueHigh = _expression.value;
                                    break;
                                }
                            case "ListOfValuesHigh":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesHigh = _expression.value;
                                    break;
                                }
                            case "ValueLow":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueLow = _expression.value;
                                    break;
                                }
                            case "ListOfValuesLow":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesLow = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ValueDataColumnOpen":
                                this._valueDataColumnOpen = node.textContent;
                                break;
                            case "ValueDataColumnClose":
                                this._valueDataColumnClose = node.textContent;
                                break;
                            case "ValueDataColumnHigh":
                                this._valueDataColumnHigh = node.textContent;
                                break;
                            case "ValueDataColumnLow":
                                this._valueDataColumnLow = node.textContent;
                                break;
                            case "BorderColor":
                                this.borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "BorderColorNegative":
                                this.borderColorNegative = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "BorderWidth":
                                this.borderWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Brush":
                            case "bh":
                                this.brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "BrushNegative":
                                this.brushNegative = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "GetValueOpenEvent":
                                break;
                            case "GetListOfValuesOpenEvent":
                                break;
                            case "GetValueCloseEvent":
                                break;
                            case "GetListOfValuesCloseEvent":
                                break;
                            case "GetValueHighEvent":
                                break;
                            case "GetListOfValuesHighEvent":
                                break;
                            case "GetValueLowEvent":
                                break;
                            case "GetListOfValuesLowEvent":
                                break;
                            case "ValueOpen":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueOpen = _expression.value;
                                    break;
                                }
                            case "ListOfValuesOpen":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesOpen = _expression.value;
                                    break;
                                }
                            case "ValueClose":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueClose = _expression.value;
                                    break;
                                }
                            case "ListOfValuesClose":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesClose = _expression.value;
                                    break;
                                }
                            case "ValueHigh":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueHigh = _expression.value;
                                    break;
                                }
                            case "ListOfValuesHigh":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesHigh = _expression.value;
                                    break;
                                }
                            case "ValueLow":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueLow = _expression.value;
                                    break;
                                }
                            case "ListOfValuesLow":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesLow = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiCandlestickSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiCandlestickArea;
                }
                get valuesOpen() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesOpen)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesOpen);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        let offset = this.getOffsetForValues();
                        return [offset + 4 + serIndex * 7, offset + 7 + serIndex * 7, offset + 5 + serIndex * 7];
                    }
                    return this._valuesOpen;
                }
                set valuesOpen(value) {
                    this._valuesOpen = value;
                }
                get valuesClose() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesClose)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesClose);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        let offset = this.getOffsetForValues();
                        return [offset + 2 + serIndex * 7, offset + 3 + serIndex * 7, offset + 5 + serIndex * 7];
                    }
                    return this._valuesClose;
                }
                set valuesClose(value) {
                    this._valuesClose = value;
                }
                get valuesStringOpen() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesOpen) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringOpen(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesOpen = [];
                    }
                    else {
                        let strs = value.split(";");
                        this.valuesOpen = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this.valuesOpen[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valuesStringClose() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesClose) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringClose(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesClose = [];
                    }
                    else {
                        let strs = value.split(";");
                        this.valuesClose = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this.valuesClose[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valuesStringHigh() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesHigh) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringHigh(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesHigh = [];
                    }
                    else {
                        let strs = value.split(";");
                        this.valuesHigh = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this.valuesHigh[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valuesStringLow() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesLow) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringLow(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesLow = [];
                    }
                    else {
                        let strs = value.split(";");
                        this.valuesLow = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this.valuesLow[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valuesHigh() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesHigh)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesHigh);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        let offset = this.getOffsetForValues();
                        return [offset + 6 + serIndex * 7, offset + 9 + serIndex * 7, offset + 7 + serIndex * 7];
                    }
                    return this._valuesHigh;
                }
                set valuesHigh(value) {
                    this._valuesHigh = value;
                }
                get valuesLow() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesLow)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesLow);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        let offset = this.getOffsetForValues();
                        return [offset + 1 + serIndex * 7, offset + 3 + serIndex * 7, offset + 4 + serIndex * 7];
                    }
                    return this._valuesLow;
                }
                set valuesLow(value) {
                    this._valuesLow = value;
                }
                get valueDataColumnOpen() {
                    return this._valueDataColumnOpen;
                }
                set valueDataColumnOpen(value) {
                    this._valueDataColumnOpen = value;
                }
                get valueDataColumnClose() {
                    return this._valueDataColumnClose;
                }
                set valueDataColumnClose(value) {
                    this._valueDataColumnClose = value;
                }
                get valueDataColumnHigh() {
                    return this._valueDataColumnHigh;
                }
                set valueDataColumnHigh(value) {
                    this._valueDataColumnHigh = value;
                }
                get valueDataColumnLow() {
                    return this._valueDataColumnLow;
                }
                set valueDataColumnLow(value) {
                    this._valueDataColumnLow = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get borderColorNegative() {
                    return this._borderColorNegative;
                }
                set borderColorNegative(value) {
                    this._borderColorNegative = value;
                }
                get borderWidth() {
                    return this._borderWidth;
                }
                set borderWidth(value) {
                    if (value > 0) {
                        this._borderWidth = value;
                    }
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this._brushNegative = value;
                }
                onGetValueOpen(e) {
                }
                invokeGetValueOpen(sender, e) {
                    try {
                        this.onGetValueOpen(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueOpen**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueOpen, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueOpen != null)
                            this.getValueOpen(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueOpen...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesOpen(e) {
                }
                invokeGetListOfValuesOpen(sender, e) {
                    try {
                        this.onGetListOfValuesOpen(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesOpen**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.listOfValuesOpen, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfValuesOpen != null)
                            this.getListOfValuesOpen(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesOpen...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetValueClose(e) {
                }
                invokeGetValueClose(sender, e) {
                    try {
                        this.onGetValueClose(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueClose**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueClose, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueClose != null)
                            this.getValueClose(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueClose...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesClose(e) {
                }
                invokeGetListOfValuesClose(sender, e) {
                    try {
                        this.onGetListOfValuesClose(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesClose**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.listOfValuesClose, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfValuesClose != null)
                            this.getListOfValuesClose(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesClose...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetValueHigh(e) {
                }
                invokeGetValueHigh(sender, e) {
                    try {
                        this.onGetValueHigh(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueHigh**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueHigh, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueHigh != null)
                            this.getValueHigh(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueHigh...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesHigh(e) {
                }
                invokeGetListOfValuesHigh(sender, e) {
                    try {
                        this.onGetListOfValuesHigh(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesHigh**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.listOfValuesHigh, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfValuesHigh != null)
                            this.getListOfValuesHigh(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesHigh...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                onGetValueLow(e) {
                }
                invokeGetValueLow(sender, e) {
                    try {
                        this.onGetValueLow(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueLow**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueLow, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueLow != null)
                            this.getValueLow(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueLow...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesLow(e) {
                }
                invokeGetListOfValuesLow(sender, e) {
                    try {
                        this.onGetListOfValuesLow(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesLow**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.listOfValuesLow, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getListOfValuesLow != null)
                            this.getListOfValuesLow(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesLow...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueOpen() {
                    return this.valueObjOpen;
                }
                set valueOpen(value) {
                    this.valueObjOpen = value;
                }
                get listOfValuesOpen() {
                    return this._listOfValuesOpen;
                }
                set listOfValuesOpen(value) {
                    this._listOfValuesOpen = value;
                }
                get valueClose() {
                    return this.valueObjClose;
                }
                set valueClose(value) {
                    this.valueObjClose = value;
                }
                get listOfValuesClose() {
                    return this._listOfValuesClose;
                }
                set listOfValuesClose(value) {
                    this._listOfValuesClose = value;
                }
                get valueHigh() {
                    return this.valueObjHigh;
                }
                set valueHigh(value) {
                    this.valueObjHigh = value;
                }
                get listOfValuesHigh() {
                    return this._listOfValuesHigh;
                }
                set listOfValuesHigh(value) {
                    this._listOfValuesHigh = value;
                }
                get valueLow() {
                    return this.valueObjLow;
                }
                set valueLow(value) {
                    this.valueObjLow = value;
                }
                get listOfValuesLow() {
                    return this._listOfValuesLow;
                }
                set listOfValuesLow(value) {
                    this._listOfValuesLow = value;
                }
                createNew() {
                    return new StiCandlestickSeries();
                }
            }
            Chart.StiCandlestickSeries = StiCandlestickSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStockSeries extends Chart.StiCandlestickSeries {
                constructor() {
                    super();
                    this._lineColor = Color.black;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lineWidth = 2;
                    this._lineColorNegative = Color.firebrick;
                    this._allowApplyColorNegative = false;
                    this.core = new Chart.StiStockSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStockSeries.implementsStiStockSeries)
                        StiStockSeries.implementsStiStockSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStockSeries,
                            Chart.IStiFinancialSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiStockSeries.implementsStiStockSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("BorderColor");
                    jObject.removeProperty("BorderWidth");
                    jObject.removeProperty("Brush");
                    jObject.removeProperty("BrushNegative");
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 2);
                    jObject.addPropertyStringNullOrEmpty("LineColorNegative", StiJsonReportObjectHelper.Serialize.jColor(this.lineColorNegative, Color.firebrick));
                    jObject.addPropertyBool("AllowApplyColorNegative", this.allowApplyColorNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "AllowApplyColorNegative":
                                this.allowApplyColorNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "AllowApplyColorNegative":
                                this.allowApplyColorNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStockSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiStockArea;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                get lineColorNegative() {
                    return this._lineColorNegative;
                }
                set lineColorNegative(value) {
                    this._lineColorNegative = value;
                }
                get allowApplyColorNegative() {
                    return this._allowApplyColorNegative;
                }
                set allowApplyColorNegative(value) {
                    this._allowApplyColorNegative = value;
                }
                createNew() {
                    return new StiStockSeries();
                }
            }
            Chart.StiStockSeries = StiStockSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiStackedBarSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showZeros = false;
                    this._width = 0.8;
                    this._borderColor = Color.black;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiStackedBarSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedBarSeries.implementsStiStackedBarSeries)
                        StiStackedBarSeries.implementsStiStackedBarSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBarSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyBrushNegative,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiStackedBarSeries.implementsStiStackedBarSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyNumber("Width", this._width, 0.8);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.black));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedBarSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedBarArea;
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    if (value >= 0.01 && value <= 1)
                        this._width = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                get xAxis() {
                    if (this.yAxis == Chart.StiSeriesYAxis.LeftYAxis)
                        return Chart.StiSeriesXAxis.BottomXAxis;
                    return Chart.StiSeriesXAxis.TopXAxis;
                }
                set xAxis(value) {
                    this.yAxis = value == Chart.StiSeriesXAxis.BottomXAxis ? Chart.StiSeriesYAxis.LeftYAxis : Chart.StiSeriesYAxis.RightYAxis;
                }
                createNew() {
                    return new StiStackedBarSeries();
                }
            }
            Chart.StiStackedBarSeries = StiStackedBarSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedBarSeries extends Chart.StiStackedBarSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedBarSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedBarSeries.implementsStiFullStackedBarSeries)
                        StiFullStackedBarSeries.implementsStiFullStackedBarSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBarSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiFullStackedBarSeries
                        ]);
                    return StiFullStackedBarSeries.implementsStiFullStackedBarSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedBarSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedBarArea;
                }
                createNew() {
                    return new StiFullStackedBarSeries();
                }
            }
            Chart.StiFullStackedBarSeries = StiFullStackedBarSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiColorUtils = Stimulsoft.Base.Drawing.StiColorUtils;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStackedBaseLineSeries extends Chart.StiSeries {
                constructor() {
                    super(...arguments);
                    this._showNulls = true;
                    this._marker = new Chart.StiMarker();
                    this._lineMarker = new Chart.StiLineMarker();
                    this._lighting = true;
                    this._lineColor = Color.mediumBlue;
                    this._lineWidth = 2;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lineColorNegative = Color.firebrick;
                    this._allowApplyColorNegative = false;
                }
                implements() {
                    if (!StiStackedBaseLineSeries.implementsStiStackedBaseLineSeries)
                        StiStackedBaseLineSeries.implementsStiStackedBaseLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBaseLineSeries,
                            ICloneable,
                            Chart.IStiSeries
                        ]);
                    return StiStackedBaseLineSeries.implementsStiStackedBaseLineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.removeProperty("Conditions");
                    jObject.addPropertyBool("ShowNulls", this._showNulls, true);
                    jObject.addPropertyJObject("Marker", this._marker.saveToJsonObject(mode));
                    jObject.addPropertyJObject("LineMarker", this.lineMarker.saveToJsonObject(mode));
                    jObject.addPropertyBool("Lighting", this._lighting, true);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this._lineColor, Color.mediumBlue));
                    jObject.addPropertyNumber("LineWidth", this._lineWidth, 2);
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this._lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyStringNullOrEmpty("LineColorNegative", StiJsonReportObjectHelper.Serialize.jColor(this.lineColorNegative, Color.firebrick));
                    jObject.addPropertyBool("AllowApplyColorNegative", this._allowApplyColorNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowNulls":
                                this._showNulls = property.value.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromJsonObject(property.value);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromJsonObject(property.value);
                                break;
                            case "Lighting":
                                this._lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this._lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineWidth":
                                this._lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "AllowApplyColorNegative":
                                this._allowApplyColorNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowNulls":
                                this._showNulls = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromXml(node);
                                break;
                            case "LineMarker":
                                this.lineMarker.loadFromXml(node);
                                break;
                            case "Lighting":
                                this._lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this._lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineWidth":
                                this._lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "LineColorNegative":
                                this.lineColorNegative = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "AllowApplyColorNegative":
                                this._allowApplyColorNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let series = super.clone();
                    series.lineStyle = this.lineStyle;
                    return series;
                }
                get showNulls() {
                    return this._showNulls;
                }
                set showNulls(value) {
                    this._showNulls = value;
                }
                get showMarker() {
                    return this.marker.visible;
                }
                set showMarker(value) {
                    this.marker.visible = value;
                }
                get markerColor() {
                    return StiBrush.toColor(this.marker.brush);
                }
                set markerColor(value) {
                    this.marker.brush = new StiSolidBrush(value);
                    this.marker.borderColor = StiColorUtils.dark(value, 50);
                }
                get markerSize() {
                    return this.marker.size;
                }
                set markerSize(value) {
                    this.marker.size = value;
                }
                get markerType() {
                    return this.marker.type;
                }
                set markerType(value) {
                    this.marker.type = value;
                }
                get marker() {
                    return this._marker;
                }
                set marker(value) {
                    this._marker = value;
                }
                get lineMarker() {
                    return this._lineMarker;
                }
                set lineMarker(value) {
                    this._lineMarker = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lineColorNegative() {
                    return this._lineColorNegative;
                }
                set lineColorNegative(value) {
                    this._lineColorNegative = value;
                }
                get allowApplyColorNegative() {
                    return this._allowApplyColorNegative;
                }
                set allowApplyColorNegative(value) {
                    this._allowApplyColorNegative = value;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
            }
            Chart.StiStackedBaseLineSeries = StiStackedBaseLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedLineSeries extends Chart.StiStackedBaseLineSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiStackedLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedLineSeries.implementsStiStackedLineSeries)
                        StiStackedLineSeries.implementsStiStackedLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiStackedLineSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiShowNullsSeries
                        ]);
                    return StiStackedLineSeries.implementsStiStackedLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedLineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
                createNew() {
                    return new StiStackedLineSeries();
                }
            }
            Chart.StiStackedLineSeries = StiStackedLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStackedAreaSeries extends Chart.StiStackedLineSeries {
                constructor() {
                    super();
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiStackedAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedAreaSeries.implementsStiStackedAreaSeries)
                        StiStackedAreaSeries.implementsStiStackedAreaSeries = super.implements().concat([
                            ICloneable,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiStackedLineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            Chart.IStiStackedAreaSeries,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiStackedAreaSeries.implementsStiStackedAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedAreaSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.coreBrush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
                get coreBrush() {
                    return this.brush;
                }
                set coreBrush(value) {
                    this.brush = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                createNew() {
                    return new StiStackedAreaSeries();
                }
            }
            Chart.StiStackedAreaSeries = StiStackedAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedAreaSeries extends Chart.StiStackedAreaSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedAreaSeries.implementsStiFullStackedAreaSeries)
                        StiFullStackedAreaSeries.implementsStiFullStackedAreaSeries = super.implements().concat([
                            Chart.IStiStackedAreaSeries,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiSeries,
                            IStiJsonReportObject,
                            Chart.IStiFullStackedAreaSeries,
                            Chart.IStiStackedLineSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiFullStackedAreaSeries.implementsStiFullStackedAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedAreaSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedAreaSeries();
                }
            }
            Chart.StiFullStackedAreaSeries = StiFullStackedAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiStackedColumnSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showZeros = false;
                    this._width = 0.8;
                    this._borderColor = Color.black;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiStackedColumnSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedColumnSeries.implementsStiStackedColumnSeries)
                        StiStackedColumnSeries.implementsStiStackedColumnSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedColumnSeries,
                            Chart.IStiFontIconsSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiAllowApplyBrushNegative,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiStackedColumnSeries.implementsStiStackedColumnSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyNumber("Width", this._width, 0.8);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.black));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = property.value.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Width":
                                this._width = node.textContent.stimulsoft().toNumber();
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedColumnSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get width() {
                    return this._width;
                }
                set width(value) {
                    if (value >= 0.01 && value <= 1)
                        this._width = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this._brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
                createNew() {
                    return new StiStackedColumnSeries();
                }
            }
            Chart.StiStackedColumnSeries = StiStackedColumnSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedColumnSeries extends Chart.StiStackedColumnSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedColumnSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedColumnSeries.implementsStiFullStackedColumnSeries)
                        StiFullStackedColumnSeries.implementsStiFullStackedColumnSeries = super.implements().concat([
                            Chart.IStiFullStackedColumnSeries,
                            Chart.IStiStackedColumnSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            IStiJsonReportObject,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiFullStackedColumnSeries.implementsStiFullStackedColumnSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedColumnSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedColumnSeries();
                }
            }
            Chart.StiFullStackedColumnSeries = StiFullStackedColumnSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedLineSeries extends Chart.StiStackedLineSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedLineSeries.implementsStiFullStackedLineSeries)
                        StiFullStackedLineSeries.implementsStiFullStackedLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiStackedLineSeries,
                            Chart.IStiSeries,
                            ICloneable
                        ]);
                    return StiFullStackedLineSeries.implementsStiFullStackedLineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedLineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedLineSeries();
                }
            }
            Chart.StiFullStackedLineSeries = StiFullStackedLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiStackedSplineSeries extends Chart.StiStackedBaseLineSeries {
                constructor() {
                    super();
                    this._tension = 0.55;
                    this.core = new Chart.StiStackedSplineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedSplineSeries.implementsStiStackedSplineSeries)
                        StiStackedSplineSeries.implementsStiStackedSplineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStackedBaseLineSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiStackedSplineSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiStackedSplineSeries.implementsStiStackedSplineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("LineMarker");
                    jObject.addPropertyNumber("Tension", this._tension, 0.55);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Tension":
                                this._tension = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Tension":
                                this._tension = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedSplineSeries;
                }
                get tension() {
                    return this._tension;
                }
                set tension(value) {
                    this._tension = value;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
                createNew() {
                    return new StiStackedSplineSeries();
                }
            }
            Chart.StiStackedSplineSeries = StiStackedSplineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiStackedSplineAreaSeries extends Chart.StiStackedSplineSeries {
                constructor() {
                    super();
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.core = new Chart.StiStackedSplineAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiStackedSplineAreaSeries.implementsStiStackedSplineAreaSeries)
                        StiStackedSplineAreaSeries.implementsStiStackedSplineAreaSeries = super.implements().concat([
                            Chart.IStiStackedSplineSeries,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiStackedSplineAreaSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiStackedSplineAreaSeries.implementsStiStackedSplineAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStackedSplineAreaSeries;
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                getDefaultAreaType() {
                    return Chart.StiStackedColumnArea;
                }
                createNew() {
                    return new StiStackedSplineAreaSeries();
                }
            }
            Chart.StiStackedSplineAreaSeries = StiStackedSplineAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedSplineAreaSeries extends Chart.StiStackedSplineAreaSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedSplineAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedSplineAreaSeries.implementsStiFullStackedSplineAreaSeries)
                        StiFullStackedSplineAreaSeries.implementsStiFullStackedSplineAreaSeries = super.implements().concat([
                            Chart.IStiStackedSplineSeries,
                            Chart.IStiFullStackedSplineAreaSeries,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiStackedSplineAreaSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiFullStackedSplineAreaSeries.implementsStiFullStackedSplineAreaSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedSplineAreaSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedSplineAreaSeries();
                }
            }
            Chart.StiFullStackedSplineAreaSeries = StiFullStackedSplineAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFullStackedSplineSeries extends Chart.StiStackedSplineSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFullStackedSplineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFullStackedSplineSeries.implementsStiFullStackedSplineSeries)
                        StiFullStackedSplineSeries.implementsStiFullStackedSplineSeries = super.implements().concat([
                            Chart.IStiStackedSplineSeries,
                            Chart.IStiStackedBaseLineSeries,
                            Chart.IStiFullStackedSplineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiFullStackedSplineSeries.implementsStiFullStackedSplineSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFullStackedSplineSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiFullStackedColumnArea;
                }
                createNew() {
                    return new StiFullStackedSplineSeries();
                }
            }
            Chart.StiFullStackedSplineSeries = StiFullStackedSplineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiFunnelSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._showZeros = false;
                    this._allowApplyBrush = true;
                    this._allowApplyBorderColor = true;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._borderColor = Color.gray;
                    this.core = new Chart.StiFunnelSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFunnelSeries.implementsStiFunnelSeries)
                        StiFunnelSeries.implementsStiFunnelSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiFunnelSeries,
                            Chart.IStiFontIconsSeries,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiShowZerosSeries
                        ]);
                    return StiFunnelSeries.implementsStiFunnelSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowZeros", this.showZeros);
                    jObject.addPropertyBool("AllowApplyBrush", this._allowApplyBrush, true);
                    jObject.addPropertyBool("AllowApplyBorderColor", this._allowApplyBorderColor, true);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowZeros":
                                this.showZeros = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBrush":
                                this._allowApplyBrush = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBorderColor":
                                this._allowApplyBorderColor = property.value.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "BorderColor":
                                this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowZeros":
                                this.showZeros = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBrush":
                                this._allowApplyBrush = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyBorderColor":
                                this._allowApplyBorderColor = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiFunnelSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiFunnelArea;
                }
                get showZeros() {
                    return this._showZeros;
                }
                set showZeros(value) {
                    this._showZeros = value;
                }
                get allowApplyBrush() {
                    return this._allowApplyBrush;
                }
                set allowApplyBrush(value) {
                    if (this._allowApplyBrush != value) {
                        this._allowApplyBrush = value;
                    }
                }
                get allowApplyBorderColor() {
                    return this._allowApplyBorderColor;
                }
                set allowApplyBorderColor(value) {
                    if (this._allowApplyBorderColor != value) {
                        this._allowApplyBorderColor = value;
                    }
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                createNew() {
                    return new StiFunnelSeries();
                }
            }
            Chart.StiFunnelSeries = StiFunnelSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFunnelWeightedSlicesSeries extends Chart.StiFunnelSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiFunnelWeightedSlicesSeriesCoreXF(this);
                }
                implements() {
                    if (!StiFunnelWeightedSlicesSeries.implementsStiFunnelWeightedSlicesSeries)
                        StiFunnelWeightedSlicesSeries.implementsStiFunnelWeightedSlicesSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiFunnelSeries,
                            Chart.IStiFunnelWeightedSlicesSeries,
                            Chart.IStiSeries,
                            ICloneable
                        ]);
                    return StiFunnelWeightedSlicesSeries.implementsStiFunnelWeightedSlicesSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiFunnelWeightedSlicesSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiFunnelWeightedSlicesArea;
                }
                createNew() {
                    return new StiFunnelWeightedSlicesSeries();
                }
            }
            Chart.StiFunnelWeightedSlicesSeries = StiFunnelWeightedSlicesSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            class StiGanttSeries extends Chart.StiClusteredBarSeries {
                constructor() {
                    super();
                    this._valuesEnd = [3, 5, 9];
                    this._valueDataColumnEnd = "";
                    this.valueObjEnd = "";
                    this._listOfValuesEnd = "";
                    this.core = new Chart.StiGanttSeriesCoreXF(this);
                }
                implements() {
                    if (!StiGanttSeries.implementsStiGanttSeries)
                        StiGanttSeries.implementsStiGanttSeries = super.implements().concat([
                            Chart.IStiClusteredColumnSeries,
                            Chart.IStiClusteredBarSeries,
                            Chart.IStiRangeSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            Chart.IStiGanttSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiGanttSeries.implementsStiGanttSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyString("ValueDataColumnEnd", this._valueDataColumnEnd);
                    jObject.addPropertyJObject("ValueEnd", new StiExpression(this.valueEnd).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesEnd", new StiExpression(this.listOfValuesEnd).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = property.value.toString();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = node.textContent;
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiGanttSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiGanttArea;
                }
                get valuesEnd() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesEnd)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesEnd);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        if (serIndex == 0)
                            return this._valuesEnd;
                        return [3 + serIndex * 3, 5 + serIndex * 4, 9 + serIndex * 3];
                    }
                    return this._valuesEnd;
                }
                set valuesEnd(value) {
                    this._valuesEnd = value;
                }
                get valuesStringEnd() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesEnd) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringEnd(value) {
                    if (value == null || value.trim().length == 0) {
                        this._valuesEnd = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._valuesEnd = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this._valuesEnd[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valueDataColumnEnd() {
                    return this._valueDataColumnEnd;
                }
                set valueDataColumnEnd(value) {
                    this._valueDataColumnEnd = value;
                }
                onGetValueEnd(e) {
                }
                invokeGetValueEnd(sender, e) {
                    try {
                        this.onGetValueEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueEnd != null)
                            this.getValueEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueEnd...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesEnd(e) {
                }
                invokeGetListOfValuesEnd(sender, e, series) {
                    try {
                        series.onGetListOfValuesEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series.listOfValuesEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValuesEnd != null)
                            series.getListOfValuesEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesEnd...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueEnd() {
                    return this.valueObjEnd;
                }
                set valueEnd(value) {
                    this.valueObjEnd = value;
                }
                get listOfValuesEnd() {
                    return this._listOfValuesEnd;
                }
                set listOfValuesEnd(value) {
                    this._listOfValuesEnd = value;
                }
                createNew() {
                    return new StiGanttSeries();
                }
            }
            Chart.StiGanttSeries = StiGanttSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Enum = Stimulsoft.System.Enum;
            class StiPictorialSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._icon = StiFontIcons.QuarterFull;
                    this.core = new Chart.StiPictorialSeriesCoreXF(this);
                }
                implements() {
                    if (!StiPictorialSeries.implementsStiPictorialSeries)
                        StiPictorialSeries.implementsStiPictorialSeries = super.implements().concat([
                            Chart.IStiPictorialSeries,
                            Chart.IStiFontIconsSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            IStiJsonReportObject
                        ]);
                    return StiPictorialSeries.implementsStiPictorialSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyEnum("Icon", StiFontIcons, this.icon, StiFontIcons.QuarterFull);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Icon":
                                this._icon = Enum.parse(StiFontIcons, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Icon":
                                this._icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get icon() {
                    return this._icon;
                }
                set icon(value) {
                    this._icon = value;
                }
                get componentId() {
                    return Report.StiComponentId.StiPictorialSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiPictorialArea;
                }
                createNew() {
                    return new StiPictorialSeries();
                }
            }
            Chart.StiPictorialSeries = StiPictorialSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarSeries extends Chart.StiSeries {
                constructor() {
                    super(...arguments);
                    this._showNulls = true;
                    this._marker = new Chart.StiMarker();
                }
                implements() {
                    if (!StiRadarSeries.implementsStiRadarSeries)
                        StiRadarSeries.implementsStiRadarSeries = super.implements().concat([
                            IStiJsonReportObject,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiRadarSeries,
                            Chart.IStiShowNullsSeries
                        ]);
                    return StiRadarSeries.implementsStiRadarSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyBool("ShowNulls", this._showNulls, true);
                    jObject.addPropertyJObject("Marker", this.marker.saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowNulls":
                                this._showNulls = property.value.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromJsonObject(property.value);
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowNulls":
                                this._showNulls = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Marker":
                                this._marker.loadFromXml(node);
                                break;
                        }
                    }
                }
                clone() {
                    let series = super.clone();
                    if (this.marker != null)
                        series.marker = this.marker.clone();
                    return series;
                }
                get showNulls() {
                    return this._showNulls;
                }
                set showNulls(value) {
                    this._showNulls = value;
                }
                get marker() {
                    return this._marker;
                }
                set marker(value) {
                    this._marker = value;
                }
            }
            Chart.StiRadarSeries = StiRadarSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRadarAreaSeries extends Chart.StiRadarSeries {
                constructor() {
                    super();
                    this._lineColor = Color.black;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lighting = true;
                    this._lineWidth = 2;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this.core = new Chart.StiRadarAreaSeriesCoreXF(this);
                }
                implements() {
                    if (!StiRadarAreaSeries.implementsStiRadarAreaSeries)
                        StiRadarAreaSeries.implementsStiRadarAreaSeries = super.implements().concat([
                            Chart.IStiRadarSeries,
                            Chart.IStiRadarLineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            Chart.IStiRadarAreaSeries,
                            ICloneable
                        ]);
                    return StiRadarAreaSeries.implementsStiRadarAreaSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("Lighting", this.lighting, true);
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 2);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Lighting":
                                this.lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Lighting":
                                this.lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarAreaSeries;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                getDefaultAreaType() {
                    return Chart.StiRadarAreaArea;
                }
                createNew() {
                    return new StiRadarAreaSeries();
                }
            }
            Chart.StiRadarAreaSeries = StiRadarAreaSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRadarLineSeries extends Chart.StiRadarSeries {
                constructor() {
                    super();
                    this._lineColor = Color.black;
                    this._lineStyle = StiPenStyle.Solid;
                    this._lighting = true;
                    this._lineWidth = 2;
                    this.core = new Chart.StiRadarLineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiRadarLineSeries.implementsStiRadarLineSeries)
                        StiRadarLineSeries.implementsStiRadarLineSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarLineSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiRadarSeries
                        ]);
                    return StiRadarLineSeries.implementsStiRadarLineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("Lighting", this.lighting, true);
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 2);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "Lighting":
                                this.lighting = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "Lighting":
                                this.lighting = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarLineSeries;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get lighting() {
                    return this._lighting;
                }
                set lighting(value) {
                    this._lighting = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    if (value > 0) {
                        this._lineWidth = value;
                    }
                }
                getDefaultAreaType() {
                    return Chart.StiRadarLineArea;
                }
                createNew() {
                    return new StiRadarLineSeries();
                }
            }
            Chart.StiRadarLineSeries = StiRadarLineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRadarPointSeries extends Chart.StiRadarSeries {
                constructor() {
                    super();
                    this.core = new Chart.StiRadarPointSeriesCoreXF(this);
                }
                implements() {
                    if (!StiRadarPointSeries.implementsStiRadarPointSeries)
                        StiRadarPointSeries.implementsStiRadarPointSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiRadarPointSeries,
                            ICloneable,
                            Chart.IStiSeries,
                            Chart.IStiRadarSeries
                        ]);
                    return StiRadarPointSeries.implementsStiRadarPointSeries;
                }
                get componentId() {
                    return Report.StiComponentId.StiRadarPointSeries;
                }
                getDefaultAreaType() {
                    return Chart.StiRadarPointArea;
                }
                createNew() {
                    return new StiRadarPointSeries();
                }
            }
            Chart.StiRadarPointSeries = StiRadarPointSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            class StiRangeBarSeries extends Chart.StiClusteredColumnSeries {
                constructor() {
                    super();
                    this._valuesEnd = [3, 5, 9];
                    this._valueDataColumnEnd = "";
                    this.valueObjEnd = "";
                    this._listOfValuesEnd = "";
                    this.core = new Chart.StiRangeBarSeriesCoreXF(this);
                }
                implements() {
                    if (!StiRangeBarSeries.implementsStiRangeBarSeries)
                        StiRangeBarSeries.implementsStiRangeBarSeries = super.implements().concat([
                            Chart.IStiRangeBarSeries,
                            Chart.IStiClusteredColumnSeries,
                            Chart.IStiRangeSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyBrushNegative
                        ]);
                    return StiRangeBarSeries.implementsStiRangeBarSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnEnd", this._valueDataColumnEnd);
                    jObject.addPropertyJObject("Value", new StiExpression(this.value).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ValueEnd", new StiExpression(this.valueEnd).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValues", new StiExpression(this.listOfValues).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesEnd", new StiExpression(this.listOfValuesEnd).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = property.value.toString();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "Value":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.value = _expression.value;
                                    break;
                                }
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValues":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValues = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = node.textContent;
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "Value":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.value = _expression.value;
                                    break;
                                }
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValues":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValues = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiRangeBarSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiRangeBarArea;
                }
                get valuesEnd() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesEnd)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesEnd);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        if (serIndex == 0)
                            return this._valuesEnd;
                        return [3 + serIndex * 3, 5 + serIndex * 4, 9 + serIndex * 3];
                    }
                    return this._valuesEnd;
                }
                set valuesEnd(value) {
                    this._valuesEnd = value;
                }
                get valuesStringEnd() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesEnd) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringEnd(value) {
                    if (value == null || value.trim().length == 0) {
                        this._valuesEnd = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._valuesEnd = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this._valuesEnd[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valueDataColumnEnd() {
                    return this._valueDataColumnEnd;
                }
                set valueDataColumnEnd(value) {
                    this._valueDataColumnEnd = value;
                }
                onGetValueEnd(e) {
                }
                invokeGetValueEnd(sender, e) {
                    try {
                        this.onGetValueEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesValueEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueEnd != null)
                            this.getValueEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueEnd...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesEnd(e) {
                }
                invokeGetListOfValuesEnd(sender, e, series) {
                    try {
                        series.onGetListOfValuesEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartGanttSeriesListOfValuesEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series.listOfValuesEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValuesEnd != null)
                            series.getListOfValuesEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesEnd...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueEnd() {
                    return this.valueObjEnd;
                }
                set valueEnd(value) {
                    this.valueObjEnd = value;
                }
                get listOfValuesEnd() {
                    return this._listOfValuesEnd;
                }
                set listOfValuesEnd(value) {
                    this._listOfValuesEnd = value;
                }
                createNew() {
                    return new StiRangeBarSeries();
                }
            }
            Chart.StiRangeBarSeries = StiRangeBarSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiRangeSeries extends Chart.StiLineSeries {
                constructor() {
                    super();
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._valuesEnd = [3, 5, 9];
                    this._valueDataColumnEnd = "";
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.valueObjEnd = "";
                    this._listOfValuesEnd = "";
                    this.core = new Chart.StiRangeSeriesCoreXF(this);
                }
                implements() {
                    if (!StiRangeSeries.implementsStiRangeSeries)
                        StiRangeSeries.implementsStiRangeSeries = super.implements().concat([
                            Chart.IStiLineSeries,
                            Chart.IStiLineRangeSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiRangeSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiRangeSeries.implementsStiRangeSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnEnd", this._valueDataColumnEnd);
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    jObject.addPropertyJObject("ValueEnd", new StiExpression(this.valueEnd).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesEnd", new StiExpression(this.listOfValuesEnd).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = property.value.toString();
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = node.textContent;
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiRangeSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiRangeArea;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get valuesEnd() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesEnd)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesEnd);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        let offset = this.getOffsetForValues();
                        return [offset + 3 + serIndex * 3, offset + 5 + serIndex * 4, offset + 9 + serIndex * 3];
                    }
                    return this._valuesEnd;
                }
                set valuesEnd(value) {
                    this._valuesEnd = value;
                }
                get valuesStringEnd() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesEnd) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringEnd(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesEnd = [];
                    }
                    else {
                        let strs = value.split(";");
                        this.valuesEnd = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this.valuesEnd[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valueDataColumnEnd() {
                    return this._valueDataColumnEnd;
                }
                set valueDataColumnEnd(value) {
                    this._valueDataColumnEnd = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this._brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                onGetValueEnd(e) {
                }
                invokeGetValueEnd(sender, e) {
                    try {
                        this.onGetValueEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartRangeSeriesValueEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueEnd != null)
                            this.getValueEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueEnd...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesEnd(e) {
                }
                invokeGetListOfValuesEnd(sender, e, series) {
                    try {
                        series.onGetListOfValuesEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartRangeSeriesListOfValuesEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series.listOfValuesEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValuesEnd != null)
                            series.getListOfValuesEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesEnd...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueEnd() {
                    return this.valueObjEnd;
                }
                set valueEnd(value) {
                    this.valueObjEnd = value;
                }
                get listOfValuesEnd() {
                    return this._listOfValuesEnd;
                }
                set listOfValuesEnd(value) {
                    this._listOfValuesEnd = value;
                }
                createNew() {
                    return new StiRangeSeries();
                }
            }
            Chart.StiRangeSeries = StiRangeSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiSplineRangeSeries extends Chart.StiSplineSeries {
                constructor() {
                    super();
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._valuesEnd = [4, 5, 9];
                    this._valueDataColumnEnd = "";
                    this.valueObjEnd = "";
                    this._listOfValuesEnd = "";
                    this.core = new Chart.StiSplineRangeSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSplineRangeSeries.implementsStiSplineRangeSeries)
                        StiSplineRangeSeries.implementsStiSplineRangeSeries = super.implements().concat([
                            Chart.IStiSplineSeries,
                            Chart.IStiSplineRangeSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiRangeSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSplineRangeSeries.implementsStiSplineRangeSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnEnd", this._valueDataColumnEnd);
                    jObject.addPropertyJObject("ValueEnd", new StiExpression(this.valueEnd).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesEnd", new StiExpression(this.listOfValuesEnd).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = property.value.toString();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = node.textContent;
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSplineRangeSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiSplineRangeArea;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get valuesEnd() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesEnd)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesEnd);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        if (serIndex == 0)
                            return this._valuesEnd;
                        return [3 + serIndex * 3, 5 + serIndex * 4, 9 + serIndex * 3];
                    }
                    return this._valuesEnd;
                }
                set valuesEnd(value) {
                    this._valuesEnd = value;
                }
                get valuesStringEnd() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this._valuesEnd) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringEnd(value) {
                    if (value == null || value.trim().length == 0) {
                        this._valuesEnd = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._valuesEnd = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this._valuesEnd[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valueDataColumnEnd() {
                    return this._valueDataColumnEnd;
                }
                set valueDataColumnEnd(value) {
                    this._valueDataColumnEnd = value;
                }
                onGetValueEnd(e) {
                }
                invokeGetValueEnd(sender, e) {
                    try {
                        this.onGetValueEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSteppedRangeSeriesValueEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueEnd != null)
                            this.getValueEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueEnd...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesEnd(e) {
                }
                invokeGetListOfValuesEnd(sender, e, series) {
                    try {
                        series.onGetListOfValuesEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSteppedRangeSeriesListOfValuesEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series.listOfValuesEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValuesEnd != null)
                            series.getListOfValuesEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesEnd...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueEnd() {
                    return this.valueObjEnd;
                }
                set valueEnd(value) {
                    this.valueObjEnd = value;
                }
                get listOfValuesEnd() {
                    return this._listOfValuesEnd;
                }
                set listOfValuesEnd(value) {
                    this._listOfValuesEnd = value;
                }
                createNew() {
                    return new StiSplineRangeSeries();
                }
            }
            Chart.StiSplineRangeSeries = StiSplineRangeSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiArray = Stimulsoft.System.StiArray;
            var StiString = Stimulsoft.System.StiString;
            var StiExpression = Stimulsoft.Report.Expressions.StiExpression;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiText = Stimulsoft.Report.Components.StiText;
            var StringBuilder = Stimulsoft.System.Text.StringBuilder;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiSteppedRangeSeries extends Chart.StiSteppedLineSeries {
                constructor() {
                    super();
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this._valuesEnd = [4, 5, 7, 6, 6];
                    this._valueDataColumnEnd = "";
                    this._brushNegative = new StiSolidBrush(Color.firebrick);
                    this._allowApplyBrushNegative = false;
                    this.valueObjEnd = "";
                    this._listOfValuesEnd = "";
                    this.core = new Chart.StiSteppedRangeSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSteppedRangeSeries.implementsStiSteppedRangeSeries)
                        StiSteppedRangeSeries.implementsStiSteppedRangeSeries = super.implements().concat([
                            Chart.IStiSteppedLineSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiRangeSeries,
                            Chart.IStiSteppedRangeSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            ICloneable,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiSteppedRangeSeries.implementsStiSteppedRangeSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("TopN");
                    jObject.removeProperty("TrendLine");
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    jObject.addPropertyStringNullOrEmpty("ValueDataColumnEnd", this._valueDataColumnEnd);
                    jObject.addPropertyStringNullOrEmpty("BrushNegative", StiJsonReportObjectHelper.Serialize.jBrush(this._brushNegative));
                    jObject.addPropertyBool("AllowApplyBrushNegative", this._allowApplyBrushNegative);
                    jObject.addPropertyJObject("ValueEnd", new StiExpression(this.valueObjEnd).saveToJsonObject(mode));
                    jObject.addPropertyJObject("ListOfValuesEnd", new StiExpression(this.listOfValuesEnd).saveToJsonObject(mode));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Brush":
                                this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = property.value.toString();
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = property.value.stimulsoft().toBoolean();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.valueObjEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromJsonObject(property.value);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "ValueDataColumnEnd":
                                this._valueDataColumnEnd = node.textContent;
                                break;
                            case "BrushNegative":
                                this._brushNegative = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "AllowApplyBrushNegative":
                                this._allowApplyBrushNegative = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "GetValueEndEvent":
                                break;
                            case "GetListOfValuesEndEvent":
                                break;
                            case "ValueEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.valueObjEnd = _expression.value;
                                    break;
                                }
                            case "ListOfValuesEnd":
                                {
                                    let _expression = new StiExpression();
                                    _expression.loadFromXml(node);
                                    this.listOfValuesEnd = _expression.value;
                                    break;
                                }
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSteppedRangeSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiSteppedRangeArea;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get valuesEnd() {
                    if (this.chart != null && this.chart.report != null && this.chart.isDesigning && !this.isDashboard) {
                        if (!StiString.isNullOrEmpty(this.listOfValuesEnd)) {
                            return Chart.StiSeries.getNullableValuesFromString(this, this.listOfValuesEnd);
                        }
                        let serIndex = this.chart.series.indexOf(this);
                        if (serIndex == 0)
                            return this._valuesEnd;
                        return [3 + serIndex * 3, 5 + serIndex * 4, 7 + serIndex * 3, 6 + serIndex * 3, 6 + serIndex * 3];
                    }
                    return this._valuesEnd;
                }
                set valuesEnd(value) {
                    this._valuesEnd = value;
                }
                get valuesStringEnd() {
                    let sb = new StringBuilder();
                    let first = true;
                    for (let value of this.valuesEnd) {
                        if (first)
                            sb.appendFormat("{0}", value);
                        else
                            sb.appendFormat(";{0}", value);
                        first = false;
                    }
                    return sb.toString();
                }
                set valuesStringEnd(value) {
                    if (value == null || value.trim().length == 0) {
                        this.valuesEnd = [];
                    }
                    else {
                        let strs = value.split(";");
                        this._valuesEnd = StiArray.create(Number, strs.length);
                        let index = 0;
                        for (let str of strs) {
                            this._valuesEnd[index++] = str.stimulsoft().toNumber();
                        }
                    }
                }
                get valueDataColumnEnd() {
                    return this._valueDataColumnEnd;
                }
                set valueDataColumnEnd(value) {
                    this._valueDataColumnEnd = value;
                }
                get brushNegative() {
                    return this._brushNegative;
                }
                set brushNegative(value) {
                    this.brushNegative = value;
                }
                get allowApplyBrushNegative() {
                    return this._allowApplyBrushNegative;
                }
                set allowApplyBrushNegative(value) {
                    this._allowApplyBrushNegative = value;
                }
                onGetValueEnd(e) {
                }
                invokeGetValueEnd(sender, e) {
                    try {
                        this.onGetValueEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSteppedRangeSeriesValueEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(this.valueEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (this.getValueEnd != null)
                            this.getValueEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series InvokeGetValueEnd...ERROR");
                        Report.StiLogService.write(this.stimulsoft().getType(), this.chart.name + "Series " + ex);
                    }
                }
                onGetListOfValuesEnd(e) {
                }
                invokeGetListOfValuesEnd(sender, e, series) {
                    try {
                        series.onGetListOfValuesEnd(e);
                        if (sender.report.calculationMode == Report.StiCalculationMode.Interpretation) {
                            let tempText = new StiText();
                            tempText.name = "**ChartSteppedRangeSeriesListOfValuesEnd**";
                            tempText.page = sender.report.pages.getByIndex(0);
                            let parserResult = Report.Engine.StiParser.StiParser.parseTextValue(series.listOfValuesEnd, tempText);
                            e.value = sender.report.toString2(parserResult);
                        }
                        if (series.getListOfValuesEnd != null)
                            series.getListOfValuesEnd(sender, e);
                    }
                    catch (ex) {
                        Stimulsoft.System.StiError.showError(ex.message, false);
                        Report.StiLogService.write(this.stimulsoft().getType(), "InvokeGetListOfValuesEnd...Warning");
                        Report.StiLogService.write(this.stimulsoft().getType(), ex);
                    }
                }
                get valueEnd() {
                    return this.valueObjEnd;
                }
                set valueEnd(value) {
                    this.valueObjEnd = value;
                }
                get listOfValuesEnd() {
                    return this._listOfValuesEnd;
                }
                set listOfValuesEnd(value) {
                    this._listOfValuesEnd = value;
                }
                createNew() {
                    return new StiSteppedRangeSeries();
                }
            }
            Chart.StiSteppedRangeSeries = StiSteppedRangeSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiScatterSplineSeries extends Chart.StiScatterSeries {
                constructor() {
                    super();
                    this._tension = 0.55;
                    this.core = new Chart.StiScatterSplineSeriesCoreXF(this);
                }
                implements() {
                    if (!StiScatterSplineSeries.implementsStiScatterSplineSeries)
                        StiScatterSplineSeries.implementsStiScatterSplineSeries = super.implements().concat([
                            ICloneable,
                            Chart.IStiScatterLineSeries,
                            Chart.IStiBaseLineSeries,
                            Chart.IStiScatterSplineSeries,
                            IStiJsonReportObject,
                            Chart.IStiSeries,
                            Chart.IStiScatterSeries,
                            Chart.IStiAllowApplyColorNegative
                        ]);
                    return StiScatterSplineSeries.implementsStiScatterSplineSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("LineMarker");
                    jObject.addPropertyNumber("Tension", this._tension, 0.55);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Tension":
                                this._tension = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Tension":
                                this._tension = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiScatterSplineSeries;
                }
                clone() {
                    let series = super.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiScatterArea;
                }
                get tension() {
                    return this._tension;
                }
                set tension(value) {
                    this._tension = value;
                }
                createNew() {
                    return new StiScatterSplineSeries();
                }
            }
            Chart.StiScatterSplineSeries = StiScatterSplineSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiSunburstSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this.core = new Chart.StiSunburstSeriesCoreXF(this);
                }
                implements() {
                    if (!StiSunburstSeries.implementsStiSunburstSeries)
                        StiSunburstSeries.implementsStiSunburstSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSunburstSeries,
                            ICloneable,
                            Chart.IStiSeries
                        ]);
                    return StiSunburstSeries.implementsStiSunburstSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiSunburstArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiSunburstSeries;
                }
                createNew() {
                    return new StiSunburstSeries();
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
            }
            Chart.StiSunburstSeries = StiSunburstSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var Enum = Stimulsoft.System.Enum;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiFontIcons = Stimulsoft.Report.Helpers.StiFontIcons;
            class StiTreemapSeries extends Chart.StiSeries {
                constructor() {
                    super();
                    this._borderColor = Color.gray;
                    this._brush = new StiSolidBrush(Color.gainsboro);
                    this.core = new Chart.StiTreemapSeriesCoreXF(this);
                }
                implements() {
                    if (!StiTreemapSeries.implementsStiTreemapSeries)
                        StiTreemapSeries.implementsStiTreemapSeries = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiTreemapSeries,
                            Chart.IStiFontIconsSeries,
                            ICloneable,
                            Chart.IStiSeries
                        ]);
                    return StiTreemapSeries.implementsStiTreemapSeries;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyStringNullOrEmpty("BorderColor", StiJsonReportObjectHelper.Serialize.jColor(this._borderColor, Color.gray));
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this._brush));
                    if (this.icon != null)
                        jObject.addPropertyEnum("Icon", StiFontIcons, this.icon);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        {
                            switch (property.name) {
                                case "BorderColor":
                                    this._borderColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                    break;
                                case "Brush":
                                    this._brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                    break;
                                case "Icon":
                                    this.icon = Enum.parse(StiFontIcons, property.value.toString());
                                    break;
                            }
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Brush":
                            case "bh":
                                this._brush = StiBrush.loadFromXml(node.textContent);
                                break;
                            case "BorderColor":
                                this._borderColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Icon":
                                this.icon = Enum.parse(StiFontIcons, node.textContent);
                                break;
                        }
                    }
                }
                clone() {
                    let series = super.clone();
                    series.brush = this.brush.clone();
                    return series;
                }
                getDefaultAreaType() {
                    return Chart.StiTreemapArea;
                }
                get componentId() {
                    return Report.StiComponentId.StiTreemapSeries;
                }
                createNew() {
                    return new StiTreemapSeries();
                }
                get borderColor() {
                    return this._borderColor;
                }
                set borderColor(value) {
                    this._borderColor = value;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
            }
            Chart.StiTreemapSeries = StiTreemapSeries;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiNoneLabels extends Chart.StiSeriesLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiNoneLabelsCoreXF(this);
                }
                implements() {
                    if (!StiNoneLabels.implementsStiNoneLabels)
                        StiNoneLabels.implementsStiNoneLabels = super.implements().concat([
                            Chart.IStiNoneLabels,
                            Chart.IStiSeriesLabels,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiNoneLabels.implementsStiNoneLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("Antialiasing");
                    jObject.removeProperty("Visible");
                    jObject.removeProperty("LabelColor");
                    jObject.removeProperty("BorderColor");
                    jObject.removeProperty("Brush");
                    jObject.removeProperty("Font");
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiNoneLabels;
                }
                createNew() {
                    return new StiNoneLabels();
                }
            }
            Chart.StiNoneLabels = StiNoneLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiInsideBaseAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiInsideBaseAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiInsideBaseAxisLabels.implementsStiInsideBaseAxisLabels)
                        StiInsideBaseAxisLabels.implementsStiInsideBaseAxisLabels = super.implements().concat([
                            Chart.IStiInsideBaseAxisLabels,
                            Chart.IStiSeriesLabels,
                            ICloneable,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject
                        ]);
                    return StiInsideBaseAxisLabels.implementsStiInsideBaseAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiInsideBaseAxisLabels;
                }
                createNew() {
                    return new StiInsideBaseAxisLabels();
                }
            }
            Chart.StiInsideBaseAxisLabels = StiInsideBaseAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiInsideEndAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiInsideEndAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiInsideEndAxisLabels.implementsStiInsideEndAxisLabels)
                        StiInsideEndAxisLabels.implementsStiInsideEndAxisLabels = super.implements().concat([
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            Chart.IStiSeriesLabels,
                            IStiJsonReportObject,
                            Chart.IStiInsideEndAxisLabels,
                            ICloneable
                        ]);
                    return StiInsideEndAxisLabels.implementsStiInsideEndAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiInsideEndAxisLabels;
                }
                createNew() {
                    return new StiInsideEndAxisLabels();
                }
            }
            Chart.StiInsideEndAxisLabels = StiInsideEndAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiLeftAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiLeftAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiLeftAxisLabels.implementsStiLeftAxisLabels)
                        StiLeftAxisLabels.implementsStiLeftAxisLabels = super.implements().concat([
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiLeftAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiLeftAxisLabels.implementsStiLeftAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiLeftAxisLabels;
                }
                createNew() {
                    return new StiLeftAxisLabels();
                }
            }
            Chart.StiLeftAxisLabels = StiLeftAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiOutsideAxisLabels extends Chart.StiAxisSeriesLabels {
                constructor() {
                    super();
                    this._lineLength = 15;
                    this.core = new Chart.StiOutsideAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsideAxisLabels.implementsStiOutsideAxisLabels)
                        StiOutsideAxisLabels.implementsStiOutsideAxisLabels = super.implements().concat([
                            Chart.IStiOutsideAxisLabels,
                            Chart.IStiSeriesLabels,
                            ICloneable,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject
                        ]);
                    return StiOutsideAxisLabels.implementsStiOutsideAxisLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyNumber("LineLength", this._lineLength, 15);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "LineLength":
                                this._lineLength = property.value.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "LineLength":
                                this._lineLength = node.textContent.stimulsoft().toNumber();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsideAxisLabels;
                }
                get lineLength() {
                    return this._lineLength;
                }
                set lineLength(value) {
                    this._lineLength = value;
                }
                createNew() {
                    return new StiOutsideAxisLabels();
                }
            }
            Chart.StiOutsideAxisLabels = StiOutsideAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiOutsideBaseAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiOutsideBaseAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsideBaseAxisLabels.implementsStiOutsideBaseAxisLabels)
                        StiOutsideBaseAxisLabels.implementsStiOutsideBaseAxisLabels = super.implements().concat([
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject,
                            Chart.IStiOutsideBaseAxisLabels,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiOutsideBaseAxisLabels.implementsStiOutsideBaseAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsideBaseAxisLabels;
                }
                createNew() {
                    return new StiOutsideBaseAxisLabels();
                }
            }
            Chart.StiOutsideBaseAxisLabels = StiOutsideBaseAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiOutsideEndAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiOutsideEndAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsideEndAxisLabels.implementsStiOutsideEndAxisLabels)
                        StiOutsideEndAxisLabels.implementsStiOutsideEndAxisLabels = super.implements().concat([
                            Chart.IStiOutsideEndAxisLabels,
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiOutsideEndAxisLabels.implementsStiOutsideEndAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsideEndAxisLabels;
                }
                createNew() {
                    return new StiOutsideEndAxisLabels();
                }
            }
            Chart.StiOutsideEndAxisLabels = StiOutsideEndAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiRightAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiRightAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiRightAxisLabels.implementsStiRightAxisLabels)
                        StiRightAxisLabels.implementsStiRightAxisLabels = super.implements().concat([
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            Chart.IStiRightAxisLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiRightAxisLabels.implementsStiRightAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiRightAxisLabels;
                }
                createNew() {
                    return new StiRightAxisLabels();
                }
            }
            Chart.StiRightAxisLabels = StiRightAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiValueAxisLabels extends Chart.StiCenterAxisLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiValueAxisLabelsCoreXF(this);
                }
                implements() {
                    if (!StiValueAxisLabels.implementsStiValueAxisLabels)
                        StiValueAxisLabels.implementsStiValueAxisLabels = super.implements().concat([
                            Chart.IStiValueAxisLabels,
                            Chart.IStiCenterAxisLabels,
                            Chart.IStiAxisSeriesLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiValueAxisLabels.implementsStiValueAxisLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiValueAxisLabels;
                }
                createNew() {
                    return new StiValueAxisLabels();
                }
            }
            Chart.StiValueAxisLabels = StiValueAxisLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiFunnelSeriesLabels extends Chart.StiSeriesLabels {
                implements() {
                    if (!StiFunnelSeriesLabels.implementsStiFunnelSeriesLabels)
                        StiFunnelSeriesLabels.implementsStiFunnelSeriesLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiFunnelSeriesLabels,
                            ICloneable,
                            Chart.IStiSeriesLabels
                        ]);
                    return StiFunnelSeriesLabels.implementsStiFunnelSeriesLabels;
                }
            }
            Chart.StiFunnelSeriesLabels = StiFunnelSeriesLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiCenterFunnelLabels extends Chart.StiFunnelSeriesLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiCenterFunnelLabelsCoreXF(this);
                }
                implements() {
                    if (!StiCenterFunnelLabels.implementsStiCenterFunnelLabels)
                        StiCenterFunnelLabels.implementsStiCenterFunnelLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            Chart.IStiFunnelSeriesLabels,
                            ICloneable,
                            Chart.IStiCenterFunnelLabels
                        ]);
                    return StiCenterFunnelLabels.implementsStiCenterFunnelLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiCenterFunnelLabels;
                }
                createNew() {
                    return new StiCenterFunnelLabels();
                }
            }
            Chart.StiCenterFunnelLabels = StiCenterFunnelLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiOutsideLeftFunnelLabels extends Chart.StiFunnelSeriesLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiOutsideLeftFunnelLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsideLeftFunnelLabels.implementsStiOutsideLeftFunnelLabels)
                        StiOutsideLeftFunnelLabels.implementsStiOutsideLeftFunnelLabels = super.implements().concat([
                            Chart.IStiCenterFunnelLabels,
                            Chart.IStiOutsideLeftFunnelLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            Chart.IStiFunnelSeriesLabels,
                            ICloneable
                        ]);
                    return StiOutsideLeftFunnelLabels.implementsStiOutsideLeftFunnelLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsideLeftFunnelLabels;
                }
                createNew() {
                    return new StiOutsideLeftFunnelLabels();
                }
            }
            Chart.StiOutsideLeftFunnelLabels = StiOutsideLeftFunnelLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiOutsideRightFunnelLabels extends Chart.StiFunnelSeriesLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiOutsideRightFunnelLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsideRightFunnelLabels.implementsStiOutsideRightFunnelLabels)
                        StiOutsideRightFunnelLabels.implementsStiOutsideRightFunnelLabels = super.implements().concat([
                            Chart.IStiOutsideRightFunnelLabels,
                            Chart.IStiCenterFunnelLabels,
                            IStiJsonReportObject,
                            Chart.IStiSeriesLabels,
                            Chart.IStiFunnelSeriesLabels,
                            ICloneable
                        ]);
                    return StiOutsideRightFunnelLabels.implementsStiOutsideRightFunnelLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsideRightFunnelLabels;
                }
                createNew() {
                    return new StiOutsideRightFunnelLabels();
                }
            }
            Chart.StiOutsideRightFunnelLabels = StiOutsideRightFunnelLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiPieSeriesLabels extends Chart.StiSeriesLabels {
                constructor() {
                    super(...arguments);
                    this._showInPercent = false;
                }
                implements() {
                    if (!StiPieSeriesLabels.implementsStiPieSeriesLabels)
                        StiPieSeriesLabels.implementsStiPieSeriesLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiPieSeriesLabels,
                            Chart.IStiSeriesLabels,
                            ICloneable
                        ]);
                    return StiPieSeriesLabels.implementsStiPieSeriesLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("ShowInPercent", this._showInPercent);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowInPercent":
                                this._showInPercent = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowInPercent":
                                this._showInPercent = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get showInPercent() {
                    return this._showInPercent;
                }
                set showInPercent(value) {
                    this._showInPercent = value;
                    if (this._showInPercent && !this.format.stimulsoft().startsWith("P"))
                        this.format = "P2";
                    if (!this._showInPercent)
                        this.format = "";
                }
            }
            Chart.StiPieSeriesLabels = StiPieSeriesLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiCenterPieLabels extends Chart.StiPieSeriesLabels {
                constructor() {
                    super();
                    this._autoRotate = false;
                    this.core = new Chart.StiCenterPieLabelsCoreXF(this);
                }
                implements() {
                    if (!StiCenterPieLabels.implementsStiCenterPieLabels)
                        StiCenterPieLabels.implementsStiCenterPieLabels = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiPieSeriesLabels,
                            Chart.IStiSeriesLabels,
                            Chart.IStiCenterPieLabels,
                            ICloneable
                        ]);
                    return StiCenterPieLabels.implementsStiCenterPieLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.addPropertyBool("AutoRotate", this.autoRotate);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AutoRotate":
                                this.autoRotate = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AutoRotate":
                                this.autoRotate = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiCenterPieLabels;
                }
                get autoRotate() {
                    return this._autoRotate;
                }
                set autoRotate(value) {
                    this._autoRotate = value;
                }
                createNew() {
                    return new StiCenterPieLabels();
                }
            }
            Chart.StiCenterPieLabels = StiCenterPieLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiInsideEndPieLabels extends Chart.StiCenterPieLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiInsideEndPieLabelsCoreXF(this);
                }
                implements() {
                    if (!StiInsideEndPieLabels.implementsStiInsideEndPieLabels)
                        StiInsideEndPieLabels.implementsStiInsideEndPieLabels = super.implements().concat([
                            Chart.IStiCenterPieLabels,
                            Chart.IStiSeriesLabels,
                            Chart.IStiPieSeriesLabels,
                            Chart.IStiInsideEndPieLabels,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiInsideEndPieLabels.implementsStiInsideEndPieLabels;
                }
                get componentId() {
                    return Report.StiComponentId.StiInsideEndPieLabels;
                }
                createNew() {
                    return new StiInsideEndPieLabels();
                }
            }
            Chart.StiInsideEndPieLabels = StiInsideEndPieLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiOutsidePieLabels extends Chart.StiCenterPieLabels {
                constructor() {
                    super();
                    this._showValue = false;
                    this._lineLength = 20;
                    this._lineColor = Color.black;
                    this.core = new Chart.StiOutsidePieLabelsCoreXF(this);
                }
                implements() {
                    if (!StiOutsidePieLabels.implementsStiOutsidePieLabels)
                        StiOutsidePieLabels.implementsStiOutsidePieLabels = super.implements().concat([
                            Chart.IStiOutsidePieLabels,
                            Chart.IStiCenterPieLabels,
                            Chart.IStiPieSeriesLabels,
                            Chart.IStiSeriesLabels,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiOutsidePieLabels.implementsStiOutsidePieLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("Angle");
                    jObject.addPropertyBool("ShowValue", this.showValue);
                    jObject.addPropertyNumber("LineLength", this.lineLength, 20);
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    super.loadFromJsonObject(jObject);
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "ShowValue":
                                this.showValue = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineLength":
                                this.lineLength = property.value.stimulsoft().toNumber();
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    super.loadFromXml(xmlNode);
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "ShowValue":
                                this.showValue = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineLength":
                                this.lineLength = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiOutsidePieLabels;
                }
                get showValue() {
                    return this._showValue;
                }
                set showValue(value) {
                    this._showValue = value;
                }
                get lineLength() {
                    return this._lineLength;
                }
                set lineLength(value) {
                    this._lineLength = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                createNew() {
                    return new StiOutsidePieLabels();
                }
            }
            Chart.StiOutsidePieLabels = StiOutsidePieLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTwoColumnsPieLabels extends Chart.StiOutsidePieLabels {
                constructor() {
                    super();
                    this.core = new Chart.StiTwoColumnsPieLabelsCoreXF(this);
                }
                implements() {
                    if (!StiTwoColumnsPieLabels.implementsStiTwoColumnsPieLabels)
                        StiTwoColumnsPieLabels.implementsStiTwoColumnsPieLabels = super.implements().concat([
                            Chart.IStiTwoColumnsPieLabels,
                            Chart.IStiOutsidePieLabels,
                            Chart.IStiCenterPieLabels,
                            Chart.IStiPieSeriesLabels,
                            Chart.IStiSeriesLabels,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiTwoColumnsPieLabels.implementsStiTwoColumnsPieLabels;
                }
                saveToJsonObject(mode) {
                    let jObject = super.saveToJsonObject(mode);
                    jObject.removeProperty("AutoRotate");
                    return jObject;
                }
                get componentId() {
                    return Report.StiComponentId.StiTwoColumnsPieLabels;
                }
                createNew() {
                    return new StiTwoColumnsPieLabels();
                }
            }
            Chart.StiTwoColumnsPieLabels = StiTwoColumnsPieLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiCenterTreemapLabels extends Chart.StiAxisSeriesLabels {
                get componentId() {
                    return Report.StiComponentId.StiCenterTreemapLabels;
                }
                createNew() {
                    return new StiCenterTreemapLabels();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiCenterTreemapLabelsCoreXF(this);
                }
            }
            Chart.StiCenterTreemapLabels = StiCenterTreemapLabels;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiService = Stimulsoft.Base.Services.StiService;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiStrips extends StiService {
                constructor() {
                    super();
                    this._allowApplyStyle = true;
                    this._showBehind = true;
                    this._stripBrush = new StiSolidBrush(Color.transparent);
                    this._antialiasing = true;
                    this._font = new Font("Arial", 7);
                    this._text = "";
                    this._titleVisible = true;
                    this._titleColor = Color.green;
                    this._orientation = Chart.StiStrips_StiOrientation.Horizontal;
                    this._showInLegend = true;
                    this._maxValue = "1";
                    this._minValue = "0";
                    this._visible = true;
                    this._core = new Chart.StiStripsCoreXF(this);
                }
                implements() {
                    if (!StiStrips.implementsStiStrips)
                        StiStrips.implementsStiStrips = super.implements().concat([
                            IStiJsonReportObject,
                            Chart.IStiStrips,
                            ICloneable
                        ]);
                    return StiStrips.implementsStiStrips;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    jObject.addPropertyBool("ShowBehind", this.showBehind, true);
                    jObject.addPropertyStringNullOrEmpty("StripBrush", StiJsonReportObjectHelper.Serialize.jBrush(this._stripBrush));
                    jObject.addPropertyBool("Antialiasing", this._antialiasing, true);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this.font, "Arial", 7));
                    jObject.addPropertyStringNullOrEmpty("Text", this._text);
                    jObject.addPropertyBool("TitleVisible", this._titleVisible, true);
                    jObject.addPropertyStringNullOrEmpty("TitleColor", StiJsonReportObjectHelper.Serialize.jColor(this.titleColor, Color.green));
                    jObject.addPropertyEnum("Orientation", Chart.StiStrips_StiOrientation, this._orientation, Chart.StiStrips_StiOrientation.Horizontal);
                    jObject.addPropertyBool("ShowInLegend", this.showInLegend, true);
                    jObject.addPropertyString("MaxValue", this.maxValue, "1");
                    jObject.addPropertyString("MinValue", this.minValue, "0");
                    jObject.addPropertyBool("Visible", this.visible, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                            case "ShowBehind":
                                this.showBehind = property.value.stimulsoft().toBoolean();
                                break;
                            case "StripBrush":
                                this._stripBrush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Antialiasing":
                                this._antialiasing = property.value.stimulsoft().toBoolean();
                                break;
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "Text":
                                this._text = property.value.toString();
                                break;
                            case "TitleVisible":
                                this._titleVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "TitleColor":
                                this.titleColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "Orientation":
                                this._orientation = Enum.parse(Chart.StiStrips_StiOrientation, property.value.toString());
                                break;
                            case "ShowInLegend":
                                this.showInLegend = property.value.stimulsoft().toBoolean();
                                break;
                            case "MaxValue":
                                this.maxValue = property.value.toString();
                                break;
                            case "MinValue":
                                this.minValue = property.value.toString();
                                break;
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "ShowBehind":
                                this.showBehind = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "StripBrush":
                                this._stripBrush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Antialiasing":
                                this._antialiasing = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Text":
                            case "text":
                                this._text = node.textContent;
                                break;
                            case "TitleVisible":
                                this._titleVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "TitleColor":
                                this.titleColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "Orientation":
                                this._orientation = Enum.parse(Chart.StiStrips_StiOrientation, node.textContent);
                                break;
                            case "ShowInLegend":
                                this.showInLegend = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "MaxValue":
                                this.maxValue = node.textContent;
                                break;
                            case "MinValue":
                                this.minValue = node.textContent;
                                break;
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiStrips;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let strips = this.stimulsoft().memberwiseClone();
                    if (this.core != null) {
                        strips.core = this.core.clone();
                        strips.core.strips = strips;
                    }
                    return strips;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiStrips;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                        if (value && this.chart != null)
                            this.core.applyStyle(this.chart.style);
                    }
                }
                get showBehind() {
                    return this._showBehind;
                }
                set showBehind(value) {
                    this._showBehind = value;
                }
                get stripBrush() {
                    return this._stripBrush;
                }
                set stripBrush(value) {
                    this._stripBrush = value;
                }
                get antialiasing() {
                    return this._antialiasing;
                }
                set antialiasing(value) {
                    this._antialiasing = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get text() {
                    return this._text;
                }
                set text(value) {
                    this._text = value;
                }
                get titleVisible() {
                    return this._titleVisible;
                }
                set titleVisible(value) {
                    this._titleVisible = value;
                }
                get titleColor() {
                    return this._titleColor;
                }
                set titleColor(value) {
                    this._titleColor = value;
                }
                get orientation() {
                    return this._orientation;
                }
                set orientation(value) {
                    this._orientation = value;
                }
                get showInLegend() {
                    return this._showInLegend;
                }
                set showInLegend(value) {
                    this._showInLegend = value;
                }
                get maxValue() {
                    return this._maxValue;
                }
                set maxValue(value) {
                    this._maxValue = value;
                }
                get minValue() {
                    return this._minValue;
                }
                set minValue(value) {
                    this._minValue = value;
                }
                get visible() {
                    return this._visible;
                }
                set visible(value) {
                    this._visible = value;
                }
                get chart() {
                    return this._chart;
                }
                set chart(value) {
                    this._chart = value;
                }
            }
            Chart.StiStrips = StiStrips;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle01 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle01();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF01();
                }
            }
            Chart.StiStyle01 = StiStyle01;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiCustomStyle extends Chart.StiStyle01 {
                constructor(reportStyleName = null) {
                    super();
                    this.core = new Chart.StiCustomStyleCoreXF(this);
                    this.core.reportStyleName = reportStyleName;
                }
                implements() {
                    if (!StiCustomStyle.implementsStiCustomStyle)
                        StiCustomStyle.implementsStiCustomStyle = super.implements().concat([
                            Chart.IStiCustomStyle
                        ]);
                    return StiCustomStyle.implementsStiCustomStyle;
                }
                get serviceName() {
                    return "CustomStyle";
                }
                get customCore() {
                    return this.core;
                }
            }
            Chart.StiCustomStyle = StiCustomStyle;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle02 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle02();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF02();
                }
            }
            Chart.StiStyle02 = StiStyle02;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle03 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle03();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF03();
                }
            }
            Chart.StiStyle03 = StiStyle03;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle04 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle04();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF04();
                }
            }
            Chart.StiStyle04 = StiStyle04;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle05 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle05();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF05();
                }
            }
            Chart.StiStyle05 = StiStyle05;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle06 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle06();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF06();
                }
            }
            Chart.StiStyle06 = StiStyle06;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle07 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle07();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF07();
                }
            }
            Chart.StiStyle07 = StiStyle07;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle08 extends Chart.StiStyle03 {
                createNew() {
                    return new StiStyle08();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF08();
                }
            }
            Chart.StiStyle08 = StiStyle08;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle09 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle09();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF09();
                }
            }
            Chart.StiStyle09 = StiStyle09;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle10 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle10();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF10();
                }
            }
            Chart.StiStyle10 = StiStyle10;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle11 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle11();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF11();
                }
            }
            Chart.StiStyle11 = StiStyle11;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle12 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle12();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF12();
                }
            }
            Chart.StiStyle12 = StiStyle12;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle13 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle13();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF13();
                }
            }
            Chart.StiStyle13 = StiStyle13;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle14 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle14();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF14();
                }
            }
            Chart.StiStyle14 = StiStyle14;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle15 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle15();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF15();
                }
            }
            Chart.StiStyle15 = StiStyle15;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle16 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle16();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF16();
                }
            }
            Chart.StiStyle16 = StiStyle16;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle17 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle17();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF17();
                }
            }
            Chart.StiStyle17 = StiStyle17;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle18 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle18();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF18();
                }
            }
            Chart.StiStyle18 = StiStyle18;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle19 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle19();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF19();
                }
            }
            Chart.StiStyle19 = StiStyle19;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle20 extends Chart.StiChartStyle {
                createNew() {
                    return new StiStyle20();
                }
                constructor() {
                    super();
                    this.core = new Chart.StiStyleCoreXF20();
                }
            }
            Chart.StiStyle20 = StiStyle20;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle21 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF21();
                }
                createNew() {
                    return new StiStyle21();
                }
            }
            Chart.StiStyle21 = StiStyle21;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle22 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF22();
                }
                createNew() {
                    return new StiStyle22();
                }
            }
            Chart.StiStyle22 = StiStyle22;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            class StiStyle23 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF23();
                }
                createNew() {
                    return new StiStyle23();
                }
            }
            Chart.StiStyle23 = StiStyle23;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle24 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.Orange;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF24();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "Orange"); }
                createNew() {
                    return new StiStyle24();
                }
            }
            Chart.StiStyle24 = StiStyle24;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle26 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.Turquoise;
                    this.core = new Chart.StiStyleCoreXF26();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "Turquoise"); }
                createNew() {
                    return new StiStyle26();
                }
            }
            Chart.StiStyle26 = StiStyle26;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle27 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.SlateGray;
                    this.core = new Chart.StiStyleCoreXF27();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "SlateGray"); }
                createNew() {
                    return new StiStyle27();
                }
            }
            Chart.StiStyle27 = StiStyle27;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle28 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.DarkBlue;
                    this.core = new Chart.StiStyleCoreXF28();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "DarkBlue"); }
                createNew() {
                    return new StiStyle28();
                }
            }
            Chart.StiStyle28 = StiStyle28;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle30 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.DarkGray;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF30();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "DarkGray"); }
                createNew() {
                    return new StiStyle30();
                }
            }
            Chart.StiStyle30 = StiStyle30;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle31 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.DarkTurquoise;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF31();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "DarkTurquoise"); }
                createNew() {
                    return new StiStyle31();
                }
            }
            Chart.StiStyle31 = StiStyle31;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle32 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.Silver;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF32();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "Silver"); }
                createNew() {
                    return new StiStyle32();
                }
            }
            Chart.StiStyle32 = StiStyle32;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle33 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.AliceBlue;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF33();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "AliceBlue"); }
                createNew() {
                    return new StiStyle33();
                }
            }
            Chart.StiStyle33 = StiStyle33;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiLocalization = Stimulsoft.Base.Localization.StiLocalization;
            var StiElementStyleIdent = Stimulsoft.Report.Dashboard.StiElementStyleIdent;
            class StiStyle34 extends Chart.StiChartStyle {
                constructor() {
                    super();
                    this.allowDashboard = true;
                    this.styleIdent = StiElementStyleIdent.DarkGreen;
                    this.isOffice2015Style = true;
                    this.core = new Chart.StiStyleCoreXF34();
                }
                get dashboardName() { return StiLocalization.get("PropertyColor", "DarkGreen"); }
                createNew() {
                    return new StiStyle34();
                }
            }
            Chart.StiStyle34 = StiStyle34;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiChartTableDataCells {
                constructor(shrinkFontToFit = false, shrinkFontToFitMinimumSize = 1, font = new Font("Arial", 8), textColor = Color.darkGray) {
                    this._font = new Font("Arial", 8);
                    this._textColor = Color.darkGray;
                    this._shrinkFontToFit = false;
                    this._shrinkFontToFitMinimumSize = 1;
                    this._font = font;
                    this._textColor = textColor;
                    this._shrinkFontToFit = shrinkFontToFit;
                    this._shrinkFontToFitMinimumSize = shrinkFontToFitMinimumSize;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.fontArial8(this.font));
                    jObject.addPropertyStringNullOrEmpty("TextColor", StiJsonReportObjectHelper.Serialize.jColor(this._textColor, Color.darkGray));
                    jObject.addPropertyNumber("ShrinkFontToFitMinimumSize", this._shrinkFontToFitMinimumSize, 1);
                    jObject.addPropertyBool("ShrinkFontToFit", this._shrinkFontToFit);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "TextColor":
                                this._textColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "ShrinkFontToFitMinimumSize":
                                this._shrinkFontToFitMinimumSize = property.value.stimulsoft().toNumber();
                                break;
                            case "ShrinkFontToFit":
                                this._shrinkFontToFit = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "TextColor":
                                this._textColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "ShrinkFontToFitMinimumSize":
                                this._shrinkFontToFitMinimumSize = node.textContent.stimulsoft().toNumber();
                                break;
                            case "ShrinkFontToFit":
                                this._shrinkFontToFit = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                clone() {
                    let header = this.stimulsoft().memberwiseClone();
                    header.font = this.font.clone();
                    return header;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get textColor() {
                    return this._textColor;
                }
                set textColor(value) {
                    this._textColor = value;
                }
                get shrinkFontToFit() {
                    return this._shrinkFontToFit;
                }
                set shrinkFontToFit(value) {
                    this._shrinkFontToFit = value;
                }
                get shrinkFontToFitMinimumSize() {
                    return this._shrinkFontToFitMinimumSize;
                }
                set shrinkFontToFitMinimumSize(value) {
                    this._shrinkFontToFitMinimumSize = value;
                }
            }
            Chart.StiChartTableDataCells = StiChartTableDataCells;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiSolidBrush = Stimulsoft.Base.Drawing.StiSolidBrush;
            var StiBrush = Stimulsoft.Base.Drawing.StiBrush;
            var Color = Stimulsoft.System.Drawing.Color;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiChartTableHeader {
                constructor(textAfter = "", brush = new StiSolidBrush(Color.white), font = new Font("Arial", 8), textColor = Color.darkGray, wordWrap = false, format = "") {
                    this._brush = new StiSolidBrush(Color.white);
                    this._font = new Font("Arial", 8);
                    this._textColor = Color.darkGray;
                    this._wordWrap = false;
                    this._textAfter = "";
                    this._textAfter = textAfter;
                    this._brush = brush;
                    this._font = font;
                    this._textColor = textColor;
                    this._wordWrap = wordWrap;
                    this.format = format;
                }
                implements() {
                    if (!StiChartTableHeader.implementsStiChartTableHeader)
                        StiChartTableHeader.implementsStiChartTableHeader = [IStiJsonReportObject,
                            Chart.IStiChartTableHeader,
                            ICloneable];
                    return StiChartTableHeader.implementsStiChartTableHeader;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("TextAfter", this.textAfter);
                    jObject.addPropertyStringNullOrEmpty("Brush", StiJsonReportObjectHelper.Serialize.jBrush(this.brush));
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.fontArial8(this.font));
                    jObject.addPropertyStringNullOrEmpty("TextColor", StiJsonReportObjectHelper.Serialize.jColor(this._textColor, Color.darkGray));
                    jObject.addPropertyBool("WordWrap", this.wordWrap);
                    jObject.addPropertyStringNullOrEmpty("Format", this.format);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "TextAfter":
                                this.textAfter = property.value.toString();
                                break;
                            case "Brush":
                                this.brush = StiJsonReportObjectHelper.Deserialize.brush(property.value.toString());
                                break;
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "TextColor":
                                this._textColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "WordWrap":
                                this.wordWrap = property.value.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this.format = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "TextAfter":
                                this.textAfter = node.textContent;
                                break;
                            case "Brush":
                            case "bh":
                                this.brush = StiBrush.convertToBrush(node.textContent);
                                break;
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "TextColor":
                                this._textColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "WordWrap":
                                this.wordWrap = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Format":
                                this.format = node.textContent;
                                break;
                        }
                    }
                }
                clone() {
                    let header = this.stimulsoft().memberwiseClone();
                    header.brush = this.brush.clone();
                    header.font = this.font.clone();
                    return header;
                }
                get brush() {
                    return this._brush;
                }
                set brush(value) {
                    this._brush = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get textColor() {
                    return this._textColor;
                }
                set textColor(value) {
                    this._textColor = value;
                }
                get wordWrap() {
                    return this._wordWrap;
                }
                set wordWrap(value) {
                    this._wordWrap = value;
                }
                get textAfter() {
                    return this._textAfter;
                }
                set textAfter(value) {
                    this._textAfter = value;
                }
            }
            Chart.StiChartTableHeader = StiChartTableHeader;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var Enum = Stimulsoft.System.Enum;
            class StiSeriesTopN {
                constructor() {
                    this._mode = Chart.StiTopNMode.None;
                    this._count = 5;
                    this._showOthers = true;
                    this._othersText = "Others";
                }
                implements() {
                    if (!StiSeriesTopN.implementsStiSeriesTopN)
                        StiSeriesTopN.implementsStiSeriesTopN = [
                            IStiJsonReportObject,
                            Chart.IStiSeriesTopN,
                            ICloneable
                        ];
                    return StiSeriesTopN.implementsStiSeriesTopN;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyEnum("Mode", Chart.StiTopNMode, this._mode, Chart.StiTopNMode.None);
                    jObject.addPropertyNumber("Count", this._count, 5);
                    jObject.addPropertyBool("ShowOthers", this._showOthers, true);
                    jObject.addPropertyString("OthersText", this._othersText, "Others");
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Mode":
                                this._mode = Enum.parse(Chart.StiTopNMode, property.value.toString());
                                break;
                            case "Count":
                                this._count = property.value.stimulsoft().toNumber();
                                break;
                            case "ShowOthers":
                                this._showOthers = property.value.stimulsoft().toBoolean();
                                break;
                            case "OthersText":
                                this._othersText = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Mode":
                                this._mode = Enum.parse(Chart.StiTopNMode, node.textContent);
                                break;
                            case "Count":
                                this._count = node.textContent.stimulsoft().toNumber();
                                break;
                            case "ShowOthers":
                                this._showOthers = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "OthersText":
                                this._othersText = node.textContent;
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiSeriesTopN;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let topN = this.stimulsoft().memberwiseClone();
                    return topN;
                }
                get mode() {
                    return this._mode;
                }
                set mode(value) {
                    this._mode = value;
                }
                get count() {
                    return this._count;
                }
                set count(value) {
                    this._count = value;
                }
                get showOthers() {
                    return this._showOthers;
                }
                set showOthers(value) {
                    this._showOthers = value;
                }
                get othersText() {
                    return this._othersText;
                }
                set othersText(value) {
                    this._othersText = value;
                }
            }
            Chart.StiSeriesTopN = StiSeriesTopN;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            var StiService = Stimulsoft.Base.Services.StiService;
            var Font = Stimulsoft.System.Drawing.Font;
            class StiTrendLine extends StiService {
                constructor() {
                    super(...arguments);
                    this._lineColor = Color.black;
                    this._lineWidth = 1;
                    this._lineStyle = StiPenStyle.Solid;
                    this._showShadow = true;
                    this._allowApplyStyle = true;
                    this._position = Chart.StiTrendLine_StiTextPosition.LeftBottom;
                    this._font = new Font("Arial", 7);
                    this._text = "";
                    this._titleVisible = true;
                }
                implements() {
                    if (!StiTrendLine.implementsStiTrendLine)
                        StiTrendLine.implementsStiTrendLine = super.implements().concat([
                            Chart.IStiTrendLine,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiTrendLine.implementsStiTrendLine;
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyIdent("Ident", this.stimulsoft().getType().stimulsoft().getTypeName());
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.black));
                    jObject.addPropertyNumber("LineWidth", this._lineWidth, 1);
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this._lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("ShowShadow", this._showShadow, true);
                    jObject.addPropertyEnum("Position", Chart.StiTrendLine_StiTextPosition, this._position, Chart.StiConstantLines_StiTextPosition.LeftBottom);
                    jObject.addPropertyStringNullOrEmpty("Font", StiJsonReportObjectHelper.Serialize.font(this.font, "Arial", 7));
                    jObject.addPropertyStringNullOrEmpty("Text", this._text);
                    jObject.addPropertyBool("TitleVisible", this._titleVisible, true);
                    jObject.addPropertyBool("AllowApplyStyle", this.allowApplyStyle, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Position":
                                this._position = Enum.parse(Chart.StiTrendLine_StiTextPosition, property.value.toString());
                                break;
                            case "Font":
                                this.font = StiJsonReportObjectHelper.Deserialize.font(property.value.toString(), this.font);
                                break;
                            case "Text":
                                this._text = property.value.toString();
                                break;
                            case "TitleVisible":
                                this._titleVisible = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineWidth":
                                this._lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                            case "ShowShadow":
                                this._showShadow = property.value.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = property.value.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                static loadFromJsonObjectInternal(jObject) {
                    let ident = jObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                    let service = Stimulsoft["StiOptions"].Services.chartTrendLines.firstOrDefault(x => x.stimulsoft().getType().stimulsoft().getTypeName() == ident);
                    if (service == null)
                        throw StiString.format("Type {0} is not found!", ident);
                    let trendLine = service.createNew();
                    trendLine.loadFromJsonObject(jObject);
                    return trendLine;
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Position":
                                this._position = Enum.parse(Chart.StiTrendLine_StiTextPosition, node.textContent);
                                break;
                            case "Font":
                            case "fn":
                                this.font = Stimulsoft.System.Convert.toFont(node.textContent);
                                break;
                            case "Text":
                                this._text = node.textContent;
                                break;
                            case "TitleVisible":
                                this._titleVisible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineWidth":
                                this._lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this._lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                            case "ShowShadow":
                                this._showShadow = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "AllowApplyStyle":
                                this.allowApplyStyle = node.textContent.stimulsoft().toBoolean();
                                break;
                        }
                    }
                }
                static loadTrendLineFromXml(xmlNode) {
                    switch (xmlNode.attributes.getNamedItem("type").value) {
                        case "Stimulsoft.Report.Chart.StiTrendLineNone": {
                            let trendLineNone = new Chart.StiTrendLineNone();
                            trendLineNone.loadFromXml(xmlNode);
                            return trendLineNone;
                        }
                        case "Stimulsoft.Report.Chart.StiTrendLineLinear": {
                            let trendLineLinear = new Chart.StiTrendLineLinear();
                            trendLineLinear.loadFromXml(xmlNode);
                            return trendLineLinear;
                        }
                        case "Stimulsoft.Report.Chart.StiTrendLineExponential": {
                            let trendLineExponential = new Chart.StiTrendLineExponential();
                            trendLineExponential.loadFromXml(xmlNode);
                            return trendLineExponential;
                        }
                        case "Stimulsoft.Report.Chart.StiTrendLineLogarithmic": {
                            let trendLineLogarithmic = new Chart.StiTrendLineLogarithmic();
                            trendLineLogarithmic.loadFromXml(xmlNode);
                            return trendLineLogarithmic;
                        }
                    }
                    return new Chart.StiTrendLineNone();
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLine;
                }
                get propName() {
                    return "";
                }
                clone() {
                    let line = super.clone();
                    if (this.core != null) {
                        line.core = this.core.clone();
                        line.core.trendLine = line;
                    }
                    return line;
                }
                get serviceName() {
                    return this.core.localizedName;
                }
                get serviceCategory() {
                    return "Chart";
                }
                get serviceType() {
                    return StiTrendLine;
                }
                get core() {
                    return this._core;
                }
                set core(value) {
                    this._core = value;
                }
                get lineColor() {
                    return this._lineColor;
                }
                set lineColor(value) {
                    this._lineColor = value;
                }
                get lineWidth() {
                    return this._lineWidth;
                }
                set lineWidth(value) {
                    this._lineWidth = value;
                }
                get lineStyle() {
                    return this._lineStyle;
                }
                set lineStyle(value) {
                    this._lineStyle = value;
                }
                get showShadow() {
                    return this._showShadow;
                }
                set showShadow(value) {
                    this._showShadow = value;
                }
                get allowApplyStyle() {
                    return this._allowApplyStyle;
                }
                set allowApplyStyle(value) {
                    if (this._allowApplyStyle != value) {
                        this._allowApplyStyle = value;
                    }
                }
                get position() {
                    return this._position;
                }
                set position(value) {
                    this._position = value;
                }
                get font() {
                    return this._font;
                }
                set font(value) {
                    this._font = value;
                }
                get text() {
                    return this._text;
                }
                set text(value) {
                    this._text = value;
                }
                get titleVisible() {
                    return this._titleVisible;
                }
                set titleVisible(value) {
                    this._titleVisible = value;
                }
                createNew() {
                    return null;
                }
                toString() {
                    return this.serviceName;
                }
            }
            Chart.StiTrendLine = StiTrendLine;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLineExponential extends Chart.StiTrendLine {
                constructor() {
                    super();
                    this.core = new Chart.StiTrendLineExponentialCoreXF(this);
                }
                implements() {
                    if (!StiTrendLineExponential.implementsStiTrendLineExponential)
                        StiTrendLineExponential.implementsStiTrendLineExponential = super.implements().concat([
                            Chart.IStiTrendLine,
                            ICloneable,
                            IStiJsonReportObject,
                            Chart.IStiTrendLineExponential
                        ]);
                    return StiTrendLineExponential.implementsStiTrendLineExponential;
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLineExponential;
                }
                createNew() {
                    return new StiTrendLineExponential();
                }
            }
            Chart.StiTrendLineExponential = StiTrendLineExponential;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLineLinear extends Chart.StiTrendLine {
                constructor() {
                    super();
                    this.core = new Chart.StiTrendLineLinearCoreXF(this);
                }
                implements() {
                    if (!StiTrendLineLinear.implementsStiTrendLineLinear)
                        StiTrendLineLinear.implementsStiTrendLineLinear = super.implements().concat([
                            Chart.IStiTrendLine,
                            Chart.IStiTrendLineLinear,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiTrendLineLinear.implementsStiTrendLineLinear;
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLineLinear;
                }
                createNew() {
                    return new StiTrendLineLinear();
                }
            }
            Chart.StiTrendLineLinear = StiTrendLineLinear;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLineLogarithmic extends Chart.StiTrendLine {
                constructor() {
                    super();
                    this.core = new Chart.StiTrendLineLogarithmicCoreXF(this);
                }
                implements() {
                    if (!StiTrendLineLogarithmic.implementsStiTrendLineLogarithmic)
                        StiTrendLineLogarithmic.implementsStiTrendLineLogarithmic = super.implements().concat([
                            Chart.IStiTrendLine,
                            Chart.IStiTrendLineLogarithmic,
                            ICloneable,
                            IStiJsonReportObject
                        ]);
                    return StiTrendLineLogarithmic.implementsStiTrendLineLogarithmic;
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLineLogarithmic;
                }
                createNew() {
                    return new StiTrendLineLogarithmic();
                }
            }
            Chart.StiTrendLineLogarithmic = StiTrendLineLogarithmic;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLineNone extends Chart.StiTrendLine {
                constructor() {
                    super();
                    this.core = new Chart.StiTrendLineNoneCoreXF(this);
                }
                implements() {
                    if (!StiTrendLineNone.implementsStiTrendLineNone)
                        StiTrendLineNone.implementsStiTrendLineNone = super.implements().concat([
                            Chart.IStiTrendLine,
                            Chart.IStiTrendLineNone,
                            IStiJsonReportObject,
                            ICloneable
                        ]);
                    return StiTrendLineNone.implementsStiTrendLineNone;
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLineNone;
                }
                createNew() {
                    return new StiTrendLineNone();
                }
            }
            Chart.StiTrendLineNone = StiTrendLineNone;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiString = Stimulsoft.System.StiString;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var CollectionBase = Stimulsoft.System.Collections.CollectionBase;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiTrendLinesCollection extends CollectionBase {
                implements() {
                    return [
                        Chart.IStiTrendLinesCollection,
                        ICloneable,
                        IStiJsonReportObject
                    ];
                }
                saveToJsonObject(mode) {
                    if (this.list.length == 0)
                        return null;
                    let jObject = new StiJson();
                    let index = 0;
                    for (let trendLine of this.list) {
                        jObject.addPropertyJObject(index.toString(), trendLine.saveToJsonObject(mode));
                        index++;
                    }
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        let propJObject = property.value;
                        let ident = propJObject.properties().firstOrDefault(x => x.name == "Ident").value.toString();
                        let trendLine = Stimulsoft["StiOptions"].Services.chartTrendLines.firstOrDefault(x => x.stimulsoft().getType().stimulsoft().getTypeName() == ident);
                        if (trendLine == null)
                            throw StiString.format("Type {0} is not found!", ident);
                        let trendLineClone = trendLine.createNew();
                        this.list.push(trendLineClone);
                        trendLineClone.loadFromJsonObject(property.value);
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        if (node.attributes == null)
                            continue;
                        let attr = node.attributes.getNamedItem("type");
                        if (attr != null) {
                            switch (node.attributes.getNamedItem("type").value) {
                                case "Stimulsoft.Report.Chart.StiTrendLineExponential": {
                                    let lineExponential = new Chart.StiTrendLineExponential();
                                    this.list.push(lineExponential);
                                    lineExponential.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiTrendLineLinear": {
                                    let lineLinear = new Chart.StiTrendLineLinear();
                                    this.list.push(lineLinear);
                                    lineLinear.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiTrendLineLogarithmic": {
                                    let lineLogarithmic = new Chart.StiTrendLineLogarithmic();
                                    this.list.push(lineLogarithmic);
                                    lineLogarithmic.loadFromXml(node);
                                    break;
                                }
                                case "Stimulsoft.Report.Chart.StiTrendLineNone": {
                                    let lineNone = new Chart.StiTrendLineNone();
                                    this.list.push(lineNone);
                                    lineNone.loadFromXml(node);
                                    break;
                                }
                            }
                        }
                    }
                }
                clone() {
                    let lines = new StiTrendLinesCollection();
                    for (let trendLine of this.list) {
                        lines.add(trendLine.clone());
                    }
                    return lines;
                }
                add(line) {
                    this.list.push(line);
                }
            }
            Chart.StiTrendLinesCollection = StiTrendLinesCollection;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJsonReportObjectHelper = Stimulsoft.Base.StiJsonReportObjectHelper;
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            var StiPenStyle = Stimulsoft.Base.Drawing.StiPenStyle;
            var Enum = Stimulsoft.System.Enum;
            var Color = Stimulsoft.System.Drawing.Color;
            class StiWaterfallConnectorLine {
                constructor() {
                    this.lineColor = Color.lightGray;
                    this.lineWidth = 1;
                    this.visible = true;
                }
                implements() {
                    if (!StiWaterfallConnectorLine.implementsStiWaterfallConnectorLine)
                        StiWaterfallConnectorLine.implementsStiWaterfallConnectorLine = [
                            Chart.IStiTrendLine,
                            ICloneable,
                            IStiJsonReportObject
                        ];
                    return StiWaterfallConnectorLine.implementsStiWaterfallConnectorLine;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("LineColor", StiJsonReportObjectHelper.Serialize.jColor(this.lineColor, Color.lightGray));
                    jObject.addPropertyNumber("LineWidth", this.lineWidth, 1);
                    jObject.addPropertyEnum("LineStyle", StiPenStyle, this.lineStyle, StiPenStyle.Solid);
                    jObject.addPropertyBool("TitleVisible", this.visible, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this.lineColor = StiJsonReportObjectHelper.Deserialize.color(property.value.toString());
                                break;
                            case "LineWidth":
                                this.lineWidth = property.value.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, property.value.toString());
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "LineColor":
                                this.lineColor = Stimulsoft.System.Text.StiReportObjectStringConverter.convertStringToColor(node.textContent);
                                break;
                            case "LineWidth":
                                this.lineWidth = node.textContent.stimulsoft().toNumber();
                                break;
                            case "LineStyle":
                                this.lineStyle = Enum.parse(StiPenStyle, node.textContent);
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLine;
                }
            }
            Chart.StiWaterfallConnectorLine = StiWaterfallConnectorLine;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
var Stimulsoft;
(function (Stimulsoft) {
    var Report;
    (function (Report) {
        var Chart;
        (function (Chart) {
            var StiJson = Stimulsoft.Base.StiJson;
            var IStiJsonReportObject = Stimulsoft.Base.JsonReportObject.IStiJsonReportObject;
            var ICloneable = Stimulsoft.System.ICloneable;
            class StiWaterfallTotal {
                constructor() {
                    this.text = "Total";
                    this.visible = true;
                }
                implements() {
                    if (!StiWaterfallTotal.implementsStiWaterfallTotal)
                        StiWaterfallTotal.implementsStiWaterfallTotal = [
                            Chart.IStiTrendLine,
                            ICloneable,
                            IStiJsonReportObject
                        ];
                    return StiWaterfallTotal.implementsStiWaterfallTotal;
                }
                clone() {
                    return this.stimulsoft().memberwiseClone();
                }
                saveToJsonObject(mode) {
                    let jObject = new StiJson();
                    jObject.addPropertyStringNullOrEmpty("Text", this.text);
                    jObject.addPropertyBool("Visible", this.visible, true);
                    return jObject;
                }
                loadFromJsonObject(jObject) {
                    for (let property of jObject.properties()) {
                        switch (property.name) {
                            case "Visible":
                                this.visible = property.value.stimulsoft().toBoolean();
                                break;
                            case "Text":
                                this.text = property.value.toString();
                                break;
                        }
                    }
                }
                loadFromXml(xmlNode) {
                    for (let index = 0; index < xmlNode.childNodes.length; index++) {
                        let node = xmlNode.childNodes[index];
                        switch (node.nodeName) {
                            case "Visible":
                                this.visible = node.textContent.stimulsoft().toBoolean();
                                break;
                            case "Text":
                                this.text = node.textContent;
                                break;
                        }
                    }
                }
                get componentId() {
                    return Report.StiComponentId.StiTrendLine;
                }
            }
            Chart.StiWaterfallTotal = StiWaterfallTotal;
        })(Chart = Report.Chart || (Report.Chart = {}));
    })(Report = Stimulsoft.Report || (Stimulsoft.Report = {}));
})(Stimulsoft || (Stimulsoft = {}));
;var Stimulsoft;
(function (Stimulsoft) {
    var Reflection;
    (function (Reflection) {
        class StiTypesHelper {
            static run(type, namespace) {
                if (type === undefined) {
                    StiTypesHelper.run(Stimulsoft, "Stimulsoft");
                    return;
                }
                namespace = namespace.stimulsoft().replaceAll("Stimulsoft.System", "System");
                for (let name in type) {
                    if (typeof type[name] == "function") {
                        type[name].ssTypeName = name;
                        type[name].ssNamespace = namespace;
                    }
                    else if (typeof type[name] == "object") {
                        StiTypesHelper.run(type[name], namespace + "." + name);
                    }
                }
            }
        }
        Reflection.StiTypesHelper = StiTypesHelper;
    })(Reflection = Stimulsoft.Reflection || (Stimulsoft.Reflection = {}));
})(Stimulsoft || (Stimulsoft = {}));
Stimulsoft.Reflection.StiTypesHelper.run();
;